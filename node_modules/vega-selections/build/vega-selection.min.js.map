{"version":3,"file":"vega-selection.min.js","sources":["../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/descending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/internmap/src/index.js","../../../node_modules/d3-array/src/intersection.js","../src/util.js","../src/selectionTest.js","../src/selectionResolve.js","../../../node_modules/d3-array/src/union.js","../src/selectionTuples.js","../src/selectionVisitor.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","export class InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nexport class InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n","import {InternSet} from \"internmap\";\n\nexport default function intersection(values, ...others) {\n  values = new InternSet(values);\n  others = others.map(set);\n  out: for (const value of values) {\n    for (const other of others) {\n      if (!other.has(value)) {\n        values.delete(value);\n        continue out;\n      }\n    }\n  }\n  return values;\n}\n\nfunction set(values) {\n  return values instanceof InternSet ? values : new InternSet(values);\n}\n","import {field} from 'vega-util';\n\n// Registers vega-util field accessors to protect against XSS attacks\nconst SELECTION_GETTER = Symbol('vega_selection_getter');\nexport function getter(f) {\n  if (!f.getter || !f.getter[SELECTION_GETTER]) {\n    f.getter = field(f.field);\n    f.getter[SELECTION_GETTER] = true;\n  }\n\n  return f.getter;\n}\n\nexport const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n\nexport const SelectionId = '_vgsid_';\nexport const $selectionId = field(SelectionId);\n","import {bisector} from 'd3-array';\nimport {inrange, isArray, isDate, toNumber} from 'vega-util';\nimport {$selectionId, Intersect, getter} from './util';\n\nconst TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    dval = getter(f)(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isArray(values[i]) && isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nconst bisect = bisector($selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\n\nexport function selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = $selectionId(datum),\n      index = bisectLeft(entries, value);\n\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n","import {intersection, union} from 'd3-array';\nimport {array, toNumber} from 'vega-util';\nimport {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './util';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, value, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) { // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[`${type}_union`];\n        res[unit] = union(resUnit, array(values[j]));\n      }\n\n      // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {  // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({[SelectionId]: value});\n      }\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field])\n        .map(unit => resolved[field][unit])\n        .reduce((acc, curr) => acc === undefined ? curr : ops[`${types[field]}_${op}`](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  [`${SelectionId}_union`]: union,\n  [`${SelectionId}_intersect`]: intersection,\n\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.indexOf(v) >= 0);\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {InternSet} from \"internmap\";\n\nexport default function union(...others) {\n  const set = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set.add(o);\n    }\n  }\n  return set;\n}\n","import {extend} from 'vega-util';\nimport {$selectionId, SelectionId, getter} from './util';\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\nexport function selectionTuples(array, base) {\n  return array.map(x => extend(\n    base.fields ? {\n      values: base.fields.map(f => getter(f)(x.datum))\n    } : {\n      [SelectionId]: $selectionId(x.datum)\n    }, base));\n}\n","import {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\nimport {Intersect} from './util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n"],"names":["ascending","a","b","NaN","descending","zero","InternSet","Set","constructor","values","key","arguments","length","undefined","keyof","super","Object","defineProperties","this","_intern","value","Map","_key","add","has","_ref","get","intern_get","_ref2","set","intern_set","delete","_ref3","intern_delete","valueOf","SELECTION_GETTER","Symbol","getter","f","field","Intersect","Union","SelectionId","$selectionId","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","UNIT_INDEX","testPoint","datum","entry","dval","fields","n","i","isDate","toNumber","isArray","map","type","indexOf","inrange","bisect","compare1","compare2","delta","left","x","lo","hi","mid","d","center","right","bisector","bisectLeft","bisectRight","ops","_len","others","Array","other","o","out","E_union","base","push","E_intersect","filter","v","R_union","R_intersect","name","op","data","context","entries","unitIdx","intersect","index","size","isMulti","vl5","unit","res","resUnit","union","j","m","resolved","multiRes","types","charAt","array","reduce","obj","curr","keys","forEach","acc","or","k","and","miss","count","extend","args","scope","params","Literal","error","indexName","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,8]}