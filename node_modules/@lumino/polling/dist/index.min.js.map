{"version":3,"names":["Poll","constructor","options","this","_disposed","Signal","_lingered","_tick","PromiseDelegate","_ticked","_factory","factory","_linger","_a","linger","Private","DEFAULT_LINGER","_standby","standby","DEFAULT_STANDBY","_state","DEFAULT_STATE","timestamp","Date","getTime","frequency","max","Math","interval","DEFAULT_FREQUENCY","name","DEFAULT_NAME","auto","setTimeout","start","disposed","_frequency","isDisposed","JSONExt","deepEqual","backoff","round","Error","NEVER","MAX_INTERVAL","state","phase","tick","promise","ticked","async","Symbol","asyncIterator","catch","dispose","DISPOSED_STATE","_","reject","emit","undefined","clearData","refresh","schedule","cancel","IMMEDIATE","next","pending","scheduled","payload","clearTimeout","_timeout","resolve","_execute","stop","hidden","then","resolved","rejected","sleep","Infinity","DEFAULT_BACKOFF","last","growth","random","min","ceil","floor","getRandomIntInclusive","document","addEventListener","visibilityState","RateLimiter","fn","limit","args","poll","connect","invoke","super","_trailing","edge","_interval","idle"],"sources":["../src/poll.ts","../src/ratelimiter.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JSONExt, PromiseDelegate } from '@lumino/coreutils';\n\nimport { IObservableDisposable } from '@lumino/disposable';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { IPoll } from './index';\n\n/**\n * A class that wraps an asynchronous function to poll at a regular interval\n * with exponential increases to the interval length if the poll fails.\n *\n * @typeparam T - The resolved type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam U - The rejected type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam V - An optional type to extend the phases supported by a poll.\n * Defaults to `standby`, which already exists in the `Phase` type.\n */\nexport class Poll<T = any, U = any, V extends string = 'standby'>\n  implements IObservableDisposable, IPoll<T, U, V>\n{\n  /**\n   * Instantiate a new poll with exponential backoff in case of failure.\n   *\n   * @param options - The poll instantiation options.\n   */\n  constructor(options: Poll.IOptions<T, U, V>) {\n    this._factory = options.factory;\n    this._linger = options.linger ?? Private.DEFAULT_LINGER;\n    this._standby = options.standby || Private.DEFAULT_STANDBY;\n    this._state = { ...Private.DEFAULT_STATE, timestamp: new Date().getTime() };\n\n    // Normalize poll frequency `max` to be the greater of\n    // default `max`, `options.frequency.max`, or `options.frequency.interval`.\n    const frequency = options.frequency || {};\n    const max = Math.max(\n      frequency.interval || 0,\n      frequency.max || 0,\n      Private.DEFAULT_FREQUENCY.max\n    );\n    this.frequency = { ...Private.DEFAULT_FREQUENCY, ...frequency, ...{ max } };\n\n    this.name = options.name || Private.DEFAULT_NAME;\n\n    if ('auto' in options ? options.auto : true) {\n      setTimeout(() => this.start());\n    }\n  }\n\n  /**\n   * The name of the poll.\n   */\n  readonly name: string;\n\n  /**\n   * A signal emitted when the poll is disposed.\n   */\n  get disposed(): ISignal<this, void> {\n    return this._disposed;\n  }\n\n  /**\n   * The polling frequency parameters.\n   */\n  get frequency(): IPoll.Frequency {\n    return this._frequency;\n  }\n  set frequency(frequency: IPoll.Frequency) {\n    if (this.isDisposed || JSONExt.deepEqual(frequency, this.frequency || {})) {\n      return;\n    }\n\n    let { backoff, interval, max } = frequency;\n\n    interval = Math.round(interval);\n    max = Math.round(max);\n\n    if (typeof backoff === 'number' && backoff < 1) {\n      throw new Error('Poll backoff growth factor must be at least 1');\n    }\n\n    if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {\n      throw new Error('Poll interval must be between 0 and max');\n    }\n\n    if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {\n      throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);\n    }\n\n    this._frequency = { backoff, interval, max };\n  }\n\n  /**\n   * Whether the poll is disposed.\n   */\n  get isDisposed(): boolean {\n    return this.state.phase === 'disposed';\n  }\n\n  /**\n   * Indicates when the poll switches to standby.\n   */\n  get standby(): Poll.Standby | (() => boolean | Poll.Standby) {\n    return this._standby;\n  }\n  set standby(standby: Poll.Standby | (() => boolean | Poll.Standby)) {\n    if (this.isDisposed || this.standby === standby) {\n      return;\n    }\n\n    this._standby = standby;\n  }\n\n  /**\n   * The poll state, which is the content of the current poll tick.\n   */\n  get state(): IPoll.State<T, U, V> {\n    return this._state;\n  }\n\n  /**\n   * A promise that resolves when the poll next ticks.\n   */\n  get tick(): Promise<this> {\n    return this._tick.promise;\n  }\n\n  /**\n   * A signal emitted when the poll ticks and fires off a new request.\n   */\n  get ticked(): ISignal<this, IPoll.State<T, U, V>> {\n    return this._ticked;\n  }\n\n  /**\n   * Return an async iterator that yields every tick.\n   */\n  async *[Symbol.asyncIterator](): AsyncIterableIterator<IPoll.State<T, U, V>> {\n    while (!this.isDisposed) {\n      yield this.state;\n      await this.tick.catch(() => undefined);\n    }\n  }\n\n  /**\n   * Dispose the poll.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._state = {\n      ...Private.DISPOSED_STATE,\n      timestamp: new Date().getTime()\n    };\n    this._tick.promise.catch(_ => undefined);\n    this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));\n    this._disposed.emit(undefined);\n    Signal.clearData(this);\n  }\n\n  /**\n   * Refreshes the poll. Schedules `refreshed` tick if necessary.\n   *\n   * @returns A promise that resolves after tick is scheduled and never rejects.\n   *\n   * #### Notes\n   * The returned promise resolves after the tick is scheduled, but before\n   * the polling action is run. To wait until after the poll action executes,\n   * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`\n   */\n  refresh(): Promise<void> {\n    return this.schedule({\n      cancel: ({ phase }) => phase === 'refreshed',\n      interval: Poll.IMMEDIATE,\n      phase: 'refreshed'\n    });\n  }\n\n  /**\n   * Schedule the next poll tick.\n   *\n   * @param next - The next poll state data to schedule. Defaults to standby.\n   *\n   * @param next.cancel - Cancels state transition if function returns `true`.\n   *\n   * @returns A promise that resolves when the next poll state is active.\n   *\n   * #### Notes\n   * This method is not meant to be invoked by user code typically. It is public\n   * to allow poll instances to be composed into classes that schedule ticks.\n   */\n  async schedule(\n    next: Partial<\n      IPoll.State<T, U, V> & { cancel: (last: IPoll.State<T, U, V>) => boolean }\n    > = {}\n  ): Promise<void> {\n    if (this.isDisposed) {\n      return;\n    }\n\n    // Check if the phase transition should be canceled.\n    if (next.cancel && next.cancel(this.state)) {\n      return;\n    }\n\n    // Update poll state.\n    const pending = this._tick;\n    const scheduled = new PromiseDelegate<this>();\n    const state = {\n      interval: this.frequency.interval,\n      payload: null,\n      phase: 'standby',\n      timestamp: new Date().getTime(),\n      ...next\n    } as IPoll.State<T, U, V>;\n    this._state = state;\n    this._tick = scheduled;\n\n    // Clear the schedule if possible.\n    clearTimeout(this._timeout);\n\n    // Emit ticked signal, resolve pending promise, and await its settlement.\n    this._ticked.emit(this.state);\n    pending.resolve(this);\n    await pending.promise;\n\n    if (state.interval === Poll.NEVER) {\n      this._timeout = undefined;\n      return;\n    }\n\n    // Schedule next execution and cache its timeout handle.\n    const execute = () => {\n      if (this.isDisposed || this.tick !== scheduled.promise) {\n        return;\n      }\n\n      this._execute();\n    };\n\n    // Cache the handle in case it needs to be unscheduled.\n    this._timeout = setTimeout(execute, state.interval);\n  }\n\n  /**\n   * Starts the poll. Schedules `started` tick if necessary.\n   *\n   * @returns A promise that resolves after tick is scheduled and never rejects.\n   */\n  start(): Promise<void> {\n    return this.schedule({\n      cancel: ({ phase }) =>\n        phase !== 'constructed' && phase !== 'standby' && phase !== 'stopped',\n      interval: Poll.IMMEDIATE,\n      phase: 'started'\n    });\n  }\n\n  /**\n   * Stops the poll. Schedules `stopped` tick if necessary.\n   *\n   * @returns A promise that resolves after tick is scheduled and never rejects.\n   */\n  stop(): Promise<void> {\n    return this.schedule({\n      cancel: ({ phase }) => phase === 'stopped',\n      interval: Poll.NEVER,\n      phase: 'stopped'\n    });\n  }\n\n  /**\n   * Whether the poll is hidden.\n   *\n   * #### Notes\n   * This property is only relevant in a browser context.\n   */\n  protected get hidden(): boolean {\n    return Private.hidden;\n  }\n\n  /**\n   * Execute a new poll factory promise or stand by if necessary.\n   */\n  private _execute(): void {\n    let standby =\n      typeof this.standby === 'function' ? this.standby() : this.standby;\n\n    // Check if execution should proceed, linger, or stand by.\n    if (standby === 'never') {\n      standby = false;\n    } else if (standby === 'when-hidden') {\n      if (this.hidden) {\n        standby = ++this._lingered > this._linger;\n      } else {\n        this._lingered = 0;\n        standby = false;\n      }\n    }\n\n    // If in standby mode schedule next tick without calling the factory.\n    if (standby) {\n      void this.schedule();\n      return;\n    }\n\n    const pending = this.tick;\n\n    this._factory(this.state)\n      .then((resolved: T) => {\n        if (this.isDisposed || this.tick !== pending) {\n          return;\n        }\n\n        void this.schedule({\n          payload: resolved,\n          phase: this.state.phase === 'rejected' ? 'reconnected' : 'resolved'\n        });\n      })\n      .catch((rejected: U) => {\n        if (this.isDisposed || this.tick !== pending) {\n          return;\n        }\n\n        void this.schedule({\n          interval: Private.sleep(this.frequency, this.state),\n          payload: rejected,\n          phase: 'rejected'\n        });\n      });\n  }\n\n  private _disposed = new Signal<this, void>(this);\n  private _factory: Poll.Factory<T, U, V>;\n  private _frequency: IPoll.Frequency;\n  private _linger: number;\n  private _lingered = 0;\n  private _standby: Poll.Standby | (() => boolean | Poll.Standby);\n  private _state: IPoll.State<T, U, V>;\n  private _tick = new PromiseDelegate<this>();\n  private _ticked = new Signal<this, IPoll.State<T, U, V>>(this);\n  private _timeout: ReturnType<typeof setTimeout> | undefined;\n}\n\n/**\n * A namespace for `Poll` types, interfaces, and statics.\n */\nexport namespace Poll {\n  /**\n   * A promise factory that returns an individual poll request.\n   *\n   * @typeparam T - The resolved type of the factory's promises.\n   *\n   * @typeparam U - The rejected type of the factory's promises.\n   *\n   * @typeparam V - The type to extend the phases supported by a poll.\n   */\n  export type Factory<T, U, V extends string> = (\n    state: IPoll.State<T, U, V>\n  ) => Promise<T>;\n\n  /**\n   * Indicates when the poll switches to standby.\n   */\n  export type Standby = 'never' | 'when-hidden';\n\n  /**\n   * Instantiation options for polls.\n   *\n   * @typeparam T - The resolved type of the factory's promises.\n   *\n   * @typeparam U - The rejected type of the factory's promises.\n   *\n   * @typeparam V - The type to extend the phases supported by a poll.\n   */\n  export interface IOptions<T, U, V extends string> {\n    /**\n     * Whether to begin polling automatically; defaults to `true`.\n     */\n    auto?: boolean;\n\n    /**\n     * A factory function that is passed a poll tick and returns a poll promise.\n     */\n    factory: Factory<T, U, V>;\n\n    /**\n     * The number of ticks to linger if poll switches to standby `when-hidden`.\n     * Defaults to `1`.\n     */\n    linger?: number;\n\n    /**\n     * The polling frequency parameters.\n     */\n    frequency?: Partial<IPoll.Frequency>;\n\n    /**\n     * The name of the poll.\n     * Defaults to `'unknown'`.\n     */\n    name?: string;\n\n    /**\n     * Indicates when the poll switches to standby or a function that returns\n     * a boolean or a `Poll.Standby` value to indicate whether to stand by.\n     * Defaults to `'when-hidden'`.\n     *\n     * #### Notes\n     * If a function is passed in, for any given context, it should be\n     * idempotent and safe to call multiple times. It will be called before each\n     * tick execution, but may be called by clients as well.\n     */\n    standby?: Standby | (() => boolean | Standby);\n  }\n  /**\n   * An interval value in ms that indicates the poll should tick immediately.\n   */\n  export const IMMEDIATE = 0;\n\n  /**\n   * Delays are 32-bit integers in many browsers so intervals need to be capped.\n   *\n   * #### Notes\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\n   */\n  export const MAX_INTERVAL = 2147483647;\n\n  /**\n   * An interval value that indicates the poll should never tick.\n   */\n  export const NEVER = Infinity;\n}\n\n/**\n * A namespace for private module data.\n */\nnamespace Private {\n  /**\n   * The default backoff growth rate if `backoff` is `true`.\n   */\n  export const DEFAULT_BACKOFF = 3;\n\n  /**\n   * The default polling frequency.\n   */\n  export const DEFAULT_FREQUENCY: IPoll.Frequency = {\n    backoff: true,\n    interval: 1000,\n    max: 30 * 1000\n  };\n\n  /**\n   * The default number of times to `linger` when a poll is hidden.\n   */\n  export const DEFAULT_LINGER = 1;\n\n  /**\n   * The default poll name.\n   */\n  export const DEFAULT_NAME = 'unknown';\n\n  /**\n   * The default poll standby behavior.\n   */\n  export const DEFAULT_STANDBY: Poll.Standby = 'when-hidden';\n\n  /**\n   * The first poll tick state's default values superseded in constructor.\n   */\n  export const DEFAULT_STATE: IPoll.State<any, any, any> = {\n    interval: Poll.NEVER,\n    payload: null,\n    phase: 'constructed',\n    timestamp: new Date(0).getTime()\n  };\n\n  /**\n   * The disposed tick state values.\n   */\n  export const DISPOSED_STATE: IPoll.State<any, any, any> = {\n    interval: Poll.NEVER,\n    payload: null,\n    phase: 'disposed',\n    timestamp: new Date(0).getTime()\n  };\n\n  /**\n   * Returns the number of milliseconds to sleep before the next tick.\n   *\n   * @param frequency - The poll's base frequency.\n   * @param last - The poll's last tick.\n   */\n  export function sleep(\n    frequency: IPoll.Frequency,\n    last: IPoll.State<any, any, any>\n  ): number {\n    const { backoff, interval, max } = frequency;\n\n    if (interval === Poll.NEVER) {\n      return interval;\n    }\n\n    const growth =\n      backoff === true ? DEFAULT_BACKOFF : backoff === false ? 1 : backoff;\n    const random = getRandomIntInclusive(interval, last.interval * growth);\n\n    return Math.min(max, random);\n  }\n\n  /**\n   * Keep track of whether the document is hidden. This flag is only relevant in\n   * a browser context.\n   *\n   * Listen to `visibilitychange` event to set the `hidden` flag.\n   *\n   * Listening to `pagehide` is also necessary because Safari support for\n   * `visibilitychange` events is partial, cf.\n   * https://developer.mozilla.org/docs/Web/API/Document/visibilitychange_event\n   */\n  export let hidden = (() => {\n    if (typeof document === 'undefined') {\n      return false;\n    }\n    document.addEventListener('visibilitychange', () => {\n      hidden = document.visibilityState === 'hidden';\n    });\n    document.addEventListener('pagehide', () => {\n      hidden = document.visibilityState === 'hidden';\n    });\n    return document.visibilityState === 'hidden';\n  })();\n\n  /**\n   * Get a random integer between min and max, inclusive of both.\n   *\n   * #### Notes\n   * From\n   * https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive\n   *\n   * From the MDN page: It might be tempting to use Math.round() to accomplish\n   * that, but doing so would cause your random numbers to follow a non-uniform\n   * distribution, which may not be acceptable for your needs.\n   */\n  function getRandomIntInclusive(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PromiseDelegate } from '@lumino/coreutils';\n\nimport { IRateLimiter } from './index';\n\nimport { Poll } from './poll';\n\n/**\n * A base class to implement rate limiters with different invocation strategies.\n *\n * @typeparam T - The resolved type of the underlying function.\n *\n * @typeparam U - The rejected type of the underlying function.\n *\n * @typeparam V - Arguments for the underlying function.\n */\nexport abstract class RateLimiter<T, U, V extends any[]>\n  implements IRateLimiter<T, U, V>\n{\n  /**\n   * Instantiate a rate limiter.\n   *\n   * @param fn - The function to rate limit.\n   *\n   * @param limit - The rate limit; defaults to 500ms.\n   */\n  constructor(fn: (...args: V) => T | Promise<T>, limit = 500) {\n    this.limit = limit;\n    this.poll = new Poll({\n      auto: false,\n      factory: async () => {\n        const { args } = this;\n        this.args = undefined;\n        return fn(...args!);\n      },\n      frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },\n      standby: 'never'\n    });\n    this.payload = new PromiseDelegate();\n    this.poll.ticked.connect((_, state) => {\n      const { payload } = this;\n\n      if (state.phase === 'resolved') {\n        this.payload = new PromiseDelegate();\n        payload!.resolve(state.payload as T);\n        return;\n      }\n\n      if (state.phase === 'rejected' || state.phase === 'stopped') {\n        this.payload = new PromiseDelegate();\n        payload!.promise.catch(_ => undefined);\n        payload!.reject(state.payload as U);\n        return;\n      }\n    }, this);\n  }\n\n  /**\n   * Whether the rate limiter is disposed.\n   */\n  get isDisposed(): boolean {\n    return this.payload === null;\n  }\n\n  /**\n   * Disposes the rate limiter.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this.args = undefined;\n    this.payload = null;\n    this.poll.dispose();\n  }\n\n  /**\n   * The rate limit in milliseconds.\n   */\n  readonly limit: number;\n\n  /**\n   * Invoke the rate limited function.\n   */\n  abstract invoke(...args: V): Promise<T>;\n\n  /**\n   * Stop the function if it is mid-flight.\n   */\n  async stop(): Promise<void> {\n    return this.poll.stop();\n  }\n\n  /**\n   * Arguments for the underlying function.\n   */\n  protected args: V | undefined = undefined;\n\n  /**\n   * A promise that resolves on each successful invocation.\n   */\n  protected payload: PromiseDelegate<T> | null = null;\n\n  /**\n   * The underlying poll instance used by the rate limiter.\n   */\n  protected poll: Poll<T, U, 'invoked'>;\n}\n\n/**\n * Wraps and debounces a function that can be called multiple times and only\n * executes the underlying function one `interval` after the last invocation.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nexport class Debouncer<\n  T = any,\n  U = any,\n  V extends any[] = any[]\n> extends RateLimiter<T, U, V> {\n  /**\n   * Invokes the function and only executes after rate limit has elapsed.\n   * Each invocation resets the timer.\n   */\n  invoke(...args: V): Promise<T> {\n    this.args = args;\n    void this.poll.schedule({ interval: this.limit, phase: 'invoked' });\n    return this.payload!.promise;\n  }\n}\n\n/**\n * Wraps and throttles a function that can be called multiple times and only\n * executes the underlying function once per `interval`.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nexport class Throttler<\n  T = any,\n  U = any,\n  V extends any[] = any[]\n> extends RateLimiter<T, U, V> {\n  /**\n   * Instantiate a throttler.\n   *\n   * @param fn - The function being throttled.\n   *\n   * @param options - Throttling configuration or throttling limit in ms.\n   *\n   * #### Notes\n   * The `edge` defaults to `leading`; the `limit` defaults to `500`.\n   */\n  constructor(\n    fn: (...args: V) => T | Promise<T>,\n    options?: Throttler.IOptions | number\n  ) {\n    super(fn, typeof options === 'number' ? options : options && options.limit);\n    if (typeof options !== 'number' && options && options.edge === 'trailing') {\n      this._trailing = true;\n    }\n    this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;\n  }\n\n  /**\n   * Throttles function invocations if one is currently in flight.\n   */\n  invoke(...args: V): Promise<T> {\n    const idle = this.poll.state.phase !== 'invoked';\n    if (idle || this._trailing) {\n      this.args = args;\n    }\n    if (idle) {\n      void this.poll.schedule({ interval: this._interval, phase: 'invoked' });\n    }\n    return this.payload!.promise;\n  }\n\n  private _interval: number;\n  private _trailing = false;\n}\n\n/**\n * A namespace for `Throttler` interfaces.\n */\nexport namespace Throttler {\n  /**\n   * Instantiation options for a `Throttler`.\n   */\n  export interface IOptions {\n    /**\n     * The throttling limit; defaults to 500ms.\n     */\n    limit?: number;\n\n    /**\n     * Whether to invoke at the leading or trailing edge of throttle cycle.\n     * Defaults to `leading`.\n     */\n    edge?: 'leading' | 'trailing';\n  }\n}\n"],"mappings":"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"}