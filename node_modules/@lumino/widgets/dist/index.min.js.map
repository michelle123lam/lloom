{"version":3,"names":["BoxSizer","constructor","this","sizeHint","minSize","maxSize","Infinity","stretch","size","done","BoxEngine","Private","Utils","calc","sizers","space","count","length","totalMin","totalMax","totalSize","totalStretch","stretchCount","i","sizer","min","max","hint","Math","nearZero","notDoneCount","freeSpace","distSpace","distStretch","amt","adjust","index","delta","growLimit","shrinkLimit","n","grow","limit","shrink","growSizer","shrinkSizer","Title","options","_label","_caption","_mnemonic","_icon","undefined","_iconClass","_iconLabel","_className","_closable","_changed","Signal","_isDisposed","owner","label","mnemonic","icon","iconClass","iconLabel","caption","className","closable","_dataset","dataset","changed","value","emit","isDisposed","dispose","clearData","Widget","_flags","_layout","_parent","_disposed","_hiddenMode","HiddenMode","Display","node","createNode","addClass","setFlag","Flag","IsDisposed","parent","isAttached","detach","title","MessageLoop","AttachedProperty","disposed","testFlag","IsAttached","isHidden","IsHidden","isVisible","IsVisible","titleProperty","get","id","hiddenMode","_toggleHidden","Scale","style","willChange","contains","Error","msg","ChildMessage","sendMessage","Msg","ParentChanged","layout","DisallowLayout","children","widget","hasClass","name","classList","add","removeClass","remove","toggleClass","force","toggle","update","postMessage","UpdateRequest","fit","FitRequest","activate","ActivateRequest","close","CloseRequest","show","BeforeShow","clearFlag","AfterShow","hide","BeforeHide","AfterHide","setHidden","hidden","flag","processMessage","type","notifyLayout","onResize","onUpdateRequest","onFitRequest","onBeforeShow","onAfterShow","onBeforeHide","onAfterHide","onBeforeAttach","onAfterAttach","onBeforeDetach","onAfterDetach","onActivateRequest","onCloseRequest","onChildAdded","onChildRemoved","processParentMessage","transform","setAttribute","ContentVisibility","contentVisibility","zIndex","removeAttribute","Message","BeforeAttach","AfterAttach","BeforeDetach","AfterDetach","ConflatableMessage","child","super","ResizeMessage","width","height","UnknownSize","attach","host","ref","isConnected","insertBefore","parentNode","removeChild","create","document","createElement","tag","Layout","_fitPolicy","fitPolicy","init","minWidth","minHeight","maxWidth","maxHeight","onChildShown","onChildHidden","removeWidget","getHorizontalAlignment","horizontalAlignmentProperty","setHorizontalAlignment","set","getVerticalAlignment","verticalAlignmentProperty","setVerticalAlignment","LayoutItem","_top","NaN","_left","_width","_height","_minWidth","_minHeight","_maxWidth","_maxHeight","position","contain","top","left","limits","ElementExt","sizeLimits","clampW","clampH","resized","onAlignmentChanged","PanelLayout","_widgets","pop","widgets","Symbol","iterator","addWidget","insertWidget","indexOf","j","ArrayExt","insert","attachWidget","move","moveWidget","removeWidgetAt","removeAt","detachWidget","fromIndex","toIndex","clampDimension","floor","Utils$1","SplitLayout","widgetOffset","_fixed","_spacing","_dirty","_hasNormedSizes","_sizers","_items","_handles","_box","_alignment","_orientation","renderer","orientation","alignment","spacing","item","handles","absoluteSizes","map","relativeSizes","normalize","setRelativeSizes","sizes","temp","slice","push","normed","moveHandle","handle","offsetLeft","offsetTop","createHandle","average","averageSize","createSizer","appendChild","_update","_fit","updateItemPosition","isHorizontal","handleStyle","nVisible","lastHandleIndex","horz","minW","minH","getStretch","box","boxSizing","horizontalSum","verticalSum","offsetWidth","offsetHeight","paddingTop","paddingLeft","extra","offset","fullOffset","stretchProperty","setStretch","coerce","reduce","v","s","values","sum","a","b","abs","AccordionLayout","_titles","titleSpace","titles","updateTitle","oldTitle","expanded","newTitle","createTitle","replaceChild","UUID","uuid4","titleStyle","data","createSectionTitle","Panel","createLayout","SplitPanel","_handleMoved","_pressData","_releaseMouse","handleMoved","handleEvent","event","_evtPointerDown","_evtPointerMove","_evtPointerUp","_evtKeyDown","preventDefault","stopPropagation","addEventListener","removeEventListener","keyCode","button","findFirstIndex","target","rect","getBoundingClientRect","clientX","clientY","window","getComputedStyle","override","Drag","overrideCursor","cursor","pos","Renderer","defaultRenderer","AccordionPanel","_widgetSizesCache","WeakMap","_expansionToggled","expansionToggled","connect","_onTitleChanged","collapse","_toggleExpansion","expand","_evtClick","_eventKeyDown","sender","_computeWidgetSize","widgetSizes","prev","curr","newSize","previousSize","widgetToCollapse","sz","lastIndexOf","forEach","_","idx","currentSize","defaultPrevented","handled","toString","key","match","click","direction","newIndex","focus","titleClassName","_titleID","_titleKeys","_uuid","_nInstance","createCollapseIcon","createTitleKey","aData","textContent","BoxLayout","_direction","getSizeBasis","sizeBasisProperty","setSizeBasis","onChildSizingChanged","dir","clampSpacing","BoxPanel","CommandPalette","_activeIndex","_results","commands","commandChanged","_onGenericChange","keyBindingChanged","searchNode","getElementsByClassName","inputNode","contentNode","items","addItem","createItem","refresh","addItems","newItems","removeItem","removeItemAt","clearItems","display","_toggleFocused","input","select","query","results","search","canActivate","VirtualDOM","render","content","renderEmptyMessage","activeIndex","Array","result","indices","category","renderHeader","active","renderItem","scrollTop","element","scrollIntoViewIfNeeded","_execute","altKey","ctrlKey","metaKey","shiftKey","_activatePreviousItem","_activateNextItem","ai","start","stop","findLastIndex","part","toLowerCase","isEnabled","execute","command","args","focused","activeElement","formatHeader","h","li","createItemClass","createItemDataset","isToggleable","role","isToggled","renderItemIcon","renderItemContent","renderItemShortcut","formatEmptyMessage","createIconClass","div","renderItemLabel","renderItemCaption","formatItemLabel","formatItemCaption","formatItemShortcut","StringExt","highlight","mark","kb","keyBinding","CommandRegistry","formatKeystroke","keys","fuzzySearch","source","score","rgx","rgxMatch","exec","matchSumOfDeltas","pivot","lowerBound","categoryIndices","labelIndices","matchType","scoreCmp","m1","d1","i1","i2","d2","localeCompare","r1","rank","r2","wrapper","clear","spellcheck","CommandItem","scores","text","replace","matchItems","sort","visited","fill","createResults","_commands","trim","JSONExt","emptyObject","findLastValue","keyBindings","deepEqual","Menu","_childIndex","_openTimerID","_closeTimerID","_childMenu","_parentMenu","_aboutToClose","_menuRequested","aboutToClose","menuRequested","parentMenu","childMenu","rootMenu","menu","leafMenu","activeItem","childNodes","activateNextItem","activatePreviousItem","triggerActiveItem","_cancelOpenTimer","_cancelCloseTimer","_openChildMenu","console","log","insertItem","open","x","y","forceX","forceY","openRootMenu","_evtMouseUp","_evtMouseMove","_evtMouseEnter","_evtMouseLeave","_evtMouseDown","collapsedFlags","computeCollapsed","collapsed","onfocus","kc","getKeyboardLayout","keyForKeydownEvent","findMnemonic","multiple","auto","hitTest","_startCloseTimer","submenu","_startOpenTimer","hitTestMenus","activateFirst","_closeChildMenu","saveWindowData","itemNode","openSubmenu","setTimeout","TIMER_DELAY","clearTimeout","static","aria","createItemARIA","tabindex","renderIcon","renderLabel","renderShortcut","renderSubmenu","formatLabel","formatShortcut","prefix","suffix","char","span","SUBMENU_OVERLAP","transientWindowDataCache","transientCacheCounter","getWindowData","_getWindowData","pageXOffset","pageYOffset","clientWidth","documentElement","clientHeight","tabIndex","MenuItem","k1","k2","windowData","px","py","cw","ch","opacity","body","itemRect","right","borderTop","bottom","borderBottom","paddingBottom","upperKey","toUpperCase","k","mn","itemCmpRank","itemCmp","s1","Selector","calculateSpecificity","selector","s2","isValid","validateSelector","groupByTarget","sortBySelector","currentTarget","elementFromPoint","availableItems","matches","parentElement","ARROW_KEYS","TabBar","_currentIndex","_titlesEditable","_previousTitle","_dragData","_addButtonEnabled","_tabMoved","_currentChanged","_addRequested","_tabCloseRequested","_tabDetachRequested","_tabActivateRequested","_document","tabsMovable","titlesEditable","allowDeselect","addButtonEnabled","insertBehavior","removeBehavior","currentChanged","tabMoved","tabActivateRequested","addRequested","tabCloseRequested","tabDetachRequested","currentTitle","currentIndex","pi","pt","ci","ct","previousIndex","previousTitle","_name","addButtonNode","addTab","insertTab","asTitle","_adjustCurrentForInsert","_adjustCurrentForMove","removeTab","removeTabAt","disconnect","_adjustCurrentForRemove","clearTabs","releaseMouse","_evtDblClick","eventPhase","Event","CAPTURING_PHASE","_evtKeyDownCapturing","tabHandlingTabindex","_a","_getCurrentTabindex","current","renderTab","elemTabindex","querySelector","getAttribute","tabs","tab","oldValue","innerHTML","onblur","focusedElement","includes","focusable","nextFocused","focusedIndex","_b","_c","addButtonClicked","pressX","pressY","tabPos","tabSize","tabPressPos","targetIndex","tabLayout","contentRect","dragActive","dragAborted","detachRequested","closeIconSelector","dragExceeded","tabRect","tabPressOffset","snapTabLayout","detachExceeded","layoutTabs","finalizeTabPosition","duration","parseTransitionDuration","resetTabPositions","bh","_tabID","_tabKeys","createTabKey","createTabStyle","createTabClass","createTabDataset","createTabARIA","renderCloseIcon","addButtonSelector","DRAG_THRESHOLD","DETACH_THRESHOLD","parseFloat","transitionDuration","margin","marginLeft","marginTop","dx","dy","pressPos","localPos","clientPos","clientSize","targetPos","targetEnd","pxPos","threshold","ideal","tgt","final","DockLayout","_root","Map","bar","tabBars","isEmpty","iterAllWidgets","empty","iterUserWidgets","selectedWidgets","iterSelectedWidgets","iterTabBars","iterHandles","offsetX","offsetY","findSplitNode","holdSizes","saveLayout","holdAllSizes","main","createConfig","restoreLayout","config","mainConfig","widgetSet","Set","normalizeAreaConfig","oldWidgets","oldTabBars","oldHandles","has","tabBar","realizeAreaConfig","createTabBar","_createTabBar","_createHandle","mode","refNode","findTabNode","_insertTab","_insertSplit","_removeWidget","hitTestTabAreas","borderLeft","tabNode","hitTestTabNodes","borderWidth","borderRight","borderHeight","delete","removeAria","splitNode","removeFirstOf","syncHandles","maybeParent","childNode","childHandle","TabLayoutNode","splitHandle","gChild","gHandle","gSizer","_createTabNode","addAria","after","findFirstTabNode","merge","root","_splitRoot","normalizeSizes","GOLDEN_RATIO","sibling","SplitLayoutNode","normalized","oldRoot","newRoot","normalizeTabAreaConfig","normalizeSplitAreaConfig","realizeTabAreaConfig","realizeSplitAreaConfig","tabSizer","widgetSizer","tabBarItem","widgetItem","tabBarSizer","createNormalizedSizes","horizontal","fixed","tabId","DockPanel","_drag","_tabsMovable","_tabsConstrained","_layoutModified","_mode","_renderer","_edges","edges","DEFAULT_EDGES","tabsConstrained","overlay","Overlay","layoutModified","createSingleDocumentConfig","LayoutModified","selectWidget","find","activateWidget","Platform","IS_EDGE","IS_IE","flush","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","isGeneratedTabBarProperty","mimeData","hasData","_showOverlay","dropAction","proposedAction","zone","findDropTarget","factory","getData","getDropRef","deltaX","deltaY","xPos","yPos","paddingRight","tabHeight","_onTabMoved","_onCurrentChanged","_onTabCloseRequested","_onTabDetachRequested","_onTabActivateRequested","_onTabAddRequested","MimeData","setData","dragImage","cloneNode","supportedActions","then","_timer","_hidden","geo","delay","panel","from","selected","next","panelRect","pl","pr","pb","al","at","ar","ab","rx","round","ry","GridLayout","_rowSpacing","_columnSpacing","_rowStarts","_columnStarts","_rowSizers","_columnSizers","rowCount","reallocSizers","columnCount","rowSpacing","clampValue","columnSpacing","rowStretch","setRowStretch","columnStretch","setColumnStretch","it","filter","maxRow","maxCol","rowSpanCmp","getCellConfig","row","rowSpan","distributeMin","columnSpanCmp","c1","column","c2","columnSpan","fixedRowSpace","fixedColSpace","w","cellConfigProperty","setCellConfig","normalizeConfig","portion","MenuBar","_tabFocusIndex","_menus","_overflowMenu","_menuItemSizes","_overflowIndex","_forceItemsPosition","forceItemsPosition","_overflowMenuOptions","overflowMenuOptions","overflowIndex","overflowMenu","activeMenu","menus","openActiveMenu","addMenu","insertMenu","_onMenuAboutToClose","_onMenuMenuRequested","removeMenu","removeMenuAt","clearMenus","_evtFocusOut","_focusItemAt","tabFocusIndex","totalMenuSize","tabbable","disabled","overflowMenuTitle","overflowMenuItems","screenSize","_updateOverflowIndex","itemMenus","stopImmediatePropagation","_positionForMenu","relatedTarget","newMenu","oldMenu","decrement","increment","track","thumb","findPart","scrollBar","thumbNode","trackNode","decrementNode","incrementNode","SingletonLayout","_widget","StackedLayout","StackedPanel","_widgetRemoved","widgetRemoved","orientationFromPlacement","plc","placementToOrientationMap","directionFromPlacement","placementToDirectionMap","_groupByTarget","_idTick","_sortBySelector","others","DisposableDelegate","_counter","_activeWidget","_currentWidget","_numbers","_nodes","_activeChanged","activeChanged","currentWidget","activeWidget","focusNumber","_onWidgetDisposed","_setWidgets","valid","previous","first","second","_evtFocus","_evtBlur","oldCurrent","oldActive","newValue","focusTarget","_onRepeat","_repeatTimer","mouseX","mouseY","thumbRect","_pageRequested","_stepRequested","_value","_page","_maximum","_thumbMoved","maximum","page","thumbMoved","stepRequested","pageRequested","thumbStyle","_moveThumb","trackPos","trackSpan","trackRect","stackedPanel","_onWidgetRemoved","_tabPlacement","tabPlacement","previousWidget"],"sources":["../src/boxengine.ts","../src/widget.ts","../src/layout.ts","../src/utils.ts","../src/title.ts","../src/panellayout.ts","../src/splitlayout.ts","../src/accordionlayout.ts","../src/panel.ts","../src/splitpanel.ts","../src/accordionpanel.ts","../src/boxlayout.ts","../src/boxpanel.ts","../src/commandpalette.ts","../src/menu.ts","../src/contextmenu.ts","../src/tabbar.ts","../src/docklayout.ts","../src/dockpanel.ts","../src/gridlayout.ts","../src/menubar.ts","../src/scrollbar.ts","../src/stackedpanel.ts","../src/tabpanel.ts","../src/singletonlayout.ts","../src/stackedlayout.ts","../src/focustracker.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * A sizer object for use with the box engine layout functions.\n *\n * #### Notes\n * A box sizer holds the geometry information for an object along an\n * arbitrary layout orientation.\n *\n * For best performance, this class should be treated as a raw data\n * struct. It should not typically be subclassed.\n */\nexport class BoxSizer {\n  /**\n   * The preferred size for the sizer.\n   *\n   * #### Notes\n   * The sizer will be given this initial size subject to its size\n   * bounds. The sizer will not deviate from this size unless such\n   * deviation is required to fit into the available layout space.\n   *\n   * There is no limit to this value, but it will be clamped to the\n   * bounds defined by {@link minSize} and {@link maxSize}.\n   *\n   * The default value is `0`.\n   */\n  sizeHint = 0;\n\n  /**\n   * The minimum size of the sizer.\n   *\n   * #### Notes\n   * The sizer will never be sized less than this value, even if\n   * it means the sizer will overflow the available layout space.\n   *\n   * It is assumed that this value lies in the range `[0, Infinity)`\n   * and that it is `<=` to {@link maxSize}. Failure to adhere to this\n   * constraint will yield undefined results.\n   *\n   * The default value is `0`.\n   */\n  minSize = 0;\n\n  /**\n   * The maximum size of the sizer.\n   *\n   * #### Notes\n   * The sizer will never be sized greater than this value, even if\n   * it means the sizer will underflow the available layout space.\n   *\n   * It is assumed that this value lies in the range `[0, Infinity]`\n   * and that it is `>=` to {@link minSize}. Failure to adhere to this\n   * constraint will yield undefined results.\n   *\n   * The default value is `Infinity`.\n   */\n  maxSize = Infinity;\n\n  /**\n   * The stretch factor for the sizer.\n   *\n   * #### Notes\n   * This controls how much the sizer stretches relative to its sibling\n   * sizers when layout space is distributed. A stretch factor of zero\n   * is special and will cause the sizer to only be resized after all\n   * other sizers with a stretch factor greater than zero have been\n   * resized to their limits.\n   *\n   * It is assumed that this value is an integer that lies in the range\n   * `[0, Infinity)`. Failure to adhere to this constraint will yield\n   * undefined results.\n   *\n   * The default value is `1`.\n   */\n  stretch = 1;\n\n  /**\n   * The computed size of the sizer.\n   *\n   * #### Notes\n   * This value is the output of a call to {@link BoxEngine.calc}. It represents\n   * the computed size for the object along the layout orientation,\n   * and will always lie in the range `[minSize, maxSize]`.\n   *\n   * This value is output only.\n   *\n   * Changing this value will have no effect.\n   */\n  size = 0;\n\n  /**\n   * An internal storage property for the layout algorithm.\n   *\n   * #### Notes\n   * This value is used as temporary storage by the layout algorithm.\n   *\n   * Changing this value will have no effect.\n   */\n  done = false;\n}\n\n/**\n * The namespace for the box engine layout functions.\n */\nexport namespace BoxEngine {\n  /**\n   * Calculate the optimal layout sizes for a sequence of box sizers.\n   *\n   * This distributes the available layout space among the box sizers\n   * according to the following algorithm:\n   *\n   * 1. Initialize the sizers's size to its size hint and compute the\n   *    sums for each of size hint, min size, and max size.\n   *\n   * 2. If the total size hint equals the available space, return.\n   *\n   * 3. If the available space is less than the total min size, set all\n   *    sizers to their min size and return.\n   *\n   * 4. If the available space is greater than the total max size, set\n   *    all sizers to their max size and return.\n   *\n   * 5. If the layout space is less than the total size hint, distribute\n   *    the negative delta as follows:\n   *\n   *    a. Shrink each sizer with a stretch factor greater than zero by\n   *       an amount proportional to the negative space and the sum of\n   *       stretch factors. If the sizer reaches its min size, remove\n   *       it and its stretch factor from the computation.\n   *\n   *    b. If after adjusting all stretch sizers there remains negative\n   *       space, distribute the space equally among the sizers with a\n   *       stretch factor of zero. If a sizer reaches its min size,\n   *       remove it from the computation.\n   *\n   * 6. If the layout space is greater than the total size hint,\n   *    distribute the positive delta as follows:\n   *\n   *    a. Expand each sizer with a stretch factor greater than zero by\n   *       an amount proportional to the postive space and the sum of\n   *       stretch factors. If the sizer reaches its max size, remove\n   *       it and its stretch factor from the computation.\n   *\n   *    b. If after adjusting all stretch sizers there remains positive\n   *       space, distribute the space equally among the sizers with a\n   *       stretch factor of zero. If a sizer reaches its max size,\n   *       remove it from the computation.\n   *\n   * 7. return\n   *\n   * @param sizers - The sizers for a particular layout line.\n   *\n   * @param space - The available layout space for the sizers.\n   *\n   * @returns The delta between the provided available space and the\n   *   actual consumed space. This value will be zero if the sizers\n   *   can be adjusted to fit, negative if the available space is too\n   *   small, and positive if the available space is too large.\n   *\n   * #### Notes\n   * The {@link BoxSizer.size} of each sizer is updated with the computed size.\n   *\n   * This function can be called at any time to recompute the layout for\n   * an existing sequence of sizers. The previously computed results will\n   * have no effect on the new output. It is therefore not necessary to\n   * create new sizer objects on each resize event.\n   */\n  export function calc(sizers: ArrayLike<BoxSizer>, space: number): number {\n    // Bail early if there is nothing to do.\n    let count = sizers.length;\n    if (count === 0) {\n      return space;\n    }\n\n    // Setup the size and stretch counters.\n    let totalMin = 0;\n    let totalMax = 0;\n    let totalSize = 0;\n    let totalStretch = 0;\n    let stretchCount = 0;\n\n    // Setup the sizers and compute the totals.\n    for (let i = 0; i < count; ++i) {\n      let sizer = sizers[i];\n      let min = sizer.minSize;\n      let max = sizer.maxSize;\n      let hint = sizer.sizeHint;\n      sizer.done = false;\n      sizer.size = Math.max(min, Math.min(hint, max));\n      totalSize += sizer.size;\n      totalMin += min;\n      totalMax += max;\n      if (sizer.stretch > 0) {\n        totalStretch += sizer.stretch;\n        stretchCount++;\n      }\n    }\n\n    // If the space is equal to the total size, return early.\n    if (space === totalSize) {\n      return 0;\n    }\n\n    // If the space is less than the total min, minimize each sizer.\n    if (space <= totalMin) {\n      for (let i = 0; i < count; ++i) {\n        let sizer = sizers[i];\n        sizer.size = sizer.minSize;\n      }\n      return space - totalMin;\n    }\n\n    // If the space is greater than the total max, maximize each sizer.\n    if (space >= totalMax) {\n      for (let i = 0; i < count; ++i) {\n        let sizer = sizers[i];\n        sizer.size = sizer.maxSize;\n      }\n      return space - totalMax;\n    }\n\n    // The loops below perform sub-pixel precision sizing. A near zero\n    // value is used for compares instead of zero to ensure that the\n    // loop terminates when the subdivided space is reasonably small.\n    let nearZero = 0.01;\n\n    // A counter which is decremented each time a sizer is resized to\n    // its limit. This ensures the loops terminate even if there is\n    // space remaining to distribute.\n    let notDoneCount = count;\n\n    // Distribute negative delta space.\n    if (space < totalSize) {\n      // Shrink each stretchable sizer by an amount proportional to its\n      // stretch factor. If a sizer reaches its min size it's marked as\n      // done. The loop progresses in phases where each sizer is given\n      // a chance to consume its fair share for the pass, regardless of\n      // whether a sizer before it reached its limit. This continues\n      // until the stretchable sizers or the free space is exhausted.\n      let freeSpace = totalSize - space;\n      while (stretchCount > 0 && freeSpace > nearZero) {\n        let distSpace = freeSpace;\n        let distStretch = totalStretch;\n        for (let i = 0; i < count; ++i) {\n          let sizer = sizers[i];\n          if (sizer.done || sizer.stretch === 0) {\n            continue;\n          }\n          let amt = (sizer.stretch * distSpace) / distStretch;\n          if (sizer.size - amt <= sizer.minSize) {\n            freeSpace -= sizer.size - sizer.minSize;\n            totalStretch -= sizer.stretch;\n            sizer.size = sizer.minSize;\n            sizer.done = true;\n            notDoneCount--;\n            stretchCount--;\n          } else {\n            freeSpace -= amt;\n            sizer.size -= amt;\n          }\n        }\n      }\n      // Distribute any remaining space evenly among the non-stretchable\n      // sizers. This progresses in phases in the same manner as above.\n      while (notDoneCount > 0 && freeSpace > nearZero) {\n        let amt = freeSpace / notDoneCount;\n        for (let i = 0; i < count; ++i) {\n          let sizer = sizers[i];\n          if (sizer.done) {\n            continue;\n          }\n          if (sizer.size - amt <= sizer.minSize) {\n            freeSpace -= sizer.size - sizer.minSize;\n            sizer.size = sizer.minSize;\n            sizer.done = true;\n            notDoneCount--;\n          } else {\n            freeSpace -= amt;\n            sizer.size -= amt;\n          }\n        }\n      }\n    }\n    // Distribute positive delta space.\n    else {\n      // Expand each stretchable sizer by an amount proportional to its\n      // stretch factor. If a sizer reaches its max size it's marked as\n      // done. The loop progresses in phases where each sizer is given\n      // a chance to consume its fair share for the pass, regardless of\n      // whether a sizer before it reached its limit. This continues\n      // until the stretchable sizers or the free space is exhausted.\n      let freeSpace = space - totalSize;\n      while (stretchCount > 0 && freeSpace > nearZero) {\n        let distSpace = freeSpace;\n        let distStretch = totalStretch;\n        for (let i = 0; i < count; ++i) {\n          let sizer = sizers[i];\n          if (sizer.done || sizer.stretch === 0) {\n            continue;\n          }\n          let amt = (sizer.stretch * distSpace) / distStretch;\n          if (sizer.size + amt >= sizer.maxSize) {\n            freeSpace -= sizer.maxSize - sizer.size;\n            totalStretch -= sizer.stretch;\n            sizer.size = sizer.maxSize;\n            sizer.done = true;\n            notDoneCount--;\n            stretchCount--;\n          } else {\n            freeSpace -= amt;\n            sizer.size += amt;\n          }\n        }\n      }\n      // Distribute any remaining space evenly among the non-stretchable\n      // sizers. This progresses in phases in the same manner as above.\n      while (notDoneCount > 0 && freeSpace > nearZero) {\n        let amt = freeSpace / notDoneCount;\n        for (let i = 0; i < count; ++i) {\n          let sizer = sizers[i];\n          if (sizer.done) {\n            continue;\n          }\n          if (sizer.size + amt >= sizer.maxSize) {\n            freeSpace -= sizer.maxSize - sizer.size;\n            sizer.size = sizer.maxSize;\n            sizer.done = true;\n            notDoneCount--;\n          } else {\n            freeSpace -= amt;\n            sizer.size += amt;\n          }\n        }\n      }\n    }\n\n    // Indicate that the consumed space equals the available space.\n    return 0;\n  }\n\n  /**\n   * Adjust a sizer by a delta and update its neighbors accordingly.\n   *\n   * @param sizers - The sizers which should be adjusted.\n   *\n   * @param index - The index of the sizer to grow.\n   *\n   * @param delta - The amount to adjust the sizer, positive or negative.\n   *\n   * #### Notes\n   * This will adjust the indicated sizer by the specified amount, along\n   * with the sizes of the appropriate neighbors, subject to the limits\n   * specified by each of the sizers.\n   *\n   * This is useful when implementing box layouts where the boundaries\n   * between the sizers are interactively adjustable by the user.\n   */\n  export function adjust(\n    sizers: ArrayLike<BoxSizer>,\n    index: number,\n    delta: number\n  ): void {\n    // Bail early when there is nothing to do.\n    if (sizers.length === 0 || delta === 0) {\n      return;\n    }\n\n    // Dispatch to the proper implementation.\n    if (delta > 0) {\n      growSizer(sizers, index, delta);\n    } else {\n      shrinkSizer(sizers, index, -delta);\n    }\n  }\n\n  /**\n   * Grow a sizer by a positive delta and adjust neighbors.\n   */\n  function growSizer(\n    sizers: ArrayLike<BoxSizer>,\n    index: number,\n    delta: number\n  ): void {\n    // Compute how much the items to the left can expand.\n    let growLimit = 0;\n    for (let i = 0; i <= index; ++i) {\n      let sizer = sizers[i];\n      growLimit += sizer.maxSize - sizer.size;\n    }\n\n    // Compute how much the items to the right can shrink.\n    let shrinkLimit = 0;\n    for (let i = index + 1, n = sizers.length; i < n; ++i) {\n      let sizer = sizers[i];\n      shrinkLimit += sizer.size - sizer.minSize;\n    }\n\n    // Clamp the delta adjustment to the limits.\n    delta = Math.min(delta, growLimit, shrinkLimit);\n\n    // Grow the sizers to the left by the delta.\n    let grow = delta;\n    for (let i = index; i >= 0 && grow > 0; --i) {\n      let sizer = sizers[i];\n      let limit = sizer.maxSize - sizer.size;\n      if (limit >= grow) {\n        sizer.sizeHint = sizer.size + grow;\n        grow = 0;\n      } else {\n        sizer.sizeHint = sizer.size + limit;\n        grow -= limit;\n      }\n    }\n\n    // Shrink the sizers to the right by the delta.\n    let shrink = delta;\n    for (let i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {\n      let sizer = sizers[i];\n      let limit = sizer.size - sizer.minSize;\n      if (limit >= shrink) {\n        sizer.sizeHint = sizer.size - shrink;\n        shrink = 0;\n      } else {\n        sizer.sizeHint = sizer.size - limit;\n        shrink -= limit;\n      }\n    }\n  }\n\n  /**\n   * Shrink a sizer by a positive delta and adjust neighbors.\n   */\n  function shrinkSizer(\n    sizers: ArrayLike<BoxSizer>,\n    index: number,\n    delta: number\n  ): void {\n    // Compute how much the items to the right can expand.\n    let growLimit = 0;\n    for (let i = index + 1, n = sizers.length; i < n; ++i) {\n      let sizer = sizers[i];\n      growLimit += sizer.maxSize - sizer.size;\n    }\n\n    // Compute how much the items to the left can shrink.\n    let shrinkLimit = 0;\n    for (let i = 0; i <= index; ++i) {\n      let sizer = sizers[i];\n      shrinkLimit += sizer.size - sizer.minSize;\n    }\n\n    // Clamp the delta adjustment to the limits.\n    delta = Math.min(delta, growLimit, shrinkLimit);\n\n    // Grow the sizers to the right by the delta.\n    let grow = delta;\n    for (let i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {\n      let sizer = sizers[i];\n      let limit = sizer.maxSize - sizer.size;\n      if (limit >= grow) {\n        sizer.sizeHint = sizer.size + grow;\n        grow = 0;\n      } else {\n        sizer.sizeHint = sizer.size + limit;\n        grow -= limit;\n      }\n    }\n\n    // Shrink the sizers to the left by the delta.\n    let shrink = delta;\n    for (let i = index; i >= 0 && shrink > 0; --i) {\n      let sizer = sizers[i];\n      let limit = sizer.size - sizer.minSize;\n      if (limit >= shrink) {\n        sizer.sizeHint = sizer.size - shrink;\n        shrink = 0;\n      } else {\n        sizer.sizeHint = sizer.size - limit;\n        shrink -= limit;\n      }\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IObservableDisposable } from '@lumino/disposable';\n\nimport {\n  ConflatableMessage,\n  IMessageHandler,\n  Message,\n  MessageLoop\n} from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { Layout } from './layout';\n\nimport { Title } from './title';\n\n/**\n * The base class of the lumino widget hierarchy.\n *\n * #### Notes\n * This class will typically be subclassed in order to create a useful\n * widget. However, it can be used directly to host externally created\n * content.\n */\nexport class Widget implements IMessageHandler, IObservableDisposable {\n  /**\n   * Construct a new widget.\n   *\n   * @param options - The options for initializing the widget.\n   */\n  constructor(options: Widget.IOptions = {}) {\n    this.node = Private.createNode(options);\n    this.addClass('lm-Widget');\n  }\n\n  /**\n   * Dispose of the widget and its descendant widgets.\n   *\n   * #### Notes\n   * It is unsafe to use the widget after it has been disposed.\n   *\n   * All calls made to this method after the first are a no-op.\n   */\n  dispose(): void {\n    // Do nothing if the widget is already disposed.\n    if (this.isDisposed) {\n      return;\n    }\n\n    // Set the disposed flag and emit the disposed signal.\n    this.setFlag(Widget.Flag.IsDisposed);\n    this._disposed.emit(undefined);\n\n    // Remove or detach the widget if necessary.\n    if (this.parent) {\n      this.parent = null;\n    } else if (this.isAttached) {\n      Widget.detach(this);\n    }\n\n    // Dispose of the widget layout.\n    if (this._layout) {\n      this._layout.dispose();\n      this._layout = null;\n    }\n\n    // Dispose the title\n    this.title.dispose();\n\n    // Clear the extra data associated with the widget.\n    Signal.clearData(this);\n    MessageLoop.clearData(this);\n    AttachedProperty.clearData(this);\n  }\n\n  /**\n   * A signal emitted when the widget is disposed.\n   */\n  get disposed(): ISignal<this, void> {\n    return this._disposed;\n  }\n\n  /**\n   * Get the DOM node owned by the widget.\n   */\n  readonly node: HTMLElement;\n\n  /**\n   * Test whether the widget has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this.testFlag(Widget.Flag.IsDisposed);\n  }\n\n  /**\n   * Test whether the widget's node is attached to the DOM.\n   */\n  get isAttached(): boolean {\n    return this.testFlag(Widget.Flag.IsAttached);\n  }\n\n  /**\n   * Test whether the widget is explicitly hidden.\n   */\n  get isHidden(): boolean {\n    return this.testFlag(Widget.Flag.IsHidden);\n  }\n\n  /**\n   * Test whether the widget is visible.\n   *\n   * #### Notes\n   * A widget is visible when it is attached to the DOM, is not\n   * explicitly hidden, and has no explicitly hidden ancestors.\n   */\n  get isVisible(): boolean {\n    return this.testFlag(Widget.Flag.IsVisible);\n  }\n\n  /**\n   * The title object for the widget.\n   *\n   * #### Notes\n   * The title object is used by some container widgets when displaying\n   * the widget alongside some title, such as a tab panel or side bar.\n   *\n   * Since not all widgets will use the title, it is created on demand.\n   *\n   * The `owner` property of the title is set to this widget.\n   */\n  get title(): Title<Widget> {\n    return Private.titleProperty.get(this);\n  }\n\n  /**\n   * Get the id of the widget's DOM node.\n   */\n  get id(): string {\n    return this.node.id;\n  }\n\n  /**\n   * Set the id of the widget's DOM node.\n   */\n  set id(value: string) {\n    this.node.id = value;\n  }\n\n  /**\n   * The dataset for the widget's DOM node.\n   */\n  get dataset(): DOMStringMap {\n    return this.node.dataset;\n  }\n\n  /**\n   * Get the method for hiding the widget.\n   */\n  get hiddenMode(): Widget.HiddenMode {\n    return this._hiddenMode;\n  }\n\n  /**\n   * Set the method for hiding the widget.\n   */\n  set hiddenMode(value: Widget.HiddenMode) {\n    if (this._hiddenMode === value) {\n      return;\n    }\n\n    if (this.isHidden) {\n      // Reset styles set by previous mode.\n      this._toggleHidden(false);\n    }\n\n    if (value == Widget.HiddenMode.Scale) {\n      this.node.style.willChange = 'transform';\n    } else {\n      this.node.style.willChange = 'auto';\n    }\n\n    this._hiddenMode = value;\n\n    if (this.isHidden) {\n      // Set styles for new mode.\n      this._toggleHidden(true);\n    }\n  }\n\n  /**\n   * Get the parent of the widget.\n   */\n  get parent(): Widget | null {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the widget.\n   *\n   * #### Notes\n   * Children are typically added to a widget by using a layout, which\n   * means user code will not normally set the parent widget directly.\n   *\n   * The widget will be automatically removed from its old parent.\n   *\n   * This is a no-op if there is no effective parent change.\n   */\n  set parent(value: Widget | null) {\n    if (this._parent === value) {\n      return;\n    }\n    if (value && this.contains(value)) {\n      throw new Error('Invalid parent widget.');\n    }\n    if (this._parent && !this._parent.isDisposed) {\n      let msg = new Widget.ChildMessage('child-removed', this);\n      MessageLoop.sendMessage(this._parent, msg);\n    }\n    this._parent = value;\n    if (this._parent && !this._parent.isDisposed) {\n      let msg = new Widget.ChildMessage('child-added', this);\n      MessageLoop.sendMessage(this._parent, msg);\n    }\n    if (!this.isDisposed) {\n      MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);\n    }\n  }\n\n  /**\n   * Get the layout for the widget.\n   */\n  get layout(): Layout | null {\n    return this._layout;\n  }\n\n  /**\n   * Set the layout for the widget.\n   *\n   * #### Notes\n   * The layout is single-use only. It cannot be changed after the\n   * first assignment.\n   *\n   * The layout is disposed automatically when the widget is disposed.\n   */\n  set layout(value: Layout | null) {\n    if (this._layout === value) {\n      return;\n    }\n    if (this.testFlag(Widget.Flag.DisallowLayout)) {\n      throw new Error('Cannot set widget layout.');\n    }\n    if (this._layout) {\n      throw new Error('Cannot change widget layout.');\n    }\n    if (value!.parent) {\n      throw new Error('Cannot change layout parent.');\n    }\n    this._layout = value;\n    value!.parent = this;\n  }\n\n  /**\n   * Create an iterator over the widget's children.\n   *\n   * @returns A new iterator over the children of the widget.\n   *\n   * #### Notes\n   * The widget must have a populated layout in order to have children.\n   *\n   * If a layout is not installed, the returned iterator will be empty.\n   */\n  *children(): IterableIterator<Widget> {\n    if (this._layout) {\n      yield* this._layout;\n    }\n  }\n\n  /**\n   * Test whether a widget is a descendant of this widget.\n   *\n   * @param widget - The descendant widget of interest.\n   *\n   * @returns `true` if the widget is a descendant, `false` otherwise.\n   */\n  contains(widget: Widget): boolean {\n    for (let value: Widget | null = widget; value; value = value._parent) {\n      if (value === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Test whether the widget's DOM node has the given class name.\n   *\n   * @param name - The class name of interest.\n   *\n   * @returns `true` if the node has the class, `false` otherwise.\n   */\n  hasClass(name: string): boolean {\n    return this.node.classList.contains(name);\n  }\n\n  /**\n   * Add a class name to the widget's DOM node.\n   *\n   * @param name - The class name to add to the node.\n   *\n   * #### Notes\n   * If the class name is already added to the node, this is a no-op.\n   *\n   * The class name must not contain whitespace.\n   */\n  addClass(name: string): void {\n    this.node.classList.add(name);\n  }\n\n  /**\n   * Remove a class name from the widget's DOM node.\n   *\n   * @param name - The class name to remove from the node.\n   *\n   * #### Notes\n   * If the class name is not yet added to the node, this is a no-op.\n   *\n   * The class name must not contain whitespace.\n   */\n  removeClass(name: string): void {\n    this.node.classList.remove(name);\n  }\n\n  /**\n   * Toggle a class name on the widget's DOM node.\n   *\n   * @param name - The class name to toggle on the node.\n   *\n   * @param force - Whether to force add the class (`true`) or force\n   *   remove the class (`false`). If not provided, the presence of\n   *   the class will be toggled from its current state.\n   *\n   * @returns `true` if the class is now present, `false` otherwise.\n   *\n   * #### Notes\n   * The class name must not contain whitespace.\n   */\n  toggleClass(name: string, force?: boolean): boolean {\n    if (force === true) {\n      this.node.classList.add(name);\n      return true;\n    }\n    if (force === false) {\n      this.node.classList.remove(name);\n      return false;\n    }\n    return this.node.classList.toggle(name);\n  }\n\n  /**\n   * Post an `'update-request'` message to the widget.\n   *\n   * #### Notes\n   * This is a simple convenience method for posting the message.\n   */\n  update(): void {\n    MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);\n  }\n\n  /**\n   * Post a `'fit-request'` message to the widget.\n   *\n   * #### Notes\n   * This is a simple convenience method for posting the message.\n   */\n  fit(): void {\n    MessageLoop.postMessage(this, Widget.Msg.FitRequest);\n  }\n\n  /**\n   * Post an `'activate-request'` message to the widget.\n   *\n   * #### Notes\n   * This is a simple convenience method for posting the message.\n   */\n  activate(): void {\n    MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);\n  }\n\n  /**\n   * Send a `'close-request'` message to the widget.\n   *\n   * #### Notes\n   * This is a simple convenience method for sending the message.\n   */\n  close(): void {\n    MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);\n  }\n\n  /**\n   * Show the widget and make it visible to its parent widget.\n   *\n   * #### Notes\n   * This causes the {@link isHidden} property to be `false`.\n   *\n   * If the widget is not explicitly hidden, this is a no-op.\n   */\n  show(): void {\n    if (!this.testFlag(Widget.Flag.IsHidden)) {\n      return;\n    }\n    if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n      MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);\n    }\n    this.clearFlag(Widget.Flag.IsHidden);\n    this._toggleHidden(false);\n\n    if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n      MessageLoop.sendMessage(this, Widget.Msg.AfterShow);\n    }\n    if (this.parent) {\n      let msg = new Widget.ChildMessage('child-shown', this);\n      MessageLoop.sendMessage(this.parent, msg);\n    }\n  }\n\n  /**\n   * Hide the widget and make it hidden to its parent widget.\n   *\n   * #### Notes\n   * This causes the {@link isHidden} property to be `true`.\n   *\n   * If the widget is explicitly hidden, this is a no-op.\n   */\n  hide(): void {\n    if (this.testFlag(Widget.Flag.IsHidden)) {\n      return;\n    }\n    if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n      MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);\n    }\n    this.setFlag(Widget.Flag.IsHidden);\n    this._toggleHidden(true);\n\n    if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n      MessageLoop.sendMessage(this, Widget.Msg.AfterHide);\n    }\n    if (this.parent) {\n      let msg = new Widget.ChildMessage('child-hidden', this);\n      MessageLoop.sendMessage(this.parent, msg);\n    }\n  }\n\n  /**\n   * Show or hide the widget according to a boolean value.\n   *\n   * @param hidden - `true` to hide the widget, or `false` to show it.\n   *\n   * #### Notes\n   * This is a convenience method for `hide()` and `show()`.\n   */\n  setHidden(hidden: boolean): void {\n    if (hidden) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  /**\n   * Test whether the given widget flag is set.\n   *\n   * #### Notes\n   * This will not typically be called directly by user code.\n   */\n  testFlag(flag: Widget.Flag): boolean {\n    return (this._flags & flag) !== 0;\n  }\n\n  /**\n   * Set the given widget flag.\n   *\n   * #### Notes\n   * This will not typically be called directly by user code.\n   */\n  setFlag(flag: Widget.Flag): void {\n    this._flags |= flag;\n  }\n\n  /**\n   * Clear the given widget flag.\n   *\n   * #### Notes\n   * This will not typically be called directly by user code.\n   */\n  clearFlag(flag: Widget.Flag): void {\n    this._flags &= ~flag;\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   *\n   * #### Notes\n   * Subclasses may reimplement this method as needed.\n   */\n  processMessage(msg: Message): void {\n    switch (msg.type) {\n      case 'resize':\n        this.notifyLayout(msg);\n        this.onResize(msg as Widget.ResizeMessage);\n        break;\n      case 'update-request':\n        this.notifyLayout(msg);\n        this.onUpdateRequest(msg);\n        break;\n      case 'fit-request':\n        this.notifyLayout(msg);\n        this.onFitRequest(msg);\n        break;\n      case 'before-show':\n        this.notifyLayout(msg);\n        this.onBeforeShow(msg);\n        break;\n      case 'after-show':\n        this.setFlag(Widget.Flag.IsVisible);\n        this.notifyLayout(msg);\n        this.onAfterShow(msg);\n        break;\n      case 'before-hide':\n        this.notifyLayout(msg);\n        this.onBeforeHide(msg);\n        break;\n      case 'after-hide':\n        this.clearFlag(Widget.Flag.IsVisible);\n        this.notifyLayout(msg);\n        this.onAfterHide(msg);\n        break;\n      case 'before-attach':\n        this.notifyLayout(msg);\n        this.onBeforeAttach(msg);\n        break;\n      case 'after-attach':\n        if (!this.isHidden && (!this.parent || this.parent.isVisible)) {\n          this.setFlag(Widget.Flag.IsVisible);\n        }\n        this.setFlag(Widget.Flag.IsAttached);\n        this.notifyLayout(msg);\n        this.onAfterAttach(msg);\n        break;\n      case 'before-detach':\n        this.notifyLayout(msg);\n        this.onBeforeDetach(msg);\n        break;\n      case 'after-detach':\n        this.clearFlag(Widget.Flag.IsVisible);\n        this.clearFlag(Widget.Flag.IsAttached);\n        this.notifyLayout(msg);\n        this.onAfterDetach(msg);\n        break;\n      case 'activate-request':\n        this.notifyLayout(msg);\n        this.onActivateRequest(msg);\n        break;\n      case 'close-request':\n        this.notifyLayout(msg);\n        this.onCloseRequest(msg);\n        break;\n      case 'child-added':\n        this.notifyLayout(msg);\n        this.onChildAdded(msg as Widget.ChildMessage);\n        break;\n      case 'child-removed':\n        this.notifyLayout(msg);\n        this.onChildRemoved(msg as Widget.ChildMessage);\n        break;\n      default:\n        this.notifyLayout(msg);\n        break;\n    }\n  }\n\n  /**\n   * Invoke the message processing routine of the widget's layout.\n   *\n   * @param msg - The message to dispatch to the layout.\n   *\n   * #### Notes\n   * This is a no-op if the widget does not have a layout.\n   *\n   * This will not typically be called directly by user code.\n   */\n  protected notifyLayout(msg: Message): void {\n    if (this._layout) {\n      this._layout.processParentMessage(msg);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'close-request'` message.\n   *\n   * #### Notes\n   * The default implementation unparents or detaches the widget.\n   */\n  protected onCloseRequest(msg: Message): void {\n    if (this.parent) {\n      this.parent = null;\n    } else if (this.isAttached) {\n      Widget.detach(this);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {}\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onUpdateRequest(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onFitRequest(msg: Message): void {}\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onActivateRequest(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onBeforeShow(msg: Message): void {}\n\n  /**\n   * A message handler invoked on an `'after-show'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onAfterShow(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'before-hide'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onBeforeHide(msg: Message): void {}\n\n  /**\n   * A message handler invoked on an `'after-hide'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onAfterHide(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onBeforeAttach(msg: Message): void {}\n\n  /**\n   * A message handler invoked on an `'after-attach'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onAfterAttach(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'before-detach'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onBeforeDetach(msg: Message): void {}\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onAfterDetach(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'child-added'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onChildAdded(msg: Widget.ChildMessage): void {}\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {}\n\n  private _toggleHidden(hidden: boolean) {\n    if (hidden) {\n      switch (this._hiddenMode) {\n        case Widget.HiddenMode.Display:\n          this.addClass('lm-mod-hidden');\n          break;\n        case Widget.HiddenMode.Scale:\n          this.node.style.transform = 'scale(0)';\n          this.node.setAttribute('aria-hidden', 'true');\n          break;\n        case Widget.HiddenMode.ContentVisibility:\n          // @ts-expect-error content-visibility unknown by DOM lib types\n          this.node.style.contentVisibility = 'hidden';\n          this.node.style.zIndex = '-1';\n          break;\n      }\n    } else {\n      switch (this._hiddenMode) {\n        case Widget.HiddenMode.Display:\n          this.removeClass('lm-mod-hidden');\n          break;\n        case Widget.HiddenMode.Scale:\n          this.node.style.transform = '';\n          this.node.removeAttribute('aria-hidden');\n          break;\n        case Widget.HiddenMode.ContentVisibility:\n          // @ts-expect-error content-visibility unknown by DOM lib types\n          this.node.style.contentVisibility = '';\n          this.node.style.zIndex = '';\n          break;\n      }\n    }\n  }\n\n  private _flags = 0;\n  private _layout: Layout | null = null;\n  private _parent: Widget | null = null;\n  private _disposed = new Signal<this, void>(this);\n  private _hiddenMode: Widget.HiddenMode = Widget.HiddenMode.Display;\n}\n\n/**\n * The namespace for the `Widget` class statics.\n */\nexport namespace Widget {\n  /**\n   * An options object for initializing a widget.\n   */\n  export interface IOptions {\n    /**\n     * The optional node to use for the widget.\n     *\n     * If a node is provided, the widget will assume full ownership\n     * and control of the node, as if it had created the node itself.\n     *\n     * The default is a new `<div>`.\n     */\n    node?: HTMLElement;\n\n    /**\n     * The optional element tag, used for constructing the widget's node.\n     *\n     * If a pre-constructed node is provided via the `node` arg, this\n     * value is ignored.\n     */\n    tag?: keyof HTMLElementTagNameMap;\n  }\n\n  /**\n   * The method for hiding the widget.\n   *\n   * The default is Display.\n   *\n   * Using `Scale` will often increase performance as most browsers will not\n   * trigger style computation for the `transform` action. This should be used\n   * sparingly and tested, since increasing the number of composition layers\n   * may slow things down.\n   *\n   * To ensure the transformation does not trigger style recomputation, you\n   * may need to set the widget CSS style `will-change: transform`. This\n   * should be used only when needed as it may overwhelm the browser with a\n   * high number of layers. See\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\n   */\n  export enum HiddenMode {\n    /**\n     * Set a `lm-mod-hidden` CSS class to hide the widget using `display:none`\n     * CSS from the standard Lumino CSS.\n     */\n    Display = 0,\n\n    /**\n     * Hide the widget by setting the `transform` to `'scale(0)'`.\n     */\n    Scale,\n\n    /**\n     *Hide the widget by setting the `content-visibility` to `'hidden'`.\n     */\n    ContentVisibility\n  }\n\n  /**\n   * An enum of widget bit flags.\n   */\n  export enum Flag {\n    /**\n     * The widget has been disposed.\n     */\n    IsDisposed = 0x1,\n\n    /**\n     * The widget is attached to the DOM.\n     */\n    IsAttached = 0x2,\n\n    /**\n     * The widget is hidden.\n     */\n    IsHidden = 0x4,\n\n    /**\n     * The widget is visible.\n     */\n    IsVisible = 0x8,\n\n    /**\n     * A layout cannot be set on the widget.\n     */\n    DisallowLayout = 0x10\n  }\n\n  /**\n   * A collection of stateless messages related to widgets.\n   */\n  export namespace Msg {\n    /**\n     * A singleton `'before-show'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget before it becomes visible.\n     *\n     * This message is **not** sent when the widget is being attached.\n     */\n    export const BeforeShow = new Message('before-show');\n\n    /**\n     * A singleton `'after-show'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget after it becomes visible.\n     *\n     * This message is **not** sent when the widget is being attached.\n     */\n    export const AfterShow = new Message('after-show');\n\n    /**\n     * A singleton `'before-hide'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget before it becomes not-visible.\n     *\n     * This message is **not** sent when the widget is being detached.\n     */\n    export const BeforeHide = new Message('before-hide');\n\n    /**\n     * A singleton `'after-hide'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget after it becomes not-visible.\n     *\n     * This message is **not** sent when the widget is being detached.\n     */\n    export const AfterHide = new Message('after-hide');\n\n    /**\n     * A singleton `'before-attach'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget before it is attached.\n     */\n    export const BeforeAttach = new Message('before-attach');\n\n    /**\n     * A singleton `'after-attach'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget after it is attached.\n     */\n    export const AfterAttach = new Message('after-attach');\n\n    /**\n     * A singleton `'before-detach'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget before it is detached.\n     */\n    export const BeforeDetach = new Message('before-detach');\n\n    /**\n     * A singleton `'after-detach'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget after it is detached.\n     */\n    export const AfterDetach = new Message('after-detach');\n\n    /**\n     * A singleton `'parent-changed'` message.\n     *\n     * #### Notes\n     * This message is sent to a widget when its parent has changed.\n     */\n    export const ParentChanged = new Message('parent-changed');\n\n    /**\n     * A singleton conflatable `'update-request'` message.\n     *\n     * #### Notes\n     * This message can be dispatched to supporting widgets in order to\n     * update their content based on the current widget state. Not all\n     * widgets will respond to messages of this type.\n     *\n     * For widgets with a layout, this message will inform the layout to\n     * update the position and size of its child widgets.\n     */\n    export const UpdateRequest = new ConflatableMessage('update-request');\n\n    /**\n     * A singleton conflatable `'fit-request'` message.\n     *\n     * #### Notes\n     * For widgets with a layout, this message will inform the layout to\n     * recalculate its size constraints to fit the space requirements of\n     * its child widgets, and to update their position and size. Not all\n     * layouts will respond to messages of this type.\n     */\n    export const FitRequest = new ConflatableMessage('fit-request');\n\n    /**\n     * A singleton conflatable `'activate-request'` message.\n     *\n     * #### Notes\n     * This message should be dispatched to a widget when it should\n     * perform the actions necessary to activate the widget, which\n     * may include focusing its node or descendant node.\n     */\n    export const ActivateRequest = new ConflatableMessage('activate-request');\n\n    /**\n     * A singleton conflatable `'close-request'` message.\n     *\n     * #### Notes\n     * This message should be dispatched to a widget when it should close\n     * and remove itself from the widget hierarchy.\n     */\n    export const CloseRequest = new ConflatableMessage('close-request');\n  }\n\n  /**\n   * A message class for child related messages.\n   */\n  export class ChildMessage extends Message {\n    /**\n     * Construct a new child message.\n     *\n     * @param type - The message type.\n     *\n     * @param child - The child widget for the message.\n     */\n    constructor(type: string, child: Widget) {\n      super(type);\n      this.child = child;\n    }\n\n    /**\n     * The child widget for the message.\n     */\n    readonly child: Widget;\n  }\n\n  /**\n   * A message class for `'resize'` messages.\n   */\n  export class ResizeMessage extends Message {\n    /**\n     * Construct a new resize message.\n     *\n     * @param width - The **offset width** of the widget, or `-1` if\n     *   the width is not known.\n     *\n     * @param height - The **offset height** of the widget, or `-1` if\n     *   the height is not known.\n     */\n    constructor(width: number, height: number) {\n      super('resize');\n      this.width = width;\n      this.height = height;\n    }\n\n    /**\n     * The offset width of the widget.\n     *\n     * #### Notes\n     * This will be `-1` if the width is unknown.\n     */\n    readonly width: number;\n\n    /**\n     * The offset height of the widget.\n     *\n     * #### Notes\n     * This will be `-1` if the height is unknown.\n     */\n    readonly height: number;\n  }\n\n  /**\n   * The namespace for the `ResizeMessage` class statics.\n   */\n  export namespace ResizeMessage {\n    /**\n     * A singleton `'resize'` message with an unknown size.\n     */\n    export const UnknownSize = new ResizeMessage(-1, -1);\n  }\n\n  /**\n   * Attach a widget to a host DOM node.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param host - The DOM node to use as the widget's host.\n   *\n   * @param ref - The child of `host` to use as the reference element.\n   *   If this is provided, the widget will be inserted before this\n   *   node in the host. The default is `null`, which will cause the\n   *   widget to be added as the last child of the host.\n   *\n   * #### Notes\n   * This will throw an error if the widget is not a root widget, if\n   * the widget is already attached, or if the host is not attached\n   * to the DOM.\n   */\n  export function attach(\n    widget: Widget,\n    host: HTMLElement,\n    ref: HTMLElement | null = null\n  ): void {\n    if (widget.parent) {\n      throw new Error('Cannot attach a child widget.');\n    }\n    if (widget.isAttached || widget.node.isConnected) {\n      throw new Error('Widget is already attached.');\n    }\n    if (!host.isConnected) {\n      throw new Error('Host is not attached.');\n    }\n    MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    host.insertBefore(widget.node, ref);\n    MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n  }\n\n  /**\n   * Detach the widget from its host DOM node.\n   *\n   * @param widget - The widget of interest.\n   *\n   * #### Notes\n   * This will throw an error if the widget is not a root widget,\n   * or if the widget is not attached to the DOM.\n   */\n  export function detach(widget: Widget): void {\n    if (widget.parent) {\n      throw new Error('Cannot detach a child widget.');\n    }\n    if (!widget.isAttached || !widget.node.isConnected) {\n      throw new Error('Widget is not attached.');\n    }\n    MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    widget.node.parentNode!.removeChild(widget.node);\n    MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An attached property for the widget title object.\n   */\n  export const titleProperty = new AttachedProperty<Widget, Title<Widget>>({\n    name: 'title',\n    create: owner => new Title<Widget>({ owner })\n  });\n\n  /**\n   * Create a DOM node for the given widget options.\n   */\n  export function createNode(options: Widget.IOptions): HTMLElement {\n    return options.node || document.createElement(options.tag || 'div');\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { Signal } from '@lumino/signaling';\n\nimport { Widget } from './widget';\n\n/**\n * An abstract base class for creating lumino layouts.\n *\n * #### Notes\n * A layout is used to add widgets to a parent and to arrange those\n * widgets within the parent's DOM node.\n *\n * This class implements the base functionality which is required of\n * nearly all layouts. It must be subclassed in order to be useful.\n *\n * Notably, this class does not define a uniform interface for adding\n * widgets to the layout. A subclass should define that API in a way\n * which is meaningful for its intended use.\n */\nexport abstract class Layout implements Iterable<Widget>, IDisposable {\n  /**\n   * Construct a new layout.\n   *\n   * @param options - The options for initializing the layout.\n   */\n  constructor(options: Layout.IOptions = {}) {\n    this._fitPolicy = options.fitPolicy || 'set-min-size';\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   *\n   * #### Notes\n   * This should be reimplemented to clear and dispose of the widgets.\n   *\n   * All reimplementations should call the superclass method.\n   *\n   * This method is called automatically when the parent is disposed.\n   */\n  dispose(): void {\n    this._parent = null;\n    this._disposed = true;\n    Signal.clearData(this);\n    AttachedProperty.clearData(this);\n  }\n\n  /**\n   * Test whether the layout is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Get the parent widget of the layout.\n   */\n  get parent(): Widget | null {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent widget of the layout.\n   *\n   * #### Notes\n   * This is set automatically when installing the layout on the parent\n   * widget. The parent widget should not be set directly by user code.\n   */\n  set parent(value: Widget | null) {\n    if (this._parent === value) {\n      return;\n    }\n    if (this._parent) {\n      throw new Error('Cannot change parent widget.');\n    }\n    if (value!.layout !== this) {\n      throw new Error('Invalid parent widget.');\n    }\n    this._parent = value;\n    this.init();\n  }\n\n  /**\n   * Get the fit policy for the layout.\n   *\n   * #### Notes\n   * The fit policy controls the computed size constraints which are\n   * applied to the parent widget by the layout.\n   *\n   * Some layout implementations may ignore the fit policy.\n   */\n  get fitPolicy(): Layout.FitPolicy {\n    return this._fitPolicy;\n  }\n\n  /**\n   * Set the fit policy for the layout.\n   *\n   * #### Notes\n   * The fit policy controls the computed size constraints which are\n   * applied to the parent widget by the layout.\n   *\n   * Some layout implementations may ignore the fit policy.\n   *\n   * Changing the fit policy will clear the current size constraint\n   * for the parent widget and then re-fit the parent.\n   */\n  set fitPolicy(value: Layout.FitPolicy) {\n    // Bail if the policy does not change\n    if (this._fitPolicy === value) {\n      return;\n    }\n\n    // Update the internal policy.\n    this._fitPolicy = value;\n\n    // Clear the size constraints and schedule a fit of the parent.\n    if (this._parent) {\n      let style = this._parent.node.style;\n      style.minWidth = '';\n      style.minHeight = '';\n      style.maxWidth = '';\n      style.maxHeight = '';\n      this._parent.fit();\n    }\n  }\n\n  /**\n   * Create an iterator over the widgets in the layout.\n   *\n   * @returns A new iterator over the widgets in the layout.\n   *\n   * #### Notes\n   * This abstract method must be implemented by a subclass.\n   */\n  abstract [Symbol.iterator](): IterableIterator<Widget>;\n\n  /**\n   * Remove a widget from the layout.\n   *\n   * @param widget - The widget to remove from the layout.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method should *not* modify the widget's `parent`.\n   */\n  abstract removeWidget(widget: Widget): void;\n\n  /**\n   * Process a message sent to the parent widget.\n   *\n   * @param msg - The message sent to the parent widget.\n   *\n   * #### Notes\n   * This method is called by the parent widget to process a message.\n   *\n   * Subclasses may reimplement this method as needed.\n   */\n  processParentMessage(msg: Message): void {\n    switch (msg.type) {\n      case 'resize':\n        this.onResize(msg as Widget.ResizeMessage);\n        break;\n      case 'update-request':\n        this.onUpdateRequest(msg);\n        break;\n      case 'fit-request':\n        this.onFitRequest(msg);\n        break;\n      case 'before-show':\n        this.onBeforeShow(msg);\n        break;\n      case 'after-show':\n        this.onAfterShow(msg);\n        break;\n      case 'before-hide':\n        this.onBeforeHide(msg);\n        break;\n      case 'after-hide':\n        this.onAfterHide(msg);\n        break;\n      case 'before-attach':\n        this.onBeforeAttach(msg);\n        break;\n      case 'after-attach':\n        this.onAfterAttach(msg);\n        break;\n      case 'before-detach':\n        this.onBeforeDetach(msg);\n        break;\n      case 'after-detach':\n        this.onAfterDetach(msg);\n        break;\n      case 'child-removed':\n        this.onChildRemoved(msg as Widget.ChildMessage);\n        break;\n      case 'child-shown':\n        this.onChildShown(msg as Widget.ChildMessage);\n        break;\n      case 'child-hidden':\n        this.onChildHidden(msg as Widget.ChildMessage);\n        break;\n    }\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   *\n   * #### Notes\n   * This method is invoked immediately after the layout is installed\n   * on the parent widget.\n   *\n   * The default implementation reparents all of the widgets to the\n   * layout parent widget.\n   *\n   * Subclasses should reimplement this method and attach the child\n   * widget nodes to the parent widget's node.\n   */\n  protected init(): void {\n    for (const widget of this) {\n      widget.parent = this.parent;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   *\n   * #### Notes\n   * The layout should ensure that its widgets are resized according\n   * to the specified layout space, and that they are sent a `'resize'`\n   * message if appropriate.\n   *\n   * The default implementation of this method sends an `UnknownSize`\n   * resize message to all widgets.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   *\n   * #### Notes\n   * The layout should ensure that its widgets are resized according\n   * to the available layout space, and that they are sent a `'resize'`\n   * message if appropriate.\n   *\n   * The default implementation of this method sends an `UnknownSize`\n   * resize message to all widgets.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message\n   * to all widgets. It assumes all widget nodes are attached to the\n   * parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, msg);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'after-attach'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message\n   * to all widgets. It assumes all widget nodes are attached to the\n   * parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onAfterAttach(msg: Message): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, msg);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-detach'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message\n   * to all widgets. It assumes all widget nodes are attached to the\n   * parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onBeforeDetach(msg: Message): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, msg);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message\n   * to all widgets. It assumes all widget nodes are attached to the\n   * parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onAfterDetach(msg: Message): void {\n    for (const widget of this) {\n      MessageLoop.sendMessage(widget, msg);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message to\n   * all non-hidden widgets. It assumes all widget nodes are attached\n   * to the parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onBeforeShow(msg: Message): void {\n    for (const widget of this) {\n      if (!widget.isHidden) {\n        MessageLoop.sendMessage(widget, msg);\n      }\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'after-show'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message to\n   * all non-hidden widgets. It assumes all widget nodes are attached\n   * to the parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onAfterShow(msg: Message): void {\n    for (const widget of this) {\n      if (!widget.isHidden) {\n        MessageLoop.sendMessage(widget, msg);\n      }\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-hide'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message to\n   * all non-hidden widgets. It assumes all widget nodes are attached\n   * to the parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onBeforeHide(msg: Message): void {\n    for (const widget of this) {\n      if (!widget.isHidden) {\n        MessageLoop.sendMessage(widget, msg);\n      }\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'after-hide'` message.\n   *\n   * #### Notes\n   * The default implementation of this method forwards the message to\n   * all non-hidden widgets. It assumes all widget nodes are attached\n   * to the parent widget node.\n   *\n   * This may be reimplemented by subclasses as needed.\n   */\n  protected onAfterHide(msg: Message): void {\n    for (const widget of this) {\n      if (!widget.isHidden) {\n        MessageLoop.sendMessage(widget, msg);\n      }\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   *\n   * #### Notes\n   * This will remove the child widget from the layout.\n   *\n   * Subclasses should **not** typically reimplement this method.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    this.removeWidget(msg.child);\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onFitRequest(msg: Message): void {}\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {}\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   *\n   * #### Notes\n   * The default implementation of this handler is a no-op.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {}\n\n  private _disposed = false;\n  private _fitPolicy: Layout.FitPolicy;\n  private _parent: Widget | null = null;\n}\n\n/**\n * The namespace for the `Layout` class statics.\n */\nexport namespace Layout {\n  /**\n   * A type alias for the layout fit policy.\n   *\n   * #### Notes\n   * The fit policy controls the computed size constraints which are\n   * applied to the parent widget by the layout.\n   *\n   * Some layout implementations may ignore the fit policy.\n   */\n  export type FitPolicy =\n    | /**\n     * No size constraint will be applied to the parent widget.\n     */\n    'set-no-constraint'\n\n    /**\n     * The computed min size will be applied to the parent widget.\n     */\n    | 'set-min-size';\n\n  /**\n   * An options object for initializing a layout.\n   */\n  export interface IOptions {\n    /**\n     * The fit policy for the layout.\n     *\n     * The default is `'set-min-size'`.\n     */\n    fitPolicy?: FitPolicy;\n  }\n\n  /**\n   * A type alias for the horizontal alignment of a widget.\n   */\n  export type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the vertical alignment of a widget.\n   */\n  export type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * Get the horizontal alignment for a widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The horizontal alignment for the widget.\n   *\n   * #### Notes\n   * If the layout width allocated to a widget is larger than its max\n   * width, the horizontal alignment controls how the widget is placed\n   * within the extra horizontal space.\n   *\n   * If the allocated width is less than the widget's max width, the\n   * horizontal alignment has no effect.\n   *\n   * Some layout implementations may ignore horizontal alignment.\n   */\n  export function getHorizontalAlignment(widget: Widget): HorizontalAlignment {\n    return Private.horizontalAlignmentProperty.get(widget);\n  }\n\n  /**\n   * Set the horizontal alignment for a widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the horizontal alignment.\n   *\n   * #### Notes\n   * If the layout width allocated to a widget is larger than its max\n   * width, the horizontal alignment controls how the widget is placed\n   * within the extra horizontal space.\n   *\n   * If the allocated width is less than the widget's max width, the\n   * horizontal alignment has no effect.\n   *\n   * Some layout implementations may ignore horizontal alignment.\n   *\n   * Changing the horizontal alignment will post an `update-request`\n   * message to widget's parent, provided the parent has a layout\n   * installed.\n   */\n  export function setHorizontalAlignment(\n    widget: Widget,\n    value: HorizontalAlignment\n  ): void {\n    Private.horizontalAlignmentProperty.set(widget, value);\n  }\n\n  /**\n   * Get the vertical alignment for a widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The vertical alignment for the widget.\n   *\n   * #### Notes\n   * If the layout height allocated to a widget is larger than its max\n   * height, the vertical alignment controls how the widget is placed\n   * within the extra vertical space.\n   *\n   * If the allocated height is less than the widget's max height, the\n   * vertical alignment has no effect.\n   *\n   * Some layout implementations may ignore vertical alignment.\n   */\n  export function getVerticalAlignment(widget: Widget): VerticalAlignment {\n    return Private.verticalAlignmentProperty.get(widget);\n  }\n\n  /**\n   * Set the vertical alignment for a widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the vertical alignment.\n   *\n   * #### Notes\n   * If the layout height allocated to a widget is larger than its max\n   * height, the vertical alignment controls how the widget is placed\n   * within the extra vertical space.\n   *\n   * If the allocated height is less than the widget's max height, the\n   * vertical alignment has no effect.\n   *\n   * Some layout implementations may ignore vertical alignment.\n   *\n   * Changing the horizontal alignment will post an `update-request`\n   * message to widget's parent, provided the parent has a layout\n   * installed.\n   */\n  export function setVerticalAlignment(\n    widget: Widget,\n    value: VerticalAlignment\n  ): void {\n    Private.verticalAlignmentProperty.set(widget, value);\n  }\n}\n\n/**\n * An object which assists in the absolute layout of widgets.\n *\n * #### Notes\n * This class is useful when implementing a layout which arranges its\n * widgets using absolute positioning.\n *\n * This class is used by nearly all of the built-in lumino layouts.\n */\nexport class LayoutItem implements IDisposable {\n  /**\n   * Construct a new layout item.\n   *\n   * @param widget - The widget to be managed by the item.\n   *\n   * #### Notes\n   * The widget will be set to absolute positioning.\n   * The widget will use strict CSS containment.\n   */\n  constructor(widget: Widget) {\n    this.widget = widget;\n    this.widget.node.style.position = 'absolute';\n    this.widget.node.style.contain = 'strict';\n  }\n\n  /**\n   * Dispose of the the layout item.\n   *\n   * #### Notes\n   * This will reset the positioning of the widget.\n   */\n  dispose(): void {\n    // Do nothing if the item is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Mark the item as disposed.\n    this._disposed = true;\n\n    // Reset the widget style.\n    let style = this.widget.node.style;\n    style.position = '';\n    style.top = '';\n    style.left = '';\n    style.width = '';\n    style.height = '';\n    style.contain = '';\n  }\n\n  /**\n   * The widget managed by the layout item.\n   */\n  readonly widget: Widget;\n\n  /**\n   * The computed minimum width of the widget.\n   *\n   * #### Notes\n   * This value can be updated by calling the `fit` method.\n   */\n  get minWidth(): number {\n    return this._minWidth;\n  }\n\n  /**\n   * The computed minimum height of the widget.\n   *\n   * #### Notes\n   * This value can be updated by calling the `fit` method.\n   */\n  get minHeight(): number {\n    return this._minHeight;\n  }\n\n  /**\n   * The computed maximum width of the widget.\n   *\n   * #### Notes\n   * This value can be updated by calling the `fit` method.\n   */\n  get maxWidth(): number {\n    return this._maxWidth;\n  }\n\n  /**\n   * The computed maximum height of the widget.\n   *\n   * #### Notes\n   * This value can be updated by calling the `fit` method.\n   */\n  get maxHeight(): number {\n    return this._maxHeight;\n  }\n\n  /**\n   * Whether the layout item is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Whether the managed widget is hidden.\n   */\n  get isHidden(): boolean {\n    return this.widget.isHidden;\n  }\n\n  /**\n   * Whether the managed widget is visible.\n   */\n  get isVisible(): boolean {\n    return this.widget.isVisible;\n  }\n\n  /**\n   * Whether the managed widget is attached.\n   */\n  get isAttached(): boolean {\n    return this.widget.isAttached;\n  }\n\n  /**\n   * Update the computed size limits of the managed widget.\n   */\n  fit(): void {\n    let limits = ElementExt.sizeLimits(this.widget.node);\n    this._minWidth = limits.minWidth;\n    this._minHeight = limits.minHeight;\n    this._maxWidth = limits.maxWidth;\n    this._maxHeight = limits.maxHeight;\n  }\n\n  /**\n   * Update the position and size of the managed widget.\n   *\n   * @param left - The left edge position of the layout box.\n   *\n   * @param top - The top edge position of the layout box.\n   *\n   * @param width - The width of the layout box.\n   *\n   * @param height - The height of the layout box.\n   */\n  update(left: number, top: number, width: number, height: number): void {\n    // Clamp the size to the computed size limits.\n    let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));\n    let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));\n\n    // Adjust the left edge for the horizontal alignment, if needed.\n    if (clampW < width) {\n      switch (Layout.getHorizontalAlignment(this.widget)) {\n        case 'left':\n          break;\n        case 'center':\n          left += (width - clampW) / 2;\n          break;\n        case 'right':\n          left += width - clampW;\n          break;\n        default:\n          throw 'unreachable';\n      }\n    }\n\n    // Adjust the top edge for the vertical alignment, if needed.\n    if (clampH < height) {\n      switch (Layout.getVerticalAlignment(this.widget)) {\n        case 'top':\n          break;\n        case 'center':\n          top += (height - clampH) / 2;\n          break;\n        case 'bottom':\n          top += height - clampH;\n          break;\n        default:\n          throw 'unreachable';\n      }\n    }\n\n    // Set up the resize variables.\n    let resized = false;\n    let style = this.widget.node.style;\n\n    // Update the top edge of the widget if needed.\n    if (this._top !== top) {\n      this._top = top;\n      style.top = `${top}px`;\n    }\n\n    // Update the left edge of the widget if needed.\n    if (this._left !== left) {\n      this._left = left;\n      style.left = `${left}px`;\n    }\n\n    // Update the width of the widget if needed.\n    if (this._width !== clampW) {\n      resized = true;\n      this._width = clampW;\n      style.width = `${clampW}px`;\n    }\n\n    // Update the height of the widget if needed.\n    if (this._height !== clampH) {\n      resized = true;\n      this._height = clampH;\n      style.height = `${clampH}px`;\n    }\n\n    // Send a resize message to the widget if needed.\n    if (resized) {\n      let msg = new Widget.ResizeMessage(clampW, clampH);\n      MessageLoop.sendMessage(this.widget, msg);\n    }\n  }\n\n  private _top = NaN;\n  private _left = NaN;\n  private _width = NaN;\n  private _height = NaN;\n  private _minWidth = 0;\n  private _minHeight = 0;\n  private _maxWidth = Infinity;\n  private _maxHeight = Infinity;\n  private _disposed = false;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The attached property for a widget horizontal alignment.\n   */\n  export const horizontalAlignmentProperty = new AttachedProperty<\n    Widget,\n    Layout.HorizontalAlignment\n  >({\n    name: 'horizontalAlignment',\n    create: () => 'center',\n    changed: onAlignmentChanged\n  });\n\n  /**\n   * The attached property for a widget vertical alignment.\n   */\n  export const verticalAlignmentProperty = new AttachedProperty<\n    Widget,\n    Layout.VerticalAlignment\n  >({\n    name: 'verticalAlignment',\n    create: () => 'top',\n    changed: onAlignmentChanged\n  });\n\n  /**\n   * The change handler for the attached alignment properties.\n   */\n  function onAlignmentChanged(child: Widget): void {\n    if (child.parent && child.parent.layout) {\n      child.parent.update();\n    }\n  }\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\nexport namespace Utils {\n  /**\n   * Clamp a dimension value to an integer >= 0.\n   */\n  export function clampDimension(value: number): number {\n    return Math.max(0, Math.floor(value));\n  }\n}\n\nexport default Utils;\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { VirtualElement } from '@lumino/virtualdom';\n\n/**\n * An object which holds data related to an object's title.\n *\n * #### Notes\n * A title object is intended to hold the data necessary to display a\n * header for a particular object. A common example is the `TabPanel`,\n * which uses the widget title to populate the tab for a child widget.\n *\n * It is the responsibility of the owner to call the title disposal.\n */\nexport class Title<T> implements IDisposable {\n  /**\n   * Construct a new title.\n   *\n   * @param options - The options for initializing the title.\n   */\n  constructor(options: Title.IOptions<T>) {\n    this.owner = options.owner;\n    if (options.label !== undefined) {\n      this._label = options.label;\n    }\n    if (options.mnemonic !== undefined) {\n      this._mnemonic = options.mnemonic;\n    }\n    if (options.icon !== undefined) {\n      this._icon = options.icon;\n    }\n\n    if (options.iconClass !== undefined) {\n      this._iconClass = options.iconClass;\n    }\n    if (options.iconLabel !== undefined) {\n      this._iconLabel = options.iconLabel;\n    }\n    if (options.caption !== undefined) {\n      this._caption = options.caption;\n    }\n    if (options.className !== undefined) {\n      this._className = options.className;\n    }\n    if (options.closable !== undefined) {\n      this._closable = options.closable;\n    }\n    this._dataset = options.dataset || {};\n  }\n\n  /**\n   * A signal emitted when the state of the title changes.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * The object which owns the title.\n   */\n  readonly owner: T;\n\n  /**\n   * Get the label for the title.\n   *\n   * #### Notes\n   * The default value is an empty string.\n   */\n  get label(): string {\n    return this._label;\n  }\n\n  /**\n   * Set the label for the title.\n   */\n  set label(value: string) {\n    if (this._label === value) {\n      return;\n    }\n    this._label = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the mnemonic index for the title.\n   *\n   * #### Notes\n   * The default value is `-1`.\n   */\n  get mnemonic(): number {\n    return this._mnemonic;\n  }\n\n  /**\n   * Set the mnemonic index for the title.\n   */\n  set mnemonic(value: number) {\n    if (this._mnemonic === value) {\n      return;\n    }\n    this._mnemonic = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the icon renderer for the title.\n   *\n   * #### Notes\n   * The default value is undefined.\n   */\n  get icon(): VirtualElement.IRenderer | undefined {\n    return this._icon;\n  }\n\n  /**\n   * Set the icon renderer for the title.\n   *\n   * #### Notes\n   * A renderer is an object that supplies a render and unrender function.\n   */\n  set icon(value: VirtualElement.IRenderer | undefined) {\n    if (this._icon === value) {\n      return;\n    }\n    this._icon = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the icon class name for the title.\n   *\n   * #### Notes\n   * The default value is an empty string.\n   */\n  get iconClass(): string {\n    return this._iconClass;\n  }\n\n  /**\n   * Set the icon class name for the title.\n   *\n   * #### Notes\n   * Multiple class names can be separated with whitespace.\n   */\n  set iconClass(value: string) {\n    if (this._iconClass === value) {\n      return;\n    }\n    this._iconClass = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the icon label for the title.\n   *\n   * #### Notes\n   * The default value is an empty string.\n   */\n  get iconLabel(): string {\n    return this._iconLabel;\n  }\n\n  /**\n   * Set the icon label for the title.\n   *\n   * #### Notes\n   * Multiple class names can be separated with whitespace.\n   */\n  set iconLabel(value: string) {\n    if (this._iconLabel === value) {\n      return;\n    }\n    this._iconLabel = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the caption for the title.\n   *\n   * #### Notes\n   * The default value is an empty string.\n   */\n  get caption(): string {\n    return this._caption;\n  }\n\n  /**\n   * Set the caption for the title.\n   */\n  set caption(value: string) {\n    if (this._caption === value) {\n      return;\n    }\n    this._caption = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the extra class name for the title.\n   *\n   * #### Notes\n   * The default value is an empty string.\n   */\n  get className(): string {\n    return this._className;\n  }\n\n  /**\n   * Set the extra class name for the title.\n   *\n   * #### Notes\n   * Multiple class names can be separated with whitespace.\n   */\n  set className(value: string) {\n    if (this._className === value) {\n      return;\n    }\n    this._className = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the closable state for the title.\n   *\n   * #### Notes\n   * The default value is `false`.\n   */\n  get closable(): boolean {\n    return this._closable;\n  }\n\n  /**\n   * Set the closable state for the title.\n   *\n   * #### Notes\n   * This controls the presence of a close icon when applicable.\n   */\n  set closable(value: boolean) {\n    if (this._closable === value) {\n      return;\n    }\n    this._closable = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Get the dataset for the title.\n   *\n   * #### Notes\n   * The default value is an empty dataset.\n   */\n  get dataset(): Title.Dataset {\n    return this._dataset;\n  }\n\n  /**\n   * Set the dataset for the title.\n   *\n   * #### Notes\n   * This controls the data attributes when applicable.\n   */\n  set dataset(value: Title.Dataset) {\n    if (this._dataset === value) {\n      return;\n    }\n    this._dataset = value;\n    this._changed.emit(undefined);\n  }\n\n  /**\n   * Test whether the title has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the title.\n   *\n   * #### Notes\n   * It is the responsibility of the owner to call the title disposal.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n\n    Signal.clearData(this);\n  }\n\n  private _label = '';\n  private _caption = '';\n  private _mnemonic = -1;\n  private _icon: VirtualElement.IRenderer | undefined = undefined;\n  private _iconClass = '';\n  private _iconLabel = '';\n  private _className = '';\n  private _closable = false;\n  private _dataset: Title.Dataset;\n  private _changed = new Signal<this, void>(this);\n  private _isDisposed = false;\n}\n\n/**\n * The namespace for the `Title` class statics.\n */\nexport namespace Title {\n  /**\n   * A type alias for a simple immutable string dataset.\n   */\n  export type Dataset = { readonly [key: string]: string };\n\n  /**\n   * An options object for initializing a title.\n   */\n  export interface IOptions<T> {\n    /**\n     * The object which owns the title.\n     */\n    owner: T;\n\n    /**\n     * The label for the title.\n     */\n    label?: string;\n\n    /**\n     * The mnemonic index for the title.\n     */\n    mnemonic?: number;\n\n    /**\n     * The icon renderer for the title.\n     */\n    icon?: VirtualElement.IRenderer;\n\n    /**\n     * The icon class name for the title.\n     */\n    iconClass?: string;\n\n    /**\n     * The icon label for the title.\n     */\n    iconLabel?: string;\n\n    /**\n     * The caption for the title.\n     */\n    caption?: string;\n\n    /**\n     * The extra class name for the title.\n     */\n    className?: string;\n\n    /**\n     * The closable state for the title.\n     */\n    closable?: boolean;\n\n    /**\n     * The dataset for the title.\n     */\n    dataset?: Dataset;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { MessageLoop } from '@lumino/messaging';\n\nimport { Layout } from './layout';\n\nimport { Widget } from './widget';\n\n/**\n * A concrete layout implementation suitable for many use cases.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * layouts, but can also be used directly with standard CSS to layout a\n * collection of widgets.\n */\nexport class PanelLayout extends Layout {\n  /**\n   * Dispose of the resources held by the layout.\n   *\n   * #### Notes\n   * This will clear and dispose all widgets in the layout.\n   *\n   * All reimplementations should call the superclass method.\n   *\n   * This method is called automatically when the parent is disposed.\n   */\n  dispose(): void {\n    while (this._widgets.length > 0) {\n      this._widgets.pop()!.dispose();\n    }\n    super.dispose();\n  }\n\n  /**\n   * A read-only array of the widgets in the layout.\n   */\n  get widgets(): ReadonlyArray<Widget> {\n    return this._widgets;\n  }\n\n  /**\n   * Create an iterator over the widgets in the layout.\n   *\n   * @returns A new iterator over the widgets in the layout.\n   */\n  *[Symbol.iterator](): IterableIterator<Widget> {\n    yield* this._widgets;\n  }\n\n  /**\n   * Add a widget to the end of the layout.\n   *\n   * @param widget - The widget to add to the layout.\n   *\n   * #### Notes\n   * If the widget is already contained in the layout, it will be moved.\n   */\n  addWidget(widget: Widget): void {\n    this.insertWidget(this._widgets.length, widget);\n  }\n\n  /**\n   * Insert a widget into the layout at the specified index.\n   *\n   * @param index - The index at which to insert the widget.\n   *\n   * @param widget - The widget to insert into the layout.\n   *\n   * #### Notes\n   * The index will be clamped to the bounds of the widgets.\n   *\n   * If the widget is already added to the layout, it will be moved.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   */\n  insertWidget(index: number, widget: Widget): void {\n    // Remove the widget from its current parent. This is a no-op\n    // if the widget's parent is already the layout parent widget.\n    widget.parent = this.parent;\n\n    // Look up the current index of the widget.\n    let i = this._widgets.indexOf(widget);\n\n    // Clamp the insert index to the array bounds.\n    let j = Math.max(0, Math.min(index, this._widgets.length));\n\n    // If the widget is not in the array, insert it.\n    if (i === -1) {\n      // Insert the widget into the array.\n      ArrayExt.insert(this._widgets, j, widget);\n\n      // If the layout is parented, attach the widget to the DOM.\n      if (this.parent) {\n        this.attachWidget(j, widget);\n      }\n\n      // There is nothing more to do.\n      return;\n    }\n\n    // Otherwise, the widget exists in the array and should be moved.\n\n    // Adjust the index if the location is at the end of the array.\n    if (j === this._widgets.length) {\n      j--;\n    }\n\n    // Bail if there is no effective move.\n    if (i === j) {\n      return;\n    }\n\n    // Move the widget to the new location.\n    ArrayExt.move(this._widgets, i, j);\n\n    // If the layout is parented, move the widget in the DOM.\n    if (this.parent) {\n      this.moveWidget(i, j, widget);\n    }\n  }\n\n  /**\n   * Remove a widget from the layout.\n   *\n   * @param widget - The widget to remove from the layout.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method does *not* modify the widget's `parent`.\n   */\n  removeWidget(widget: Widget): void {\n    this.removeWidgetAt(this._widgets.indexOf(widget));\n  }\n\n  /**\n   * Remove the widget at a given index from the layout.\n   *\n   * @param index - The index of the widget to remove.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method does *not* modify the widget's `parent`.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   */\n  removeWidgetAt(index: number): void {\n    // Remove the widget from the array.\n    let widget = ArrayExt.removeAt(this._widgets, index);\n\n    // If the layout is parented, detach the widget from the DOM.\n    if (widget && this.parent) {\n      this.detachWidget(index, widget);\n    }\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    super.init();\n    let index = 0;\n    for (const widget of this) {\n      this.attachWidget(index++, widget);\n    }\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This method is called automatically by the panel layout at the\n   * appropriate time. It should not be called directly by user code.\n   *\n   * The default implementation adds the widgets's node to the parent's\n   * node at the proper location, and sends the appropriate attach\n   * messages to the widget if the parent is attached to the DOM.\n   *\n   * Subclasses may reimplement this method to control how the widget's\n   * node is added to the parent's node.\n   */\n  protected attachWidget(index: number, widget: Widget): void {\n    // Look up the next sibling reference node.\n    let ref = this.parent!.node.children[index];\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Insert the widget's node before the sibling.\n    this.parent!.node.insertBefore(widget.node, ref);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n  }\n\n  /**\n   * Move a widget in the parent's DOM node.\n   *\n   * @param fromIndex - The previous index of the widget in the layout.\n   *\n   * @param toIndex - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to move in the parent.\n   *\n   * #### Notes\n   * This method is called automatically by the panel layout at the\n   * appropriate time. It should not be called directly by user code.\n   *\n   * The default implementation moves the widget's node to the proper\n   * location in the parent's node and sends the appropriate attach and\n   * detach messages to the widget if the parent is attached to the DOM.\n   *\n   * Subclasses may reimplement this method to control how the widget's\n   * node is moved in the parent's node.\n   */\n  protected moveWidget(\n    fromIndex: number,\n    toIndex: number,\n    widget: Widget\n  ): void {\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` and  message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Look up the next sibling reference node.\n    let ref = this.parent!.node.children[toIndex];\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Insert the widget's node before the sibling.\n    this.parent!.node.insertBefore(widget.node, ref);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param index - The previous index of the widget in the layout.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This method is called automatically by the panel layout at the\n   * appropriate time. It should not be called directly by user code.\n   *\n   * The default implementation removes the widget's node from the\n   * parent's node, and sends the appropriate detach messages to the\n   * widget if the parent is attached to the DOM.\n   *\n   * Subclasses may reimplement this method to control how the widget's\n   * node is removed from the parent's node.\n   */\n  protected detachWidget(index: number, widget: Widget): void {\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n  }\n\n  private _widgets: Widget[] = [];\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { BoxEngine, BoxSizer } from './boxengine';\n\nimport { LayoutItem } from './layout';\n\nimport { PanelLayout } from './panellayout';\n\nimport { Utils } from './utils';\n\nimport { Widget } from './widget';\n\n/**\n * A layout which arranges its widgets into resizable sections.\n */\nexport class SplitLayout extends PanelLayout {\n  /**\n   * Construct a new split layout.\n   *\n   * @param options - The options for initializing the layout.\n   */\n  constructor(options: SplitLayout.IOptions) {\n    super();\n    this.renderer = options.renderer;\n    if (options.orientation !== undefined) {\n      this._orientation = options.orientation;\n    }\n    if (options.alignment !== undefined) {\n      this._alignment = options.alignment;\n    }\n    if (options.spacing !== undefined) {\n      this._spacing = Utils.clampDimension(options.spacing);\n    }\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    // Dispose of the layout items.\n    for (const item of this._items) {\n      item.dispose();\n    }\n\n    // Clear the layout state.\n    this._box = null;\n    this._items.length = 0;\n    this._sizers.length = 0;\n    this._handles.length = 0;\n\n    // Dispose of the rest of the layout.\n    super.dispose();\n  }\n\n  /**\n   * The renderer used by the split layout.\n   */\n  readonly renderer: SplitLayout.IRenderer;\n\n  /**\n   * Get the layout orientation for the split layout.\n   */\n  get orientation(): SplitLayout.Orientation {\n    return this._orientation;\n  }\n\n  /**\n   * Set the layout orientation for the split layout.\n   */\n  set orientation(value: SplitLayout.Orientation) {\n    if (this._orientation === value) {\n      return;\n    }\n    this._orientation = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.dataset['orientation'] = value;\n    this.parent.fit();\n  }\n\n  /**\n   * Get the content alignment for the split layout.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand  to fill the\n   * entire split layout.\n   */\n  get alignment(): SplitLayout.Alignment {\n    return this._alignment;\n  }\n\n  /**\n   * Set the content alignment for the split layout.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand  to fill the\n   * entire split layout.\n   */\n  set alignment(value: SplitLayout.Alignment) {\n    if (this._alignment === value) {\n      return;\n    }\n    this._alignment = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.dataset['alignment'] = value;\n    this.parent.update();\n  }\n\n  /**\n   * Get the inter-element spacing for the split layout.\n   */\n  get spacing(): number {\n    return this._spacing;\n  }\n\n  /**\n   * Set the inter-element spacing for the split layout.\n   */\n  set spacing(value: number) {\n    value = Utils.clampDimension(value);\n    if (this._spacing === value) {\n      return;\n    }\n    this._spacing = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.fit();\n  }\n\n  /**\n   * A read-only array of the split handles in the layout.\n   */\n  get handles(): ReadonlyArray<HTMLDivElement> {\n    return this._handles;\n  }\n\n  /**\n   * Get the absolute sizes of the widgets in the layout.\n   *\n   * @returns A new array of the absolute sizes of the widgets.\n   *\n   * This method **does not** measure the DOM nodes.\n   */\n  absoluteSizes(): number[] {\n    return this._sizers.map(sizer => sizer.size);\n  }\n\n  /**\n   * Get the relative sizes of the widgets in the layout.\n   *\n   * @returns A new array of the relative sizes of the widgets.\n   *\n   * #### Notes\n   * The returned sizes reflect the sizes of the widgets normalized\n   * relative to their siblings.\n   *\n   * This method **does not** measure the DOM nodes.\n   */\n  relativeSizes(): number[] {\n    return Private.normalize(this._sizers.map(sizer => sizer.size));\n  }\n\n  /**\n   * Set the relative sizes for the widgets in the layout.\n   *\n   * @param sizes - The relative sizes for the widgets in the panel.\n   * @param update - Update the layout after setting relative sizes.\n   * Default is True.\n   *\n   * #### Notes\n   * Extra values are ignored, too few will yield an undefined layout.\n   *\n   * The actual geometry of the DOM nodes is updated asynchronously.\n   */\n  setRelativeSizes(sizes: number[], update = true): void {\n    // Copy the sizes and pad with zeros as needed.\n    let n = this._sizers.length;\n    let temp = sizes.slice(0, n);\n    while (temp.length < n) {\n      temp.push(0);\n    }\n\n    // Normalize the padded sizes.\n    let normed = Private.normalize(temp);\n\n    // Apply the normalized sizes to the sizers.\n    for (let i = 0; i < n; ++i) {\n      let sizer = this._sizers[i];\n      sizer.sizeHint = normed[i];\n      sizer.size = normed[i];\n    }\n\n    // Set the flag indicating the sizes are normalized.\n    this._hasNormedSizes = true;\n\n    // Trigger an update of the parent widget.\n    if (update && this.parent) {\n      this.parent.update();\n    }\n  }\n\n  /**\n   * Move the offset position of a split handle.\n   *\n   * @param index - The index of the handle of the interest.\n   *\n   * @param position - The desired offset position of the handle.\n   *\n   * #### Notes\n   * The position is relative to the offset parent.\n   *\n   * This will move the handle as close as possible to the desired\n   * position. The sibling widgets will be adjusted as necessary.\n   */\n  moveHandle(index: number, position: number): void {\n    // Bail if the index is invalid or the handle is hidden.\n    let handle = this._handles[index];\n    if (!handle || handle.classList.contains('lm-mod-hidden')) {\n      return;\n    }\n\n    // Compute the desired delta movement for the handle.\n    let delta: number;\n    if (this._orientation === 'horizontal') {\n      delta = position - handle.offsetLeft;\n    } else {\n      delta = position - handle.offsetTop;\n    }\n\n    // Bail if there is no handle movement.\n    if (delta === 0) {\n      return;\n    }\n\n    // Prevent widget resizing unless needed.\n    for (let sizer of this._sizers) {\n      if (sizer.size > 0) {\n        sizer.sizeHint = sizer.size;\n      }\n    }\n\n    // Adjust the sizers to reflect the handle movement.\n    BoxEngine.adjust(this._sizers, index, delta);\n\n    // Update the layout of the widgets.\n    if (this.parent) {\n      this.parent.update();\n    }\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    this.parent!.dataset['orientation'] = this.orientation;\n    this.parent!.dataset['alignment'] = this.alignment;\n    super.init();\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected attachWidget(index: number, widget: Widget): void {\n    // Create the item, handle, and sizer for the new widget.\n    let item = new LayoutItem(widget);\n    let handle = Private.createHandle(this.renderer);\n    let average = Private.averageSize(this._sizers);\n    let sizer = Private.createSizer(average);\n\n    // Insert the item, handle, and sizer into the internal arrays.\n    ArrayExt.insert(this._items, index, item);\n    ArrayExt.insert(this._sizers, index, sizer);\n    ArrayExt.insert(this._handles, index, handle);\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget and handle nodes to the parent.\n    this.parent!.node.appendChild(widget.node);\n    this.parent!.node.appendChild(handle);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * Move a widget in the parent's DOM node.\n   *\n   * @param fromIndex - The previous index of the widget in the layout.\n   *\n   * @param toIndex - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to move in the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected moveWidget(\n    fromIndex: number,\n    toIndex: number,\n    widget: Widget\n  ): void {\n    // Move the item, sizer, and handle for the widget.\n    ArrayExt.move(this._items, fromIndex, toIndex);\n    ArrayExt.move(this._sizers, fromIndex, toIndex);\n    ArrayExt.move(this._handles, fromIndex, toIndex);\n\n    // Post a fit request to the parent to show/hide last handle.\n    this.parent!.fit();\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param index - The previous index of the widget in the layout.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected detachWidget(index: number, widget: Widget): void {\n    // Remove the item, handle, and sizer for the widget.\n    let item = ArrayExt.removeAt(this._items, index);\n    let handle = ArrayExt.removeAt(this._handles, index);\n    ArrayExt.removeAt(this._sizers, index);\n\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget and handle nodes from the parent.\n    this.parent!.node.removeChild(widget.node);\n    this.parent!.node.removeChild(handle!);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Dispose of the layout item.\n    item!.dispose();\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    super.onBeforeShow(msg);\n    this.parent!.update();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.parent!.isVisible) {\n      this._update(msg.width, msg.height);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.parent!.isVisible) {\n      this._update(-1, -1);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   */\n  protected onFitRequest(msg: Message): void {\n    if (this.parent!.isAttached) {\n      this._fit();\n    }\n  }\n\n  /**\n   * Update the item position.\n   *\n   * @param i Item index\n   * @param isHorizontal Whether the layout is horizontal or not\n   * @param left Left position in pixels\n   * @param top Top position in pixels\n   * @param height Item height\n   * @param width Item width\n   * @param size Item size\n   */\n  protected updateItemPosition(\n    i: number,\n    isHorizontal: boolean,\n    left: number,\n    top: number,\n    height: number,\n    width: number,\n    size: number\n  ): void {\n    const item = this._items[i];\n    if (item.isHidden) {\n      return;\n    }\n\n    // Fetch the style for the handle.\n    let handleStyle = this._handles[i].style;\n\n    // Update the widget and handle, and advance the relevant edge.\n    if (isHorizontal) {\n      left += this.widgetOffset;\n      item.update(left, top, size, height);\n      left += size;\n      handleStyle.top = `${top}px`;\n      handleStyle.left = `${left}px`;\n      handleStyle.width = `${this._spacing}px`;\n      handleStyle.height = `${height}px`;\n    } else {\n      top += this.widgetOffset;\n      item.update(left, top, width, size);\n      top += size;\n      handleStyle.top = `${top}px`;\n      handleStyle.left = `${left}px`;\n      handleStyle.width = `${width}px`;\n      handleStyle.height = `${this._spacing}px`;\n    }\n  }\n\n  /**\n   * Fit the layout to the total size required by the widgets.\n   */\n  private _fit(): void {\n    // Update the handles and track the visible widget count.\n    let nVisible = 0;\n    let lastHandleIndex = -1;\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      if (this._items[i].isHidden) {\n        this._handles[i].classList.add('lm-mod-hidden');\n      } else {\n        this._handles[i].classList.remove('lm-mod-hidden');\n        lastHandleIndex = i;\n        nVisible++;\n      }\n    }\n\n    // Hide the handle for the last visible widget.\n    if (lastHandleIndex !== -1) {\n      this._handles[lastHandleIndex].classList.add('lm-mod-hidden');\n    }\n\n    // Update the fixed space for the visible items.\n    this._fixed =\n      this._spacing * Math.max(0, nVisible - 1) +\n      this.widgetOffset * this._items.length;\n\n    // Setup the computed minimum size.\n    let horz = this._orientation === 'horizontal';\n    let minW = horz ? this._fixed : 0;\n    let minH = horz ? 0 : this._fixed;\n\n    // Update the sizers and computed size limits.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item and corresponding box sizer.\n      let item = this._items[i];\n      let sizer = this._sizers[i];\n\n      // Prevent resizing unless necessary.\n      if (sizer.size > 0) {\n        sizer.sizeHint = sizer.size;\n      }\n\n      // If the item is hidden, it should consume zero size.\n      if (item.isHidden) {\n        sizer.minSize = 0;\n        sizer.maxSize = 0;\n        continue;\n      }\n\n      // Update the size limits for the item.\n      item.fit();\n\n      // Update the stretch factor.\n      sizer.stretch = SplitLayout.getStretch(item.widget);\n\n      // Update the sizer limits and computed min size.\n      if (horz) {\n        sizer.minSize = item.minWidth;\n        sizer.maxSize = item.maxWidth;\n        minW += item.minWidth;\n        minH = Math.max(minH, item.minHeight);\n      } else {\n        sizer.minSize = item.minHeight;\n        sizer.maxSize = item.maxHeight;\n        minH += item.minHeight;\n        minW = Math.max(minW, item.minWidth);\n      }\n    }\n\n    // Update the box sizing and add it to the computed min size.\n    let box = (this._box = ElementExt.boxSizing(this.parent!.node));\n    minW += box.horizontalSum;\n    minH += box.verticalSum;\n\n    // Update the parent's min size constraints.\n    let style = this.parent!.node.style;\n    style.minWidth = `${minW}px`;\n    style.minHeight = `${minH}px`;\n\n    // Set the dirty flag to ensure only a single update occurs.\n    this._dirty = true;\n\n    // Notify the ancestor that it should fit immediately. This may\n    // cause a resize of the parent, fulfilling the required update.\n    if (this.parent!.parent) {\n      MessageLoop.sendMessage(this.parent!.parent!, Widget.Msg.FitRequest);\n    }\n\n    // If the dirty flag is still set, the parent was not resized.\n    // Trigger the required update on the parent widget immediately.\n    if (this._dirty) {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n    }\n  }\n\n  /**\n   * Update the layout position and size of the widgets.\n   *\n   * The parent offset dimensions should be `-1` if unknown.\n   */\n  private _update(offsetWidth: number, offsetHeight: number): void {\n    // Clear the dirty flag to indicate the update occurred.\n    this._dirty = false;\n\n    // Compute the visible item count.\n    let nVisible = 0;\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      nVisible += +!this._items[i].isHidden;\n    }\n\n    // Bail early if there are no visible items to layout.\n    if (nVisible === 0 && this.widgetOffset === 0) {\n      return;\n    }\n\n    // Measure the parent if the offset dimensions are unknown.\n    if (offsetWidth < 0) {\n      offsetWidth = this.parent!.node.offsetWidth;\n    }\n    if (offsetHeight < 0) {\n      offsetHeight = this.parent!.node.offsetHeight;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent!.node);\n    }\n\n    // Compute the actual layout bounds adjusted for border and padding.\n    let top = this._box.paddingTop;\n    let left = this._box.paddingLeft;\n    let width = offsetWidth - this._box.horizontalSum;\n    let height = offsetHeight - this._box.verticalSum;\n\n    // Set up the variables for justification and alignment offset.\n    let extra = 0;\n    let offset = 0;\n    let horz = this._orientation === 'horizontal';\n\n    if (nVisible > 0) {\n      // Compute the adjusted layout space.\n      let space: number;\n      if (horz) {\n        // left += this.widgetOffset;\n        space = Math.max(0, width - this._fixed);\n      } else {\n        // top += this.widgetOffset;\n        space = Math.max(0, height - this._fixed);\n      }\n\n      // Scale the size hints if they are normalized.\n      if (this._hasNormedSizes) {\n        for (let sizer of this._sizers) {\n          sizer.sizeHint *= space;\n        }\n        this._hasNormedSizes = false;\n      }\n\n      // Distribute the layout space to the box sizers.\n      let delta = BoxEngine.calc(this._sizers, space);\n\n      // Account for alignment if there is extra layout space.\n      if (delta > 0) {\n        switch (this._alignment) {\n          case 'start':\n            break;\n          case 'center':\n            extra = 0;\n            offset = delta / 2;\n            break;\n          case 'end':\n            extra = 0;\n            offset = delta;\n            break;\n          case 'justify':\n            extra = delta / nVisible;\n            offset = 0;\n            break;\n          default:\n            throw 'unreachable';\n        }\n      }\n    }\n\n    // Layout the items using the computed box sizes.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item.\n      const item = this._items[i];\n\n      // Fetch the computed size for the widget.\n      const size = item.isHidden ? 0 : this._sizers[i].size + extra;\n\n      this.updateItemPosition(\n        i,\n        horz,\n        horz ? left + offset : left,\n        horz ? top : top + offset,\n        height,\n        width,\n        size\n      );\n\n      const fullOffset =\n        this.widgetOffset +\n        (this._handles[i].classList.contains('lm-mod-hidden')\n          ? 0\n          : this._spacing);\n\n      if (horz) {\n        left += size + fullOffset;\n      } else {\n        top += size + fullOffset;\n      }\n    }\n  }\n\n  protected widgetOffset = 0;\n  private _fixed = 0;\n  private _spacing = 4;\n  private _dirty = false;\n  private _hasNormedSizes = false;\n  private _sizers: BoxSizer[] = [];\n  private _items: LayoutItem[] = [];\n  private _handles: HTMLDivElement[] = [];\n  private _box: ElementExt.IBoxSizing | null = null;\n  private _alignment: SplitLayout.Alignment = 'start';\n  private _orientation: SplitLayout.Orientation = 'horizontal';\n}\n\n/**\n * The namespace for the `SplitLayout` class statics.\n */\nexport namespace SplitLayout {\n  /**\n   * A type alias for a split layout orientation.\n   */\n  export type Orientation = 'horizontal' | 'vertical';\n\n  /**\n   * A type alias for a split layout alignment.\n   */\n  export type Alignment = 'start' | 'center' | 'end' | 'justify';\n\n  /**\n   * An options object for initializing a split layout.\n   */\n  export interface IOptions {\n    /**\n     * The renderer to use for the split layout.\n     */\n    renderer: IRenderer;\n\n    /**\n     * The orientation of the layout.\n     *\n     * The default is `'horizontal'`.\n     */\n    orientation?: Orientation;\n\n    /**\n     * The content alignment of the layout.\n     *\n     * The default is `'start'`.\n     */\n    alignment?: Alignment;\n\n    /**\n     * The spacing between items in the layout.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n  }\n\n  /**\n   * A renderer for use with a split layout.\n   */\n  export interface IRenderer {\n    /**\n     * Create a new handle for use with a split layout.\n     *\n     * @returns A new handle element.\n     */\n    createHandle(): HTMLDivElement;\n  }\n\n  /**\n   * Get the split layout stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The split layout stretch factor for the widget.\n   */\n  export function getStretch(widget: Widget): number {\n    return Private.stretchProperty.get(widget);\n  }\n\n  /**\n   * Set the split layout stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the stretch factor.\n   */\n  export function setStretch(widget: Widget, value: number): void {\n    Private.stretchProperty.set(widget, value);\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The property descriptor for a widget stretch factor.\n   */\n  export const stretchProperty = new AttachedProperty<Widget, number>({\n    name: 'stretch',\n    create: () => 0,\n    coerce: (owner, value) => Math.max(0, Math.floor(value)),\n    changed: onChildSizingChanged\n  });\n\n  /**\n   * Create a new box sizer with the given size hint.\n   */\n  export function createSizer(size: number): BoxSizer {\n    let sizer = new BoxSizer();\n    sizer.sizeHint = Math.floor(size);\n    return sizer;\n  }\n\n  /**\n   * Create a new split handle node using the given renderer.\n   */\n  export function createHandle(\n    renderer: SplitLayout.IRenderer\n  ): HTMLDivElement {\n    let handle = renderer.createHandle();\n    handle.style.position = 'absolute';\n    // Do not use size containment to allow the handle to fill the available space\n    handle.style.contain = 'style';\n    return handle;\n  }\n\n  /**\n   * Compute the average size of an array of box sizers.\n   */\n  export function averageSize(sizers: BoxSizer[]): number {\n    return sizers.reduce((v, s) => v + s.size, 0) / sizers.length || 0;\n  }\n\n  /**\n   * Normalize an array of values.\n   */\n  export function normalize(values: number[]): number[] {\n    let n = values.length;\n    if (n === 0) {\n      return [];\n    }\n    let sum = values.reduce((a, b) => a + Math.abs(b), 0);\n    return sum === 0 ? values.map(v => 1 / n) : values.map(v => v / sum);\n  }\n\n  /**\n   * The change handler for the attached sizing properties.\n   */\n  function onChildSizingChanged(child: Widget): void {\n    if (child.parent && child.parent.layout instanceof SplitLayout) {\n      child.parent.fit();\n    }\n  }\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\nimport { SplitLayout } from './splitlayout';\nimport { Title } from './title';\nimport Utils from './utils';\nimport { Widget } from './widget';\n\n/**\n * A layout which arranges its widgets into collapsible resizable sections.\n */\nexport class AccordionLayout extends SplitLayout {\n  /**\n   * Construct a new accordion layout.\n   *\n   * @param options - The options for initializing the layout.\n   *\n   * #### Notes\n   * The default orientation will be vertical.\n   *\n   * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n   */\n  constructor(options: AccordionLayout.IOptions) {\n    super({ ...options, orientation: options.orientation || 'vertical' });\n    this.titleSpace = options.titleSpace || 22;\n  }\n\n  /**\n   * The section title height or width depending on the orientation.\n   */\n  get titleSpace(): number {\n    return this.widgetOffset;\n  }\n  set titleSpace(value: number) {\n    value = Utils.clampDimension(value);\n    if (this.widgetOffset === value) {\n      return;\n    }\n    this.widgetOffset = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.fit();\n  }\n\n  /**\n   * A read-only array of the section titles in the panel.\n   */\n  get titles(): ReadonlyArray<HTMLElement> {\n    return this._titles;\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    // Clear the layout state.\n    this._titles.length = 0;\n\n    // Dispose of the rest of the layout.\n    super.dispose();\n  }\n\n  /**\n   * The renderer used by the accordion layout.\n   */\n  readonly renderer: AccordionLayout.IRenderer;\n\n  public updateTitle(index: number, widget: Widget): void {\n    const oldTitle = this._titles[index];\n    const expanded = oldTitle.classList.contains('lm-mod-expanded');\n    const newTitle = Private.createTitle(this.renderer, widget.title, expanded);\n    this._titles[index] = newTitle;\n\n    // Add the title node to the parent before the widget.\n    this.parent!.node.replaceChild(newTitle, oldTitle);\n  }\n\n  /**\n   * Insert a widget into the layout at the specified index.\n   *\n   * @param index - The index at which to insert the widget.\n   *\n   * @param widget - The widget to insert into the layout.\n   *\n   * #### Notes\n   * The index will be clamped to the bounds of the widgets.\n   *\n   * If the widget is already added to the layout, it will be moved.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   */\n  insertWidget(index: number, widget: Widget): void {\n    if (!widget.id) {\n      widget.id = `id-${UUID.uuid4()}`;\n    }\n    super.insertWidget(index, widget);\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   */\n  protected attachWidget(index: number, widget: Widget): void {\n    const title = Private.createTitle(this.renderer, widget.title);\n\n    ArrayExt.insert(this._titles, index, title);\n\n    // Add the title node to the parent before the widget.\n    this.parent!.node.appendChild(title);\n\n    widget.node.setAttribute('role', 'region');\n    widget.node.setAttribute('aria-labelledby', title.id);\n\n    super.attachWidget(index, widget);\n  }\n\n  /**\n   * Move a widget in the parent's DOM node.\n   *\n   * @param fromIndex - The previous index of the widget in the layout.\n   *\n   * @param toIndex - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to move in the parent.\n   */\n  protected moveWidget(\n    fromIndex: number,\n    toIndex: number,\n    widget: Widget\n  ): void {\n    ArrayExt.move(this._titles, fromIndex, toIndex);\n    super.moveWidget(fromIndex, toIndex, widget);\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param index - The previous index of the widget in the layout.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected detachWidget(index: number, widget: Widget): void {\n    const title = ArrayExt.removeAt(this._titles, index);\n\n    this.parent!.node.removeChild(title!);\n\n    super.detachWidget(index, widget);\n  }\n\n  /**\n   * Update the item position.\n   *\n   * @param i Item index\n   * @param isHorizontal Whether the layout is horizontal or not\n   * @param left Left position in pixels\n   * @param top Top position in pixels\n   * @param height Item height\n   * @param width Item width\n   * @param size Item size\n   */\n  protected updateItemPosition(\n    i: number,\n    isHorizontal: boolean,\n    left: number,\n    top: number,\n    height: number,\n    width: number,\n    size: number\n  ): void {\n    const titleStyle = this._titles[i].style;\n\n    // Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n    titleStyle.top = `${top}px`;\n    titleStyle.left = `${left}px`;\n    titleStyle.height = `${this.widgetOffset}px`;\n    if (isHorizontal) {\n      titleStyle.width = `${height}px`;\n    } else {\n      titleStyle.width = `${width}px`;\n    }\n\n    super.updateItemPosition(i, isHorizontal, left, top, height, width, size);\n  }\n\n  private _titles: HTMLElement[] = [];\n}\n\nexport namespace AccordionLayout {\n  /**\n   * A type alias for a accordion layout orientation.\n   */\n  export type Orientation = SplitLayout.Orientation;\n\n  /**\n   * A type alias for a accordion layout alignment.\n   */\n  export type Alignment = SplitLayout.Alignment;\n\n  /**\n   * An options object for initializing a accordion layout.\n   */\n  export interface IOptions extends SplitLayout.IOptions {\n    /**\n     * The renderer to use for the accordion layout.\n     */\n    renderer: IRenderer;\n\n    /**\n     * The section title height or width depending on the orientation.\n     *\n     * The default is `22`.\n     */\n    titleSpace?: number;\n  }\n\n  /**\n   * A renderer for use with an accordion layout.\n   */\n  export interface IRenderer extends SplitLayout.IRenderer {\n    /**\n     * Common class name for all accordion titles.\n     */\n    readonly titleClassName: string;\n\n    /**\n     * Render the element for a section title.\n     *\n     * @param data - The data to use for rendering the section title.\n     *\n     * @returns A element representing the section title.\n     */\n    createSectionTitle(title: Title<Widget>): HTMLElement;\n  }\n}\n\nnamespace Private {\n  /**\n   * Create the title HTML element.\n   *\n   * @param renderer Accordion renderer\n   * @param data Widget title\n   * @returns Title HTML element\n   */\n  export function createTitle(\n    renderer: AccordionLayout.IRenderer,\n    data: Title<Widget>,\n    expanded: boolean = true\n  ): HTMLElement {\n    const title = renderer.createSectionTitle(data);\n    title.style.position = 'absolute';\n    title.style.contain = 'strict';\n    title.setAttribute('aria-label', `${data.label} Section`);\n    title.setAttribute('aria-expanded', expanded ? 'true' : 'false');\n    title.setAttribute('aria-controls', data.owner.id);\n    if (expanded) {\n      title.classList.add('lm-mod-expanded');\n    }\n    return title;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { PanelLayout } from './panellayout';\n\nimport { Widget } from './widget';\n\n/**\n * A simple and convenient panel widget class.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * convenience panel widgets, but can also be used directly with CSS to\n * arrange a collection of widgets.\n *\n * This class provides a convenience wrapper around a {@link PanelLayout}.\n */\nexport class Panel extends Widget {\n  /**\n   * Construct a new panel.\n   *\n   * @param options - The options for initializing the panel.\n   */\n  constructor(options: Panel.IOptions = {}) {\n    super();\n    this.addClass('lm-Panel');\n    this.layout = Private.createLayout(options);\n  }\n\n  /**\n   * A read-only array of the widgets in the panel.\n   */\n  get widgets(): ReadonlyArray<Widget> {\n    return (this.layout as PanelLayout).widgets;\n  }\n\n  /**\n   * Add a widget to the end of the panel.\n   *\n   * @param widget - The widget to add to the panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   */\n  addWidget(widget: Widget): void {\n    (this.layout as PanelLayout).addWidget(widget);\n  }\n\n  /**\n   * Insert a widget at the specified index.\n   *\n   * @param index - The index at which to insert the widget.\n   *\n   * @param widget - The widget to insert into to the panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   */\n  insertWidget(index: number, widget: Widget): void {\n    (this.layout as PanelLayout).insertWidget(index, widget);\n  }\n}\n\n/**\n * The namespace for the `Panel` class statics.\n */\nexport namespace Panel {\n  /**\n   * An options object for creating a panel.\n   */\n  export interface IOptions {\n    /**\n     * The panel layout to use for the panel.\n     *\n     * The default is a new `PanelLayout`.\n     */\n    layout?: PanelLayout;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create a panel layout for the given panel options.\n   */\n  export function createLayout(options: Panel.IOptions): PanelLayout {\n    return options.layout || new PanelLayout();\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { IDisposable } from '@lumino/disposable';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { Message } from '@lumino/messaging';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { Panel } from './panel';\n\nimport { SplitLayout } from './splitlayout';\n\nimport { Widget } from './widget';\n\n/**\n * A panel which arranges its widgets into resizable sections.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link SplitLayout}.\n */\nexport class SplitPanel extends Panel {\n  /**\n   * Construct a new split panel.\n   *\n   * @param options - The options for initializing the split panel.\n   */\n  constructor(options: SplitPanel.IOptions = {}) {\n    super({ layout: Private.createLayout(options) });\n    this.addClass('lm-SplitPanel');\n  }\n\n  /**\n   * Dispose of the resources held by the panel.\n   */\n  dispose(): void {\n    this._releaseMouse();\n    super.dispose();\n  }\n\n  /**\n   * Get the layout orientation for the split panel.\n   */\n  get orientation(): SplitPanel.Orientation {\n    return (this.layout as SplitLayout).orientation;\n  }\n\n  /**\n   * Set the layout orientation for the split panel.\n   */\n  set orientation(value: SplitPanel.Orientation) {\n    (this.layout as SplitLayout).orientation = value;\n  }\n\n  /**\n   * Get the content alignment for the split panel.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire split panel.\n   */\n  get alignment(): SplitPanel.Alignment {\n    return (this.layout as SplitLayout).alignment;\n  }\n\n  /**\n   * Set the content alignment for the split panel.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire split panel.\n   */\n  set alignment(value: SplitPanel.Alignment) {\n    (this.layout as SplitLayout).alignment = value;\n  }\n\n  /**\n   * Get the inter-element spacing for the split panel.\n   */\n  get spacing(): number {\n    return (this.layout as SplitLayout).spacing;\n  }\n\n  /**\n   * Set the inter-element spacing for the split panel.\n   */\n  set spacing(value: number) {\n    (this.layout as SplitLayout).spacing = value;\n  }\n\n  /**\n   * The renderer used by the split panel.\n   */\n  get renderer(): SplitPanel.IRenderer {\n    return (this.layout as SplitLayout).renderer;\n  }\n\n  /**\n   * A signal emitted when a split handle has moved.\n   */\n  get handleMoved(): ISignal<this, void> {\n    return this._handleMoved;\n  }\n\n  /**\n   * A read-only array of the split handles in the panel.\n   */\n  get handles(): ReadonlyArray<HTMLDivElement> {\n    return (this.layout as SplitLayout).handles;\n  }\n\n  /**\n   * Get the relative sizes of the widgets in the panel.\n   *\n   * @returns A new array of the relative sizes of the widgets.\n   *\n   * #### Notes\n   * The returned sizes reflect the sizes of the widgets normalized\n   * relative to their siblings.\n   *\n   * This method **does not** measure the DOM nodes.\n   */\n  relativeSizes(): number[] {\n    return (this.layout as SplitLayout).relativeSizes();\n  }\n\n  /**\n   * Set the relative sizes for the widgets in the panel.\n   *\n   * @param sizes - The relative sizes for the widgets in the panel.\n   * @param update - Update the layout after setting relative sizes.\n   * Default is True.\n   *\n   * #### Notes\n   * Extra values are ignored, too few will yield an undefined layout.\n   *\n   * The actual geometry of the DOM nodes is updated asynchronously.\n   */\n  setRelativeSizes(sizes: number[], update = true): void {\n    (this.layout as SplitLayout).setRelativeSizes(sizes, update);\n  }\n\n  /**\n   * Handle the DOM events for the split panel.\n   *\n   * @param event - The DOM event sent to the panel.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the panel's DOM node. It should\n   * not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'pointerdown':\n        this._evtPointerDown(event as PointerEvent);\n        break;\n      case 'pointermove':\n        this._evtPointerMove(event as PointerEvent);\n        break;\n      case 'pointerup':\n        this._evtPointerUp(event as PointerEvent);\n        break;\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('pointerdown', this);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('pointerdown', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'child-added'` message.\n   */\n  protected onChildAdded(msg: Widget.ChildMessage): void {\n    msg.child.addClass('lm-SplitPanel-child');\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    msg.child.removeClass('lm-SplitPanel-child');\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'keydown'` event for the split panel.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Stop input events during drag.\n    if (this._pressData) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    // Release the mouse if `Escape` is pressed.\n    if (event.keyCode === 27) {\n      this._releaseMouse();\n    }\n  }\n\n  /**\n   * Handle the `'pointerdown'` event for the split panel.\n   */\n  private _evtPointerDown(event: PointerEvent): void {\n    // Do nothing if the primary button is not pressed.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Find the handle which contains the target, if any.\n    let layout = this.layout as SplitLayout;\n    let index = ArrayExt.findFirstIndex(layout.handles, handle => {\n      return handle.contains(event.target as HTMLElement);\n    });\n\n    // Bail early if the mouse press was not on a handle.\n    if (index === -1) {\n      return;\n    }\n\n    // Stop the event when a split handle is pressed.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    document.addEventListener('pointerup', this, true);\n    document.addEventListener('pointermove', this, true);\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Compute the offset delta for the handle press.\n    let delta: number;\n    let handle = layout.handles[index];\n    let rect = handle.getBoundingClientRect();\n    if (layout.orientation === 'horizontal') {\n      delta = event.clientX - rect.left;\n    } else {\n      delta = event.clientY - rect.top;\n    }\n\n    // Override the cursor and store the press data.\n    let style = window.getComputedStyle(handle);\n    let override = Drag.overrideCursor(style.cursor!);\n    this._pressData = { index, delta, override };\n  }\n\n  /**\n   * Handle the `'pointermove'` event for the split panel.\n   */\n  private _evtPointerMove(event: PointerEvent): void {\n    // Stop the event when dragging a split handle.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Compute the desired offset position for the handle.\n    let pos: number;\n    let layout = this.layout as SplitLayout;\n    let rect = this.node.getBoundingClientRect();\n    if (layout.orientation === 'horizontal') {\n      pos = event.clientX - rect.left - this._pressData!.delta;\n    } else {\n      pos = event.clientY - rect.top - this._pressData!.delta;\n    }\n\n    // Move the handle as close to the desired position as possible.\n    layout.moveHandle(this._pressData!.index, pos);\n  }\n\n  /**\n   * Handle the `'pointerup'` event for the split panel.\n   */\n  private _evtPointerUp(event: PointerEvent): void {\n    // Do nothing if the primary button is not released.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event when releasing a handle.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Finalize the mouse release.\n    this._releaseMouse();\n  }\n\n  /**\n   * Release the mouse grab for the split panel.\n   */\n  private _releaseMouse(): void {\n    // Bail early if no drag is in progress.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the override cursor.\n    this._pressData.override.dispose();\n    this._pressData = null;\n\n    // Emit the handle moved signal.\n    this._handleMoved.emit();\n\n    // Remove the extra document listeners.\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('pointerup', this, true);\n    document.removeEventListener('pointermove', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  private _handleMoved = new Signal<any, void>(this);\n  private _pressData: Private.IPressData | null = null;\n}\n\n/**\n * The namespace for the `SplitPanel` class statics.\n */\nexport namespace SplitPanel {\n  /**\n   * A type alias for a split panel orientation.\n   */\n  export type Orientation = SplitLayout.Orientation;\n\n  /**\n   * A type alias for a split panel alignment.\n   */\n  export type Alignment = SplitLayout.Alignment;\n\n  /**\n   * A type alias for a split panel renderer.\n   */\n  export type IRenderer = SplitLayout.IRenderer;\n\n  /**\n   * An options object for initializing a split panel.\n   */\n  export interface IOptions {\n    /**\n     * The renderer to use for the split panel.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer;\n\n    /**\n     * The layout orientation of the panel.\n     *\n     * The default is `'horizontal'`.\n     */\n    orientation?: Orientation;\n\n    /**\n     * The content alignment of the panel.\n     *\n     * The default is `'start'`.\n     */\n    alignment?: Alignment;\n\n    /**\n     * The spacing between items in the panel.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n\n    /**\n     * The split layout to use for the split panel.\n     *\n     * If this is provided, the other options are ignored.\n     *\n     * The default is a new `SplitLayout`.\n     */\n    layout?: SplitLayout;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   */\n  export class Renderer implements IRenderer {\n    /**\n     * Create a new handle for use with a split panel.\n     *\n     * @returns A new handle element for a split panel.\n     */\n    createHandle(): HTMLDivElement {\n      let handle = document.createElement('div');\n      handle.className = 'lm-SplitPanel-handle';\n      return handle;\n    }\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n\n  /**\n   * Get the split panel stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The split panel stretch factor for the widget.\n   */\n  export function getStretch(widget: Widget): number {\n    return SplitLayout.getStretch(widget);\n  }\n\n  /**\n   * Set the split panel stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the stretch factor.\n   */\n  export function setStretch(widget: Widget, value: number): void {\n    SplitLayout.setStretch(widget, value);\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds mouse press data.\n   */\n  export interface IPressData {\n    /**\n     * The index of the pressed handle.\n     */\n    index: number;\n\n    /**\n     * The offset of the press in handle coordinates.\n     */\n    delta: number;\n\n    /**\n     * The disposable which will clear the override cursor.\n     */\n    override: IDisposable;\n  }\n\n  /**\n   * Create a split layout for the given panel options.\n   */\n  export function createLayout(options: SplitPanel.IOptions): SplitLayout {\n    return (\n      options.layout ||\n      new SplitLayout({\n        renderer: options.renderer || SplitPanel.defaultRenderer,\n        orientation: options.orientation,\n        alignment: options.alignment,\n        spacing: options.spacing\n      })\n    );\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { ArrayExt } from '@lumino/algorithm';\nimport { Message } from '@lumino/messaging';\nimport { ISignal, Signal } from '@lumino/signaling';\nimport { AccordionLayout } from './accordionlayout';\nimport { SplitLayout } from './splitlayout';\nimport { SplitPanel } from './splitpanel';\nimport { Title } from './title';\nimport { Widget } from './widget';\n\n/**\n * A panel which arranges its widgets into resizable sections separated by a title widget.\n *\n * #### Notes\n * This class provides a convenience wrapper around {@link AccordionLayout}.\n */\nexport class AccordionPanel extends SplitPanel {\n  /**\n   * Construct a new accordion panel.\n   *\n   * @param options - The options for initializing the accordion panel.\n   */\n  constructor(options: AccordionPanel.IOptions = {}) {\n    super({ ...options, layout: Private.createLayout(options) });\n    this.addClass('lm-AccordionPanel');\n  }\n\n  /**\n   * The renderer used by the accordion panel.\n   */\n  get renderer(): AccordionPanel.IRenderer {\n    return (this.layout as AccordionLayout).renderer;\n  }\n\n  /**\n   * The section title space.\n   *\n   * This is the height if the panel is vertical and the width if it is\n   * horizontal.\n   */\n  get titleSpace(): number {\n    return (this.layout as AccordionLayout).titleSpace;\n  }\n  set titleSpace(value: number) {\n    (this.layout as AccordionLayout).titleSpace = value;\n  }\n\n  /**\n   * A read-only array of the section titles in the panel.\n   */\n  get titles(): ReadonlyArray<HTMLElement> {\n    return (this.layout as AccordionLayout).titles;\n  }\n\n  /**\n   * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.\n   */\n  get expansionToggled(): ISignal<this, number> {\n    return this._expansionToggled;\n  }\n\n  /**\n   * Add a widget to the end of the panel.\n   *\n   * @param widget - The widget to add to the panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   */\n  addWidget(widget: Widget): void {\n    super.addWidget(widget);\n    widget.title.changed.connect(this._onTitleChanged, this);\n  }\n\n  /**\n   * Collapse the widget at position `index`.\n   *\n   * #### Notes\n   * If no widget is found for `index`, this will bail.\n   *\n   * @param index Widget index\n   */\n  collapse(index: number): void {\n    const widget = (this.layout as AccordionLayout).widgets[index];\n\n    if (widget && !widget.isHidden) {\n      this._toggleExpansion(index);\n    }\n  }\n\n  /**\n   * Expand the widget at position `index`.\n   *\n   * #### Notes\n   * If no widget is found for `index`, this will bail.\n   *\n   * @param index Widget index\n   */\n  expand(index: number): void {\n    const widget = (this.layout as AccordionLayout).widgets[index];\n\n    if (widget && widget.isHidden) {\n      this._toggleExpansion(index);\n    }\n  }\n\n  /**\n   * Insert a widget at the specified index.\n   *\n   * @param index - The index at which to insert the widget.\n   *\n   * @param widget - The widget to insert into to the panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   */\n  insertWidget(index: number, widget: Widget): void {\n    super.insertWidget(index, widget);\n    widget.title.changed.connect(this._onTitleChanged, this);\n  }\n\n  /**\n   * Handle the DOM events for the accordion panel.\n   *\n   * @param event - The DOM event sent to the panel.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the panel's DOM node. It should\n   * not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    super.handleEvent(event);\n    switch (event.type) {\n      case 'click':\n        this._evtClick(event as MouseEvent);\n        break;\n      case 'keydown':\n        this._eventKeyDown(event as KeyboardEvent);\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('click', this);\n    this.node.addEventListener('keydown', this);\n    super.onBeforeAttach(msg);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    super.onAfterDetach(msg);\n    this.node.removeEventListener('click', this);\n    this.node.removeEventListener('keydown', this);\n  }\n\n  /**\n   * Handle the `changed` signal of a title object.\n   */\n  private _onTitleChanged(sender: Title<Widget>): void {\n    const index = ArrayExt.findFirstIndex(this.widgets, widget => {\n      return widget.contains(sender.owner);\n    });\n\n    if (index >= 0) {\n      (this.layout as AccordionLayout).updateTitle(index, sender.owner);\n      this.update();\n    }\n  }\n\n  /**\n   * Compute the size of widgets in this panel on the title click event.\n   * On closing, the size of the widget is cached and we will try to expand\n   * the last opened widget.\n   * On opening, we will use the cached size if it is available to restore the\n   * widget.\n   * In both cases, if we can not compute the size of widgets, we will let\n   * `SplitLayout` decide.\n   *\n   * @param index - The index of widget to be opened of closed\n   *\n   * @returns Relative size of widgets in this panel, if this size can\n   * not be computed, return `undefined`\n   */\n  private _computeWidgetSize(index: number): number[] | undefined {\n    const layout = this.layout as AccordionLayout;\n\n    const widget = layout.widgets[index];\n    if (!widget) {\n      return undefined;\n    }\n    const isHidden = widget.isHidden;\n    const widgetSizes = layout.absoluteSizes();\n    const delta = (isHidden ? -1 : 1) * this.spacing;\n    const totalSize = widgetSizes.reduce(\n      (prev: number, curr: number) => prev + curr\n    );\n\n    let newSize = [...widgetSizes];\n\n    if (!isHidden) {\n      // Hide the widget\n      const currentSize = widgetSizes[index];\n\n      this._widgetSizesCache.set(widget, currentSize);\n      newSize[index] = 0;\n\n      const widgetToCollapse = newSize.map(sz => sz > 0).lastIndexOf(true);\n      if (widgetToCollapse === -1) {\n        // All widget are closed, let the `SplitLayout` compute widget sizes.\n        return undefined;\n      }\n\n      newSize[widgetToCollapse] =\n        widgetSizes[widgetToCollapse] + currentSize + delta;\n    } else {\n      // Show the widget\n      const previousSize = this._widgetSizesCache.get(widget);\n      if (!previousSize) {\n        // Previous size is unavailable, let the `SplitLayout` compute widget sizes.\n        return undefined;\n      }\n      newSize[index] += previousSize;\n\n      const widgetToCollapse = newSize\n        .map(sz => sz - previousSize > 0)\n        .lastIndexOf(true);\n      if (widgetToCollapse === -1) {\n        // Can not reduce the size of one widget, reduce all opened widgets\n        // proportionally with its size.\n        newSize.forEach((_, idx) => {\n          if (idx !== index) {\n            newSize[idx] -=\n              (widgetSizes[idx] / totalSize) * (previousSize - delta);\n          }\n        });\n      } else {\n        newSize[widgetToCollapse] -= previousSize - delta;\n      }\n    }\n    return newSize.map(sz => sz / (totalSize + delta));\n  }\n  /**\n   * Handle the `'click'` event for the accordion panel\n   */\n  private _evtClick(event: MouseEvent): void {\n    const target = event.target as HTMLElement | null;\n\n    if (target) {\n      const index = ArrayExt.findFirstIndex(this.titles, title => {\n        return title.contains(target);\n      });\n\n      if (index >= 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        this._toggleExpansion(index);\n      }\n    }\n  }\n\n  /**\n   * Handle the `'keydown'` event for the accordion panel.\n   */\n  private _eventKeyDown(event: KeyboardEvent): void {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    const target = event.target as HTMLElement | null;\n    let handled = false;\n    if (target) {\n      const index = ArrayExt.findFirstIndex(this.titles, title => {\n        return title.contains(target);\n      });\n\n      if (index >= 0) {\n        const keyCode = event.keyCode.toString();\n\n        // If Space or Enter is pressed on title, emulate click event\n        if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {\n          target.click();\n          handled = true;\n        } else if (\n          this.orientation === 'horizontal'\n            ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/)\n            : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)\n        ) {\n          // If Up or Down (for vertical) / Left or Right (for horizontal) is pressed on title, loop on titles\n          const direction =\n            event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/)\n              ? -1\n              : 1;\n          const length = this.titles.length;\n          const newIndex = (index + length + direction) % length;\n\n          this.titles[newIndex].focus();\n          handled = true;\n        } else if (event.key === 'End' || keyCode === '35') {\n          // If End is pressed on title, focus on the last title\n          this.titles[this.titles.length - 1].focus();\n          handled = true;\n        } else if (event.key === 'Home' || keyCode === '36') {\n          // If Home is pressed on title, focus on the first title\n          this.titles[0].focus();\n          handled = true;\n        }\n      }\n\n      if (handled) {\n        event.preventDefault();\n      }\n    }\n  }\n\n  private _toggleExpansion(index: number) {\n    const title = this.titles[index];\n    const widget = (this.layout as AccordionLayout).widgets[index];\n\n    const newSize = this._computeWidgetSize(index);\n    if (newSize) {\n      this.setRelativeSizes(newSize, false);\n    }\n\n    if (widget.isHidden) {\n      title.classList.add('lm-mod-expanded');\n      title.setAttribute('aria-expanded', 'true');\n      widget.show();\n    } else {\n      title.classList.remove('lm-mod-expanded');\n      title.setAttribute('aria-expanded', 'false');\n      widget.hide();\n    }\n\n    // Emit the expansion state signal.\n    this._expansionToggled.emit(index);\n  }\n\n  private _widgetSizesCache: WeakMap<Widget, number> = new WeakMap();\n  private _expansionToggled = new Signal<this, number>(this);\n}\n\n/**\n * The namespace for the `AccordionPanel` class statics.\n */\nexport namespace AccordionPanel {\n  /**\n   * A type alias for a accordion panel orientation.\n   */\n  export type Orientation = SplitLayout.Orientation;\n\n  /**\n   * A type alias for a accordion panel alignment.\n   */\n  export type Alignment = SplitLayout.Alignment;\n\n  /**\n   * A type alias for a accordion panel renderer.\n   */\n  export type IRenderer = AccordionLayout.IRenderer;\n\n  /**\n   * An options object for initializing a accordion panel.\n   */\n  export interface IOptions extends Partial<AccordionLayout.IOptions> {\n    /**\n     * The accordion layout to use for the accordion panel.\n     *\n     * If this is provided, the other options are ignored.\n     *\n     * The default is a new `AccordionLayout`.\n     */\n    layout?: AccordionLayout;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   */\n  export class Renderer extends SplitPanel.Renderer implements IRenderer {\n    constructor() {\n      super();\n      this._uuid = ++Renderer._nInstance;\n    }\n    /**\n     * A selector which matches any title node in the accordion.\n     */\n    readonly titleClassName = 'lm-AccordionPanel-title';\n\n    /**\n     * Render the collapse indicator for a section title.\n     *\n     * @param data - The data to use for rendering the section title.\n     *\n     * @returns A element representing the collapse indicator.\n     */\n    createCollapseIcon(data: Title<Widget>): HTMLElement {\n      return document.createElement('span');\n    }\n\n    /**\n     * Render the element for a section title.\n     *\n     * @param data - The data to use for rendering the section title.\n     *\n     * @returns A element representing the section title.\n     */\n    createSectionTitle(data: Title<Widget>): HTMLElement {\n      const handle = document.createElement('h3');\n      handle.setAttribute('tabindex', '0');\n      handle.id = this.createTitleKey(data);\n      handle.className = this.titleClassName;\n      for (const aData in data.dataset) {\n        handle.dataset[aData] = data.dataset[aData];\n      }\n\n      const collapser = handle.appendChild(this.createCollapseIcon(data));\n      collapser.className = 'lm-AccordionPanel-titleCollapser';\n\n      const label = handle.appendChild(document.createElement('span'));\n      label.className = 'lm-AccordionPanel-titleLabel';\n      label.textContent = data.label;\n      label.title = data.caption || data.label;\n\n      return handle;\n    }\n\n    /**\n     * Create a unique render key for the title.\n     *\n     * @param data - The data to use for the title.\n     *\n     * @returns The unique render key for the title.\n     *\n     * #### Notes\n     * This method caches the key against the section title the first time\n     * the key is generated.\n     */\n    createTitleKey(data: Title<Widget>): string {\n      let key = this._titleKeys.get(data);\n      if (key === undefined) {\n        key = `title-key-${this._uuid}-${this._titleID++}`;\n        this._titleKeys.set(data, key);\n      }\n      return key;\n    }\n\n    private static _nInstance = 0;\n    private readonly _uuid: number;\n    private _titleID = 0;\n    private _titleKeys = new WeakMap<Title<Widget>, string>();\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n}\n\nnamespace Private {\n  /**\n   * Create an accordion layout for the given panel options.\n   *\n   * @param options Panel options\n   * @returns Panel layout\n   */\n  export function createLayout(\n    options: AccordionPanel.IOptions\n  ): AccordionLayout {\n    return (\n      options.layout ||\n      new AccordionLayout({\n        renderer: options.renderer || AccordionPanel.defaultRenderer,\n        orientation: options.orientation,\n        alignment: options.alignment,\n        spacing: options.spacing,\n        titleSpace: options.titleSpace\n      })\n    );\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { BoxEngine, BoxSizer } from './boxengine';\n\nimport { LayoutItem } from './layout';\n\nimport { PanelLayout } from './panellayout';\n\nimport Utils from './utils';\n\nimport { Widget } from './widget';\n\n/**\n * A layout which arranges its widgets in a single row or column.\n */\nexport class BoxLayout extends PanelLayout {\n  /**\n   * Construct a new box layout.\n   *\n   * @param options - The options for initializing the layout.\n   */\n  constructor(options: BoxLayout.IOptions = {}) {\n    super();\n    if (options.direction !== undefined) {\n      this._direction = options.direction;\n    }\n    if (options.alignment !== undefined) {\n      this._alignment = options.alignment;\n    }\n    if (options.spacing !== undefined) {\n      this._spacing = Utils.clampDimension(options.spacing);\n    }\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    // Dispose of the layout items.\n    for (const item of this._items) {\n      item.dispose();\n    }\n\n    // Clear the layout state.\n    this._box = null;\n    this._items.length = 0;\n    this._sizers.length = 0;\n\n    // Dispose of the rest of the layout.\n    super.dispose();\n  }\n\n  /**\n   * Get the layout direction for the box layout.\n   */\n  get direction(): BoxLayout.Direction {\n    return this._direction;\n  }\n\n  /**\n   * Set the layout direction for the box layout.\n   */\n  set direction(value: BoxLayout.Direction) {\n    if (this._direction === value) {\n      return;\n    }\n    this._direction = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.dataset['direction'] = value;\n    this.parent.fit();\n  }\n\n  /**\n   * Get the content alignment for the box layout.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire box layout.\n   */\n  get alignment(): BoxLayout.Alignment {\n    return this._alignment;\n  }\n\n  /**\n   * Set the content alignment for the box layout.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire box layout.\n   */\n  set alignment(value: BoxLayout.Alignment) {\n    if (this._alignment === value) {\n      return;\n    }\n    this._alignment = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.dataset['alignment'] = value;\n    this.parent.update();\n  }\n\n  /**\n   * Get the inter-element spacing for the box layout.\n   */\n  get spacing(): number {\n    return this._spacing;\n  }\n\n  /**\n   * Set the inter-element spacing for the box layout.\n   */\n  set spacing(value: number) {\n    value = Utils.clampDimension(value);\n    if (this._spacing === value) {\n      return;\n    }\n    this._spacing = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.fit();\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    this.parent!.dataset['direction'] = this.direction;\n    this.parent!.dataset['alignment'] = this.alignment;\n    super.init();\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected attachWidget(index: number, widget: Widget): void {\n    // Create and add a new layout item for the widget.\n    ArrayExt.insert(this._items, index, new LayoutItem(widget));\n\n    // Create and add a new sizer for the widget.\n    ArrayExt.insert(this._sizers, index, new BoxSizer());\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget's node to the parent.\n    this.parent!.node.appendChild(widget.node);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * Move a widget in the parent's DOM node.\n   *\n   * @param fromIndex - The previous index of the widget in the layout.\n   *\n   * @param toIndex - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to move in the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected moveWidget(\n    fromIndex: number,\n    toIndex: number,\n    widget: Widget\n  ): void {\n    // Move the layout item for the widget.\n    ArrayExt.move(this._items, fromIndex, toIndex);\n\n    // Move the sizer for the widget.\n    ArrayExt.move(this._sizers, fromIndex, toIndex);\n\n    // Post an update request for the parent widget.\n    this.parent!.update();\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param index - The previous index of the widget in the layout.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected detachWidget(index: number, widget: Widget): void {\n    // Remove the layout item for the widget.\n    let item = ArrayExt.removeAt(this._items, index);\n\n    // Remove the sizer for the widget.\n    ArrayExt.removeAt(this._sizers, index);\n\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Dispose of the layout item.\n    item!.dispose();\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    super.onBeforeShow(msg);\n    this.parent!.update();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.parent!.isVisible) {\n      this._update(msg.width, msg.height);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.parent!.isVisible) {\n      this._update(-1, -1);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   */\n  protected onFitRequest(msg: Message): void {\n    if (this.parent!.isAttached) {\n      this._fit();\n    }\n  }\n\n  /**\n   * Fit the layout to the total size required by the widgets.\n   */\n  private _fit(): void {\n    // Compute the visible item count.\n    let nVisible = 0;\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      nVisible += +!this._items[i].isHidden;\n    }\n\n    // Update the fixed space for the visible items.\n    this._fixed = this._spacing * Math.max(0, nVisible - 1);\n\n    // Setup the computed minimum size.\n    let horz = Private.isHorizontal(this._direction);\n    let minW = horz ? this._fixed : 0;\n    let minH = horz ? 0 : this._fixed;\n\n    // Update the sizers and computed minimum size.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item and corresponding box sizer.\n      let item = this._items[i];\n      let sizer = this._sizers[i];\n\n      // If the item is hidden, it should consume zero size.\n      if (item.isHidden) {\n        sizer.minSize = 0;\n        sizer.maxSize = 0;\n        continue;\n      }\n\n      // Update the size limits for the item.\n      item.fit();\n\n      // Update the size basis and stretch factor.\n      sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);\n      sizer.stretch = BoxLayout.getStretch(item.widget);\n\n      // Update the sizer limits and computed min size.\n      if (horz) {\n        sizer.minSize = item.minWidth;\n        sizer.maxSize = item.maxWidth;\n        minW += item.minWidth;\n        minH = Math.max(minH, item.minHeight);\n      } else {\n        sizer.minSize = item.minHeight;\n        sizer.maxSize = item.maxHeight;\n        minH += item.minHeight;\n        minW = Math.max(minW, item.minWidth);\n      }\n    }\n\n    // Update the box sizing and add it to the computed min size.\n    let box = (this._box = ElementExt.boxSizing(this.parent!.node));\n    minW += box.horizontalSum;\n    minH += box.verticalSum;\n\n    // Update the parent's min size constraints.\n    let style = this.parent!.node.style;\n    style.minWidth = `${minW}px`;\n    style.minHeight = `${minH}px`;\n\n    // Set the dirty flag to ensure only a single update occurs.\n    this._dirty = true;\n\n    // Notify the ancestor that it should fit immediately. This may\n    // cause a resize of the parent, fulfilling the required update.\n    if (this.parent!.parent) {\n      MessageLoop.sendMessage(this.parent!.parent!, Widget.Msg.FitRequest);\n    }\n\n    // If the dirty flag is still set, the parent was not resized.\n    // Trigger the required update on the parent widget immediately.\n    if (this._dirty) {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n    }\n  }\n\n  /**\n   * Update the layout position and size of the widgets.\n   *\n   * The parent offset dimensions should be `-1` if unknown.\n   */\n  private _update(offsetWidth: number, offsetHeight: number): void {\n    // Clear the dirty flag to indicate the update occurred.\n    this._dirty = false;\n\n    // Compute the visible item count.\n    let nVisible = 0;\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      nVisible += +!this._items[i].isHidden;\n    }\n\n    // Bail early if there are no visible items to layout.\n    if (nVisible === 0) {\n      return;\n    }\n\n    // Measure the parent if the offset dimensions are unknown.\n    if (offsetWidth < 0) {\n      offsetWidth = this.parent!.node.offsetWidth;\n    }\n    if (offsetHeight < 0) {\n      offsetHeight = this.parent!.node.offsetHeight;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent!.node);\n    }\n\n    // Compute the layout area adjusted for border and padding.\n    let top = this._box.paddingTop;\n    let left = this._box.paddingLeft;\n    let width = offsetWidth - this._box.horizontalSum;\n    let height = offsetHeight - this._box.verticalSum;\n\n    // Distribute the layout space and adjust the start position.\n    let delta: number;\n    switch (this._direction) {\n      case 'left-to-right':\n        delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n        break;\n      case 'top-to-bottom':\n        delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n        break;\n      case 'right-to-left':\n        delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n        left += width;\n        break;\n      case 'bottom-to-top':\n        delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n        top += height;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Setup the variables for justification and alignment offset.\n    let extra = 0;\n    let offset = 0;\n\n    // Account for alignment if there is extra layout space.\n    if (delta > 0) {\n      switch (this._alignment) {\n        case 'start':\n          break;\n        case 'center':\n          extra = 0;\n          offset = delta / 2;\n          break;\n        case 'end':\n          extra = 0;\n          offset = delta;\n          break;\n        case 'justify':\n          extra = delta / nVisible;\n          offset = 0;\n          break;\n        default:\n          throw 'unreachable';\n      }\n    }\n\n    // Layout the items using the computed box sizes.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = this._items[i];\n\n      // Ignore hidden items.\n      if (item.isHidden) {\n        continue;\n      }\n\n      // Fetch the computed size for the widget.\n      let size = this._sizers[i].size;\n\n      // Update the widget geometry and advance the relevant edge.\n      switch (this._direction) {\n        case 'left-to-right':\n          item.update(left + offset, top, size + extra, height);\n          left += size + extra + this._spacing;\n          break;\n        case 'top-to-bottom':\n          item.update(left, top + offset, width, size + extra);\n          top += size + extra + this._spacing;\n          break;\n        case 'right-to-left':\n          item.update(left - offset - size - extra, top, size + extra, height);\n          left -= size + extra + this._spacing;\n          break;\n        case 'bottom-to-top':\n          item.update(left, top - offset - size - extra, width, size + extra);\n          top -= size + extra + this._spacing;\n          break;\n        default:\n          throw 'unreachable';\n      }\n    }\n  }\n\n  private _fixed = 0;\n  private _spacing = 4;\n  private _dirty = false;\n  private _sizers: BoxSizer[] = [];\n  private _items: LayoutItem[] = [];\n  private _box: ElementExt.IBoxSizing | null = null;\n  private _alignment: BoxLayout.Alignment = 'start';\n  private _direction: BoxLayout.Direction = 'top-to-bottom';\n}\n\n/**\n * The namespace for the `BoxLayout` class statics.\n */\nexport namespace BoxLayout {\n  /**\n   * A type alias for a box layout direction.\n   */\n  export type Direction =\n    | 'left-to-right'\n    | 'right-to-left'\n    | 'top-to-bottom'\n    | 'bottom-to-top';\n\n  /**\n   * A type alias for a box layout alignment.\n   */\n  export type Alignment = 'start' | 'center' | 'end' | 'justify';\n\n  /**\n   * An options object for initializing a box layout.\n   */\n  export interface IOptions {\n    /**\n     * The direction of the layout.\n     *\n     * The default is `'top-to-bottom'`.\n     */\n    direction?: Direction;\n\n    /**\n     * The content alignment of the layout.\n     *\n     * The default is `'start'`.\n     */\n    alignment?: Alignment;\n\n    /**\n     * The spacing between items in the layout.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n  }\n\n  /**\n   * Get the box layout stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The box layout stretch factor for the widget.\n   */\n  export function getStretch(widget: Widget): number {\n    return Private.stretchProperty.get(widget);\n  }\n\n  /**\n   * Set the box layout stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the stretch factor.\n   */\n  export function setStretch(widget: Widget, value: number): void {\n    Private.stretchProperty.set(widget, value);\n  }\n\n  /**\n   * Get the box layout size basis for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The box layout size basis for the widget.\n   */\n  export function getSizeBasis(widget: Widget): number {\n    return Private.sizeBasisProperty.get(widget);\n  }\n\n  /**\n   * Set the box layout size basis for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the size basis.\n   */\n  export function setSizeBasis(widget: Widget, value: number): void {\n    Private.sizeBasisProperty.set(widget, value);\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The property descriptor for a widget stretch factor.\n   */\n  export const stretchProperty = new AttachedProperty<Widget, number>({\n    name: 'stretch',\n    create: () => 0,\n    coerce: (owner, value) => Math.max(0, Math.floor(value)),\n    changed: onChildSizingChanged\n  });\n\n  /**\n   * The property descriptor for a widget size basis.\n   */\n  export const sizeBasisProperty = new AttachedProperty<Widget, number>({\n    name: 'sizeBasis',\n    create: () => 0,\n    coerce: (owner, value) => Math.max(0, Math.floor(value)),\n    changed: onChildSizingChanged\n  });\n\n  /**\n   * Test whether a direction has horizontal orientation.\n   */\n  export function isHorizontal(dir: BoxLayout.Direction): boolean {\n    return dir === 'left-to-right' || dir === 'right-to-left';\n  }\n\n  /**\n   * Clamp a spacing value to an integer >= 0.\n   */\n  export function clampSpacing(value: number): number {\n    return Math.max(0, Math.floor(value));\n  }\n\n  /**\n   * The change handler for the attached sizing properties.\n   */\n  function onChildSizingChanged(child: Widget): void {\n    if (child.parent && child.parent.layout instanceof BoxLayout) {\n      child.parent.fit();\n    }\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { BoxLayout } from './boxlayout';\n\nimport { Panel } from './panel';\n\nimport { Widget } from './widget';\n\n/**\n * A panel which arranges its widgets in a single row or column.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link BoxLayout}.\n */\nexport class BoxPanel extends Panel {\n  /**\n   * Construct a new box panel.\n   *\n   * @param options - The options for initializing the box panel.\n   */\n  constructor(options: BoxPanel.IOptions = {}) {\n    super({ layout: Private.createLayout(options) });\n    this.addClass('lm-BoxPanel');\n  }\n\n  /**\n   * Get the layout direction for the box panel.\n   */\n  get direction(): BoxPanel.Direction {\n    return (this.layout as BoxLayout).direction;\n  }\n\n  /**\n   * Set the layout direction for the box panel.\n   */\n  set direction(value: BoxPanel.Direction) {\n    (this.layout as BoxLayout).direction = value;\n  }\n\n  /**\n   * Get the content alignment for the box panel.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire box layout.\n   */\n  get alignment(): BoxPanel.Alignment {\n    return (this.layout as BoxLayout).alignment;\n  }\n\n  /**\n   * Set the content alignment for the box panel.\n   *\n   * #### Notes\n   * This is the alignment of the widgets in the layout direction.\n   *\n   * The alignment has no effect if the widgets can expand to fill the\n   * entire box layout.\n   */\n  set alignment(value: BoxPanel.Alignment) {\n    (this.layout as BoxLayout).alignment = value;\n  }\n\n  /**\n   * Get the inter-element spacing for the box panel.\n   */\n  get spacing(): number {\n    return (this.layout as BoxLayout).spacing;\n  }\n\n  /**\n   * Set the inter-element spacing for the box panel.\n   */\n  set spacing(value: number) {\n    (this.layout as BoxLayout).spacing = value;\n  }\n\n  /**\n   * A message handler invoked on a `'child-added'` message.\n   */\n  protected onChildAdded(msg: Widget.ChildMessage): void {\n    msg.child.addClass('lm-BoxPanel-child');\n  }\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    msg.child.removeClass('lm-BoxPanel-child');\n  }\n}\n\n/**\n * The namespace for the `BoxPanel` class statics.\n */\nexport namespace BoxPanel {\n  /**\n   * A type alias for a box panel direction.\n   */\n  export type Direction = BoxLayout.Direction;\n\n  /**\n   * A type alias for a box panel alignment.\n   */\n  export type Alignment = BoxLayout.Alignment;\n\n  /**\n   * An options object for initializing a box panel.\n   */\n  export interface IOptions {\n    /**\n     * The layout direction of the panel.\n     *\n     * The default is `'top-to-bottom'`.\n     */\n    direction?: Direction;\n\n    /**\n     * The content alignment of the panel.\n     *\n     * The default is `'start'`.\n     */\n    alignment?: Alignment;\n\n    /**\n     * The spacing between items in the panel.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n\n    /**\n     * The box layout to use for the box panel.\n     *\n     * If this is provided, the other options are ignored.\n     *\n     * The default is a new `BoxLayout`.\n     */\n    layout?: BoxLayout;\n  }\n\n  /**\n   * Get the box panel stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The box panel stretch factor for the widget.\n   */\n  export function getStretch(widget: Widget): number {\n    return BoxLayout.getStretch(widget);\n  }\n\n  /**\n   * Set the box panel stretch factor for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the stretch factor.\n   */\n  export function setStretch(widget: Widget, value: number): void {\n    BoxLayout.setStretch(widget, value);\n  }\n\n  /**\n   * Get the box panel size basis for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The box panel size basis for the widget.\n   */\n  export function getSizeBasis(widget: Widget): number {\n    return BoxLayout.getSizeBasis(widget);\n  }\n\n  /**\n   * Set the box panel size basis for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the size basis.\n   */\n  export function setSizeBasis(widget: Widget, value: number): void {\n    BoxLayout.setSizeBasis(widget, value);\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create a box layout for the given panel options.\n   */\n  export function createLayout(options: BoxPanel.IOptions): BoxLayout {\n    return options.layout || new BoxLayout(options);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt, StringExt } from '@lumino/algorithm';\n\nimport { JSONExt, ReadonlyJSONObject } from '@lumino/coreutils';\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message } from '@lumino/messaging';\n\nimport {\n  ElementDataset,\n  h,\n  VirtualDOM,\n  VirtualElement\n} from '@lumino/virtualdom';\n\nimport { Widget } from './widget';\n\n/**\n * A widget which displays command items as a searchable palette.\n */\nexport class CommandPalette extends Widget {\n  /**\n   * Construct a new command palette.\n   *\n   * @param options - The options for initializing the palette.\n   */\n  constructor(options: CommandPalette.IOptions) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-CommandPalette');\n    this.setFlag(Widget.Flag.DisallowLayout);\n    this.commands = options.commands;\n    this.renderer = options.renderer || CommandPalette.defaultRenderer;\n    this.commands.commandChanged.connect(this._onGenericChange, this);\n    this.commands.keyBindingChanged.connect(this._onGenericChange, this);\n  }\n\n  /**\n   * Dispose of the resources held by the widget.\n   */\n  dispose(): void {\n    this._items.length = 0;\n    this._results = null;\n    super.dispose();\n  }\n\n  /**\n   * The command registry used by the command palette.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The renderer used by the command palette.\n   */\n  readonly renderer: CommandPalette.IRenderer;\n\n  /**\n   * The command palette search node.\n   *\n   * #### Notes\n   * This is the node which contains the search-related elements.\n   */\n  get searchNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-CommandPalette-search'\n    )[0] as HTMLDivElement;\n  }\n\n  /**\n   * The command palette input node.\n   *\n   * #### Notes\n   * This is the actual input node for the search area.\n   */\n  get inputNode(): HTMLInputElement {\n    return this.node.getElementsByClassName(\n      'lm-CommandPalette-input'\n    )[0] as HTMLInputElement;\n  }\n\n  /**\n   * The command palette content node.\n   *\n   * #### Notes\n   * This is the node which holds the command item nodes.\n   *\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get contentNode(): HTMLUListElement {\n    return this.node.getElementsByClassName(\n      'lm-CommandPalette-content'\n    )[0] as HTMLUListElement;\n  }\n\n  /**\n   * A read-only array of the command items in the palette.\n   */\n  get items(): ReadonlyArray<CommandPalette.IItem> {\n    return this._items;\n  }\n\n  /**\n   * Add a command item to the command palette.\n   *\n   * @param options - The options for creating the command item.\n   *\n   * @returns The command item added to the palette.\n   */\n  addItem(options: CommandPalette.IItemOptions): CommandPalette.IItem {\n    // Create a new command item for the options.\n    let item = Private.createItem(this.commands, options);\n\n    // Add the item to the array.\n    this._items.push(item);\n\n    // Refresh the search results.\n    this.refresh();\n\n    // Return the item added to the palette.\n    return item;\n  }\n\n  /**\n   * Adds command items to the command palette.\n   *\n   * @param items - An array of options for creating each command item.\n   *\n   * @returns The command items added to the palette.\n   */\n  addItems(items: CommandPalette.IItemOptions[]): CommandPalette.IItem[] {\n    const newItems = items.map(item => Private.createItem(this.commands, item));\n    newItems.forEach(item => this._items.push(item));\n    this.refresh();\n    return newItems;\n  }\n\n  /**\n   * Remove an item from the command palette.\n   *\n   * @param item - The item to remove from the palette.\n   *\n   * #### Notes\n   * This is a no-op if the item is not in the palette.\n   */\n  removeItem(item: CommandPalette.IItem): void {\n    this.removeItemAt(this._items.indexOf(item));\n  }\n\n  /**\n   * Remove the item at a given index from the command palette.\n   *\n   * @param index - The index of the item to remove.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  removeItemAt(index: number): void {\n    // Remove the item from the array.\n    let item = ArrayExt.removeAt(this._items, index);\n\n    // Bail if the index is out of range.\n    if (!item) {\n      return;\n    }\n\n    // Refresh the search results.\n    this.refresh();\n  }\n\n  /**\n   * Remove all items from the command palette.\n   */\n  clearItems(): void {\n    // Bail if there is nothing to remove.\n    if (this._items.length === 0) {\n      return;\n    }\n\n    // Clear the array of items.\n    this._items.length = 0;\n\n    // Refresh the search results.\n    this.refresh();\n  }\n\n  /**\n   * Clear the search results and schedule an update.\n   *\n   * #### Notes\n   * This should be called whenever the search results of the palette\n   * should be updated.\n   *\n   * This is typically called automatically by the palette as needed,\n   * but can be called manually if the input text is programatically\n   * changed.\n   *\n   * The rendered results are updated asynchronously.\n   */\n  refresh(): void {\n    this._results = null;\n    if (this.inputNode.value !== '') {\n      let clear = this.node.getElementsByClassName(\n        'lm-close-icon'\n      )[0] as HTMLInputElement;\n      clear.style.display = 'inherit';\n    } else {\n      let clear = this.node.getElementsByClassName(\n        'lm-close-icon'\n      )[0] as HTMLInputElement;\n      clear.style.display = 'none';\n    }\n    this.update();\n  }\n\n  /**\n   * Handle the DOM events for the command palette.\n   *\n   * @param event - The DOM event sent to the command palette.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the command palette's DOM node.\n   * It should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'click':\n        this._evtClick(event as MouseEvent);\n        break;\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'input':\n        this.refresh();\n        break;\n      case 'focus':\n      case 'blur':\n        this._toggleFocused();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('click', this);\n    this.node.addEventListener('keydown', this);\n    this.node.addEventListener('input', this);\n    this.node.addEventListener('focus', this, true);\n    this.node.addEventListener('blur', this, true);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('click', this);\n    this.node.removeEventListener('keydown', this);\n    this.node.removeEventListener('input', this);\n    this.node.removeEventListener('focus', this, true);\n    this.node.removeEventListener('blur', this, true);\n  }\n\n  /**\n   * A message handler invoked on an `'after-show'` message.\n   */\n  protected onAfterShow(msg: Message): void {\n    this.update();\n    super.onAfterShow(msg);\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    if (this.isAttached) {\n      let input = this.inputNode;\n      input.focus();\n      input.select();\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.isHidden) {\n      return;\n    }\n\n    // Fetch the current query text and content node.\n    let query = this.inputNode.value;\n    let contentNode = this.contentNode;\n\n    // Ensure the search results are generated.\n    let results = this._results;\n    if (!results) {\n      // Generate and store the new search results.\n      results = this._results = Private.search(this._items, query);\n\n      // Reset the active index.\n      this._activeIndex = query\n        ? ArrayExt.findFirstIndex(results, Private.canActivate)\n        : -1;\n    }\n\n    // If there is no query and no results, clear the content.\n    if (!query && results.length === 0) {\n      VirtualDOM.render(null, contentNode);\n      return;\n    }\n\n    // If the is a query but no results, render the empty message.\n    if (query && results.length === 0) {\n      let content = this.renderer.renderEmptyMessage({ query });\n      VirtualDOM.render(content, contentNode);\n      return;\n    }\n\n    // Create the render content for the search results.\n    let renderer = this.renderer;\n    let activeIndex = this._activeIndex;\n    let content = new Array<VirtualElement>(results.length);\n    for (let i = 0, n = results.length; i < n; ++i) {\n      let result = results[i];\n      if (result.type === 'header') {\n        let indices = result.indices;\n        let category = result.category;\n        content[i] = renderer.renderHeader({ category, indices });\n      } else {\n        let item = result.item;\n        let indices = result.indices;\n        let active = i === activeIndex;\n        content[i] = renderer.renderItem({ item, indices, active });\n      }\n    }\n\n    // Render the search result content.\n    VirtualDOM.render(content, contentNode);\n\n    // Adjust the scroll position as needed.\n    if (activeIndex < 0 || activeIndex >= results.length) {\n      contentNode.scrollTop = 0;\n    } else {\n      let element = contentNode.children[activeIndex];\n      ElementExt.scrollIntoViewIfNeeded(contentNode, element);\n    }\n  }\n\n  /**\n   * Handle the `'click'` event for the command palette.\n   */\n  private _evtClick(event: MouseEvent): void {\n    // Bail if the click is not the left button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Clear input if the target is clear button\n    if ((event.target as HTMLElement).classList.contains('lm-close-icon')) {\n      this.inputNode.value = '';\n      this.refresh();\n      return;\n    }\n\n    // Find the index of the item which was clicked.\n    let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n      return node.contains(event.target as HTMLElement);\n    });\n\n    // Bail if the click was not on an item.\n    if (index === -1) {\n      return;\n    }\n\n    // Kill the event when a content item is clicked.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Execute the item if possible.\n    this._execute(index);\n  }\n\n  /**\n   * Handle the `'keydown'` event for the command palette.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n      return;\n    }\n    switch (event.keyCode) {\n      case 13: // Enter\n        event.preventDefault();\n        event.stopPropagation();\n        this._execute(this._activeIndex);\n        break;\n      case 38: // Up Arrow\n        event.preventDefault();\n        event.stopPropagation();\n        this._activatePreviousItem();\n        break;\n      case 40: // Down Arrow\n        event.preventDefault();\n        event.stopPropagation();\n        this._activateNextItem();\n        break;\n    }\n  }\n\n  /**\n   * Activate the next enabled command item.\n   */\n  private _activateNextItem(): void {\n    // Bail if there are no search results.\n    if (!this._results || this._results.length === 0) {\n      return;\n    }\n\n    // Find the next enabled item index.\n    let ai = this._activeIndex;\n    let n = this._results.length;\n    let start = ai < n - 1 ? ai + 1 : 0;\n    let stop = start === 0 ? n - 1 : start - 1;\n    this._activeIndex = ArrayExt.findFirstIndex(\n      this._results,\n      Private.canActivate,\n      start,\n      stop\n    );\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * Activate the previous enabled command item.\n   */\n  private _activatePreviousItem(): void {\n    // Bail if there are no search results.\n    if (!this._results || this._results.length === 0) {\n      return;\n    }\n\n    // Find the previous enabled item index.\n    let ai = this._activeIndex;\n    let n = this._results.length;\n    let start = ai <= 0 ? n - 1 : ai - 1;\n    let stop = start === n - 1 ? 0 : start + 1;\n    this._activeIndex = ArrayExt.findLastIndex(\n      this._results,\n      Private.canActivate,\n      start,\n      stop\n    );\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * Execute the command item at the given index, if possible.\n   */\n  private _execute(index: number): void {\n    // Bail if there are no search results.\n    if (!this._results) {\n      return;\n    }\n\n    // Bail if the index is out of range.\n    let part = this._results[index];\n    if (!part) {\n      return;\n    }\n\n    // Update the search text if the item is a header.\n    if (part.type === 'header') {\n      let input = this.inputNode;\n      input.value = `${part.category.toLowerCase()} `;\n      input.focus();\n      this.refresh();\n      return;\n    }\n\n    // Bail if item is not enabled.\n    if (!part.item.isEnabled) {\n      return;\n    }\n\n    // Execute the item.\n    this.commands.execute(part.item.command, part.item.args);\n\n    // Clear the query text.\n    this.inputNode.value = '';\n\n    // Refresh the search results.\n    this.refresh();\n  }\n\n  /**\n   * Toggle the focused modifier based on the input node focus state.\n   */\n  private _toggleFocused(): void {\n    let focused = document.activeElement === this.inputNode;\n    this.toggleClass('lm-mod-focused', focused);\n  }\n\n  /**\n   * A signal handler for generic command changes.\n   */\n  private _onGenericChange(): void {\n    this.refresh();\n  }\n\n  private _activeIndex = -1;\n  private _items: CommandPalette.IItem[] = [];\n  private _results: Private.SearchResult[] | null = null;\n}\n\n/**\n * The namespace for the `CommandPalette` class statics.\n */\nexport namespace CommandPalette {\n  /**\n   * An options object for creating a command palette.\n   */\n  export interface IOptions {\n    /**\n     * The command registry for use with the command palette.\n     */\n    commands: CommandRegistry;\n\n    /**\n     * A custom renderer for use with the command palette.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer;\n  }\n\n  /**\n   * An options object for creating a command item.\n   */\n  export interface IItemOptions {\n    /**\n     * The category for the item.\n     */\n    category: string;\n\n    /**\n     * The command to execute when the item is triggered.\n     */\n    command: string;\n\n    /**\n     * The arguments for the command.\n     *\n     * The default value is an empty object.\n     */\n    args?: ReadonlyJSONObject;\n\n    /**\n     * The rank for the command item.\n     *\n     * The rank is used as a tie-breaker when ordering command items\n     * for display. Items are sorted in the following order:\n     *   1. Text match (lower is better)\n     *   2. Category (locale order)\n     *   3. Rank (lower is better)\n     *   4. Label (locale order)\n     *\n     * The default rank is `Infinity`.\n     */\n    rank?: number;\n  }\n\n  /**\n   * An object which represents an item in a command palette.\n   *\n   * #### Notes\n   * Item objects are created automatically by a command palette.\n   */\n  export interface IItem {\n    /**\n     * The command to execute when the item is triggered.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyJSONObject;\n\n    /**\n     * The category for the command item.\n     */\n    readonly category: string;\n\n    /**\n     * The rank for the command item.\n     */\n    readonly rank: number;\n\n    /**\n     * The display label for the command item.\n     */\n    readonly label: string;\n\n    /**\n     * The display caption for the command item.\n     */\n    readonly caption: string;\n\n    /**\n     * The icon renderer for the command item.\n     */\n    readonly icon: VirtualElement.IRenderer | undefined;\n\n    /**\n     * The icon class for the command item.\n     */\n    readonly iconClass: string;\n\n    /**\n     * The icon label for the command item.\n     */\n    readonly iconLabel: string;\n\n    /**\n     * The extra class name for the command item.\n     */\n    readonly className: string;\n\n    /**\n     * The dataset for the command item.\n     */\n    readonly dataset: CommandRegistry.Dataset;\n\n    /**\n     * Whether the command item is enabled.\n     */\n    readonly isEnabled: boolean;\n\n    /**\n     * Whether the command item is toggled.\n     */\n    readonly isToggled: boolean;\n\n    /**\n     * Whether the command item is toggleable.\n     */\n    readonly isToggleable: boolean;\n\n    /**\n     * Whether the command item is visible.\n     */\n    readonly isVisible: boolean;\n\n    /**\n     * The key binding for the command item.\n     */\n    readonly keyBinding: CommandRegistry.IKeyBinding | null;\n  }\n\n  /**\n   * The render data for a command palette header.\n   */\n  export interface IHeaderRenderData {\n    /**\n     * The category of the header.\n     */\n    readonly category: string;\n\n    /**\n     * The indices of the matched characters in the category.\n     */\n    readonly indices: ReadonlyArray<number> | null;\n  }\n\n  /**\n   * The render data for a command palette item.\n   */\n  export interface IItemRenderData {\n    /**\n     * The command palette item to render.\n     */\n    readonly item: IItem;\n\n    /**\n     * The indices of the matched characters in the label.\n     */\n    readonly indices: ReadonlyArray<number> | null;\n\n    /**\n     * Whether the item is the active item.\n     */\n    readonly active: boolean;\n  }\n\n  /**\n   * The render data for a command palette empty message.\n   */\n  export interface IEmptyMessageRenderData {\n    /**\n     * The query which failed to match any commands.\n     */\n    query: string;\n  }\n\n  /**\n   * A renderer for use with a command palette.\n   */\n  export interface IRenderer {\n    /**\n     * Render the virtual element for a command palette header.\n     *\n     * @param data - The data to use for rendering the header.\n     *\n     * @returns A virtual element representing the header.\n     */\n    renderHeader(data: IHeaderRenderData): VirtualElement;\n\n    /**\n     * Render the virtual element for a command palette item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     *\n     * #### Notes\n     * The command palette will not render invisible items.\n     */\n    renderItem(data: IItemRenderData): VirtualElement;\n\n    /**\n     * Render the empty results message for a command palette.\n     *\n     * @param data - The data to use for rendering the message.\n     *\n     * @returns A virtual element representing the message.\n     */\n    renderEmptyMessage(data: IEmptyMessageRenderData): VirtualElement;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   */\n  export class Renderer implements IRenderer {\n    /**\n     * Render the virtual element for a command palette header.\n     *\n     * @param data - The data to use for rendering the header.\n     *\n     * @returns A virtual element representing the header.\n     */\n    renderHeader(data: IHeaderRenderData): VirtualElement {\n      let content = this.formatHeader(data);\n      return h.li({ className: 'lm-CommandPalette-header' }, content);\n    }\n\n    /**\n     * Render the virtual element for a command palette item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     */\n    renderItem(data: IItemRenderData): VirtualElement {\n      let className = this.createItemClass(data);\n      let dataset = this.createItemDataset(data);\n      if (data.item.isToggleable) {\n        return h.li(\n          {\n            className,\n            dataset,\n            role: 'menuitemcheckbox',\n            'aria-checked': `${data.item.isToggled}`\n          },\n          this.renderItemIcon(data),\n          this.renderItemContent(data),\n          this.renderItemShortcut(data)\n        );\n      }\n      return h.li(\n        {\n          className,\n          dataset,\n          role: 'menuitem'\n        },\n        this.renderItemIcon(data),\n        this.renderItemContent(data),\n        this.renderItemShortcut(data)\n      );\n    }\n\n    /**\n     * Render the empty results message for a command palette.\n     *\n     * @param data - The data to use for rendering the message.\n     *\n     * @returns A virtual element representing the message.\n     */\n    renderEmptyMessage(data: IEmptyMessageRenderData): VirtualElement {\n      let content = this.formatEmptyMessage(data);\n      return h.li({ className: 'lm-CommandPalette-emptyMessage' }, content);\n    }\n\n    /**\n     * Render the icon for a command palette item.\n     *\n     * @param data - The data to use for rendering the icon.\n     *\n     * @returns A virtual element representing the icon.\n     */\n    renderItemIcon(data: IItemRenderData): VirtualElement {\n      let className = this.createIconClass(data);\n\n      // If data.item.icon is undefined, it will be ignored.\n      return h.div({ className }, data.item.icon!, data.item.iconLabel);\n    }\n\n    /**\n     * Render the content for a command palette item.\n     *\n     * @param data - The data to use for rendering the content.\n     *\n     * @returns A virtual element representing the content.\n     */\n    renderItemContent(data: IItemRenderData): VirtualElement {\n      return h.div(\n        { className: 'lm-CommandPalette-itemContent' },\n        this.renderItemLabel(data),\n        this.renderItemCaption(data)\n      );\n    }\n\n    /**\n     * Render the label for a command palette item.\n     *\n     * @param data - The data to use for rendering the label.\n     *\n     * @returns A virtual element representing the label.\n     */\n    renderItemLabel(data: IItemRenderData): VirtualElement {\n      let content = this.formatItemLabel(data);\n      return h.div({ className: 'lm-CommandPalette-itemLabel' }, content);\n    }\n\n    /**\n     * Render the caption for a command palette item.\n     *\n     * @param data - The data to use for rendering the caption.\n     *\n     * @returns A virtual element representing the caption.\n     */\n    renderItemCaption(data: IItemRenderData): VirtualElement {\n      let content = this.formatItemCaption(data);\n      return h.div({ className: 'lm-CommandPalette-itemCaption' }, content);\n    }\n\n    /**\n     * Render the shortcut for a command palette item.\n     *\n     * @param data - The data to use for rendering the shortcut.\n     *\n     * @returns A virtual element representing the shortcut.\n     */\n    renderItemShortcut(data: IItemRenderData): VirtualElement {\n      let content = this.formatItemShortcut(data);\n      return h.div({ className: 'lm-CommandPalette-itemShortcut' }, content);\n    }\n\n    /**\n     * Create the class name for the command palette item.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the command palette item.\n     */\n    createItemClass(data: IItemRenderData): string {\n      // Set up the initial class name.\n      let name = 'lm-CommandPalette-item';\n\n      // Add the boolean state classes.\n      if (!data.item.isEnabled) {\n        name += ' lm-mod-disabled';\n      }\n      if (data.item.isToggled) {\n        name += ' lm-mod-toggled';\n      }\n      if (data.active) {\n        name += ' lm-mod-active';\n      }\n\n      // Add the extra class.\n      let extra = data.item.className;\n      if (extra) {\n        name += ` ${extra}`;\n      }\n\n      // Return the complete class name.\n      return name;\n    }\n\n    /**\n     * Create the dataset for the command palette item.\n     *\n     * @param data - The data to use for creating the dataset.\n     *\n     * @returns The dataset for the command palette item.\n     */\n    createItemDataset(data: IItemRenderData): ElementDataset {\n      return { ...data.item.dataset, command: data.item.command };\n    }\n\n    /**\n     * Create the class name for the command item icon.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the item icon.\n     */\n    createIconClass(data: IItemRenderData): string {\n      let name = 'lm-CommandPalette-itemIcon';\n      let extra = data.item.iconClass;\n      return extra ? `${name} ${extra}` : name;\n    }\n\n    /**\n     * Create the render content for the header node.\n     *\n     * @param data - The data to use for the header content.\n     *\n     * @returns The content to add to the header node.\n     */\n    formatHeader(data: IHeaderRenderData): h.Child {\n      if (!data.indices || data.indices.length === 0) {\n        return data.category;\n      }\n      return StringExt.highlight(data.category, data.indices, h.mark);\n    }\n\n    /**\n     * Create the render content for the empty message node.\n     *\n     * @param data - The data to use for the empty message content.\n     *\n     * @returns The content to add to the empty message node.\n     */\n    formatEmptyMessage(data: IEmptyMessageRenderData): h.Child {\n      return `No commands found that match '${data.query}'`;\n    }\n\n    /**\n     * Create the render content for the item shortcut node.\n     *\n     * @param data - The data to use for the shortcut content.\n     *\n     * @returns The content to add to the shortcut node.\n     */\n    formatItemShortcut(data: IItemRenderData): h.Child {\n      let kb = data.item.keyBinding;\n      return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;\n    }\n\n    /**\n     * Create the render content for the item label node.\n     *\n     * @param data - The data to use for the label content.\n     *\n     * @returns The content to add to the label node.\n     */\n    formatItemLabel(data: IItemRenderData): h.Child {\n      if (!data.indices || data.indices.length === 0) {\n        return data.item.label;\n      }\n      return StringExt.highlight(data.item.label, data.indices, h.mark);\n    }\n\n    /**\n     * Create the render content for the item caption node.\n     *\n     * @param data - The data to use for the caption content.\n     *\n     * @returns The content to add to the caption node.\n     */\n    formatItemCaption(data: IItemRenderData): h.Child {\n      return data.item.caption;\n    }\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create the DOM node for a command palette.\n   */\n  export function createNode(): HTMLDivElement {\n    let node = document.createElement('div');\n    let search = document.createElement('div');\n    let wrapper = document.createElement('div');\n    let input = document.createElement('input');\n    let content = document.createElement('ul');\n    let clear = document.createElement('button');\n    search.className = 'lm-CommandPalette-search';\n    wrapper.className = 'lm-CommandPalette-wrapper';\n    input.className = 'lm-CommandPalette-input';\n    clear.className = 'lm-close-icon';\n\n    content.className = 'lm-CommandPalette-content';\n    content.setAttribute('role', 'menu');\n    input.spellcheck = false;\n    wrapper.appendChild(input);\n    wrapper.appendChild(clear);\n    search.appendChild(wrapper);\n    node.appendChild(search);\n    node.appendChild(content);\n    return node;\n  }\n\n  /**\n   * Create a new command item from a command registry and options.\n   */\n  export function createItem(\n    commands: CommandRegistry,\n    options: CommandPalette.IItemOptions\n  ): CommandPalette.IItem {\n    return new CommandItem(commands, options);\n  }\n\n  /**\n   * A search result object for a header label.\n   */\n  export interface IHeaderResult {\n    /**\n     * The discriminated type of the object.\n     */\n    readonly type: 'header';\n\n    /**\n     * The category for the header.\n     */\n    readonly category: string;\n\n    /**\n     * The indices of the matched category characters.\n     */\n    readonly indices: ReadonlyArray<number> | null;\n  }\n\n  /**\n   * A search result object for a command item.\n   */\n  export interface IItemResult {\n    /**\n     * The discriminated type of the object.\n     */\n    readonly type: 'item';\n\n    /**\n     * The command item which was matched.\n     */\n    readonly item: CommandPalette.IItem;\n\n    /**\n     * The indices of the matched label characters.\n     */\n    readonly indices: ReadonlyArray<number> | null;\n  }\n\n  /**\n   * A type alias for a search result item.\n   */\n  export type SearchResult = IHeaderResult | IItemResult;\n\n  /**\n   * Search an array of command items for fuzzy matches.\n   */\n  export function search(\n    items: CommandPalette.IItem[],\n    query: string\n  ): SearchResult[] {\n    // Fuzzy match the items for the query.\n    let scores = matchItems(items, query);\n\n    // Sort the items based on their score.\n    scores.sort(scoreCmp);\n\n    // Create the results for the search.\n    return createResults(scores);\n  }\n\n  /**\n   * Test whether a result item can be activated.\n   */\n  export function canActivate(result: SearchResult): boolean {\n    return result.type === 'item' && result.item.isEnabled;\n  }\n\n  /**\n   * Normalize a category for a command item.\n   */\n  function normalizeCategory(category: string): string {\n    return category.trim().replace(/\\s+/g, ' ');\n  }\n\n  /**\n   * Normalize the query text for a fuzzy search.\n   */\n  function normalizeQuery(text: string): string {\n    return text.replace(/\\s+/g, '').toLowerCase();\n  }\n\n  /**\n   * An enum of the supported match types.\n   */\n  const enum MatchType {\n    Label,\n    Category,\n    Split,\n    Default\n  }\n\n  /**\n   * A text match score with associated command item.\n   */\n  interface IScore {\n    /**\n     * The numerical type for the text match.\n     */\n    matchType: MatchType;\n\n    /**\n     * The numerical score for the text match.\n     */\n    score: number;\n\n    /**\n     * The indices of the matched category characters.\n     */\n    categoryIndices: number[] | null;\n\n    /**\n     * The indices of the matched label characters.\n     */\n    labelIndices: number[] | null;\n\n    /**\n     * The command item associated with the match.\n     */\n    item: CommandPalette.IItem;\n  }\n\n  /**\n   * Perform a fuzzy match on an array of command items.\n   */\n  function matchItems(items: CommandPalette.IItem[], query: string): IScore[] {\n    // Normalize the query text to lower case with no whitespace.\n    query = normalizeQuery(query);\n\n    // Create the array to hold the scores.\n    let scores: IScore[] = [];\n\n    // Iterate over the items and match against the query.\n    for (let i = 0, n = items.length; i < n; ++i) {\n      // Ignore items which are not visible.\n      let item = items[i];\n      if (!item.isVisible) {\n        continue;\n      }\n\n      // If the query is empty, all items are matched by default.\n      if (!query) {\n        scores.push({\n          matchType: MatchType.Default,\n          categoryIndices: null,\n          labelIndices: null,\n          score: 0,\n          item\n        });\n        continue;\n      }\n\n      // Run the fuzzy search for the item and query.\n      let score = fuzzySearch(item, query);\n\n      // Ignore the item if it is not a match.\n      if (!score) {\n        continue;\n      }\n\n      // Penalize disabled items.\n      // TODO - push disabled items all the way down in sort cmp?\n      if (!item.isEnabled) {\n        score.score += 1000;\n      }\n\n      // Add the score to the results.\n      scores.push(score);\n    }\n\n    // Return the final array of scores.\n    return scores;\n  }\n\n  /**\n   * Perform a fuzzy search on a single command item.\n   */\n  function fuzzySearch(\n    item: CommandPalette.IItem,\n    query: string\n  ): IScore | null {\n    // Create the source text to be searched.\n    let category = item.category.toLowerCase();\n    let label = item.label.toLowerCase();\n    let source = `${category} ${label}`;\n\n    // Set up the match score and indices array.\n    let score = Infinity;\n    let indices: number[] | null = null;\n\n    // The regex for search word boundaries\n    let rgx = /\\b\\w/g;\n\n    // Search the source by word boundary.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Find the next word boundary in the source.\n      let rgxMatch = rgx.exec(source);\n\n      // Break if there is no more source context.\n      if (!rgxMatch) {\n        break;\n      }\n\n      // Run the string match on the relevant substring.\n      let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);\n\n      // Break if there is no match.\n      if (!match) {\n        break;\n      }\n\n      // Update the match if the score is better.\n      if (match.score <= score) {\n        score = match.score;\n        indices = match.indices;\n      }\n    }\n\n    // Bail if there was no match.\n    if (!indices || score === Infinity) {\n      return null;\n    }\n\n    // Compute the pivot index between category and label text.\n    let pivot = category.length + 1;\n\n    // Find the slice index to separate matched indices.\n    let j = ArrayExt.lowerBound(indices, pivot, (a, b) => a - b);\n\n    // Extract the matched category and label indices.\n    let categoryIndices = indices.slice(0, j);\n    let labelIndices = indices.slice(j);\n\n    // Adjust the label indices for the pivot offset.\n    for (let i = 0, n = labelIndices.length; i < n; ++i) {\n      labelIndices[i] -= pivot;\n    }\n\n    // Handle a pure label match.\n    if (categoryIndices.length === 0) {\n      return {\n        matchType: MatchType.Label,\n        categoryIndices: null,\n        labelIndices,\n        score,\n        item\n      };\n    }\n\n    // Handle a pure category match.\n    if (labelIndices.length === 0) {\n      return {\n        matchType: MatchType.Category,\n        categoryIndices,\n        labelIndices: null,\n        score,\n        item\n      };\n    }\n\n    // Handle a split match.\n    return {\n      matchType: MatchType.Split,\n      categoryIndices,\n      labelIndices,\n      score,\n      item\n    };\n  }\n\n  /**\n   * A sort comparison function for a match score.\n   */\n  function scoreCmp(a: IScore, b: IScore): number {\n    // First compare based on the match type\n    let m1 = a.matchType - b.matchType;\n    if (m1 !== 0) {\n      return m1;\n    }\n\n    // Otherwise, compare based on the match score.\n    let d1 = a.score - b.score;\n    if (d1 !== 0) {\n      return d1;\n    }\n\n    // Find the match index based on the match type.\n    let i1 = 0;\n    let i2 = 0;\n    switch (a.matchType) {\n      case MatchType.Label:\n        i1 = a.labelIndices![0];\n        i2 = b.labelIndices![0];\n        break;\n      case MatchType.Category:\n      case MatchType.Split:\n        i1 = a.categoryIndices![0];\n        i2 = b.categoryIndices![0];\n        break;\n    }\n\n    // Compare based on the match index.\n    if (i1 !== i2) {\n      return i1 - i2;\n    }\n\n    // Otherwise, compare by category.\n    let d2 = a.item.category.localeCompare(b.item.category);\n    if (d2 !== 0) {\n      return d2;\n    }\n\n    // Otherwise, compare by rank.\n    let r1 = a.item.rank;\n    let r2 = b.item.rank;\n    if (r1 !== r2) {\n      return r1 < r2 ? -1 : 1; // Infinity safe\n    }\n\n    // Finally, compare by label.\n    return a.item.label.localeCompare(b.item.label);\n  }\n\n  /**\n   * Create the results from an array of sorted scores.\n   */\n  function createResults(scores: IScore[]): SearchResult[] {\n    // Set up an array to track which scores have been visited.\n    let visited = new Array(scores.length);\n    ArrayExt.fill(visited, false);\n\n    // Set up the search results array.\n    let results: SearchResult[] = [];\n\n    // Iterate over each score in the array.\n    for (let i = 0, n = scores.length; i < n; ++i) {\n      // Ignore a score which has already been processed.\n      if (visited[i]) {\n        continue;\n      }\n\n      // Extract the current item and indices.\n      let { item, categoryIndices } = scores[i];\n\n      // Extract the category for the current item.\n      let category = item.category;\n\n      // Add the header result for the category.\n      results.push({ type: 'header', category, indices: categoryIndices });\n\n      // Find the rest of the scores with the same category.\n      for (let j = i; j < n; ++j) {\n        // Ignore a score which has already been processed.\n        if (visited[j]) {\n          continue;\n        }\n\n        // Extract the data for the current score.\n        let { item, labelIndices } = scores[j];\n\n        // Ignore an item with a different category.\n        if (item.category !== category) {\n          continue;\n        }\n\n        // Create the item result for the score.\n        results.push({ type: 'item', item, indices: labelIndices });\n\n        // Mark the score as processed.\n        visited[j] = true;\n      }\n    }\n\n    // Return the final results.\n    return results;\n  }\n\n  /**\n   * A concrete implementation of `CommandPalette.IItem`.\n   */\n  class CommandItem implements CommandPalette.IItem {\n    /**\n     * Construct a new command item.\n     */\n    constructor(\n      commands: CommandRegistry,\n      options: CommandPalette.IItemOptions\n    ) {\n      this._commands = commands;\n      this.category = normalizeCategory(options.category);\n      this.command = options.command;\n      this.args = options.args || JSONExt.emptyObject;\n      this.rank = options.rank !== undefined ? options.rank : Infinity;\n    }\n\n    /**\n     * The category for the command item.\n     */\n    readonly category: string;\n\n    /**\n     * The command to execute when the item is triggered.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyJSONObject;\n\n    /**\n     * The rank for the command item.\n     */\n    readonly rank: number;\n\n    /**\n     * The display label for the command item.\n     */\n    get label(): string {\n      return this._commands.label(this.command, this.args);\n    }\n\n    /**\n     * The icon renderer for the command item.\n     */\n    get icon(): VirtualElement.IRenderer | undefined {\n      return this._commands.icon(this.command, this.args);\n    }\n\n    /**\n     * The icon class for the command item.\n     */\n    get iconClass(): string {\n      return this._commands.iconClass(this.command, this.args);\n    }\n\n    /**\n     * The icon label for the command item.\n     */\n    get iconLabel(): string {\n      return this._commands.iconLabel(this.command, this.args);\n    }\n\n    /**\n     * The display caption for the command item.\n     */\n    get caption(): string {\n      return this._commands.caption(this.command, this.args);\n    }\n\n    /**\n     * The extra class name for the command item.\n     */\n    get className(): string {\n      return this._commands.className(this.command, this.args);\n    }\n\n    /**\n     * The dataset for the command item.\n     */\n    get dataset(): CommandRegistry.Dataset {\n      return this._commands.dataset(this.command, this.args);\n    }\n\n    /**\n     * Whether the command item is enabled.\n     */\n    get isEnabled(): boolean {\n      return this._commands.isEnabled(this.command, this.args);\n    }\n\n    /**\n     * Whether the command item is toggled.\n     */\n    get isToggled(): boolean {\n      return this._commands.isToggled(this.command, this.args);\n    }\n\n    /**\n     * Whether the command item is toggleable.\n     */\n    get isToggleable(): boolean {\n      return this._commands.isToggleable(this.command, this.args);\n    }\n\n    /**\n     * Whether the command item is visible.\n     */\n    get isVisible(): boolean {\n      return this._commands.isVisible(this.command, this.args);\n    }\n\n    /**\n     * The key binding for the command item.\n     */\n    get keyBinding(): CommandRegistry.IKeyBinding | null {\n      let { command, args } = this;\n      return (\n        ArrayExt.findLastValue(this._commands.keyBindings, kb => {\n          return kb.command === command && JSONExt.deepEqual(kb.args, args);\n        }) || null\n      );\n    }\n\n    private _commands: CommandRegistry;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport { JSONExt, ReadonlyJSONObject } from '@lumino/coreutils';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport {\n  ARIAAttrNames,\n  ElementARIAAttrs,\n  ElementDataset,\n  h,\n  VirtualDOM,\n  VirtualElement\n} from '@lumino/virtualdom';\n\nimport { Widget } from './widget';\n\ninterface IWindowData {\n  pageXOffset: number;\n  pageYOffset: number;\n  clientWidth: number;\n  clientHeight: number;\n}\n\n/**\n * A widget which displays items as a canonical menu.\n */\nexport class Menu extends Widget {\n  /**\n   * Construct a new menu.\n   *\n   * @param options - The options for initializing the menu.\n   */\n  constructor(options: Menu.IOptions) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-Menu');\n    this.setFlag(Widget.Flag.DisallowLayout);\n    this.commands = options.commands;\n    this.renderer = options.renderer || Menu.defaultRenderer;\n  }\n\n  /**\n   * Dispose of the resources held by the menu.\n   */\n  dispose(): void {\n    this.close();\n    this._items.length = 0;\n    super.dispose();\n  }\n\n  /**\n   * A signal emitted just before the menu is closed.\n   *\n   * #### Notes\n   * This signal is emitted when the menu receives a `'close-request'`\n   * message, just before it removes itself from the DOM.\n   *\n   * This signal is not emitted if the menu is already detached from\n   * the DOM when it receives the `'close-request'` message.\n   */\n  get aboutToClose(): ISignal<this, void> {\n    return this._aboutToClose;\n  }\n\n  /**\n   * A signal emitted when a new menu is requested by the user.\n   *\n   * #### Notes\n   * This signal is emitted whenever the user presses the right or left\n   * arrow keys, and a submenu cannot be opened or closed in response.\n   *\n   * This signal is useful when implementing menu bars in order to open\n   * the next or previous menu in response to a user key press.\n   *\n   * This signal is only emitted for the root menu in a hierarchy.\n   */\n  get menuRequested(): ISignal<this, 'next' | 'previous'> {\n    return this._menuRequested;\n  }\n\n  /**\n   * The command registry used by the menu.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The renderer used by the menu.\n   */\n  readonly renderer: Menu.IRenderer;\n\n  /**\n   * The parent menu of the menu.\n   *\n   * #### Notes\n   * This is `null` unless the menu is an open submenu.\n   */\n  get parentMenu(): Menu | null {\n    return this._parentMenu;\n  }\n\n  /**\n   * The child menu of the menu.\n   *\n   * #### Notes\n   * This is `null` unless the menu has an open submenu.\n   */\n  get childMenu(): Menu | null {\n    return this._childMenu;\n  }\n\n  /**\n   * The root menu of the menu hierarchy.\n   */\n  get rootMenu(): Menu {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let menu: Menu = this;\n    while (menu._parentMenu) {\n      menu = menu._parentMenu;\n    }\n    return menu;\n  }\n\n  /**\n   * The leaf menu of the menu hierarchy.\n   */\n  get leafMenu(): Menu {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let menu: Menu = this;\n    while (menu._childMenu) {\n      menu = menu._childMenu;\n    }\n    return menu;\n  }\n\n  /**\n   * The menu content node.\n   *\n   * #### Notes\n   * This is the node which holds the menu item nodes.\n   *\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get contentNode(): HTMLUListElement {\n    return this.node.getElementsByClassName(\n      'lm-Menu-content'\n    )[0] as HTMLUListElement;\n  }\n\n  /**\n   * Get the currently active menu item.\n   */\n  get activeItem(): Menu.IItem | null {\n    return this._items[this._activeIndex] || null;\n  }\n\n  /**\n   * Set the currently active menu item.\n   *\n   * #### Notes\n   * If the item cannot be activated, the item will be set to `null`.\n   */\n  set activeItem(value: Menu.IItem | null) {\n    this.activeIndex = value ? this._items.indexOf(value) : -1;\n  }\n\n  /**\n   * Get the index of the currently active menu item.\n   *\n   * #### Notes\n   * This will be `-1` if no menu item is active.\n   */\n  get activeIndex(): number {\n    return this._activeIndex;\n  }\n\n  /**\n   * Set the index of the currently active menu item.\n   *\n   * #### Notes\n   * If the item cannot be activated, the index will be set to `-1`.\n   */\n  set activeIndex(value: number) {\n    // Adjust the value for an out of range index.\n    if (value < 0 || value >= this._items.length) {\n      value = -1;\n    }\n\n    // Ensure the item can be activated.\n    if (value !== -1 && !Private.canActivate(this._items[value])) {\n      value = -1;\n    }\n\n    // Bail if the index will not change.\n    if (this._activeIndex === value) {\n      return;\n    }\n\n    // Update the active index.\n    this._activeIndex = value;\n\n    // Make active element in focus\n    if (\n      this._activeIndex >= 0 &&\n      this.contentNode.childNodes[this._activeIndex]\n    ) {\n      (this.contentNode.childNodes[this._activeIndex] as HTMLElement).focus();\n    }\n\n    // schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * A read-only array of the menu items in the menu.\n   */\n  get items(): ReadonlyArray<Menu.IItem> {\n    return this._items;\n  }\n\n  /**\n   * Activate the next selectable item in the menu.\n   *\n   * #### Notes\n   * If no item is selectable, the index will be set to `-1`.\n   */\n  activateNextItem(): void {\n    let n = this._items.length;\n    let ai = this._activeIndex;\n    let start = ai < n - 1 ? ai + 1 : 0;\n    let stop = start === 0 ? n - 1 : start - 1;\n    this.activeIndex = ArrayExt.findFirstIndex(\n      this._items,\n      Private.canActivate,\n      start,\n      stop\n    );\n  }\n\n  /**\n   * Activate the previous selectable item in the menu.\n   *\n   * #### Notes\n   * If no item is selectable, the index will be set to `-1`.\n   */\n  activatePreviousItem(): void {\n    let n = this._items.length;\n    let ai = this._activeIndex;\n    let start = ai <= 0 ? n - 1 : ai - 1;\n    let stop = start === n - 1 ? 0 : start + 1;\n    this.activeIndex = ArrayExt.findLastIndex(\n      this._items,\n      Private.canActivate,\n      start,\n      stop\n    );\n  }\n\n  /**\n   * Trigger the active menu item.\n   *\n   * #### Notes\n   * If the active item is a submenu, it will be opened and the first\n   * item will be activated.\n   *\n   * If the active item is a command, the command will be executed.\n   *\n   * If the menu is not attached, this is a no-op.\n   *\n   * If there is no active item, this is a no-op.\n   */\n  triggerActiveItem(): void {\n    // Bail if the menu is not attached.\n    if (!this.isAttached) {\n      return;\n    }\n\n    // Bail if there is no active item.\n    let item = this.activeItem;\n    if (!item) {\n      return;\n    }\n\n    // Cancel the pending timers.\n    this._cancelOpenTimer();\n    this._cancelCloseTimer();\n\n    // If the item is a submenu, open it.\n    if (item.type === 'submenu') {\n      this._openChildMenu(true);\n      return;\n    }\n\n    // Close the root menu before executing the command.\n    this.rootMenu.close();\n\n    // Execute the command for the item.\n    let { command, args } = item;\n    if (this.commands.isEnabled(command, args)) {\n      this.commands.execute(command, args);\n    } else {\n      console.log(`Command '${command}' is disabled.`);\n    }\n  }\n\n  /**\n   * Add a menu item to the end of the menu.\n   *\n   * @param options - The options for creating the menu item.\n   *\n   * @returns The menu item added to the menu.\n   */\n  addItem(options: Menu.IItemOptions): Menu.IItem {\n    return this.insertItem(this._items.length, options);\n  }\n\n  /**\n   * Insert a menu item into the menu at the specified index.\n   *\n   * @param index - The index at which to insert the item.\n   *\n   * @param options - The options for creating the menu item.\n   *\n   * @returns The menu item added to the menu.\n   *\n   * #### Notes\n   * The index will be clamped to the bounds of the items.\n   */\n  insertItem(index: number, options: Menu.IItemOptions): Menu.IItem {\n    // Close the menu if it's attached.\n    if (this.isAttached) {\n      this.close();\n    }\n\n    // Reset the active index.\n    this.activeIndex = -1;\n\n    // Clamp the insert index to the array bounds.\n    let i = Math.max(0, Math.min(index, this._items.length));\n\n    // Create the item for the options.\n    let item = Private.createItem(this, options);\n\n    // Insert the item into the array.\n    ArrayExt.insert(this._items, i, item);\n\n    // Schedule an update of the items.\n    this.update();\n\n    // Return the item added to the menu.\n    return item;\n  }\n\n  /**\n   * Remove an item from the menu.\n   *\n   * @param item - The item to remove from the menu.\n   *\n   * #### Notes\n   * This is a no-op if the item is not in the menu.\n   */\n  removeItem(item: Menu.IItem): void {\n    this.removeItemAt(this._items.indexOf(item));\n  }\n\n  /**\n   * Remove the item at a given index from the menu.\n   *\n   * @param index - The index of the item to remove.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  removeItemAt(index: number): void {\n    // Close the menu if it's attached.\n    if (this.isAttached) {\n      this.close();\n    }\n\n    // Reset the active index.\n    this.activeIndex = -1;\n\n    // Remove the item from the array.\n    let item = ArrayExt.removeAt(this._items, index);\n\n    // Bail if the index is out of range.\n    if (!item) {\n      return;\n    }\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * Remove all menu items from the menu.\n   */\n  clearItems(): void {\n    // Close the menu if it's attached.\n    if (this.isAttached) {\n      this.close();\n    }\n\n    // Reset the active index.\n    this.activeIndex = -1;\n\n    // Bail if there is nothing to remove.\n    if (this._items.length === 0) {\n      return;\n    }\n\n    // Clear the items.\n    this._items.length = 0;\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * Open the menu at the specified location.\n   *\n   * @param x - The client X coordinate of the menu location.\n   *\n   * @param y - The client Y coordinate of the menu location.\n   *\n   * @param options - The additional options for opening the menu.\n   *\n   * #### Notes\n   * The menu will be opened at the given location unless it will not\n   * fully fit on the screen. If it will not fit, it will be adjusted\n   * to fit naturally on the screen.\n   *\n   * This is a no-op if the menu is already attached to the DOM.\n   */\n  open(x: number, y: number, options: Menu.IOpenOptions = {}): void {\n    // Bail early if the menu is already attached.\n    if (this.isAttached) {\n      return;\n    }\n\n    // Extract the position options.\n    let forceX = options.forceX || false;\n    let forceY = options.forceY || false;\n\n    // Open the menu as a root menu.\n    Private.openRootMenu(this, x, y, forceX, forceY);\n\n    // Activate the menu to accept keyboard input.\n    this.activate();\n  }\n\n  /**\n   * Handle the DOM events for the menu.\n   *\n   * @param event - The DOM event sent to the menu.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the menu's DOM nodes. It should\n   * not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'mouseup':\n        this._evtMouseUp(event as MouseEvent);\n        break;\n      case 'mousemove':\n        this._evtMouseMove(event as MouseEvent);\n        break;\n      case 'mouseenter':\n        this._evtMouseEnter(event as MouseEvent);\n        break;\n      case 'mouseleave':\n        this._evtMouseLeave(event as MouseEvent);\n        break;\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('keydown', this);\n    this.node.addEventListener('mouseup', this);\n    this.node.addEventListener('mousemove', this);\n    this.node.addEventListener('mouseenter', this);\n    this.node.addEventListener('mouseleave', this);\n    this.node.addEventListener('contextmenu', this);\n    document.addEventListener('mousedown', this, true);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('keydown', this);\n    this.node.removeEventListener('mouseup', this);\n    this.node.removeEventListener('mousemove', this);\n    this.node.removeEventListener('mouseenter', this);\n    this.node.removeEventListener('mouseleave', this);\n    this.node.removeEventListener('contextmenu', this);\n    document.removeEventListener('mousedown', this, true);\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    if (this.isAttached) {\n      this.node.focus();\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    let items = this._items;\n    let renderer = this.renderer;\n    let activeIndex = this._activeIndex;\n    let collapsedFlags = Private.computeCollapsed(items);\n    let content = new Array<VirtualElement>(items.length);\n    for (let i = 0, n = items.length; i < n; ++i) {\n      let item = items[i];\n      let active = i === activeIndex;\n      let collapsed = collapsedFlags[i];\n      content[i] = renderer.renderItem({\n        item,\n        active,\n        collapsed,\n        onfocus: () => {\n          this.activeIndex = i;\n        }\n      });\n    }\n    VirtualDOM.render(content, this.contentNode);\n  }\n\n  /**\n   * A message handler invoked on a `'close-request'` message.\n   */\n  protected onCloseRequest(msg: Message): void {\n    // Cancel the pending timers.\n    this._cancelOpenTimer();\n    this._cancelCloseTimer();\n\n    // Reset the active index.\n    this.activeIndex = -1;\n\n    // Close any open child menu.\n    let childMenu = this._childMenu;\n    if (childMenu) {\n      this._childIndex = -1;\n      this._childMenu = null;\n      childMenu._parentMenu = null;\n      childMenu.close();\n    }\n\n    // Remove this menu from its parent and activate the parent.\n    let parentMenu = this._parentMenu;\n    if (parentMenu) {\n      this._parentMenu = null;\n      parentMenu._childIndex = -1;\n      parentMenu._childMenu = null;\n      parentMenu.activate();\n    }\n\n    // Emit the `aboutToClose` signal if the menu is attached.\n    if (this.isAttached) {\n      this._aboutToClose.emit(undefined);\n    }\n\n    // Finish closing the menu.\n    super.onCloseRequest(msg);\n  }\n\n  /**\n   * Handle the `'keydown'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the menu node.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // A menu handles all keydown events.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the key code for the event.\n    let kc = event.keyCode;\n\n    // Enter\n    if (kc === 13) {\n      this.triggerActiveItem();\n      return;\n    }\n\n    // Escape\n    if (kc === 27) {\n      this.close();\n      return;\n    }\n\n    // Left Arrow\n    if (kc === 37) {\n      if (this._parentMenu) {\n        this.close();\n      } else {\n        this._menuRequested.emit('previous');\n      }\n      return;\n    }\n\n    // Up Arrow\n    if (kc === 38) {\n      this.activatePreviousItem();\n      return;\n    }\n\n    // Right Arrow\n    if (kc === 39) {\n      let item = this.activeItem;\n      if (item && item.type === 'submenu') {\n        this.triggerActiveItem();\n      } else {\n        this.rootMenu._menuRequested.emit('next');\n      }\n      return;\n    }\n\n    // Down Arrow\n    if (kc === 40) {\n      this.activateNextItem();\n      return;\n    }\n\n    // Get the pressed key character.\n    let key = getKeyboardLayout().keyForKeydownEvent(event);\n\n    // Bail if the key is not valid.\n    if (!key) {\n      return;\n    }\n\n    // Search for the next best matching mnemonic item.\n    let start = this._activeIndex + 1;\n    let result = Private.findMnemonic(this._items, key, start);\n\n    // Handle the requested mnemonic based on the search results.\n    // If exactly one mnemonic is matched, that item is triggered.\n    // Otherwise, the next mnemonic is activated if available,\n    // followed by the auto mnemonic if available.\n    if (result.index !== -1 && !result.multiple) {\n      this.activeIndex = result.index;\n      this.triggerActiveItem();\n    } else if (result.index !== -1) {\n      this.activeIndex = result.index;\n    } else if (result.auto !== -1) {\n      this.activeIndex = result.auto;\n    }\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the menu node.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    if (event.button !== 0) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    this.triggerActiveItem();\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the menu node.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Hit test the item nodes for the item under the mouse.\n    let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n      return ElementExt.hitTest(node, event.clientX, event.clientY);\n    });\n\n    // Bail early if the mouse is already over the active index.\n    if (index === this._activeIndex) {\n      return;\n    }\n\n    // Update and coerce the active index.\n    this.activeIndex = index;\n    index = this.activeIndex;\n\n    // If the index is the current child index, cancel the timers.\n    if (index === this._childIndex) {\n      this._cancelOpenTimer();\n      this._cancelCloseTimer();\n      return;\n    }\n\n    // If a child menu is currently open, start the close timer.\n    if (this._childIndex !== -1) {\n      this._startCloseTimer();\n    }\n\n    // Cancel the open timer to give a full delay for opening.\n    this._cancelOpenTimer();\n\n    // Bail if the active item is not a valid submenu item.\n    let item = this.activeItem;\n    if (!item || item.type !== 'submenu' || !item.submenu) {\n      return;\n    }\n\n    // Start the open timer to open the active item submenu.\n    this._startOpenTimer();\n  }\n\n  /**\n   * Handle the `'mouseenter'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the menu node.\n   */\n  private _evtMouseEnter(event: MouseEvent): void {\n    // Synchronize the active ancestor items.\n    for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {\n      menu._cancelOpenTimer();\n      menu._cancelCloseTimer();\n      menu.activeIndex = menu._childIndex;\n    }\n  }\n\n  /**\n   * Handle the `'mouseleave'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the menu node.\n   */\n  private _evtMouseLeave(event: MouseEvent): void {\n    // Cancel any pending submenu opening.\n    this._cancelOpenTimer();\n\n    // If there is no open child menu, just reset the active index.\n    if (!this._childMenu) {\n      this.activeIndex = -1;\n      return;\n    }\n\n    // If the mouse is over the child menu, cancel the close timer.\n    let { clientX, clientY } = event;\n    if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {\n      this._cancelCloseTimer();\n      return;\n    }\n\n    // Otherwise, reset the active index and start the close timer.\n    this.activeIndex = -1;\n    this._startCloseTimer();\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the menu.\n   *\n   * #### Notes\n   * This listener is attached to the document node.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Bail if the menu is not a root menu.\n    if (this._parentMenu) {\n      return;\n    }\n\n    // The mouse button which is pressed is irrelevant. If the press\n    // is not on a menu, the entire hierarchy is closed and the event\n    // is allowed to propagate. This allows other code to act on the\n    // event, such as focusing the clicked element.\n    if (Private.hitTestMenus(this, event.clientX, event.clientY)) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else {\n      this.close();\n    }\n  }\n\n  /**\n   * Open the child menu at the active index immediately.\n   *\n   * If a different child menu is already open, it will be closed,\n   * even if the active item is not a valid submenu.\n   */\n  private _openChildMenu(activateFirst = false): void {\n    // If the item is not a valid submenu, close the child menu.\n    let item = this.activeItem;\n    if (!item || item.type !== 'submenu' || !item.submenu) {\n      this._closeChildMenu();\n      return;\n    }\n\n    // Do nothing if the child menu will not change.\n    let submenu = item.submenu;\n    if (submenu === this._childMenu) {\n      return;\n    }\n\n    // Prior to any DOM modifications save window data\n    Menu.saveWindowData();\n\n    // Ensure the current child menu is closed.\n    this._closeChildMenu();\n\n    // Update the private child state.\n    this._childMenu = submenu;\n    this._childIndex = this._activeIndex;\n\n    // Set the parent menu reference for the child.\n    submenu._parentMenu = this;\n\n    // Ensure the menu is updated and lookup the item node.\n    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n    let itemNode = this.contentNode.children[this._activeIndex];\n\n    // Open the submenu at the active node.\n    Private.openSubmenu(submenu, itemNode as HTMLElement);\n\n    // Activate the first item if desired.\n    if (activateFirst) {\n      submenu.activeIndex = -1;\n      submenu.activateNextItem();\n    }\n\n    // Activate the child menu.\n    submenu.activate();\n  }\n\n  /**\n   * Close the child menu immediately.\n   *\n   * This is a no-op if a child menu is not open.\n   */\n  private _closeChildMenu(): void {\n    if (this._childMenu) {\n      this._childMenu.close();\n    }\n  }\n\n  /**\n   * Start the open timer, unless it is already pending.\n   */\n  private _startOpenTimer(): void {\n    if (this._openTimerID === 0) {\n      this._openTimerID = window.setTimeout(() => {\n        this._openTimerID = 0;\n        this._openChildMenu();\n      }, Private.TIMER_DELAY);\n    }\n  }\n\n  /**\n   * Start the close timer, unless it is already pending.\n   */\n  private _startCloseTimer(): void {\n    if (this._closeTimerID === 0) {\n      this._closeTimerID = window.setTimeout(() => {\n        this._closeTimerID = 0;\n        this._closeChildMenu();\n      }, Private.TIMER_DELAY);\n    }\n  }\n\n  /**\n   * Cancel the open timer, if the timer is pending.\n   */\n  private _cancelOpenTimer(): void {\n    if (this._openTimerID !== 0) {\n      clearTimeout(this._openTimerID);\n      this._openTimerID = 0;\n    }\n  }\n\n  /**\n   * Cancel the close timer, if the timer is pending.\n   */\n  private _cancelCloseTimer(): void {\n    if (this._closeTimerID !== 0) {\n      clearTimeout(this._closeTimerID);\n      this._closeTimerID = 0;\n    }\n  }\n\n  /**\n   * Save window data used for menu positioning in transient cache.\n   *\n   * In order to avoid layout trashing it is recommended to invoke this\n   * method immediately prior to opening the menu and any DOM modifications\n   * (like closing previously visible menu, or adding a class to menu widget).\n   *\n   * The transient cache will be released upon `open()` call.\n   */\n  static saveWindowData(): void {\n    Private.saveWindowData();\n  }\n\n  private _childIndex = -1;\n  private _activeIndex = -1;\n  private _openTimerID = 0;\n  private _closeTimerID = 0;\n  private _items: Menu.IItem[] = [];\n  private _childMenu: Menu | null = null;\n  private _parentMenu: Menu | null = null;\n  private _aboutToClose = new Signal<this, void>(this);\n  private _menuRequested = new Signal<this, 'next' | 'previous'>(this);\n}\n\n/**\n * The namespace for the `Menu` class statics.\n */\nexport namespace Menu {\n  /**\n   * An options object for creating a menu.\n   */\n  export interface IOptions {\n    /**\n     * The command registry for use with the menu.\n     */\n    commands: CommandRegistry;\n\n    /**\n     * A custom renderer for use with the menu.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer;\n  }\n\n  /**\n   * An options object for the `open` method on a menu.\n   */\n  export interface IOpenOptions {\n    /**\n     * Whether to force the X position of the menu.\n     *\n     * Setting to `true` will disable the logic which repositions the\n     * X coordinate of the menu if it will not fit entirely on screen.\n     *\n     * The default is `false`.\n     */\n    forceX?: boolean;\n\n    /**\n     * Whether to force the Y position of the menu.\n     *\n     * Setting to `true` will disable the logic which repositions the\n     * Y coordinate of the menu if it will not fit entirely on screen.\n     *\n     * The default is `false`.\n     */\n    forceY?: boolean;\n  }\n\n  /**\n   * A type alias for a menu item type.\n   */\n  export type ItemType = 'command' | 'submenu' | 'separator';\n\n  /**\n   * An options object for creating a menu item.\n   */\n  export interface IItemOptions {\n    /**\n     * The type of the menu item.\n     *\n     * The default value is `'command'`.\n     */\n    type?: ItemType;\n\n    /**\n     * The command to execute when the item is triggered.\n     *\n     * The default value is an empty string.\n     */\n    command?: string;\n\n    /**\n     * The arguments for the command.\n     *\n     * The default value is an empty object.\n     */\n    args?: ReadonlyJSONObject;\n\n    /**\n     * The submenu for a `'submenu'` type item.\n     *\n     * The default value is `null`.\n     */\n    submenu?: Menu | null;\n  }\n\n  /**\n   * An object which represents a menu item.\n   *\n   * #### Notes\n   * Item objects are created automatically by a menu.\n   */\n  export interface IItem {\n    /**\n     * The type of the menu item.\n     */\n    readonly type: ItemType;\n\n    /**\n     * The command to execute when the item is triggered.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyJSONObject;\n\n    /**\n     * The submenu for a `'submenu'` type item.\n     */\n    readonly submenu: Menu | null;\n\n    /**\n     * The display label for the menu item.\n     */\n    readonly label: string;\n\n    /**\n     * The mnemonic index for the menu item.\n     */\n    readonly mnemonic: number;\n\n    /**\n     * The icon renderer for the menu item.\n     */\n    readonly icon: VirtualElement.IRenderer | undefined;\n\n    /**\n     * The icon class for the menu item.\n     */\n    readonly iconClass: string;\n\n    /**\n     * The icon label for the menu item.\n     */\n    readonly iconLabel: string;\n\n    /**\n     * The display caption for the menu item.\n     */\n    readonly caption: string;\n\n    /**\n     * The extra class name for the menu item.\n     */\n    readonly className: string;\n\n    /**\n     * The dataset for the menu item.\n     */\n    readonly dataset: CommandRegistry.Dataset;\n\n    /**\n     * Whether the menu item is enabled.\n     */\n    readonly isEnabled: boolean;\n\n    /**\n     * Whether the menu item is toggled.\n     */\n    readonly isToggled: boolean;\n\n    /**\n     * Whether the menu item is visible.\n     */\n    readonly isVisible: boolean;\n\n    /**\n     * The key binding for the menu item.\n     */\n    readonly keyBinding: CommandRegistry.IKeyBinding | null;\n  }\n\n  /**\n   * An object which holds the data to render a menu item.\n   */\n  export interface IRenderData {\n    /**\n     * The item to be rendered.\n     */\n    readonly item: IItem;\n\n    /**\n     * Whether the item is the active item.\n     */\n    readonly active: boolean;\n\n    /**\n     * Whether the item should be collapsed.\n     */\n    readonly collapsed: boolean;\n\n    /**\n     * Handler for when element is in focus.\n     */\n    readonly onfocus?: () => void;\n  }\n\n  /**\n   * A renderer for use with a menu.\n   */\n  export interface IRenderer {\n    /**\n     * Render the virtual element for a menu item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     */\n    renderItem(data: IRenderData): VirtualElement;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   *\n   * #### Notes\n   * Subclasses are free to reimplement rendering methods as needed.\n   */\n  export class Renderer implements IRenderer {\n    /**\n     * Render the virtual element for a menu item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     */\n    renderItem(data: IRenderData): VirtualElement {\n      let className = this.createItemClass(data);\n      let dataset = this.createItemDataset(data);\n      let aria = this.createItemARIA(data);\n      return h.li(\n        {\n          className,\n          dataset,\n          tabindex: '0',\n          onfocus: data.onfocus,\n          ...aria\n        },\n        this.renderIcon(data),\n        this.renderLabel(data),\n        this.renderShortcut(data),\n        this.renderSubmenu(data)\n      );\n    }\n\n    /**\n     * Render the icon element for a menu item.\n     *\n     * @param data - The data to use for rendering the icon.\n     *\n     * @returns A virtual element representing the item icon.\n     */\n    renderIcon(data: IRenderData): VirtualElement {\n      let className = this.createIconClass(data);\n\n      // If data.item.icon is undefined, it will be ignored.\n      return h.div({ className }, data.item.icon!, data.item.iconLabel);\n    }\n\n    /**\n     * Render the label element for a menu item.\n     *\n     * @param data - The data to use for rendering the label.\n     *\n     * @returns A virtual element representing the item label.\n     */\n    renderLabel(data: IRenderData): VirtualElement {\n      let content = this.formatLabel(data);\n      return h.div({ className: 'lm-Menu-itemLabel' }, content);\n    }\n\n    /**\n     * Render the shortcut element for a menu item.\n     *\n     * @param data - The data to use for rendering the shortcut.\n     *\n     * @returns A virtual element representing the item shortcut.\n     */\n    renderShortcut(data: IRenderData): VirtualElement {\n      let content = this.formatShortcut(data);\n      return h.div({ className: 'lm-Menu-itemShortcut' }, content);\n    }\n\n    /**\n     * Render the submenu icon element for a menu item.\n     *\n     * @param data - The data to use for rendering the submenu icon.\n     *\n     * @returns A virtual element representing the submenu icon.\n     */\n    renderSubmenu(data: IRenderData): VirtualElement {\n      return h.div({ className: 'lm-Menu-itemSubmenuIcon' });\n    }\n\n    /**\n     * Create the class name for the menu item.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the menu item.\n     */\n    createItemClass(data: IRenderData): string {\n      // Setup the initial class name.\n      let name = 'lm-Menu-item';\n\n      // Add the boolean state classes.\n      if (!data.item.isEnabled) {\n        name += ' lm-mod-disabled';\n      }\n      if (data.item.isToggled) {\n        name += ' lm-mod-toggled';\n      }\n      if (!data.item.isVisible) {\n        name += ' lm-mod-hidden';\n      }\n      if (data.active) {\n        name += ' lm-mod-active';\n      }\n      if (data.collapsed) {\n        name += ' lm-mod-collapsed';\n      }\n\n      // Add the extra class.\n      let extra = data.item.className;\n      if (extra) {\n        name += ` ${extra}`;\n      }\n\n      // Return the complete class name.\n      return name;\n    }\n\n    /**\n     * Create the dataset for the menu item.\n     *\n     * @param data - The data to use for creating the dataset.\n     *\n     * @returns The dataset for the menu item.\n     */\n    createItemDataset(data: IRenderData): ElementDataset {\n      let result: ElementDataset;\n      let { type, command, dataset } = data.item;\n      if (type === 'command') {\n        result = { ...dataset, type, command };\n      } else {\n        result = { ...dataset, type };\n      }\n      return result;\n    }\n\n    /**\n     * Create the class name for the menu item icon.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the item icon.\n     */\n    createIconClass(data: IRenderData): string {\n      let name = 'lm-Menu-itemIcon';\n      let extra = data.item.iconClass;\n      return extra ? `${name} ${extra}` : name;\n    }\n\n    /**\n     * Create the aria attributes for menu item.\n     *\n     * @param data - The data to use for the aria attributes.\n     *\n     * @returns The aria attributes object for the item.\n     */\n    createItemARIA(data: IRenderData): ElementARIAAttrs {\n      let aria: { [T in ARIAAttrNames]?: string } = {};\n      switch (data.item.type) {\n        case 'separator':\n          aria.role = 'presentation';\n          break;\n        case 'submenu':\n          aria['aria-haspopup'] = 'true';\n          if (!data.item.isEnabled) {\n            aria['aria-disabled'] = 'true';\n          }\n          break;\n        default:\n          if (!data.item.isEnabled) {\n            aria['aria-disabled'] = 'true';\n          }\n          aria.role = 'menuitem';\n      }\n      return aria;\n    }\n\n    /**\n     * Create the render content for the label node.\n     *\n     * @param data - The data to use for the label content.\n     *\n     * @returns The content to add to the label node.\n     */\n    formatLabel(data: IRenderData): h.Child {\n      // Fetch the label text and mnemonic index.\n      let { label, mnemonic } = data.item;\n\n      // If the index is out of range, do not modify the label.\n      if (mnemonic < 0 || mnemonic >= label.length) {\n        return label;\n      }\n\n      // Split the label into parts.\n      let prefix = label.slice(0, mnemonic);\n      let suffix = label.slice(mnemonic + 1);\n      let char = label[mnemonic];\n\n      // Wrap the mnemonic character in a span.\n      let span = h.span({ className: 'lm-Menu-itemMnemonic' }, char);\n\n      // Return the content parts.\n      return [prefix, span, suffix];\n    }\n\n    /**\n     * Create the render content for the shortcut node.\n     *\n     * @param data - The data to use for the shortcut content.\n     *\n     * @returns The content to add to the shortcut node.\n     */\n    formatShortcut(data: IRenderData): h.Child {\n      let kb = data.item.keyBinding;\n      return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;\n    }\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The ms delay for opening and closing a submenu.\n   */\n  export const TIMER_DELAY = 300;\n\n  /**\n   * The horizontal pixel overlap for an open submenu.\n   */\n  export const SUBMENU_OVERLAP = 3;\n\n  let transientWindowDataCache: IWindowData | null = null;\n  let transientCacheCounter: number = 0;\n\n  function getWindowData(): IWindowData {\n    // if transient cache is in use, take one from it\n    if (transientCacheCounter > 0) {\n      transientCacheCounter--;\n      return transientWindowDataCache!;\n    }\n    return _getWindowData();\n  }\n\n  /**\n   * Store window data in transient cache.\n   *\n   * The transient cache will be released upon `getWindowData()` call.\n   * If this function is called multiple times, the cache will be\n   * retained until as many calls to `getWindowData()` were made.\n   *\n   * Note: should be called before any DOM modifications.\n   */\n  export function saveWindowData(): void {\n    transientWindowDataCache = _getWindowData();\n    transientCacheCounter++;\n  }\n\n  /**\n   * Create the DOM node for a menu.\n   */\n  export function createNode(): HTMLDivElement {\n    let node = document.createElement('div');\n    let content = document.createElement('ul');\n    content.className = 'lm-Menu-content';\n    node.appendChild(content);\n    content.setAttribute('role', 'menu');\n    node.tabIndex = 0;\n    return node;\n  }\n\n  /**\n   * Test whether a menu item can be activated.\n   */\n  export function canActivate(item: Menu.IItem): boolean {\n    return item.type !== 'separator' && item.isEnabled && item.isVisible;\n  }\n\n  /**\n   * Create a new menu item for an owner menu.\n   */\n  export function createItem(\n    owner: Menu,\n    options: Menu.IItemOptions\n  ): Menu.IItem {\n    return new MenuItem(owner.commands, options);\n  }\n\n  /**\n   * Hit test a menu hierarchy starting at the given root.\n   */\n  export function hitTestMenus(menu: Menu, x: number, y: number): boolean {\n    for (let temp: Menu | null = menu; temp; temp = temp.childMenu) {\n      if (ElementExt.hitTest(temp.node, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Compute which extra separator items should be collapsed.\n   */\n  export function computeCollapsed(\n    items: ReadonlyArray<Menu.IItem>\n  ): boolean[] {\n    // Allocate the return array and fill it with `false`.\n    let result = new Array<boolean>(items.length);\n    ArrayExt.fill(result, false);\n\n    // Collapse the leading separators.\n    let k1 = 0;\n    let n = items.length;\n    for (; k1 < n; ++k1) {\n      let item = items[k1];\n      if (!item.isVisible) {\n        continue;\n      }\n      if (item.type !== 'separator') {\n        break;\n      }\n      result[k1] = true;\n    }\n\n    // Hide the trailing separators.\n    let k2 = n - 1;\n    for (; k2 >= 0; --k2) {\n      let item = items[k2];\n      if (!item.isVisible) {\n        continue;\n      }\n      if (item.type !== 'separator') {\n        break;\n      }\n      result[k2] = true;\n    }\n\n    // Hide the remaining consecutive separators.\n    let hide = false;\n    while (++k1 < k2) {\n      let item = items[k1];\n      if (!item.isVisible) {\n        continue;\n      }\n      if (item.type !== 'separator') {\n        hide = false;\n      } else if (hide) {\n        result[k1] = true;\n      } else {\n        hide = true;\n      }\n    }\n\n    // Return the resulting flags.\n    return result;\n  }\n\n  function _getWindowData(): IWindowData {\n    return {\n      pageXOffset: window.pageXOffset,\n      pageYOffset: window.pageYOffset,\n      clientWidth: document.documentElement.clientWidth,\n      clientHeight: document.documentElement.clientHeight\n    };\n  }\n\n  /**\n   * Open a menu as a root menu at the target location.\n   */\n  export function openRootMenu(\n    menu: Menu,\n    x: number,\n    y: number,\n    forceX: boolean,\n    forceY: boolean\n  ): void {\n    // Get the current position and size of the main viewport.\n    const windowData = getWindowData();\n    let px = windowData.pageXOffset;\n    let py = windowData.pageYOffset;\n    let cw = windowData.clientWidth;\n    let ch = windowData.clientHeight;\n\n    // Ensure the menu is updated before attaching and measuring.\n    MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);\n\n    // Compute the maximum allowed height for the menu.\n    let maxHeight = ch - (forceY ? y : 0);\n\n    // Fetch common variables.\n    let node = menu.node;\n    let style = node.style;\n\n    // Clear the menu geometry and prepare it for measuring.\n    style.opacity = '0';\n    style.maxHeight = `${maxHeight}px`;\n\n    // Attach the menu to the document.\n    Widget.attach(menu, document.body);\n\n    // Measure the size of the menu.\n    let { width, height } = node.getBoundingClientRect();\n\n    // Adjust the X position of the menu to fit on-screen.\n    if (!forceX && x + width > px + cw) {\n      x = px + cw - width;\n    }\n\n    // Adjust the Y position of the menu to fit on-screen.\n    if (!forceY && y + height > py + ch) {\n      if (y > py + ch) {\n        y = py + ch - height;\n      } else {\n        y = y - height;\n      }\n    }\n\n    // Update the position of the menu to the computed position.\n    style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;\n\n    // Finally, make the menu visible on the screen.\n    style.opacity = '1';\n  }\n\n  /**\n   * Open a menu as a submenu using an item node for positioning.\n   */\n  export function openSubmenu(submenu: Menu, itemNode: HTMLElement): void {\n    // Get the current position and size of the main viewport.\n    const windowData = getWindowData();\n    let px = windowData.pageXOffset;\n    let py = windowData.pageYOffset;\n    let cw = windowData.clientWidth;\n    let ch = windowData.clientHeight;\n\n    // Ensure the menu is updated before opening.\n    MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);\n\n    // Compute the maximum allowed height for the menu.\n    let maxHeight = ch;\n\n    // Fetch common variables.\n    let node = submenu.node;\n    let style = node.style;\n\n    // Clear the menu geometry and prepare it for measuring.\n    style.opacity = '0';\n    style.maxHeight = `${maxHeight}px`;\n\n    // Attach the menu to the document.\n    Widget.attach(submenu, document.body);\n\n    // Measure the size of the menu.\n    let { width, height } = node.getBoundingClientRect();\n\n    // Compute the box sizing for the menu.\n    let box = ElementExt.boxSizing(submenu.node);\n\n    // Get the bounding rect for the target item node.\n    let itemRect = itemNode.getBoundingClientRect();\n\n    // Compute the target X position.\n    let x = itemRect.right - SUBMENU_OVERLAP;\n\n    // Adjust the X position to fit on the screen.\n    if (x + width > px + cw) {\n      x = itemRect.left + SUBMENU_OVERLAP - width;\n    }\n\n    // Compute the target Y position.\n    let y = itemRect.top - box.borderTop - box.paddingTop;\n\n    // Adjust the Y position to fit on the screen.\n    if (y + height > py + ch) {\n      y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;\n    }\n\n    // Update the position of the menu to the computed position.\n    style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;\n\n    // Finally, make the menu visible on the screen.\n    style.opacity = '1';\n  }\n\n  /**\n   * The results of a mnemonic search.\n   */\n  export interface IMnemonicResult {\n    /**\n     * The index of the first matching mnemonic item, or `-1`.\n     */\n    index: number;\n\n    /**\n     * Whether multiple mnemonic items matched.\n     */\n    multiple: boolean;\n\n    /**\n     * The index of the first auto matched non-mnemonic item.\n     */\n    auto: number;\n  }\n\n  /**\n   * Find the best matching mnemonic item.\n   *\n   * The search starts at the given index and wraps around.\n   */\n  export function findMnemonic(\n    items: ReadonlyArray<Menu.IItem>,\n    key: string,\n    start: number\n  ): IMnemonicResult {\n    // Setup the result variables.\n    let index = -1;\n    let auto = -1;\n    let multiple = false;\n\n    // Normalize the key to upper case.\n    let upperKey = key.toUpperCase();\n\n    // Search the items from the given start index.\n    for (let i = 0, n = items.length; i < n; ++i) {\n      // Compute the wrapped index.\n      let k = (i + start) % n;\n\n      // Lookup the item\n      let item = items[k];\n\n      // Ignore items which cannot be activated.\n      if (!canActivate(item)) {\n        continue;\n      }\n\n      // Ignore items with an empty label.\n      let label = item.label;\n      if (label.length === 0) {\n        continue;\n      }\n\n      // Lookup the mnemonic index for the label.\n      let mn = item.mnemonic;\n\n      // Handle a valid mnemonic index.\n      if (mn >= 0 && mn < label.length) {\n        if (label[mn].toUpperCase() === upperKey) {\n          if (index === -1) {\n            index = k;\n          } else {\n            multiple = true;\n          }\n        }\n        continue;\n      }\n\n      // Finally, handle the auto index if possible.\n      if (auto === -1 && label[0].toUpperCase() === upperKey) {\n        auto = k;\n      }\n    }\n\n    // Return the search results.\n    return { index, multiple, auto };\n  }\n\n  /**\n   * A concrete implementation of `Menu.IItem`.\n   */\n  class MenuItem implements Menu.IItem {\n    /**\n     * Construct a new menu item.\n     */\n    constructor(commands: CommandRegistry, options: Menu.IItemOptions) {\n      this._commands = commands;\n      this.type = options.type || 'command';\n      this.command = options.command || '';\n      this.args = options.args || JSONExt.emptyObject;\n      this.submenu = options.submenu || null;\n    }\n\n    /**\n     * The type of the menu item.\n     */\n    readonly type: Menu.ItemType;\n\n    /**\n     * The command to execute when the item is triggered.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyJSONObject;\n\n    /**\n     * The submenu for a `'submenu'` type item.\n     */\n    readonly submenu: Menu | null;\n\n    /**\n     * The display label for the menu item.\n     */\n    get label(): string {\n      if (this.type === 'command') {\n        return this._commands.label(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.label;\n      }\n      return '';\n    }\n\n    /**\n     * The mnemonic index for the menu item.\n     */\n    get mnemonic(): number {\n      if (this.type === 'command') {\n        return this._commands.mnemonic(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.mnemonic;\n      }\n      return -1;\n    }\n\n    /**\n     * The icon renderer for the menu item.\n     */\n    get icon(): VirtualElement.IRenderer | undefined {\n      if (this.type === 'command') {\n        return this._commands.icon(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.icon;\n      }\n      return undefined;\n    }\n\n    /**\n     * The icon class for the menu item.\n     */\n    get iconClass(): string {\n      if (this.type === 'command') {\n        return this._commands.iconClass(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.iconClass;\n      }\n      return '';\n    }\n\n    /**\n     * The icon label for the menu item.\n     */\n    get iconLabel(): string {\n      if (this.type === 'command') {\n        return this._commands.iconLabel(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.iconLabel;\n      }\n      return '';\n    }\n\n    /**\n     * The display caption for the menu item.\n     */\n    get caption(): string {\n      if (this.type === 'command') {\n        return this._commands.caption(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.caption;\n      }\n      return '';\n    }\n\n    /**\n     * The extra class name for the menu item.\n     */\n    get className(): string {\n      if (this.type === 'command') {\n        return this._commands.className(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.className;\n      }\n      return '';\n    }\n\n    /**\n     * The dataset for the menu item.\n     */\n    get dataset(): CommandRegistry.Dataset {\n      if (this.type === 'command') {\n        return this._commands.dataset(this.command, this.args);\n      }\n      if (this.type === 'submenu' && this.submenu) {\n        return this.submenu.title.dataset;\n      }\n      return {};\n    }\n\n    /**\n     * Whether the menu item is enabled.\n     */\n    get isEnabled(): boolean {\n      if (this.type === 'command') {\n        return this._commands.isEnabled(this.command, this.args);\n      }\n      if (this.type === 'submenu') {\n        return this.submenu !== null;\n      }\n      return true;\n    }\n\n    /**\n     * Whether the menu item is toggled.\n     */\n    get isToggled(): boolean {\n      if (this.type === 'command') {\n        return this._commands.isToggled(this.command, this.args);\n      }\n      return false;\n    }\n\n    /**\n     * Whether the menu item is visible.\n     */\n    get isVisible(): boolean {\n      if (this.type === 'command') {\n        return this._commands.isVisible(this.command, this.args);\n      }\n      if (this.type === 'submenu') {\n        return this.submenu !== null;\n      }\n      return true;\n    }\n\n    /**\n     * The key binding for the menu item.\n     */\n    get keyBinding(): CommandRegistry.IKeyBinding | null {\n      if (this.type === 'command') {\n        let { command, args } = this;\n        return (\n          ArrayExt.findLastValue(this._commands.keyBindings, kb => {\n            return kb.command === command && JSONExt.deepEqual(kb.args, args);\n          }) || null\n        );\n      }\n      return null;\n    }\n\n    private _commands: CommandRegistry;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport { DisposableDelegate, IDisposable } from '@lumino/disposable';\n\nimport { Selector } from '@lumino/domutils';\n\nimport { Menu } from './menu';\n\n/**\n * An object which implements a universal context menu.\n *\n * #### Notes\n * The items shown in the context menu are determined by CSS selector\n * matching against the DOM hierarchy at the site of the mouse click.\n * This is similar in concept to how keyboard shortcuts are matched\n * in the command registry.\n */\nexport class ContextMenu {\n  /**\n   * Construct a new context menu.\n   *\n   * @param options - The options for initializing the menu.\n   */\n  constructor(options: ContextMenu.IOptions) {\n    const { groupByTarget, sortBySelector, ...others } = options;\n    this.menu = new Menu(others);\n    this._groupByTarget = groupByTarget !== false;\n    this._sortBySelector = sortBySelector !== false;\n  }\n\n  /**\n   * The menu widget which displays the matched context items.\n   */\n  readonly menu: Menu;\n\n  /**\n   * Add an item to the context menu.\n   *\n   * @param options - The options for creating the item.\n   *\n   * @returns A disposable which will remove the item from the menu.\n   */\n  addItem(options: ContextMenu.IItemOptions): IDisposable {\n    // Create an item from the given options.\n    let item = Private.createItem(options, this._idTick++);\n\n    // Add the item to the internal array.\n    this._items.push(item);\n\n    // Return a disposable which will remove the item.\n    return new DisposableDelegate(() => {\n      ArrayExt.removeFirstOf(this._items, item);\n    });\n  }\n\n  /**\n   * Open the context menu in response to a `'contextmenu'` event.\n   *\n   * @param event - The `'contextmenu'` event of interest.\n   *\n   * @returns `true` if the menu was opened, or `false` if no items\n   *   matched the event and the menu was not opened.\n   *\n   * #### Notes\n   * This method will populate the context menu with items which match\n   * the propagation path of the event, then open the menu at the mouse\n   * position indicated by the event.\n   */\n  open(event: MouseEvent): boolean {\n    // Prior to any DOM modifications update the window data.\n    Menu.saveWindowData();\n\n    // Clear the current contents of the context menu.\n    this.menu.clearItems();\n\n    // Bail early if there are no items to match.\n    if (this._items.length === 0) {\n      return false;\n    }\n\n    // Find the matching items for the event.\n    let items = Private.matchItems(\n      this._items,\n      event,\n      this._groupByTarget,\n      this._sortBySelector\n    );\n\n    // Bail if there are no matching items.\n    if (!items || items.length === 0) {\n      return false;\n    }\n\n    // Add the filtered items to the menu.\n    for (const item of items) {\n      this.menu.addItem(item);\n    }\n\n    // Open the context menu at the current mouse position.\n    this.menu.open(event.clientX, event.clientY);\n\n    // Indicate success.\n    return true;\n  }\n\n  private _groupByTarget: boolean = true;\n  private _idTick = 0;\n  private _items: Private.IItem[] = [];\n  private _sortBySelector: boolean = true;\n}\n\n/**\n * The namespace for the `ContextMenu` class statics.\n */\nexport namespace ContextMenu {\n  /**\n   * An options object for initializing a context menu.\n   */\n  export interface IOptions {\n    /**\n     * The command registry to use with the context menu.\n     */\n    commands: CommandRegistry;\n\n    /**\n     * A custom renderer for use with the context menu.\n     */\n    renderer?: Menu.IRenderer;\n\n    /**\n     * Whether to sort by selector and rank or only rank.\n     *\n     * Default true.\n     */\n    sortBySelector?: boolean;\n\n    /**\n     * Whether to group items following the DOM hierarchy.\n     *\n     * Default true.\n     *\n     * #### Note\n     * If true, when the mouse event occurs on element `span` within `div.top`,\n     * the items matching `div.top` will be shown before the ones matching `body`.\n     */\n    groupByTarget?: boolean;\n  }\n\n  /**\n   * An options object for creating a context menu item.\n   */\n  export interface IItemOptions extends Menu.IItemOptions {\n    /**\n     * The CSS selector for the context menu item.\n     *\n     * The context menu item will only be displayed in the context menu\n     * when the selector matches a node on the propagation path of the\n     * contextmenu event. This allows the menu item to be restricted to\n     * user-defined contexts.\n     *\n     * The selector must not contain commas.\n     */\n    selector: string;\n\n    /**\n     * The rank for the item.\n     *\n     * The rank is used as a tie-breaker when ordering context menu\n     * items for display. Items are sorted in the following order:\n     *   1. Depth in the DOM tree (deeper is better)\n     *   2. Selector specificity (higher is better)\n     *   3. Rank (lower is better)\n     *   4. Insertion order\n     *\n     * The default rank is `Infinity`.\n     */\n    rank?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A normalized item for a context menu.\n   */\n  export interface IItem extends Menu.IItemOptions {\n    /**\n     * The selector for the item.\n     */\n    selector: string;\n\n    /**\n     * The rank for the item.\n     */\n    rank: number;\n\n    /**\n     * The tie-breaking id for the item.\n     */\n    id: number;\n  }\n\n  /**\n   * Create a normalized context menu item from an options object.\n   */\n  export function createItem(\n    options: ContextMenu.IItemOptions,\n    id: number\n  ): IItem {\n    let selector = validateSelector(options.selector);\n    let rank = options.rank !== undefined ? options.rank : Infinity;\n    return { ...options, selector, rank, id };\n  }\n\n  /**\n   * Find the items which match a context menu event.\n   *\n   * The results are sorted by DOM level, specificity, and rank.\n   */\n  export function matchItems(\n    items: IItem[],\n    event: MouseEvent,\n    groupByTarget: boolean,\n    sortBySelector: boolean\n  ): IItem[] | null {\n    // Look up the target of the event.\n    let target = event.target as Element | null;\n\n    // Bail if there is no target.\n    if (!target) {\n      return null;\n    }\n\n    // Look up the current target of the event.\n    let currentTarget = event.currentTarget as Element | null;\n\n    // Bail if there is no current target.\n    if (!currentTarget) {\n      return null;\n    }\n\n    // There are some third party libraries that cause the `target` to\n    // be detached from the DOM before lumino can process the event.\n    // If that happens, search for a new target node by point. If that\n    // node is still dangling, bail.\n    if (!currentTarget.contains(target)) {\n      target = document.elementFromPoint(event.clientX, event.clientY);\n      if (!target || !currentTarget.contains(target)) {\n        return null;\n      }\n    }\n\n    // Set up the result array.\n    let result: IItem[] = [];\n\n    // Copy the items array to allow in-place modification.\n    let availableItems: Array<IItem | null> = items.slice();\n\n    // Walk up the DOM hierarchy searching for matches.\n    while (target !== null) {\n      // Set up the match array for this DOM level.\n      let matches: IItem[] = [];\n\n      // Search the remaining items for matches.\n      for (let i = 0, n = availableItems.length; i < n; ++i) {\n        // Fetch the item.\n        let item = availableItems[i];\n\n        // Skip items which are already consumed.\n        if (!item) {\n          continue;\n        }\n\n        // Skip items which do not match the element.\n        if (!Selector.matches(target, item.selector)) {\n          continue;\n        }\n\n        // Add the matched item to the result for this DOM level.\n        matches.push(item);\n\n        // Mark the item as consumed.\n        availableItems[i] = null;\n      }\n\n      // Sort the matches for this level and add them to the results.\n      if (matches.length !== 0) {\n        if (groupByTarget) {\n          matches.sort(sortBySelector ? itemCmp : itemCmpRank);\n        }\n        result.push(...matches);\n      }\n\n      // Stop searching at the limits of the DOM range.\n      if (target === currentTarget) {\n        break;\n      }\n\n      // Step to the parent DOM level.\n      target = target.parentElement;\n    }\n\n    if (!groupByTarget) {\n      result.sort(sortBySelector ? itemCmp : itemCmpRank);\n    }\n\n    // Return the matched and sorted results.\n    return result;\n  }\n\n  /**\n   * Validate the selector for a menu item.\n   *\n   * This returns the validated selector, or throws if the selector is\n   * invalid or contains commas.\n   */\n  function validateSelector(selector: string): string {\n    if (selector.indexOf(',') !== -1) {\n      throw new Error(`Selector cannot contain commas: ${selector}`);\n    }\n    if (!Selector.isValid(selector)) {\n      throw new Error(`Invalid selector: ${selector}`);\n    }\n    return selector;\n  }\n\n  /**\n   * A sort comparison function for a context menu item by ranks.\n   */\n  function itemCmpRank(a: IItem, b: IItem): number {\n    // Sort based on rank.\n    let r1 = a.rank;\n    let r2 = b.rank;\n    if (r1 !== r2) {\n      return r1 < r2 ? -1 : 1; // Infinity-safe\n    }\n\n    // When all else fails, sort by item id.\n    return a.id - b.id;\n  }\n\n  /**\n   * A sort comparison function for a context menu item by selectors and ranks.\n   */\n  function itemCmp(a: IItem, b: IItem): number {\n    // Sort first based on selector specificity.\n    let s1 = Selector.calculateSpecificity(a.selector);\n    let s2 = Selector.calculateSpecificity(b.selector);\n    if (s1 !== s2) {\n      return s2 - s1;\n    }\n\n    // If specificities are equal\n    return itemCmpRank(a, b);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport {\n  ElementARIAAttrs,\n  ElementBaseAttrs,\n  ElementDataset,\n  ElementInlineStyle,\n  h,\n  VirtualDOM,\n  VirtualElement\n} from '@lumino/virtualdom';\n\nimport { Title } from './title';\n\nimport { Widget } from './widget';\n\nconst ARROW_KEYS = [\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End'\n];\n\n/**\n * A widget which displays titles as a single row or column of tabs.\n *\n * #### Notes\n * If CSS transforms are used to rotate nodes for vertically oriented\n * text, then tab dragging will not work correctly. The `tabsMovable`\n * property should be set to `false` when rotating nodes from CSS.\n */\nexport class TabBar<T> extends Widget {\n  /**\n   * Construct a new tab bar.\n   *\n   * @param options - The options for initializing the tab bar.\n   */\n  constructor(options: TabBar.IOptions<T> = {}) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-TabBar');\n    this.contentNode.setAttribute('role', 'tablist');\n    this.setFlag(Widget.Flag.DisallowLayout);\n    this._document = options.document || document;\n    this.tabsMovable = options.tabsMovable || false;\n    this.titlesEditable = options.titlesEditable || false;\n    this.allowDeselect = options.allowDeselect || false;\n    this.addButtonEnabled = options.addButtonEnabled || false;\n    this.insertBehavior = options.insertBehavior || 'select-tab-if-needed';\n    this.name = options.name || '';\n    this.orientation = options.orientation || 'horizontal';\n    this.removeBehavior = options.removeBehavior || 'select-tab-after';\n    this.renderer = options.renderer || TabBar.defaultRenderer;\n  }\n\n  /**\n   * Dispose of the resources held by the widget.\n   */\n  dispose(): void {\n    this._releaseMouse();\n    this._titles.length = 0;\n    this._previousTitle = null;\n    super.dispose();\n  }\n\n  /**\n   * A signal emitted when the current tab is changed.\n   *\n   * #### Notes\n   * This signal is emitted when the currently selected tab is changed\n   * either through user or programmatic interaction.\n   *\n   * Notably, this signal is not emitted when the index of the current\n   * tab changes due to tabs being inserted, removed, or moved. It is\n   * only emitted when the actual current tab node is changed.\n   */\n  get currentChanged(): ISignal<this, TabBar.ICurrentChangedArgs<T>> {\n    return this._currentChanged;\n  }\n\n  /**\n   * A signal emitted when a tab is moved by the user.\n   *\n   * #### Notes\n   * This signal is emitted when a tab is moved by user interaction.\n   *\n   * This signal is not emitted when a tab is moved programmatically.\n   */\n  get tabMoved(): ISignal<this, TabBar.ITabMovedArgs<T>> {\n    return this._tabMoved;\n  }\n\n  /**\n   * A signal emitted when a tab is clicked by the user.\n   *\n   * #### Notes\n   * If the clicked tab is not the current tab, the clicked tab will be\n   * made current and the `currentChanged` signal will be emitted first.\n   *\n   * This signal is emitted even if the clicked tab is the current tab.\n   */\n  get tabActivateRequested(): ISignal<\n    this,\n    TabBar.ITabActivateRequestedArgs<T>\n  > {\n    return this._tabActivateRequested;\n  }\n\n  /**\n   * A signal emitted when the tab bar add button is clicked.\n   */\n  get addRequested(): ISignal<this, void> {\n    return this._addRequested;\n  }\n\n  /**\n   * A signal emitted when a tab close icon is clicked.\n   *\n   * #### Notes\n   * This signal is not emitted unless the tab title is `closable`.\n   */\n  get tabCloseRequested(): ISignal<this, TabBar.ITabCloseRequestedArgs<T>> {\n    return this._tabCloseRequested;\n  }\n\n  /**\n   * A signal emitted when a tab is dragged beyond the detach threshold.\n   *\n   * #### Notes\n   * This signal is emitted when the user drags a tab with the mouse,\n   * and mouse is dragged beyond the detach threshold.\n   *\n   * The consumer of the signal should call `releaseMouse` and remove\n   * the tab in order to complete the detach.\n   *\n   * This signal is only emitted once per drag cycle.\n   */\n  get tabDetachRequested(): ISignal<this, TabBar.ITabDetachRequestedArgs<T>> {\n    return this._tabDetachRequested;\n  }\n\n  /**\n   * The renderer used by the tab bar.\n   */\n  readonly renderer: TabBar.IRenderer<T>;\n\n  /**\n   * The document to use with the tab bar.\n   *\n   * The default is the global `document` instance.\n   */\n  get document(): Document | ShadowRoot {\n    return this._document;\n  }\n\n  /**\n   * Whether the tabs are movable by the user.\n   *\n   * #### Notes\n   * Tabs can always be moved programmatically.\n   */\n  tabsMovable: boolean;\n\n  /**\n   * Whether the titles can be user-edited.\n   *\n   */\n  get titlesEditable(): boolean {\n    return this._titlesEditable;\n  }\n\n  /**\n   * Set whether titles can be user edited.\n   *\n   */\n  set titlesEditable(value: boolean) {\n    this._titlesEditable = value;\n  }\n\n  /**\n   * Whether a tab can be deselected by the user.\n   *\n   * #### Notes\n   * Tabs can be always be deselected programmatically.\n   */\n  allowDeselect: boolean;\n\n  /**\n   * The selection behavior when inserting a tab.\n   */\n  insertBehavior: TabBar.InsertBehavior;\n\n  /**\n   * The selection behavior when removing a tab.\n   */\n  removeBehavior: TabBar.RemoveBehavior;\n\n  /**\n   * Get the currently selected title.\n   *\n   * #### Notes\n   * This will be `null` if no tab is selected.\n   */\n  get currentTitle(): Title<T> | null {\n    return this._titles[this._currentIndex] || null;\n  }\n\n  /**\n   * Set the currently selected title.\n   *\n   * #### Notes\n   * If the title does not exist, the title will be set to `null`.\n   */\n  set currentTitle(value: Title<T> | null) {\n    this.currentIndex = value ? this._titles.indexOf(value) : -1;\n  }\n\n  /**\n   * Get the index of the currently selected tab.\n   *\n   * #### Notes\n   * This will be `-1` if no tab is selected.\n   */\n  get currentIndex(): number {\n    return this._currentIndex;\n  }\n\n  /**\n   * Set the index of the currently selected tab.\n   *\n   * #### Notes\n   * If the value is out of range, the index will be set to `-1`.\n   */\n  set currentIndex(value: number) {\n    // Adjust for an out of range index.\n    if (value < 0 || value >= this._titles.length) {\n      value = -1;\n    }\n\n    // Bail early if the index will not change.\n    if (this._currentIndex === value) {\n      return;\n    }\n\n    // Look up the previous index and title.\n    let pi = this._currentIndex;\n    let pt = this._titles[pi] || null;\n\n    // Look up the current index and title.\n    let ci = value;\n    let ct = this._titles[ci] || null;\n\n    // Update the current index and previous title.\n    this._currentIndex = ci;\n    this._previousTitle = pt;\n\n    // Schedule an update of the tabs.\n    this.update();\n\n    // Emit the current changed signal.\n    this._currentChanged.emit({\n      previousIndex: pi,\n      previousTitle: pt,\n      currentIndex: ci,\n      currentTitle: ct\n    });\n  }\n\n  /**\n   * Get the name of the tab bar.\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Set the name of the tab bar.\n   */\n  set name(value: string) {\n    this._name = value;\n    if (value) {\n      this.contentNode.setAttribute('aria-label', value);\n    } else {\n      this.contentNode.removeAttribute('aria-label');\n    }\n  }\n\n  /**\n   * Get the orientation of the tab bar.\n   *\n   * #### Notes\n   * This controls whether the tabs are arranged in a row or column.\n   */\n  get orientation(): TabBar.Orientation {\n    return this._orientation;\n  }\n\n  /**\n   * Set the orientation of the tab bar.\n   *\n   * #### Notes\n   * This controls whether the tabs are arranged in a row or column.\n   */\n  set orientation(value: TabBar.Orientation) {\n    // Do nothing if the orientation does not change.\n    if (this._orientation === value) {\n      return;\n    }\n\n    // Release the mouse before making any changes.\n    this._releaseMouse();\n\n    // Toggle the orientation values.\n    this._orientation = value;\n    this.dataset['orientation'] = value;\n    this.contentNode.setAttribute('aria-orientation', value);\n  }\n\n  /**\n   * Whether the add button is enabled.\n   */\n  get addButtonEnabled(): boolean {\n    return this._addButtonEnabled;\n  }\n\n  /**\n   * Set whether the add button is enabled.\n   */\n  set addButtonEnabled(value: boolean) {\n    // Do nothing if the value does not change.\n    if (this._addButtonEnabled === value) {\n      return;\n    }\n\n    this._addButtonEnabled = value;\n    if (value) {\n      this.addButtonNode.classList.remove('lm-mod-hidden');\n    } else {\n      this.addButtonNode.classList.add('lm-mod-hidden');\n    }\n  }\n\n  /**\n   * A read-only array of the titles in the tab bar.\n   */\n  get titles(): ReadonlyArray<Title<T>> {\n    return this._titles;\n  }\n\n  /**\n   * The tab bar content node.\n   *\n   * #### Notes\n   * This is the node which holds the tab nodes.\n   *\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get contentNode(): HTMLUListElement {\n    return this.node.getElementsByClassName(\n      'lm-TabBar-content'\n    )[0] as HTMLUListElement;\n  }\n\n  /**\n   * The tab bar add button node.\n   *\n   * #### Notes\n   * This is the node which holds the add button.\n   *\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get addButtonNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-TabBar-addButton'\n    )[0] as HTMLDivElement;\n  }\n\n  /**\n   * Add a tab to the end of the tab bar.\n   *\n   * @param value - The title which holds the data for the tab,\n   *   or an options object to convert to a title.\n   *\n   * @returns The title object added to the tab bar.\n   *\n   * #### Notes\n   * If the title is already added to the tab bar, it will be moved.\n   */\n  addTab(value: Title<T> | Title.IOptions<T>): Title<T> {\n    return this.insertTab(this._titles.length, value);\n  }\n\n  /**\n   * Insert a tab into the tab bar at the specified index.\n   *\n   * @param index - The index at which to insert the tab.\n   *\n   * @param value - The title which holds the data for the tab,\n   *   or an options object to convert to a title.\n   *\n   * @returns The title object added to the tab bar.\n   *\n   * #### Notes\n   * The index will be clamped to the bounds of the tabs.\n   *\n   * If the title is already added to the tab bar, it will be moved.\n   */\n  insertTab(index: number, value: Title<T> | Title.IOptions<T>): Title<T> {\n    // Release the mouse before making any changes.\n    this._releaseMouse();\n\n    // Coerce the value to a title.\n    let title = Private.asTitle(value);\n\n    // Look up the index of the title.\n    let i = this._titles.indexOf(title);\n\n    // Clamp the insert index to the array bounds.\n    let j = Math.max(0, Math.min(index, this._titles.length));\n\n    // If the title is not in the array, insert it.\n    if (i === -1) {\n      // Insert the title into the array.\n      ArrayExt.insert(this._titles, j, title);\n\n      // Connect to the title changed signal.\n      title.changed.connect(this._onTitleChanged, this);\n\n      // Schedule an update of the tabs.\n      this.update();\n\n      // Adjust the current index for the insert.\n      this._adjustCurrentForInsert(j, title);\n\n      // Return the title added to the tab bar.\n      return title;\n    }\n\n    // Otherwise, the title exists in the array and should be moved.\n\n    // Adjust the index if the location is at the end of the array.\n    if (j === this._titles.length) {\n      j--;\n    }\n\n    // Bail if there is no effective move.\n    if (i === j) {\n      return title;\n    }\n\n    // Move the title to the new location.\n    ArrayExt.move(this._titles, i, j);\n\n    // Schedule an update of the tabs.\n    this.update();\n\n    // Adjust the current index for the move.\n    this._adjustCurrentForMove(i, j);\n\n    // Return the title added to the tab bar.\n    return title;\n  }\n\n  /**\n   * Remove a tab from the tab bar.\n   *\n   * @param title - The title for the tab to remove.\n   *\n   * #### Notes\n   * This is a no-op if the title is not in the tab bar.\n   */\n  removeTab(title: Title<T>): void {\n    this.removeTabAt(this._titles.indexOf(title));\n  }\n\n  /**\n   * Remove the tab at a given index from the tab bar.\n   *\n   * @param index - The index of the tab to remove.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  removeTabAt(index: number): void {\n    // Release the mouse before making any changes.\n    this._releaseMouse();\n\n    // Remove the title from the array.\n    let title = ArrayExt.removeAt(this._titles, index);\n\n    // Bail if the index is out of range.\n    if (!title) {\n      return;\n    }\n\n    // Disconnect from the title changed signal.\n    title.changed.disconnect(this._onTitleChanged, this);\n\n    // Clear the previous title if it's being removed.\n    if (title === this._previousTitle) {\n      this._previousTitle = null;\n    }\n\n    // Schedule an update of the tabs.\n    this.update();\n\n    // Adjust the current index for the remove.\n    this._adjustCurrentForRemove(index, title);\n  }\n\n  /**\n   * Remove all tabs from the tab bar.\n   */\n  clearTabs(): void {\n    // Bail if there is nothing to remove.\n    if (this._titles.length === 0) {\n      return;\n    }\n\n    // Release the mouse before making any changes.\n    this._releaseMouse();\n\n    // Disconnect from the title changed signals.\n    for (let title of this._titles) {\n      title.changed.disconnect(this._onTitleChanged, this);\n    }\n\n    // Get the current index and title.\n    let pi = this.currentIndex;\n    let pt = this.currentTitle;\n\n    // Reset the current index and previous title.\n    this._currentIndex = -1;\n    this._previousTitle = null;\n\n    // Clear the title array.\n    this._titles.length = 0;\n\n    // Schedule an update of the tabs.\n    this.update();\n\n    // If no tab was selected, there's nothing else to do.\n    if (pi === -1) {\n      return;\n    }\n\n    // Emit the current changed signal.\n    this._currentChanged.emit({\n      previousIndex: pi,\n      previousTitle: pt,\n      currentIndex: -1,\n      currentTitle: null\n    });\n  }\n\n  /**\n   * Release the mouse and restore the non-dragged tab positions.\n   *\n   * #### Notes\n   * This will cause the tab bar to stop handling mouse events and to\n   * restore the tabs to their non-dragged positions.\n   */\n  releaseMouse(): void {\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the DOM events for the tab bar.\n   *\n   * @param event - The DOM event sent to the tab bar.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the tab bar's DOM node.\n   *\n   * This should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'pointerdown':\n        this._evtPointerDown(event as PointerEvent);\n        break;\n      case 'pointermove':\n        this._evtPointerMove(event as PointerEvent);\n        break;\n      case 'pointerup':\n        this._evtPointerUp(event as PointerEvent);\n        break;\n      case 'dblclick':\n        this._evtDblClick(event as MouseEvent);\n        break;\n      case 'keydown':\n        event.eventPhase === Event.CAPTURING_PHASE\n          ? this._evtKeyDownCapturing(event as KeyboardEvent)\n          : this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('pointerdown', this);\n    this.node.addEventListener('dblclick', this);\n    this.node.addEventListener('keydown', this);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('pointerdown', this);\n    this.node.removeEventListener('dblclick', this);\n    this.node.removeEventListener('keydown', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    let titles = this._titles;\n    let renderer = this.renderer;\n    let currentTitle = this.currentTitle;\n    let content = new Array<VirtualElement>(titles.length);\n    // Keep the tabindex=\"0\" attribute to the tab which handled it before the update.\n    // If the add button handles it, no need to do anything. If no element of the tab\n    // bar handles it, set it on the current or the first tab to ensure one element\n    // handles it after update.\n    const tabHandlingTabindex =\n      this._getCurrentTabindex() ??\n      (this._currentIndex > -1 ? this._currentIndex : 0);\n\n    for (let i = 0, n = titles.length; i < n; ++i) {\n      let title = titles[i];\n      let current = title === currentTitle;\n      let zIndex = current ? n : n - i - 1;\n      let tabIndex = tabHandlingTabindex === i ? 0 : -1;\n      content[i] = renderer.renderTab({ title, current, zIndex, tabIndex });\n    }\n    VirtualDOM.render(content, this.contentNode);\n  }\n\n  /**\n   * Get the index of the tab which handles tabindex=\"0\".\n   * If the add button handles tabindex=\"0\", -1 is returned.\n   * If none of the previous handles tabindex=\"0\", null is returned.\n   */\n  private _getCurrentTabindex(): number | null {\n    let index = null;\n    const elemTabindex = this.contentNode.querySelector('li[tabindex=\"0\"]');\n    if (elemTabindex) {\n      index = [...this.contentNode.children].indexOf(elemTabindex);\n    } else if (\n      this._addButtonEnabled &&\n      this.addButtonNode.getAttribute('tabindex') === '0'\n    ) {\n      index = -1;\n    }\n    return index;\n  }\n\n  /**\n   * Handle the `'dblclick'` event for the tab bar.\n   */\n  private _evtDblClick(event: MouseEvent): void {\n    // Do nothing if titles are not editable\n    if (!this.titlesEditable) {\n      return;\n    }\n\n    let tabs = this.contentNode.children;\n\n    // Find the index of the targeted tab.\n    let index = ArrayExt.findFirstIndex(tabs, tab => {\n      return ElementExt.hitTest(tab, event.clientX, event.clientY);\n    });\n\n    // Do nothing if the press is not on a tab.\n    if (index === -1) {\n      return;\n    }\n\n    let title = this.titles[index];\n    let label = tabs[index].querySelector('.lm-TabBar-tabLabel') as HTMLElement;\n    if (label && label.contains(event.target as HTMLElement)) {\n      let value = title.label || '';\n\n      // Clear the label element\n      let oldValue = label.innerHTML;\n      label.innerHTML = '';\n\n      let input = document.createElement('input');\n      input.classList.add('lm-TabBar-tabInput');\n      input.value = value;\n      label.appendChild(input);\n\n      let onblur = () => {\n        input.removeEventListener('blur', onblur);\n        label.innerHTML = oldValue;\n        this.node.addEventListener('keydown', this);\n      };\n\n      input.addEventListener('dblclick', (event: Event) =>\n        event.stopPropagation()\n      );\n      input.addEventListener('blur', onblur);\n      input.addEventListener('keydown', (event: KeyboardEvent) => {\n        if (event.key === 'Enter') {\n          if (input.value !== '') {\n            title.label = title.caption = input.value;\n          }\n          onblur();\n        } else if (event.key === 'Escape') {\n          onblur();\n        }\n      });\n      this.node.removeEventListener('keydown', this);\n      input.select();\n      input.focus();\n\n      if (label.children.length > 0) {\n        (label.children[0] as HTMLElement).focus();\n      }\n    }\n  }\n\n  /**\n   * Handle the `'keydown'` event for the tab bar at capturing phase.\n   */\n  private _evtKeyDownCapturing(event: KeyboardEvent): void {\n    if (event.eventPhase !== Event.CAPTURING_PHASE) {\n      return;\n    }\n\n    // Stop all input events during drag.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Release the mouse if `Escape` is pressed.\n    if (event.key === 'Escape') {\n      this._releaseMouse();\n    }\n  }\n\n  /**\n   * Handle the `'keydown'` event for the tab bar at target phase.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Allow for navigation using tab key\n    if (event.key === 'Tab' || event.eventPhase === Event.CAPTURING_PHASE) {\n      return;\n    }\n\n    // Check if Enter or Spacebar key has been pressed and open that tab\n    if (\n      event.key === 'Enter' ||\n      event.key === 'Spacebar' ||\n      event.key === ' '\n    ) {\n      // Get focus element that is in focus by the tab key\n      const focusedElement = document.activeElement;\n\n      // Test first if the focus is on the add button node\n      if (\n        this.addButtonEnabled &&\n        this.addButtonNode.contains(focusedElement)\n      ) {\n        event.preventDefault();\n        event.stopPropagation();\n        this._addRequested.emit();\n      } else {\n        const index = ArrayExt.findFirstIndex(this.contentNode.children, tab =>\n          tab.contains(focusedElement)\n        );\n        if (index >= 0) {\n          event.preventDefault();\n          event.stopPropagation();\n          this.currentIndex = index;\n        }\n      }\n      // Handle the arrow keys to switch tabs.\n    } else if (ARROW_KEYS.includes(event.key)) {\n      // Create a list of all focusable elements in the tab bar.\n      const focusable: Element[] = [...this.contentNode.children];\n      if (this.addButtonEnabled) {\n        focusable.push(this.addButtonNode);\n      }\n      // If the tab bar contains only one element, nothing to do.\n      if (focusable.length <= 1) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Get the current focused element.\n      let focusedIndex = focusable.indexOf(document.activeElement as Element);\n      if (focusedIndex === -1) {\n        focusedIndex = this._currentIndex;\n      }\n\n      // Find the next element to focus on.\n      let nextFocused: Element | null | undefined;\n      if (\n        (event.key === 'ArrowRight' && this._orientation === 'horizontal') ||\n        (event.key === 'ArrowDown' && this._orientation === 'vertical')\n      ) {\n        nextFocused = focusable[focusedIndex + 1] ?? focusable[0];\n      } else if (\n        (event.key === 'ArrowLeft' && this._orientation === 'horizontal') ||\n        (event.key === 'ArrowUp' && this._orientation === 'vertical')\n      ) {\n        nextFocused =\n          focusable[focusedIndex - 1] ?? focusable[focusable.length - 1];\n      } else if (event.key === 'Home') {\n        nextFocused = focusable[0];\n      } else if (event.key === 'End') {\n        nextFocused = focusable[focusable.length - 1];\n      }\n\n      // Change the focused element and the tabindex value.\n      if (nextFocused) {\n        focusable[focusedIndex]?.setAttribute('tabindex', '-1');\n        nextFocused?.setAttribute('tabindex', '0');\n        (nextFocused as HTMLElement).focus();\n      }\n    }\n  }\n\n  /**\n   * Handle the `'pointerdown'` event for the tab bar.\n   */\n  private _evtPointerDown(event: PointerEvent | MouseEvent): void {\n    // Do nothing if it's not a left or middle mouse press.\n    if (event.button !== 0 && event.button !== 1) {\n      return;\n    }\n\n    // Do nothing if a drag is in progress.\n    if (this._dragData) {\n      return;\n    }\n\n    // Do nothing if a title editable input was clicked.\n    if (\n      (event.target as HTMLElement).classList.contains('lm-TabBar-tabInput')\n    ) {\n      return;\n    }\n\n    // Check if the add button was clicked.\n    let addButtonClicked =\n      this.addButtonEnabled &&\n      this.addButtonNode.contains(event.target as HTMLElement);\n\n    // Lookup the tab nodes.\n    let tabs = this.contentNode.children;\n\n    // Find the index of the pressed tab.\n    let index = ArrayExt.findFirstIndex(tabs, tab => {\n      return ElementExt.hitTest(tab, event.clientX, event.clientY);\n    });\n\n    // Do nothing if the press is not on a tab or the add button.\n    if (index === -1 && !addButtonClicked) {\n      return;\n    }\n\n    // Pressing on a tab stops the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Initialize the non-measured parts of the drag data.\n    this._dragData = {\n      tab: tabs[index] as HTMLElement,\n      index: index,\n      pressX: event.clientX,\n      pressY: event.clientY,\n      tabPos: -1,\n      tabSize: -1,\n      tabPressPos: -1,\n      targetIndex: -1,\n      tabLayout: null,\n      contentRect: null,\n      override: null,\n      dragActive: false,\n      dragAborted: false,\n      detachRequested: false\n    };\n\n    // Add the document pointer up listener.\n    this.document.addEventListener('pointerup', this, true);\n\n    // Do nothing else if the middle button or add button is clicked.\n    if (event.button === 1 || addButtonClicked) {\n      return;\n    }\n\n    // Do nothing else if the close icon is clicked.\n    let icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n    if (icon && icon.contains(event.target as HTMLElement)) {\n      return;\n    }\n\n    // Add the extra listeners if the tabs are movable.\n    if (this.tabsMovable) {\n      this.document.addEventListener('pointermove', this, true);\n      this.document.addEventListener('keydown', this, true);\n      this.document.addEventListener('contextmenu', this, true);\n    }\n\n    // Update the current index as appropriate.\n    if (this.allowDeselect && this.currentIndex === index) {\n      this.currentIndex = -1;\n    } else {\n      this.currentIndex = index;\n    }\n\n    // Do nothing else if there is no current tab.\n    if (this.currentIndex === -1) {\n      return;\n    }\n\n    // Emit the tab activate request signal.\n    this._tabActivateRequested.emit({\n      index: this.currentIndex,\n      title: this.currentTitle!\n    });\n  }\n\n  /**\n   * Handle the `'pointermove'` event for the tab bar.\n   */\n  private _evtPointerMove(event: PointerEvent | MouseEvent): void {\n    // Do nothing if no drag is in progress.\n    let data = this._dragData;\n    if (!data) {\n      return;\n    }\n\n    // Suppress the event during a drag.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Lookup the tab nodes.\n    let tabs = this.contentNode.children;\n\n    // Bail early if the drag threshold has not been met.\n    if (!data.dragActive && !Private.dragExceeded(data, event)) {\n      return;\n    }\n\n    // Activate the drag if necessary.\n    if (!data.dragActive) {\n      // Fill in the rest of the drag data measurements.\n      let tabRect = data.tab.getBoundingClientRect();\n      if (this._orientation === 'horizontal') {\n        data.tabPos = data.tab.offsetLeft;\n        data.tabSize = tabRect.width;\n        data.tabPressPos = data.pressX - tabRect.left;\n      } else {\n        data.tabPos = data.tab.offsetTop;\n        data.tabSize = tabRect.height;\n        data.tabPressPos = data.pressY - tabRect.top;\n      }\n      data.tabPressOffset = {\n        x: data.pressX - tabRect.left,\n        y: data.pressY - tabRect.top\n      };\n      data.tabLayout = Private.snapTabLayout(tabs, this._orientation);\n      data.contentRect = this.contentNode.getBoundingClientRect();\n      data.override = Drag.overrideCursor('default');\n\n      // Add the dragging style classes.\n      data.tab.classList.add('lm-mod-dragging');\n      this.addClass('lm-mod-dragging');\n\n      // Mark the drag as active.\n      data.dragActive = true;\n    }\n\n    // Emit the detach requested signal if the threshold is exceeded.\n    if (!data.detachRequested && Private.detachExceeded(data, event)) {\n      // Only emit the signal once per drag cycle.\n      data.detachRequested = true;\n\n      // Setup the arguments for the signal.\n      let index = data.index;\n      let clientX = event.clientX;\n      let clientY = event.clientY;\n      let tab = tabs[index] as HTMLElement;\n      let title = this._titles[index];\n\n      // Emit the tab detach requested signal.\n      this._tabDetachRequested.emit({\n        index,\n        title,\n        tab,\n        clientX,\n        clientY,\n        offset: data.tabPressOffset\n      });\n\n      // Bail if the signal handler aborted the drag.\n      if (data.dragAborted) {\n        return;\n      }\n    }\n\n    // Update the positions of the tabs.\n    Private.layoutTabs(tabs, data, event, this._orientation);\n  }\n\n  /**\n   * Handle the `'pointerup'` event for the document.\n   */\n  private _evtPointerUp(event: PointerEvent | MouseEvent): void {\n    // Do nothing if it's not a left or middle mouse release.\n    if (event.button !== 0 && event.button !== 1) {\n      return;\n    }\n\n    // Do nothing if no drag is in progress.\n    const data = this._dragData;\n    if (!data) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Remove the extra mouse event listeners.\n    this.document.removeEventListener('pointermove', this, true);\n    this.document.removeEventListener('pointerup', this, true);\n    this.document.removeEventListener('keydown', this, true);\n    this.document.removeEventListener('contextmenu', this, true);\n\n    // Handle a release when the drag is not active.\n    if (!data.dragActive) {\n      // Clear the drag data.\n      this._dragData = null;\n\n      // Handle clicking the add button.\n      let addButtonClicked =\n        this.addButtonEnabled &&\n        this.addButtonNode.contains(event.target as HTMLElement);\n      if (addButtonClicked) {\n        this._addRequested.emit(undefined);\n        return;\n      }\n\n      // Lookup the tab nodes.\n      let tabs = this.contentNode.children;\n\n      // Find the index of the released tab.\n      let index = ArrayExt.findFirstIndex(tabs, tab => {\n        return ElementExt.hitTest(tab, event.clientX, event.clientY);\n      });\n\n      // Do nothing if the release is not on the original pressed tab.\n      if (index !== data.index) {\n        return;\n      }\n\n      // Ignore the release if the title is not closable.\n      let title = this._titles[index];\n      if (!title.closable) {\n        return;\n      }\n\n      // Emit the close requested signal if the middle button is released.\n      if (event.button === 1) {\n        this._tabCloseRequested.emit({ index, title });\n        return;\n      }\n\n      // Emit the close requested signal if the close icon was released.\n      let icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n      if (icon && icon.contains(event.target as HTMLElement)) {\n        this._tabCloseRequested.emit({ index, title });\n        return;\n      }\n\n      // Otherwise, there is nothing left to do.\n      return;\n    }\n\n    // Do nothing if the left button is not released.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Position the tab at its final resting position.\n    Private.finalizeTabPosition(data, this._orientation);\n\n    // Remove the dragging class from the tab so it can be transitioned.\n    data.tab.classList.remove('lm-mod-dragging');\n\n    // Parse the transition duration for releasing the tab.\n    let duration = Private.parseTransitionDuration(data.tab);\n\n    // Complete the release on a timer to allow the tab to transition.\n    setTimeout(() => {\n      // Do nothing if the drag has been aborted.\n      if (data.dragAborted) {\n        return;\n      }\n\n      // Clear the drag data reference.\n      this._dragData = null;\n\n      // Reset the positions of the tabs.\n      Private.resetTabPositions(this.contentNode.children, this._orientation);\n\n      // Clear the cursor grab.\n      data.override!.dispose();\n\n      // Remove the remaining dragging style.\n      this.removeClass('lm-mod-dragging');\n\n      // If the tab was not moved, there is nothing else to do.\n      let i = data.index;\n      let j = data.targetIndex;\n      if (j === -1 || i === j) {\n        return;\n      }\n\n      // Move the title to the new locations.\n      ArrayExt.move(this._titles, i, j);\n\n      // Adjust the current index for the move.\n      this._adjustCurrentForMove(i, j);\n\n      // Emit the tab moved signal.\n      this._tabMoved.emit({\n        fromIndex: i,\n        toIndex: j,\n        title: this._titles[j]\n      });\n\n      // Update the tabs immediately to prevent flicker.\n      MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n    }, duration);\n  }\n\n  /**\n   * Release the mouse and restore the non-dragged tab positions.\n   */\n  private _releaseMouse(): void {\n    // Do nothing if no drag is in progress.\n    let data = this._dragData;\n    if (!data) {\n      return;\n    }\n\n    // Clear the drag data reference.\n    this._dragData = null;\n\n    // Remove the extra document event listeners.\n    this.document.removeEventListener('pointermove', this, true);\n    this.document.removeEventListener('pointerup', this, true);\n    this.document.removeEventListener('keydown', this, true);\n    this.document.removeEventListener('contextmenu', this, true);\n\n    // Indicate the drag has been aborted. This allows the mouse\n    // event handlers to return early when the drag is canceled.\n    data.dragAborted = true;\n\n    // If the drag is not active, there's nothing more to do.\n    if (!data.dragActive) {\n      return;\n    }\n\n    // Reset the tabs to their non-dragged positions.\n    Private.resetTabPositions(this.contentNode.children, this._orientation);\n\n    // Clear the cursor override.\n    data.override!.dispose();\n\n    // Clear the dragging style classes.\n    data.tab.classList.remove('lm-mod-dragging');\n    this.removeClass('lm-mod-dragging');\n  }\n\n  /**\n   * Adjust the current index for a tab insert operation.\n   *\n   * This method accounts for the tab bar's insertion behavior when\n   * adjusting the current index and emitting the changed signal.\n   */\n  private _adjustCurrentForInsert(i: number, title: Title<T>): void {\n    // Lookup commonly used variables.\n    let ct = this.currentTitle;\n    let ci = this._currentIndex;\n    let bh = this.insertBehavior;\n\n    // TODO: do we need to do an update to update the aria-selected attribute?\n\n    // Handle the behavior where the new tab is always selected,\n    // or the behavior where the new tab is selected if needed.\n    if (bh === 'select-tab' || (bh === 'select-tab-if-needed' && ci === -1)) {\n      this._currentIndex = i;\n      this._previousTitle = ct;\n      this._currentChanged.emit({\n        previousIndex: ci,\n        previousTitle: ct,\n        currentIndex: i,\n        currentTitle: title\n      });\n      return;\n    }\n\n    // Otherwise, silently adjust the current index if needed.\n    if (ci >= i) {\n      this._currentIndex++;\n    }\n  }\n\n  /**\n   * Adjust the current index for a tab move operation.\n   *\n   * This method will not cause the actual current tab to change.\n   * It silently adjusts the index to account for the given move.\n   */\n  private _adjustCurrentForMove(i: number, j: number): void {\n    if (this._currentIndex === i) {\n      this._currentIndex = j;\n    } else if (this._currentIndex < i && this._currentIndex >= j) {\n      this._currentIndex++;\n    } else if (this._currentIndex > i && this._currentIndex <= j) {\n      this._currentIndex--;\n    }\n  }\n\n  /**\n   * Adjust the current index for a tab remove operation.\n   *\n   * This method accounts for the tab bar's remove behavior when\n   * adjusting the current index and emitting the changed signal.\n   */\n  private _adjustCurrentForRemove(i: number, title: Title<T>): void {\n    // Lookup commonly used variables.\n    let ci = this._currentIndex;\n    let bh = this.removeBehavior;\n\n    // Silently adjust the index if the current tab is not removed.\n    if (ci !== i) {\n      if (ci > i) {\n        this._currentIndex--;\n      }\n      return;\n    }\n\n    // TODO: do we need to do an update to adjust the aria-selected value?\n\n    // No tab gets selected if the tab bar is empty.\n    if (this._titles.length === 0) {\n      this._currentIndex = -1;\n      this._currentChanged.emit({\n        previousIndex: i,\n        previousTitle: title,\n        currentIndex: -1,\n        currentTitle: null\n      });\n      return;\n    }\n\n    // Handle behavior where the next sibling tab is selected.\n    if (bh === 'select-tab-after') {\n      this._currentIndex = Math.min(i, this._titles.length - 1);\n      this._currentChanged.emit({\n        previousIndex: i,\n        previousTitle: title,\n        currentIndex: this._currentIndex,\n        currentTitle: this.currentTitle\n      });\n      return;\n    }\n\n    // Handle behavior where the previous sibling tab is selected.\n    if (bh === 'select-tab-before') {\n      this._currentIndex = Math.max(0, i - 1);\n      this._currentChanged.emit({\n        previousIndex: i,\n        previousTitle: title,\n        currentIndex: this._currentIndex,\n        currentTitle: this.currentTitle\n      });\n      return;\n    }\n\n    // Handle behavior where the previous history tab is selected.\n    if (bh === 'select-previous-tab') {\n      if (this._previousTitle) {\n        this._currentIndex = this._titles.indexOf(this._previousTitle);\n        this._previousTitle = null;\n      } else {\n        this._currentIndex = Math.min(i, this._titles.length - 1);\n      }\n      this._currentChanged.emit({\n        previousIndex: i,\n        previousTitle: title,\n        currentIndex: this._currentIndex,\n        currentTitle: this.currentTitle\n      });\n      return;\n    }\n\n    // Otherwise, no tab gets selected.\n    this._currentIndex = -1;\n    this._currentChanged.emit({\n      previousIndex: i,\n      previousTitle: title,\n      currentIndex: -1,\n      currentTitle: null\n    });\n  }\n\n  /**\n   * Handle the `changed` signal of a title object.\n   */\n  private _onTitleChanged(sender: Title<T>): void {\n    this.update();\n  }\n\n  private _name: string;\n  private _currentIndex = -1;\n  private _titles: Title<T>[] = [];\n  private _orientation: TabBar.Orientation;\n  private _document: Document | ShadowRoot;\n  private _titlesEditable: boolean = false;\n  private _previousTitle: Title<T> | null = null;\n  private _dragData: Private.IDragData | null = null;\n  private _addButtonEnabled: boolean = false;\n  private _tabMoved = new Signal<this, TabBar.ITabMovedArgs<T>>(this);\n  private _currentChanged = new Signal<this, TabBar.ICurrentChangedArgs<T>>(\n    this\n  );\n  private _addRequested = new Signal<this, void>(this);\n  private _tabCloseRequested = new Signal<\n    this,\n    TabBar.ITabCloseRequestedArgs<T>\n  >(this);\n  private _tabDetachRequested = new Signal<\n    this,\n    TabBar.ITabDetachRequestedArgs<T>\n  >(this);\n  private _tabActivateRequested = new Signal<\n    this,\n    TabBar.ITabActivateRequestedArgs<T>\n  >(this);\n}\n\n/**\n * The namespace for the `TabBar` class statics.\n */\nexport namespace TabBar {\n  /**\n   * A type alias for a tab bar orientation.\n   */\n  export type Orientation =\n    | /**\n     * The tabs are arranged in a single row, left-to-right.\n     *\n     * The tab text orientation is horizontal.\n     */\n    'horizontal'\n\n    /**\n     * The tabs are arranged in a single column, top-to-bottom.\n     *\n     * The tab text orientation is horizontal.\n     */\n    | 'vertical';\n\n  /**\n   * A type alias for the selection behavior on tab insert.\n   */\n  export type InsertBehavior =\n    | /**\n     * The selected tab will not be changed.\n     */\n    'none'\n\n    /**\n     * The inserted tab will be selected.\n     */\n    | 'select-tab'\n\n    /**\n     * The inserted tab will be selected if the current tab is null.\n     */\n    | 'select-tab-if-needed';\n\n  /**\n   * A type alias for the selection behavior on tab remove.\n   */\n  export type RemoveBehavior =\n    | /**\n     * No tab will be selected.\n     */\n    'none'\n\n    /**\n     * The tab after the removed tab will be selected if possible.\n     */\n    | 'select-tab-after'\n\n    /**\n     * The tab before the removed tab will be selected if possible.\n     */\n    | 'select-tab-before'\n\n    /**\n     * The previously selected tab will be selected if possible.\n     */\n    | 'select-previous-tab';\n\n  /**\n   * An options object for creating a tab bar.\n   */\n  export interface IOptions<T> {\n    /**\n     * The document to use with the tab bar.\n     *\n     * The default is the global `document` instance.\n     */\n\n    document?: Document | ShadowRoot;\n\n    /**\n     * Name of the tab bar.\n     *\n     * This is used for accessibility reasons. The default is the empty string.\n     */\n    name?: string;\n\n    /**\n     * The layout orientation of the tab bar.\n     *\n     * The default is `horizontal`.\n     */\n    orientation?: TabBar.Orientation;\n\n    /**\n     * Whether the tabs are movable by the user.\n     *\n     * The default is `false`.\n     */\n    tabsMovable?: boolean;\n\n    /**\n     * Whether a tab can be deselected by the user.\n     *\n     * The default is `false`.\n     */\n    allowDeselect?: boolean;\n\n    /**\n     * Whether the titles can be directly edited by the user.\n     *\n     * The default is `false`.\n     */\n    titlesEditable?: boolean;\n\n    /**\n     * Whether the add button is enabled.\n     *\n     * The default is `false`.\n     */\n    addButtonEnabled?: boolean;\n\n    /**\n     * The selection behavior when inserting a tab.\n     *\n     * The default is `'select-tab-if-needed'`.\n     */\n    insertBehavior?: TabBar.InsertBehavior;\n\n    /**\n     * The selection behavior when removing a tab.\n     *\n     * The default is `'select-tab-after'`.\n     */\n    removeBehavior?: TabBar.RemoveBehavior;\n\n    /**\n     * A renderer to use with the tab bar.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer<T>;\n  }\n\n  /**\n   * The arguments object for the `currentChanged` signal.\n   */\n  export interface ICurrentChangedArgs<T> {\n    /**\n     * The previously selected index.\n     */\n    readonly previousIndex: number;\n\n    /**\n     * The previously selected title.\n     */\n    readonly previousTitle: Title<T> | null;\n\n    /**\n     * The currently selected index.\n     */\n    readonly currentIndex: number;\n\n    /**\n     * The currently selected title.\n     */\n    readonly currentTitle: Title<T> | null;\n  }\n\n  /**\n   * The arguments object for the `tabMoved` signal.\n   */\n  export interface ITabMovedArgs<T> {\n    /**\n     * The previous index of the tab.\n     */\n    readonly fromIndex: number;\n\n    /**\n     * The current index of the tab.\n     */\n    readonly toIndex: number;\n\n    /**\n     * The title for the tab.\n     */\n    readonly title: Title<T>;\n  }\n\n  /**\n   * The arguments object for the `tabActivateRequested` signal.\n   */\n  export interface ITabActivateRequestedArgs<T> {\n    /**\n     * The index of the tab to activate.\n     */\n    readonly index: number;\n\n    /**\n     * The title for the tab.\n     */\n    readonly title: Title<T>;\n  }\n\n  /**\n   * The arguments object for the `tabCloseRequested` signal.\n   */\n  export interface ITabCloseRequestedArgs<T> {\n    /**\n     * The index of the tab to close.\n     */\n    readonly index: number;\n\n    /**\n     * The title for the tab.\n     */\n    readonly title: Title<T>;\n  }\n\n  /**\n   * The arguments object for the `tabDetachRequested` signal.\n   */\n  export interface ITabDetachRequestedArgs<T> {\n    /**\n     * The index of the tab to detach.\n     */\n    readonly index: number;\n\n    /**\n     * The title for the tab.\n     */\n    readonly title: Title<T>;\n\n    /**\n     * The node representing the tab.\n     */\n    readonly tab: HTMLElement;\n\n    /**\n     * The current client X position of the mouse.\n     */\n    readonly clientX: number;\n\n    /**\n     * The current client Y position of the mouse.\n     */\n    readonly clientY: number;\n\n    /**\n     * The mouse position in the tab coordinate.\n     */\n    readonly offset?: { x: number; y: number };\n  }\n\n  /**\n   * An object which holds the data to render a tab.\n   */\n  export interface IRenderData<T> {\n    /**\n     * The title associated with the tab.\n     */\n    readonly title: Title<T>;\n\n    /**\n     * Whether the tab is the current tab.\n     */\n    readonly current: boolean;\n\n    /**\n     * The z-index for the tab.\n     */\n    readonly zIndex: number;\n\n    /**\n     * The tabindex value for the tab.\n     */\n    readonly tabIndex?: number;\n  }\n\n  /**\n   * A renderer for use with a tab bar.\n   */\n  export interface IRenderer<T> {\n    /**\n     * A selector which matches the close icon node in a tab.\n     */\n    readonly closeIconSelector: string;\n\n    /**\n     * Render the virtual element for a tab.\n     *\n     * @param data - The data to use for rendering the tab.\n     *\n     * @returns A virtual element representing the tab.\n     */\n    renderTab(data: IRenderData<T>): VirtualElement;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   *\n   * #### Notes\n   * Subclasses are free to reimplement rendering methods as needed.\n   */\n  export class Renderer implements IRenderer<any> {\n    constructor() {\n      this._uuid = ++Renderer._nInstance;\n    }\n    /**\n     * A selector which matches the close icon node in a tab.\n     */\n    readonly closeIconSelector = '.lm-TabBar-tabCloseIcon';\n\n    /**\n     * Render the virtual element for a tab.\n     *\n     * @param data - The data to use for rendering the tab.\n     *\n     * @returns A virtual element representing the tab.\n     */\n    renderTab(data: IRenderData<any>): VirtualElement {\n      let title = data.title.caption;\n      let key = this.createTabKey(data);\n      let id = key;\n      let style = this.createTabStyle(data);\n      let className = this.createTabClass(data);\n      let dataset = this.createTabDataset(data);\n      let aria = this.createTabARIA(data);\n      if (data.title.closable) {\n        return h.li(\n          { id, key, className, title, style, dataset, ...aria },\n          this.renderIcon(data),\n          this.renderLabel(data),\n          this.renderCloseIcon(data)\n        );\n      } else {\n        return h.li(\n          { id, key, className, title, style, dataset, ...aria },\n          this.renderIcon(data),\n          this.renderLabel(data)\n        );\n      }\n    }\n\n    /**\n     * Render the icon element for a tab.\n     *\n     * @param data - The data to use for rendering the tab.\n     *\n     * @returns A virtual element representing the tab icon.\n     */\n    renderIcon(data: IRenderData<any>): VirtualElement {\n      const { title } = data;\n      let className = this.createIconClass(data);\n\n      // If title.icon is undefined, it will be ignored.\n      return h.div({ className }, title.icon!, title.iconLabel);\n    }\n\n    /**\n     * Render the label element for a tab.\n     *\n     * @param data - The data to use for rendering the tab.\n     *\n     * @returns A virtual element representing the tab label.\n     */\n    renderLabel(data: IRenderData<any>): VirtualElement {\n      return h.div({ className: 'lm-TabBar-tabLabel' }, data.title.label);\n    }\n\n    /**\n     * Render the close icon element for a tab.\n     *\n     * @param data - The data to use for rendering the tab.\n     *\n     * @returns A virtual element representing the tab close icon.\n     */\n    renderCloseIcon(data: IRenderData<any>): VirtualElement {\n      return h.div({ className: 'lm-TabBar-tabCloseIcon' });\n    }\n\n    /**\n     * Create a unique render key for the tab.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The unique render key for the tab.\n     *\n     * #### Notes\n     * This method caches the key against the tab title the first time\n     * the key is generated. This enables efficient rendering of moved\n     * tabs and avoids subtle hover style artifacts.\n     */\n    createTabKey(data: IRenderData<any>): string {\n      let key = this._tabKeys.get(data.title);\n      if (key === undefined) {\n        key = `tab-key-${this._uuid}-${this._tabID++}`;\n        this._tabKeys.set(data.title, key);\n      }\n      return key;\n    }\n\n    /**\n     * Create the inline style object for a tab.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The inline style data for the tab.\n     */\n    createTabStyle(data: IRenderData<any>): ElementInlineStyle {\n      return { zIndex: `${data.zIndex}` };\n    }\n\n    /**\n     * Create the class name for the tab.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The full class name for the tab.\n     */\n    createTabClass(data: IRenderData<any>): string {\n      let name = 'lm-TabBar-tab';\n      if (data.title.className) {\n        name += ` ${data.title.className}`;\n      }\n      if (data.title.closable) {\n        name += ' lm-mod-closable';\n      }\n      if (data.current) {\n        name += ' lm-mod-current';\n      }\n      return name;\n    }\n\n    /**\n     * Create the dataset for a tab.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The dataset for the tab.\n     */\n    createTabDataset(data: IRenderData<any>): ElementDataset {\n      return data.title.dataset;\n    }\n\n    /**\n     * Create the ARIA attributes for a tab.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The ARIA attributes for the tab.\n     */\n    createTabARIA(data: IRenderData<any>): ElementARIAAttrs | ElementBaseAttrs {\n      return {\n        role: 'tab',\n        'aria-selected': data.current.toString(),\n        tabindex: `${data.tabIndex ?? '-1'}`\n      };\n    }\n\n    /**\n     * Create the class name for the tab icon.\n     *\n     * @param data - The data to use for the tab.\n     *\n     * @returns The full class name for the tab icon.\n     */\n    createIconClass(data: IRenderData<any>): string {\n      let name = 'lm-TabBar-tabIcon';\n      let extra = data.title.iconClass;\n      return extra ? `${name} ${extra}` : name;\n    }\n\n    private static _nInstance = 0;\n    private readonly _uuid: number;\n    private _tabID = 0;\n    private _tabKeys = new WeakMap<Title<any>, string>();\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n\n  /**\n   * A selector which matches the add button node in the tab bar.\n   */\n  export const addButtonSelector = '.lm-TabBar-addButton';\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The start drag distance threshold.\n   */\n  export const DRAG_THRESHOLD = 5;\n\n  /**\n   * The detach distance threshold.\n   */\n  export const DETACH_THRESHOLD = 20;\n\n  /**\n   * A struct which holds the drag data for a tab bar.\n   */\n  export interface IDragData {\n    /**\n     * The tab node being dragged.\n     */\n    tab: HTMLElement;\n\n    /**\n     * The index of the tab being dragged.\n     */\n    index: number;\n\n    /**\n     * The mouse press client X position.\n     */\n    pressX: number;\n\n    /**\n     * The mouse press client Y position.\n     */\n    pressY: number;\n\n    /**\n     * The offset left/top of the tab being dragged.\n     *\n     * This will be `-1` if the drag is not active.\n     */\n    tabPos: number;\n\n    /**\n     * The offset width/height of the tab being dragged.\n     *\n     * This will be `-1` if the drag is not active.\n     */\n    tabSize: number;\n\n    /**\n     * The original mouse X/Y position in tab coordinates.\n     *\n     * This will be `-1` if the drag is not active.\n     */\n    tabPressPos: number;\n\n    /**\n     * The original mouse position in tab coordinates.\n     *\n     * This is undefined if the drag is not active.\n     */\n    tabPressOffset?: { x: number; y: number };\n\n    /**\n     * The tab target index upon mouse release.\n     *\n     * This will be `-1` if the drag is not active.\n     */\n    targetIndex: number;\n\n    /**\n     * The array of tab layout objects snapped at drag start.\n     *\n     * This will be `null` if the drag is not active.\n     */\n    tabLayout: ITabLayout[] | null;\n\n    /**\n     * The bounding client rect of the tab bar content node.\n     *\n     * This will be `null` if the drag is not active.\n     */\n    contentRect: DOMRect | null;\n\n    /**\n     * The disposable to clean up the cursor override.\n     *\n     * This will be `null` if the drag is not active.\n     */\n    override: IDisposable | null;\n\n    /**\n     * Whether the drag is currently active.\n     */\n    dragActive: boolean;\n\n    /**\n     * Whether the drag has been aborted.\n     */\n    dragAborted: boolean;\n\n    /**\n     * Whether a detach request as been made.\n     */\n    detachRequested: boolean;\n  }\n\n  /**\n   * An object which holds layout data for a tab.\n   */\n  export interface ITabLayout {\n    /**\n     * The left/top margin value for the tab.\n     */\n    margin: number;\n\n    /**\n     * The offset left/top position of the tab.\n     */\n    pos: number;\n\n    /**\n     * The offset width/height of the tab.\n     */\n    size: number;\n  }\n\n  /**\n   * Create the DOM node for a tab bar.\n   */\n  export function createNode(): HTMLDivElement {\n    let node = document.createElement('div');\n    let content = document.createElement('ul');\n    content.setAttribute('role', 'tablist');\n    content.className = 'lm-TabBar-content';\n    node.appendChild(content);\n\n    let add = document.createElement('div');\n    add.className = 'lm-TabBar-addButton lm-mod-hidden';\n    add.setAttribute('tabindex', '-1');\n    add.setAttribute('role', 'button');\n    node.appendChild(add);\n    return node;\n  }\n\n  /**\n   * Coerce a title or options into a real title.\n   */\n  export function asTitle<T>(value: Title<T> | Title.IOptions<T>): Title<T> {\n    return value instanceof Title ? value : new Title<T>(value);\n  }\n\n  /**\n   * Parse the transition duration for a tab node.\n   */\n  export function parseTransitionDuration(tab: HTMLElement): number {\n    let style = window.getComputedStyle(tab);\n    return 1000 * (parseFloat(style.transitionDuration!) || 0);\n  }\n\n  /**\n   * Get a snapshot of the current tab layout values.\n   */\n  export function snapTabLayout(\n    tabs: HTMLCollection,\n    orientation: TabBar.Orientation\n  ): ITabLayout[] {\n    let layout = new Array<ITabLayout>(tabs.length);\n    for (let i = 0, n = tabs.length; i < n; ++i) {\n      let node = tabs[i] as HTMLElement;\n      let style = window.getComputedStyle(node);\n      if (orientation === 'horizontal') {\n        layout[i] = {\n          pos: node.offsetLeft,\n          size: node.offsetWidth,\n          margin: parseFloat(style.marginLeft!) || 0\n        };\n      } else {\n        layout[i] = {\n          pos: node.offsetTop,\n          size: node.offsetHeight,\n          margin: parseFloat(style.marginTop!) || 0\n        };\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * Test if the event exceeds the drag threshold.\n   */\n  export function dragExceeded(data: IDragData, event: MouseEvent): boolean {\n    let dx = Math.abs(event.clientX - data.pressX);\n    let dy = Math.abs(event.clientY - data.pressY);\n    return dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD;\n  }\n\n  /**\n   * Test if the event exceeds the drag detach threshold.\n   */\n  export function detachExceeded(data: IDragData, event: MouseEvent): boolean {\n    let rect = data.contentRect!;\n    return (\n      event.clientX < rect.left - DETACH_THRESHOLD ||\n      event.clientX >= rect.right + DETACH_THRESHOLD ||\n      event.clientY < rect.top - DETACH_THRESHOLD ||\n      event.clientY >= rect.bottom + DETACH_THRESHOLD\n    );\n  }\n\n  /**\n   * Update the relative tab positions and computed target index.\n   */\n  export function layoutTabs(\n    tabs: HTMLCollection,\n    data: IDragData,\n    event: MouseEvent,\n    orientation: TabBar.Orientation\n  ): void {\n    // Compute the orientation-sensitive values.\n    let pressPos: number;\n    let localPos: number;\n    let clientPos: number;\n    let clientSize: number;\n    if (orientation === 'horizontal') {\n      pressPos = data.pressX;\n      localPos = event.clientX - data.contentRect!.left;\n      clientPos = event.clientX;\n      clientSize = data.contentRect!.width;\n    } else {\n      pressPos = data.pressY;\n      localPos = event.clientY - data.contentRect!.top;\n      clientPos = event.clientY;\n      clientSize = data.contentRect!.height;\n    }\n\n    // Compute the target data.\n    let targetIndex = data.index;\n    let targetPos = localPos - data.tabPressPos;\n    let targetEnd = targetPos + data.tabSize;\n\n    // Update the relative tab positions.\n    for (let i = 0, n = tabs.length; i < n; ++i) {\n      let pxPos: string;\n      let layout = data.tabLayout![i];\n      let threshold = layout.pos + (layout.size >> 1);\n      if (i < data.index && targetPos < threshold) {\n        pxPos = `${data.tabSize + data.tabLayout![i + 1].margin}px`;\n        targetIndex = Math.min(targetIndex, i);\n      } else if (i > data.index && targetEnd > threshold) {\n        pxPos = `${-data.tabSize - layout.margin}px`;\n        targetIndex = Math.max(targetIndex, i);\n      } else if (i === data.index) {\n        let ideal = clientPos - pressPos;\n        let limit = clientSize - (data.tabPos + data.tabSize);\n        pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;\n      } else {\n        pxPos = '';\n      }\n      if (orientation === 'horizontal') {\n        (tabs[i] as HTMLElement).style.left = pxPos;\n      } else {\n        (tabs[i] as HTMLElement).style.top = pxPos;\n      }\n    }\n\n    // Update the computed target index.\n    data.targetIndex = targetIndex;\n  }\n\n  /**\n   * Position the drag tab at its final resting relative position.\n   */\n  export function finalizeTabPosition(\n    data: IDragData,\n    orientation: TabBar.Orientation\n  ): void {\n    // Compute the orientation-sensitive client size.\n    let clientSize: number;\n    if (orientation === 'horizontal') {\n      clientSize = data.contentRect!.width;\n    } else {\n      clientSize = data.contentRect!.height;\n    }\n\n    // Compute the ideal final tab position.\n    let ideal: number;\n    if (data.targetIndex === data.index) {\n      ideal = 0;\n    } else if (data.targetIndex > data.index) {\n      let tgt = data.tabLayout![data.targetIndex];\n      ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;\n    } else {\n      let tgt = data.tabLayout![data.targetIndex];\n      ideal = tgt.pos - data.tabPos;\n    }\n\n    // Compute the tab position limit.\n    let limit = clientSize - (data.tabPos + data.tabSize);\n    let final = Math.max(-data.tabPos, Math.min(ideal, limit));\n\n    // Set the final orientation-sensitive position.\n    if (orientation === 'horizontal') {\n      data.tab.style.left = `${final}px`;\n    } else {\n      data.tab.style.top = `${final}px`;\n    }\n  }\n\n  /**\n   * Reset the relative positions of the given tabs.\n   */\n  export function resetTabPositions(\n    tabs: HTMLCollection,\n    orientation: TabBar.Orientation\n  ): void {\n    for (const tab of tabs) {\n      if (orientation === 'horizontal') {\n        (tab as HTMLElement).style.left = '';\n      } else {\n        (tab as HTMLElement).style.top = '';\n      }\n    }\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt, empty } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { BoxEngine, BoxSizer } from './boxengine';\n\nimport { Layout, LayoutItem } from './layout';\n\nimport { TabBar } from './tabbar';\n\nimport Utils from './utils';\n\nimport { Widget } from './widget';\n\n/**\n * A layout which provides a flexible docking arrangement.\n *\n * #### Notes\n * The consumer of this layout is responsible for handling all signals\n * from the generated tab bars and managing the visibility of widgets\n * and tab bars as needed.\n */\nexport class DockLayout extends Layout {\n  /**\n   * Construct a new dock layout.\n   *\n   * @param options - The options for initializing the layout.\n   */\n  constructor(options: DockLayout.IOptions) {\n    super();\n    this.renderer = options.renderer;\n    if (options.spacing !== undefined) {\n      this._spacing = Utils.clampDimension(options.spacing);\n    }\n    this._document = options.document || document;\n    this._hiddenMode =\n      options.hiddenMode !== undefined\n        ? options.hiddenMode\n        : Widget.HiddenMode.Display;\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   *\n   * #### Notes\n   * This will clear and dispose all widgets in the layout.\n   */\n  dispose(): void {\n    // Get an iterator over the widgets in the layout.\n    let widgets = this[Symbol.iterator]();\n\n    // Dispose of the layout items.\n    this._items.forEach(item => {\n      item.dispose();\n    });\n\n    // Clear the layout state before disposing the widgets.\n    this._box = null;\n    this._root = null;\n    this._items.clear();\n\n    // Dispose of the widgets contained in the old layout root.\n    for (const widget of widgets) {\n      widget.dispose();\n    }\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * The renderer used by the dock layout.\n   */\n  readonly renderer: DockLayout.IRenderer;\n\n  /**\n   * The method for hiding child widgets.\n   *\n   * #### Notes\n   * If there is only one child widget, `Display` hiding mode will be used\n   * regardless of this setting.\n   */\n  get hiddenMode(): Widget.HiddenMode {\n    return this._hiddenMode;\n  }\n  set hiddenMode(v: Widget.HiddenMode) {\n    if (this._hiddenMode === v) {\n      return;\n    }\n    this._hiddenMode = v;\n    for (const bar of this.tabBars()) {\n      if (bar.titles.length > 1) {\n        for (const title of bar.titles) {\n          title.owner.hiddenMode = this._hiddenMode;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the inter-element spacing for the dock layout.\n   */\n  get spacing(): number {\n    return this._spacing;\n  }\n\n  /**\n   * Set the inter-element spacing for the dock layout.\n   */\n  set spacing(value: number) {\n    value = Utils.clampDimension(value);\n    if (this._spacing === value) {\n      return;\n    }\n    this._spacing = value;\n    if (!this.parent) {\n      return;\n    }\n    this.parent.fit();\n  }\n\n  /**\n   * Whether the dock layout is empty.\n   */\n  get isEmpty(): boolean {\n    return this._root === null;\n  }\n\n  /**\n   * Create an iterator over all widgets in the layout.\n   *\n   * @returns A new iterator over the widgets in the layout.\n   *\n   * #### Notes\n   * This iterator includes the generated tab bars.\n   */\n  [Symbol.iterator](): IterableIterator<Widget> {\n    return this._root ? this._root.iterAllWidgets() : empty();\n  }\n\n  /**\n   * Create an iterator over the user widgets in the layout.\n   *\n   * @returns A new iterator over the user widgets in the layout.\n   *\n   * #### Notes\n   * This iterator does not include the generated tab bars.\n   */\n  widgets(): IterableIterator<Widget> {\n    return this._root ? this._root.iterUserWidgets() : empty();\n  }\n\n  /**\n   * Create an iterator over the selected widgets in the layout.\n   *\n   * @returns A new iterator over the selected user widgets.\n   *\n   * #### Notes\n   * This iterator yields the widgets corresponding to the current tab\n   * of each tab bar in the layout.\n   */\n  selectedWidgets(): IterableIterator<Widget> {\n    return this._root ? this._root.iterSelectedWidgets() : empty();\n  }\n\n  /**\n   * Create an iterator over the tab bars in the layout.\n   *\n   * @returns A new iterator over the tab bars in the layout.\n   *\n   * #### Notes\n   * This iterator does not include the user widgets.\n   */\n  tabBars(): IterableIterator<TabBar<Widget>> {\n    return this._root ? this._root.iterTabBars() : empty();\n  }\n\n  /**\n   * Create an iterator over the handles in the layout.\n   *\n   * @returns A new iterator over the handles in the layout.\n   */\n  handles(): IterableIterator<HTMLDivElement> {\n    return this._root ? this._root.iterHandles() : empty();\n  }\n\n  /**\n   * Move a handle to the given offset position.\n   *\n   * @param handle - The handle to move.\n   *\n   * @param offsetX - The desired offset X position of the handle.\n   *\n   * @param offsetY - The desired offset Y position of the handle.\n   *\n   * #### Notes\n   * If the given handle is not contained in the layout, this is no-op.\n   *\n   * The handle will be moved as close as possible to the desired\n   * position without violating any of the layout constraints.\n   *\n   * Only one of the coordinates is used depending on the orientation\n   * of the handle. This method accepts both coordinates to make it\n   * easy to invoke from a mouse move event without needing to know\n   * the handle orientation.\n   */\n  moveHandle(handle: HTMLDivElement, offsetX: number, offsetY: number): void {\n    // Bail early if there is no root or if the handle is hidden.\n    let hidden = handle.classList.contains('lm-mod-hidden');\n    if (!this._root || hidden) {\n      return;\n    }\n\n    // Lookup the split node for the handle.\n    let data = this._root.findSplitNode(handle);\n    if (!data) {\n      return;\n    }\n\n    // Compute the desired delta movement for the handle.\n    let delta: number;\n    if (data.node.orientation === 'horizontal') {\n      delta = offsetX - handle.offsetLeft;\n    } else {\n      delta = offsetY - handle.offsetTop;\n    }\n\n    // Bail if there is no handle movement.\n    if (delta === 0) {\n      return;\n    }\n\n    // Prevent sibling resizing unless needed.\n    data.node.holdSizes();\n\n    // Adjust the sizers to reflect the handle movement.\n    BoxEngine.adjust(data.node.sizers, data.index, delta);\n\n    // Update the layout of the widgets.\n    if (this.parent) {\n      this.parent.update();\n    }\n  }\n\n  /**\n   * Save the current configuration of the dock layout.\n   *\n   * @returns A new config object for the current layout state.\n   *\n   * #### Notes\n   * The return value can be provided to the `restoreLayout` method\n   * in order to restore the layout to its current configuration.\n   */\n  saveLayout(): DockLayout.ILayoutConfig {\n    // Bail early if there is no root.\n    if (!this._root) {\n      return { main: null };\n    }\n\n    // Hold the current sizes in the layout tree.\n    this._root.holdAllSizes();\n\n    // Return the layout config.\n    return { main: this._root.createConfig() };\n  }\n\n  /**\n   * Restore the layout to a previously saved configuration.\n   *\n   * @param config - The layout configuration to restore.\n   *\n   * #### Notes\n   * Widgets which currently belong to the layout but which are not\n   * contained in the config will be unparented.\n   */\n  restoreLayout(config: DockLayout.ILayoutConfig): void {\n    // Create the widget set for validating the config.\n    let widgetSet = new Set<Widget>();\n\n    // Normalize the main area config and collect the widgets.\n    let mainConfig: DockLayout.AreaConfig | null;\n    if (config.main) {\n      mainConfig = Private.normalizeAreaConfig(config.main, widgetSet);\n    } else {\n      mainConfig = null;\n    }\n\n    // Create iterators over the old content.\n    let oldWidgets = this.widgets();\n    let oldTabBars = this.tabBars();\n    let oldHandles = this.handles();\n\n    // Clear the root before removing the old content.\n    this._root = null;\n\n    // Unparent the old widgets which are not in the new config.\n    for (const widget of oldWidgets) {\n      if (!widgetSet.has(widget)) {\n        widget.parent = null;\n      }\n    }\n\n    // Dispose of the old tab bars.\n    for (const tabBar of oldTabBars) {\n      tabBar.dispose();\n    }\n\n    // Remove the old handles.\n    for (const handle of oldHandles) {\n      if (handle.parentNode) {\n        handle.parentNode.removeChild(handle);\n      }\n    }\n\n    // Reparent the new widgets to the current parent.\n    for (const widget of widgetSet) {\n      widget.parent = this.parent;\n    }\n\n    // Create the root node for the new config.\n    if (mainConfig) {\n      this._root = Private.realizeAreaConfig(\n        mainConfig,\n        {\n          // Ignoring optional `document` argument as we must reuse `this._document`\n          createTabBar: (document?: Document | ShadowRoot) =>\n            this._createTabBar(),\n          createHandle: () => this._createHandle()\n        },\n        this._document\n      );\n    } else {\n      this._root = null;\n    }\n\n    // If there is no parent, there is nothing more to do.\n    if (!this.parent) {\n      return;\n    }\n\n    // Attach the new widgets to the parent.\n    widgetSet.forEach(widget => {\n      this.attachWidget(widget);\n    });\n\n    // Post a fit request to the parent.\n    this.parent.fit();\n  }\n\n  /**\n   * Add a widget to the dock layout.\n   *\n   * @param widget - The widget to add to the dock layout.\n   *\n   * @param options - The additional options for adding the widget.\n   *\n   * #### Notes\n   * The widget will be moved if it is already contained in the layout.\n   *\n   * An error will be thrown if the reference widget is invalid.\n   */\n  addWidget(widget: Widget, options: DockLayout.IAddOptions = {}): void {\n    // Parse the options.\n    let ref = options.ref || null;\n    let mode = options.mode || 'tab-after';\n\n    // Find the tab node which holds the reference widget.\n    let refNode: Private.TabLayoutNode | null = null;\n    if (this._root && ref) {\n      refNode = this._root.findTabNode(ref);\n    }\n\n    // Throw an error if the reference widget is invalid.\n    if (ref && !refNode) {\n      throw new Error('Reference widget is not in the layout.');\n    }\n\n    // Reparent the widget to the current layout parent.\n    widget.parent = this.parent;\n\n    // Insert the widget according to the insert mode.\n    switch (mode) {\n      case 'tab-after':\n        this._insertTab(widget, ref, refNode, true);\n        break;\n      case 'tab-before':\n        this._insertTab(widget, ref, refNode, false);\n        break;\n      case 'split-top':\n        this._insertSplit(widget, ref, refNode, 'vertical', false);\n        break;\n      case 'split-left':\n        this._insertSplit(widget, ref, refNode, 'horizontal', false);\n        break;\n      case 'split-right':\n        this._insertSplit(widget, ref, refNode, 'horizontal', true);\n        break;\n      case 'split-bottom':\n        this._insertSplit(widget, ref, refNode, 'vertical', true);\n        break;\n      case 'merge-top':\n        this._insertSplit(widget, ref, refNode, 'vertical', false, true);\n        break;\n      case 'merge-left':\n        this._insertSplit(widget, ref, refNode, 'horizontal', false, true);\n        break;\n      case 'merge-right':\n        this._insertSplit(widget, ref, refNode, 'horizontal', true, true);\n        break;\n      case 'merge-bottom':\n        this._insertSplit(widget, ref, refNode, 'vertical', true, true);\n        break;\n    }\n\n    // Do nothing else if there is no parent widget.\n    if (!this.parent) {\n      return;\n    }\n\n    // Ensure the widget is attached to the parent widget.\n    this.attachWidget(widget);\n\n    // Post a fit request for the parent widget.\n    this.parent.fit();\n  }\n\n  /**\n   * Remove a widget from the layout.\n   *\n   * @param widget - The widget to remove from the layout.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method does *not* modify the widget's `parent`.\n   */\n  removeWidget(widget: Widget): void {\n    // Remove the widget from its current layout location.\n    this._removeWidget(widget);\n\n    // Do nothing else if there is no parent widget.\n    if (!this.parent) {\n      return;\n    }\n\n    // Detach the widget from the parent widget.\n    this.detachWidget(widget);\n\n    // Post a fit request for the parent widget.\n    this.parent.fit();\n  }\n\n  /**\n   * Find the tab area which contains the given client position.\n   *\n   * @param clientX - The client X position of interest.\n   *\n   * @param clientY - The client Y position of interest.\n   *\n   * @returns The geometry of the tab area at the given position, or\n   *   `null` if there is no tab area at the given position.\n   */\n  hitTestTabAreas(\n    clientX: number,\n    clientY: number\n  ): DockLayout.ITabAreaGeometry | null {\n    // Bail early if hit testing cannot produce valid results.\n    if (!this._root || !this.parent || !this.parent.isVisible) {\n      return null;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent.node);\n    }\n\n    // Convert from client to local coordinates.\n    let rect = this.parent.node.getBoundingClientRect();\n    let x = clientX - rect.left - this._box.borderLeft;\n    let y = clientY - rect.top - this._box.borderTop;\n\n    // Find the tab layout node at the local position.\n    let tabNode = this._root.hitTestTabNodes(x, y);\n\n    // Bail if a tab layout node was not found.\n    if (!tabNode) {\n      return null;\n    }\n\n    // Extract the data from the tab node.\n    let { tabBar, top, left, width, height } = tabNode;\n\n    // Compute the right and bottom edges of the tab area.\n    let borderWidth = this._box.borderLeft + this._box.borderRight;\n    let borderHeight = this._box.borderTop + this._box.borderBottom;\n    let right = rect.width - borderWidth - (left + width);\n    let bottom = rect.height - borderHeight - (top + height);\n\n    // Return the hit test results.\n    return { tabBar, x, y, top, left, right, bottom, width, height };\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    // Perform superclass initialization.\n    super.init();\n\n    // Attach each widget to the parent.\n    for (const widget of this) {\n      this.attachWidget(widget);\n    }\n\n    // Attach each handle to the parent.\n    for (const handle of this.handles()) {\n      this.parent!.node.appendChild(handle);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * Attach the widget to the layout parent widget.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This is a no-op if the widget is already attached.\n   */\n  protected attachWidget(widget: Widget): void {\n    // Do nothing if the widget is already attached.\n    if (this.parent!.node === widget.node.parentNode) {\n      return;\n    }\n\n    // Create the layout item for the widget.\n    this._items.set(widget, new LayoutItem(widget));\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget's node to the parent.\n    this.parent!.node.appendChild(widget.node);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n  }\n\n  /**\n   * Detach the widget from the layout parent widget.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This is a no-op if the widget is not attached.\n   */\n  protected detachWidget(widget: Widget): void {\n    // Do nothing if the widget is not attached.\n    if (this.parent!.node !== widget.node.parentNode) {\n      return;\n    }\n\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Delete the layout item for the widget.\n    let item = this._items.get(widget);\n    if (item) {\n      this._items.delete(widget);\n      item.dispose();\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    super.onBeforeShow(msg);\n    this.parent!.update();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.parent!.isVisible) {\n      this._update(msg.width, msg.height);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.parent!.isVisible) {\n      this._update(-1, -1);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   */\n  protected onFitRequest(msg: Message): void {\n    if (this.parent!.isAttached) {\n      this._fit();\n    }\n  }\n\n  /**\n   * Remove the specified widget from the layout structure.\n   *\n   * #### Notes\n   * This is a no-op if the widget is not in the layout tree.\n   *\n   * This does not detach the widget from the parent node.\n   */\n  private _removeWidget(widget: Widget): void {\n    // Bail early if there is no layout root.\n    if (!this._root) {\n      return;\n    }\n\n    // Find the tab node which contains the given widget.\n    let tabNode = this._root.findTabNode(widget);\n\n    // Bail early if the tab node is not found.\n    if (!tabNode) {\n      return;\n    }\n\n    Private.removeAria(widget);\n\n    // If there are multiple tabs, just remove the widget's tab.\n    if (tabNode.tabBar.titles.length > 1) {\n      tabNode.tabBar.removeTab(widget.title);\n      if (\n        this._hiddenMode === Widget.HiddenMode.Scale &&\n        tabNode.tabBar.titles.length == 1\n      ) {\n        const existingWidget = tabNode.tabBar.titles[0].owner;\n        existingWidget.hiddenMode = Widget.HiddenMode.Display;\n      }\n      return;\n    }\n\n    // Otherwise, the tab node needs to be removed...\n\n    // Dispose the tab bar.\n    tabNode.tabBar.dispose();\n\n    // Handle the case where the tab node is the root.\n    if (this._root === tabNode) {\n      this._root = null;\n      return;\n    }\n\n    // Otherwise, remove the tab node from its parent...\n\n    // Prevent widget resizing unless needed.\n    this._root.holdAllSizes();\n\n    // Clear the parent reference on the tab node.\n    let splitNode = tabNode.parent!;\n    tabNode.parent = null;\n\n    // Remove the tab node from its parent split node.\n    let i = ArrayExt.removeFirstOf(splitNode.children, tabNode);\n    let handle = ArrayExt.removeAt(splitNode.handles, i)!;\n    ArrayExt.removeAt(splitNode.sizers, i);\n\n    // Remove the handle from its parent DOM node.\n    if (handle.parentNode) {\n      handle.parentNode.removeChild(handle);\n    }\n\n    // If there are multiple children, just update the handles.\n    if (splitNode.children.length > 1) {\n      splitNode.syncHandles();\n      return;\n    }\n\n    // Otherwise, the split node also needs to be removed...\n\n    // Clear the parent reference on the split node.\n    let maybeParent = splitNode.parent;\n    splitNode.parent = null;\n\n    // Lookup the remaining child node and handle.\n    let childNode = splitNode.children[0];\n    let childHandle = splitNode.handles[0];\n\n    // Clear the split node data.\n    splitNode.children.length = 0;\n    splitNode.handles.length = 0;\n    splitNode.sizers.length = 0;\n\n    // Remove the child handle from its parent node.\n    if (childHandle.parentNode) {\n      childHandle.parentNode.removeChild(childHandle);\n    }\n\n    // Handle the case where the split node is the root.\n    if (this._root === splitNode) {\n      childNode.parent = null;\n      this._root = childNode;\n      return;\n    }\n\n    // Otherwise, move the child node to the parent node...\n    let parentNode = maybeParent!;\n\n    // Lookup the index of the split node.\n    let j = parentNode.children.indexOf(splitNode);\n\n    // Handle the case where the child node is a tab node.\n    if (childNode instanceof Private.TabLayoutNode) {\n      childNode.parent = parentNode;\n      parentNode.children[j] = childNode;\n      return;\n    }\n\n    // Remove the split data from the parent.\n    let splitHandle = ArrayExt.removeAt(parentNode.handles, j)!;\n    ArrayExt.removeAt(parentNode.children, j);\n    ArrayExt.removeAt(parentNode.sizers, j);\n\n    // Remove the handle from its parent node.\n    if (splitHandle.parentNode) {\n      splitHandle.parentNode.removeChild(splitHandle);\n    }\n\n    // The child node and the split parent node will have the same\n    // orientation. Merge the grand-children with the parent node.\n    for (let i = 0, n = childNode.children.length; i < n; ++i) {\n      let gChild = childNode.children[i];\n      let gHandle = childNode.handles[i];\n      let gSizer = childNode.sizers[i];\n      ArrayExt.insert(parentNode.children, j + i, gChild);\n      ArrayExt.insert(parentNode.handles, j + i, gHandle);\n      ArrayExt.insert(parentNode.sizers, j + i, gSizer);\n      gChild.parent = parentNode;\n    }\n\n    // Clear the child node.\n    childNode.children.length = 0;\n    childNode.handles.length = 0;\n    childNode.sizers.length = 0;\n    childNode.parent = null;\n\n    // Sync the handles on the parent node.\n    parentNode.syncHandles();\n  }\n\n  /**\n   * Create the tab layout node to hold the widget.\n   */\n  private _createTabNode(widget: Widget): Private.TabLayoutNode {\n    let tabNode = new Private.TabLayoutNode(this._createTabBar());\n    tabNode.tabBar.addTab(widget.title);\n    Private.addAria(widget, tabNode.tabBar);\n    return tabNode;\n  }\n\n  /**\n   * Insert a widget next to an existing tab.\n   *\n   * #### Notes\n   * This does not attach the widget to the parent widget.\n   */\n  private _insertTab(\n    widget: Widget,\n    ref: Widget | null,\n    refNode: Private.TabLayoutNode | null,\n    after: boolean\n  ): void {\n    // Do nothing if the tab is inserted next to itself.\n    if (widget === ref) {\n      return;\n    }\n\n    // Create the root if it does not exist.\n    if (!this._root) {\n      let tabNode = new Private.TabLayoutNode(this._createTabBar());\n      tabNode.tabBar.addTab(widget.title);\n      this._root = tabNode;\n      Private.addAria(widget, tabNode.tabBar);\n      return;\n    }\n\n    // Use the first tab node as the ref node if needed.\n    if (!refNode) {\n      refNode = this._root.findFirstTabNode()!;\n    }\n\n    // If the widget is not contained in the ref node, ensure it is\n    // removed from the layout and hidden before being added again.\n    if (refNode.tabBar.titles.indexOf(widget.title) === -1) {\n      this._removeWidget(widget);\n      widget.hide();\n    }\n\n    // Lookup the target index for inserting the tab.\n    let index: number;\n    if (ref) {\n      index = refNode.tabBar.titles.indexOf(ref.title);\n    } else {\n      index = refNode.tabBar.currentIndex;\n    }\n\n    // Using transform create an additional layer in the pixel pipeline\n    // to limit the number of layer, it is set only if there is more than one widget.\n    if (this._hiddenMode === Widget.HiddenMode.Scale) {\n      if (refNode.tabBar.titles.length === 0) {\n        // Singular tab should use display mode to limit number of layers.\n        widget.hiddenMode = Widget.HiddenMode.Display;\n      } else if (refNode.tabBar.titles.length == 1) {\n        // If we are adding a second tab, switch the existing tab back to scale.\n        const existingWidget = refNode.tabBar.titles[0].owner;\n        existingWidget.hiddenMode = Widget.HiddenMode.Scale;\n      } else {\n        // For the third and subsequent tabs no special action is needed.\n        widget.hiddenMode = Widget.HiddenMode.Scale;\n      }\n    } else {\n      // For all other modes just propagate the current mode.\n      widget.hiddenMode = this._hiddenMode;\n    }\n\n    // Insert the widget's tab relative to the target index.\n    refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);\n    Private.addAria(widget, refNode.tabBar);\n  }\n\n  /**\n   * Insert a widget as a new split area.\n   *\n   * #### Notes\n   * This does not attach the widget to the parent widget.\n   */\n  private _insertSplit(\n    widget: Widget,\n    ref: Widget | null,\n    refNode: Private.TabLayoutNode | null,\n    orientation: Private.Orientation,\n    after: boolean,\n    merge: boolean = false\n  ): void {\n    // Do nothing if there is no effective split.\n    if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {\n      return;\n    }\n\n    // Ensure the widget is removed from the current layout.\n    this._removeWidget(widget);\n\n    // Set the root if it does not exist.\n    if (!this._root) {\n      this._root = this._createTabNode(widget);\n      return;\n    }\n\n    // If the ref node parent is null, split the root.\n    if (!refNode || !refNode.parent) {\n      // Ensure the root is split with the correct orientation.\n      let root = this._splitRoot(orientation);\n\n      // Determine the insert index for the new tab node.\n      let i = after ? root.children.length : 0;\n\n      // Normalize the split node.\n      root.normalizeSizes();\n\n      // Create the sizer for new tab node.\n      let sizer = Private.createSizer(refNode ? 1 : Private.GOLDEN_RATIO);\n\n      // Insert the tab node sized to the golden ratio.\n      let tabNode = this._createTabNode(widget);\n      ArrayExt.insert(root.children, i, tabNode);\n      ArrayExt.insert(root.sizers, i, sizer);\n      ArrayExt.insert(root.handles, i, this._createHandle());\n      tabNode.parent = root;\n\n      // Re-normalize the split node to maintain the ratios.\n      root.normalizeSizes();\n\n      // Finally, synchronize the visibility of the handles.\n      root.syncHandles();\n      return;\n    }\n\n    // Lookup the split node for the ref widget.\n    let splitNode = refNode.parent;\n\n    // If the split node already had the correct orientation,\n    // the widget can be inserted into the split node directly.\n    if (splitNode.orientation === orientation) {\n      // Find the index of the ref node.\n      let i = splitNode.children.indexOf(refNode);\n\n      // Conditionally reuse a tab layout found in the wanted position.\n      if (merge) {\n        let j = i + (after ? 1 : -1);\n        let sibling = splitNode.children[j];\n        if (sibling instanceof Private.TabLayoutNode) {\n          this._insertTab(widget, null, sibling, true);\n          ++sibling.tabBar.currentIndex;\n          return;\n        }\n      }\n\n      // Normalize the split node.\n      splitNode.normalizeSizes();\n\n      // Consume half the space for the insert location.\n      let s = (splitNode.sizers[i].sizeHint /= 2);\n\n      // Insert the tab node sized to the other half.\n      let j = i + (after ? 1 : 0);\n      let tabNode = this._createTabNode(widget);\n      ArrayExt.insert(splitNode.children, j, tabNode);\n      ArrayExt.insert(splitNode.sizers, j, Private.createSizer(s));\n      ArrayExt.insert(splitNode.handles, j, this._createHandle());\n      tabNode.parent = splitNode;\n\n      // Finally, synchronize the visibility of the handles.\n      splitNode.syncHandles();\n      return;\n    }\n\n    // Remove the ref node from the split node.\n    let i = ArrayExt.removeFirstOf(splitNode.children, refNode);\n\n    // Create a new normalized split node for the children.\n    let childNode = new Private.SplitLayoutNode(orientation);\n    childNode.normalized = true;\n\n    // Add the ref node sized to half the space.\n    childNode.children.push(refNode);\n    childNode.sizers.push(Private.createSizer(0.5));\n    childNode.handles.push(this._createHandle());\n    refNode.parent = childNode;\n\n    // Add the tab node sized to the other half.\n    let j = after ? 1 : 0;\n    let tabNode = this._createTabNode(widget);\n    ArrayExt.insert(childNode.children, j, tabNode);\n    ArrayExt.insert(childNode.sizers, j, Private.createSizer(0.5));\n    ArrayExt.insert(childNode.handles, j, this._createHandle());\n    tabNode.parent = childNode;\n\n    // Synchronize the visibility of the handles.\n    childNode.syncHandles();\n\n    // Finally, add the new child node to the original split node.\n    ArrayExt.insert(splitNode.children, i, childNode);\n    childNode.parent = splitNode;\n  }\n\n  /**\n   * Ensure the root is a split node with the given orientation.\n   */\n  private _splitRoot(\n    orientation: Private.Orientation\n  ): Private.SplitLayoutNode {\n    // Bail early if the root already meets the requirements.\n    let oldRoot = this._root;\n    if (oldRoot instanceof Private.SplitLayoutNode) {\n      if (oldRoot.orientation === orientation) {\n        return oldRoot;\n      }\n    }\n\n    // Create a new root node with the specified orientation.\n    let newRoot = (this._root = new Private.SplitLayoutNode(orientation));\n\n    // Add the old root to the new root.\n    if (oldRoot) {\n      newRoot.children.push(oldRoot);\n      newRoot.sizers.push(Private.createSizer(0));\n      newRoot.handles.push(this._createHandle());\n      oldRoot.parent = newRoot;\n    }\n\n    // Return the new root as a convenience.\n    return newRoot;\n  }\n\n  /**\n   * Fit the layout to the total size required by the widgets.\n   */\n  private _fit(): void {\n    // Set up the computed minimum size.\n    let minW = 0;\n    let minH = 0;\n\n    // Update the size limits for the layout tree.\n    if (this._root) {\n      let limits = this._root.fit(this._spacing, this._items);\n      minW = limits.minWidth;\n      minH = limits.minHeight;\n    }\n\n    // Update the box sizing and add it to the computed min size.\n    let box = (this._box = ElementExt.boxSizing(this.parent!.node));\n    minW += box.horizontalSum;\n    minH += box.verticalSum;\n\n    // Update the parent's min size constraints.\n    let style = this.parent!.node.style;\n    style.minWidth = `${minW}px`;\n    style.minHeight = `${minH}px`;\n\n    // Set the dirty flag to ensure only a single update occurs.\n    this._dirty = true;\n\n    // Notify the ancestor that it should fit immediately. This may\n    // cause a resize of the parent, fulfilling the required update.\n    if (this.parent!.parent) {\n      MessageLoop.sendMessage(this.parent!.parent!, Widget.Msg.FitRequest);\n    }\n\n    // If the dirty flag is still set, the parent was not resized.\n    // Trigger the required update on the parent widget immediately.\n    if (this._dirty) {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n    }\n  }\n\n  /**\n   * Update the layout position and size of the widgets.\n   *\n   * The parent offset dimensions should be `-1` if unknown.\n   */\n  private _update(offsetWidth: number, offsetHeight: number): void {\n    // Clear the dirty flag to indicate the update occurred.\n    this._dirty = false;\n\n    // Bail early if there is no root layout node.\n    if (!this._root) {\n      return;\n    }\n\n    // Measure the parent if the offset dimensions are unknown.\n    if (offsetWidth < 0) {\n      offsetWidth = this.parent!.node.offsetWidth;\n    }\n    if (offsetHeight < 0) {\n      offsetHeight = this.parent!.node.offsetHeight;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent!.node);\n    }\n\n    // Compute the actual layout bounds adjusted for border and padding.\n    let x = this._box.paddingTop;\n    let y = this._box.paddingLeft;\n    let width = offsetWidth - this._box.horizontalSum;\n    let height = offsetHeight - this._box.verticalSum;\n\n    // Update the geometry of the layout tree.\n    this._root.update(x, y, width, height, this._spacing, this._items);\n  }\n\n  /**\n   * Create a new tab bar for use by the dock layout.\n   *\n   * #### Notes\n   * The tab bar will be attached to the parent if it exists.\n   */\n  private _createTabBar(): TabBar<Widget> {\n    // Create the tab bar using the renderer.\n    let tabBar = this.renderer.createTabBar(this._document);\n\n    // Enforce necessary tab bar behavior.\n    tabBar.orientation = 'horizontal';\n\n    // Attach the tab bar to the parent if possible.\n    if (this.parent) {\n      this.attachWidget(tabBar);\n    }\n\n    // Return the initialized tab bar.\n    return tabBar;\n  }\n\n  /**\n   * Create a new handle for the dock layout.\n   *\n   * #### Notes\n   * The handle will be attached to the parent if it exists.\n   */\n  private _createHandle(): HTMLDivElement {\n    // Create the handle using the renderer.\n    let handle = this.renderer.createHandle();\n\n    // Initialize the handle layout behavior.\n    let style = handle.style;\n    style.position = 'absolute';\n    style.contain = 'strict';\n    style.top = '0';\n    style.left = '0';\n    style.width = '0';\n    style.height = '0';\n\n    // Attach the handle to the parent if it exists.\n    if (this.parent) {\n      this.parent.node.appendChild(handle);\n    }\n\n    // Return the initialized handle.\n    return handle;\n  }\n\n  private _spacing = 4;\n  private _dirty = false;\n  private _root: Private.LayoutNode | null = null;\n  private _box: ElementExt.IBoxSizing | null = null;\n  private _document: Document | ShadowRoot;\n  private _hiddenMode: Widget.HiddenMode;\n  private _items: Private.ItemMap = new Map<Widget, LayoutItem>();\n}\n\n/**\n * The namespace for the `DockLayout` class statics.\n */\nexport namespace DockLayout {\n  /**\n   * An options object for creating a dock layout.\n   */\n  export interface IOptions {\n    /**\n     * The document to use with the dock panel.\n     *\n     * The default is the global `document` instance.\n     */\n    document?: Document | ShadowRoot;\n\n    /**\n     * The method for hiding widgets.\n     *\n     * The default is `Widget.HiddenMode.Display`.\n     */\n    hiddenMode?: Widget.HiddenMode;\n\n    /**\n     * The renderer to use for the dock layout.\n     */\n    renderer: IRenderer;\n\n    /**\n     * The spacing between items in the layout.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n  }\n\n  /**\n   * A renderer for use with a dock layout.\n   */\n  export interface IRenderer {\n    /**\n     * Create a new tab bar for use with a dock layout.\n     *\n     * @returns A new tab bar for a dock layout.\n     */\n    createTabBar(document?: Document | ShadowRoot): TabBar<Widget>;\n\n    /**\n     * Create a new handle node for use with a dock layout.\n     *\n     * @returns A new handle node for a dock layout.\n     */\n    createHandle(): HTMLDivElement;\n  }\n\n  /**\n   * A type alias for the supported insertion modes.\n   *\n   * An insert mode is used to specify how a widget should be added\n   * to the dock layout relative to a reference widget.\n   */\n  export type InsertMode =\n    | /**\n     * The area to the top of the reference widget.\n     *\n     * The widget will be inserted just above the reference widget.\n     *\n     * If the reference widget is null or invalid, the widget will be\n     * inserted at the top edge of the dock layout.\n     */\n    'split-top'\n\n    /**\n     * The area to the left of the reference widget.\n     *\n     * The widget will be inserted just left of the reference widget.\n     *\n     * If the reference widget is null or invalid, the widget will be\n     * inserted at the left edge of the dock layout.\n     */\n    | 'split-left'\n\n    /**\n     * The area to the right of the reference widget.\n     *\n     * The widget will be inserted just right of the reference widget.\n     *\n     * If the reference widget is null or invalid, the widget will be\n     * inserted  at the right edge of the dock layout.\n     */\n    | 'split-right'\n\n    /**\n     * The area to the bottom of the reference widget.\n     *\n     * The widget will be inserted just below the reference widget.\n     *\n     * If the reference widget is null or invalid, the widget will be\n     * inserted at the bottom edge of the dock layout.\n     */\n    | 'split-bottom'\n\n    /**\n     * Like `split-top` but if a tab layout exists above the reference widget,\n     * it behaves like `tab-after` with reference to that instead.\n     */\n    | 'merge-top'\n\n    /**\n     * Like `split-left` but if a tab layout exists left of the reference widget,\n     * it behaves like `tab-after` with reference to that instead.\n     */\n    | 'merge-left'\n\n    /**\n     * Like `split-right` but if a tab layout exists right of the reference widget,\n     * it behaves like `tab-after` with reference to that instead.\n     */\n    | 'merge-right'\n\n    /**\n     * Like `split-bottom` but if a tab layout exists below the reference widget,\n     * it behaves like `tab-after` with reference to that instead.\n     */\n    | 'merge-bottom'\n\n    /**\n     * The tab position before the reference widget.\n     *\n     * The widget will be added as a tab before the reference widget.\n     *\n     * If the reference widget is null or invalid, a sensible default\n     * will be used.\n     */\n    | 'tab-before'\n\n    /**\n     * The tab position after the reference widget.\n     *\n     * The widget will be added as a tab after the reference widget.\n     *\n     * If the reference widget is null or invalid, a sensible default\n     * will be used.\n     */\n    | 'tab-after';\n\n  /**\n   * An options object for adding a widget to the dock layout.\n   */\n  export interface IAddOptions {\n    /**\n     * The insertion mode for adding the widget.\n     *\n     * The default is `'tab-after'`.\n     */\n    mode?: InsertMode;\n\n    /**\n     * The reference widget for the insert location.\n     *\n     * The default is `null`.\n     */\n    ref?: Widget | null;\n  }\n\n  /**\n   * A layout config object for a tab area.\n   */\n  export interface ITabAreaConfig {\n    /**\n     * The discriminated type of the config object.\n     */\n    type: 'tab-area';\n\n    /**\n     * The widgets contained in the tab area.\n     */\n    widgets: Widget[];\n\n    /**\n     * The index of the selected tab.\n     */\n    currentIndex: number;\n  }\n\n  /**\n   * A layout config object for a split area.\n   */\n  export interface ISplitAreaConfig {\n    /**\n     * The discriminated type of the config object.\n     */\n    type: 'split-area';\n\n    /**\n     * The orientation of the split area.\n     */\n    orientation: 'horizontal' | 'vertical';\n\n    /**\n     * The children in the split area.\n     */\n    children: AreaConfig[];\n\n    /**\n     * The relative sizes of the children.\n     */\n    sizes: number[];\n  }\n\n  /**\n   * A type alias for a general area config.\n   */\n  export type AreaConfig = ITabAreaConfig | ISplitAreaConfig;\n\n  /**\n   * A dock layout configuration object.\n   */\n  export interface ILayoutConfig {\n    /**\n     * The layout config for the main dock area.\n     */\n    main: AreaConfig | null;\n  }\n\n  /**\n   * An object which represents the geometry of a tab area.\n   */\n  export interface ITabAreaGeometry {\n    /**\n     * The tab bar for the tab area.\n     */\n    tabBar: TabBar<Widget>;\n\n    /**\n     * The local X position of the hit test in the dock area.\n     *\n     * #### Notes\n     * This is the distance from the left edge of the layout parent\n     * widget, to the local X coordinate of the hit test query.\n     */\n    x: number;\n\n    /**\n     * The local Y position of the hit test in the dock area.\n     *\n     * #### Notes\n     * This is the distance from the top edge of the layout parent\n     * widget, to the local Y coordinate of the hit test query.\n     */\n    y: number;\n\n    /**\n     * The local coordinate of the top edge of the tab area.\n     *\n     * #### Notes\n     * This is the distance from the top edge of the layout parent\n     * widget, to the top edge of the tab area.\n     */\n    top: number;\n\n    /**\n     * The local coordinate of the left edge of the tab area.\n     *\n     * #### Notes\n     * This is the distance from the left edge of the layout parent\n     * widget, to the left edge of the tab area.\n     */\n    left: number;\n\n    /**\n     * The local coordinate of the right edge of the tab area.\n     *\n     * #### Notes\n     * This is the distance from the right edge of the layout parent\n     * widget, to the right edge of the tab area.\n     */\n    right: number;\n\n    /**\n     * The local coordinate of the bottom edge of the tab area.\n     *\n     * #### Notes\n     * This is the distance from the bottom edge of the layout parent\n     * widget, to the bottom edge of the tab area.\n     */\n    bottom: number;\n\n    /**\n     * The width of the tab area.\n     *\n     * #### Notes\n     * This is total width allocated for the tab area.\n     */\n    width: number;\n\n    /**\n     * The height of the tab area.\n     *\n     * #### Notes\n     * This is total height allocated for the tab area.\n     */\n    height: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n   */\n  export const GOLDEN_RATIO = 0.618;\n\n  /**\n   * A type alias for a dock layout node.\n   */\n  export type LayoutNode = TabLayoutNode | SplitLayoutNode;\n\n  /**\n   * A type alias for the orientation of a split layout node.\n   */\n  export type Orientation = 'horizontal' | 'vertical';\n\n  /**\n   * A type alias for a layout item map.\n   */\n  export type ItemMap = Map<Widget, LayoutItem>;\n\n  /**\n   * Create a box sizer with an initial size hint.\n   */\n  export function createSizer(hint: number): BoxSizer {\n    let sizer = new BoxSizer();\n    sizer.sizeHint = hint;\n    sizer.size = hint;\n    return sizer;\n  }\n\n  /**\n   * Normalize an area config object and collect the visited widgets.\n   */\n  export function normalizeAreaConfig(\n    config: DockLayout.AreaConfig,\n    widgetSet: Set<Widget>\n  ): DockLayout.AreaConfig | null {\n    let result: DockLayout.AreaConfig | null;\n    if (config.type === 'tab-area') {\n      result = normalizeTabAreaConfig(config, widgetSet);\n    } else {\n      result = normalizeSplitAreaConfig(config, widgetSet);\n    }\n    return result;\n  }\n\n  /**\n   * Convert a normalized area config into a layout tree.\n   */\n  export function realizeAreaConfig(\n    config: DockLayout.AreaConfig,\n    renderer: DockLayout.IRenderer,\n    document: Document | ShadowRoot\n  ): LayoutNode {\n    let node: LayoutNode;\n    if (config.type === 'tab-area') {\n      node = realizeTabAreaConfig(config, renderer, document);\n    } else {\n      node = realizeSplitAreaConfig(config, renderer, document);\n    }\n    return node;\n  }\n\n  /**\n   * A layout node which holds the data for a tabbed area.\n   */\n  export class TabLayoutNode {\n    /**\n     * Construct a new tab layout node.\n     *\n     * @param tabBar - The tab bar to use for the layout node.\n     */\n    constructor(tabBar: TabBar<Widget>) {\n      let tabSizer = new BoxSizer();\n      let widgetSizer = new BoxSizer();\n      tabSizer.stretch = 0;\n      widgetSizer.stretch = 1;\n      this.tabBar = tabBar;\n      this.sizers = [tabSizer, widgetSizer];\n    }\n\n    /**\n     * The parent of the layout node.\n     */\n    parent: SplitLayoutNode | null = null;\n\n    /**\n     * The tab bar for the layout node.\n     */\n    readonly tabBar: TabBar<Widget>;\n\n    /**\n     * The sizers for the layout node.\n     */\n    readonly sizers: [BoxSizer, BoxSizer];\n\n    /**\n     * The most recent value for the `top` edge of the layout box.\n     */\n    get top(): number {\n      return this._top;\n    }\n\n    /**\n     * The most recent value for the `left` edge of the layout box.\n     */\n    get left(): number {\n      return this._left;\n    }\n\n    /**\n     * The most recent value for the `width` of the layout box.\n     */\n    get width(): number {\n      return this._width;\n    }\n\n    /**\n     * The most recent value for the `height` of the layout box.\n     */\n    get height(): number {\n      return this._height;\n    }\n\n    /**\n     * Create an iterator for all widgets in the layout tree.\n     */\n    *iterAllWidgets(): IterableIterator<Widget> {\n      yield this.tabBar;\n      yield* this.iterUserWidgets();\n    }\n\n    /**\n     * Create an iterator for the user widgets in the layout tree.\n     */\n    *iterUserWidgets(): IterableIterator<Widget> {\n      for (const title of this.tabBar.titles) {\n        yield title.owner;\n      }\n    }\n\n    /**\n     * Create an iterator for the selected widgets in the layout tree.\n     */\n    *iterSelectedWidgets(): IterableIterator<Widget> {\n      let title = this.tabBar.currentTitle;\n      if (title) {\n        yield title.owner;\n      }\n    }\n\n    /**\n     * Create an iterator for the tab bars in the layout tree.\n     */\n    *iterTabBars(): IterableIterator<TabBar<Widget>> {\n      yield this.tabBar;\n    }\n\n    /**\n     * Create an iterator for the handles in the layout tree.\n     */\n    // eslint-disable-next-line require-yield\n    *iterHandles(): IterableIterator<HTMLDivElement> {\n      return;\n    }\n\n    /**\n     * Find the tab layout node which contains the given widget.\n     */\n    findTabNode(widget: Widget): TabLayoutNode | null {\n      return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;\n    }\n\n    /**\n     * Find the split layout node which contains the given handle.\n     */\n    findSplitNode(\n      handle: HTMLDivElement\n    ): { index: number; node: SplitLayoutNode } | null {\n      return null;\n    }\n\n    /**\n     * Find the first tab layout node in a layout tree.\n     */\n    findFirstTabNode(): TabLayoutNode | null {\n      return this;\n    }\n\n    /**\n     * Find the tab layout node which contains the local point.\n     */\n    hitTestTabNodes(x: number, y: number): TabLayoutNode | null {\n      if (x < this._left || x >= this._left + this._width) {\n        return null;\n      }\n      if (y < this._top || y >= this._top + this._height) {\n        return null;\n      }\n      return this;\n    }\n\n    /**\n     * Create a configuration object for the layout tree.\n     */\n    createConfig(): DockLayout.ITabAreaConfig {\n      let widgets = this.tabBar.titles.map(title => title.owner);\n      let currentIndex = this.tabBar.currentIndex;\n      return { type: 'tab-area', widgets, currentIndex };\n    }\n\n    /**\n     * Recursively hold all of the sizes in the layout tree.\n     *\n     * This ignores the sizers of tab layout nodes.\n     */\n    holdAllSizes(): void {\n      return;\n    }\n\n    /**\n     * Fit the layout tree.\n     */\n    fit(spacing: number, items: ItemMap): ElementExt.ISizeLimits {\n      // Set up the limit variables.\n      let minWidth = 0;\n      let minHeight = 0;\n      let maxWidth = Infinity;\n      let maxHeight = Infinity;\n\n      // Lookup the tab bar layout item.\n      let tabBarItem = items.get(this.tabBar);\n\n      // Lookup the widget layout item.\n      let current = this.tabBar.currentTitle;\n      let widgetItem = current ? items.get(current.owner) : undefined;\n\n      // Lookup the tab bar and widget sizers.\n      let [tabBarSizer, widgetSizer] = this.sizers;\n\n      // Update the tab bar limits.\n      if (tabBarItem) {\n        tabBarItem.fit();\n      }\n\n      // Update the widget limits.\n      if (widgetItem) {\n        widgetItem.fit();\n      }\n\n      // Update the results and sizer for the tab bar.\n      if (tabBarItem && !tabBarItem.isHidden) {\n        minWidth = Math.max(minWidth, tabBarItem.minWidth);\n        minHeight += tabBarItem.minHeight;\n        tabBarSizer.minSize = tabBarItem.minHeight;\n        tabBarSizer.maxSize = tabBarItem.maxHeight;\n      } else {\n        tabBarSizer.minSize = 0;\n        tabBarSizer.maxSize = 0;\n      }\n\n      // Update the results and sizer for the current widget.\n      if (widgetItem && !widgetItem.isHidden) {\n        minWidth = Math.max(minWidth, widgetItem.minWidth);\n        minHeight += widgetItem.minHeight;\n        widgetSizer.minSize = widgetItem.minHeight;\n        widgetSizer.maxSize = Infinity;\n      } else {\n        widgetSizer.minSize = 0;\n        widgetSizer.maxSize = Infinity;\n      }\n\n      // Return the computed size limits for the layout node.\n      return { minWidth, minHeight, maxWidth, maxHeight };\n    }\n\n    /**\n     * Update the layout tree.\n     */\n    update(\n      left: number,\n      top: number,\n      width: number,\n      height: number,\n      spacing: number,\n      items: ItemMap\n    ): void {\n      // Update the layout box values.\n      this._top = top;\n      this._left = left;\n      this._width = width;\n      this._height = height;\n\n      // Lookup the tab bar layout item.\n      let tabBarItem = items.get(this.tabBar);\n\n      // Lookup the widget layout item.\n      let current = this.tabBar.currentTitle;\n      let widgetItem = current ? items.get(current.owner) : undefined;\n\n      // Distribute the layout space to the sizers.\n      BoxEngine.calc(this.sizers, height);\n\n      // Update the tab bar item using the computed size.\n      if (tabBarItem && !tabBarItem.isHidden) {\n        let size = this.sizers[0].size;\n        tabBarItem.update(left, top, width, size);\n        top += size;\n      }\n\n      // Layout the widget using the computed size.\n      if (widgetItem && !widgetItem.isHidden) {\n        let size = this.sizers[1].size;\n        widgetItem.update(left, top, width, size);\n      }\n    }\n\n    private _top = 0;\n    private _left = 0;\n    private _width = 0;\n    private _height = 0;\n  }\n\n  /**\n   * A layout node which holds the data for a split area.\n   */\n  export class SplitLayoutNode {\n    /**\n     * Construct a new split layout node.\n     *\n     * @param orientation - The orientation of the node.\n     */\n    constructor(orientation: Orientation) {\n      this.orientation = orientation;\n    }\n\n    /**\n     * The parent of the layout node.\n     */\n    parent: SplitLayoutNode | null = null;\n\n    /**\n     * Whether the sizers have been normalized.\n     */\n    normalized = false;\n\n    /**\n     * The orientation of the node.\n     */\n    readonly orientation: Orientation;\n\n    /**\n     * The child nodes for the split node.\n     */\n    readonly children: LayoutNode[] = [];\n\n    /**\n     * The box sizers for the layout children.\n     */\n    readonly sizers: BoxSizer[] = [];\n\n    /**\n     * The handles for the layout children.\n     */\n    readonly handles: HTMLDivElement[] = [];\n\n    /**\n     * Create an iterator for all widgets in the layout tree.\n     */\n    *iterAllWidgets(): IterableIterator<Widget> {\n      for (const child of this.children) {\n        yield* child.iterAllWidgets();\n      }\n    }\n\n    /**\n     * Create an iterator for the user widgets in the layout tree.\n     */\n    *iterUserWidgets(): IterableIterator<Widget> {\n      for (const child of this.children) {\n        yield* child.iterUserWidgets();\n      }\n    }\n\n    /**\n     * Create an iterator for the selected widgets in the layout tree.\n     */\n    *iterSelectedWidgets(): IterableIterator<Widget> {\n      for (const child of this.children) {\n        yield* child.iterSelectedWidgets();\n      }\n    }\n\n    /**\n     * Create an iterator for the tab bars in the layout tree.\n     */\n    *iterTabBars(): IterableIterator<TabBar<Widget>> {\n      for (const child of this.children) {\n        yield* child.iterTabBars();\n      }\n    }\n\n    /**\n     * Create an iterator for the handles in the layout tree.\n     */\n    *iterHandles(): IterableIterator<HTMLDivElement> {\n      yield* this.handles;\n      for (const child of this.children) {\n        yield* child.iterHandles();\n      }\n    }\n\n    /**\n     * Find the tab layout node which contains the given widget.\n     */\n    findTabNode(widget: Widget): TabLayoutNode | null {\n      for (let i = 0, n = this.children.length; i < n; ++i) {\n        let result = this.children[i].findTabNode(widget);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Find the split layout node which contains the given handle.\n     */\n    findSplitNode(\n      handle: HTMLDivElement\n    ): { index: number; node: SplitLayoutNode } | null {\n      let index = this.handles.indexOf(handle);\n      if (index !== -1) {\n        return { index, node: this };\n      }\n      for (let i = 0, n = this.children.length; i < n; ++i) {\n        let result = this.children[i].findSplitNode(handle);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Find the first tab layout node in a layout tree.\n     */\n    findFirstTabNode(): TabLayoutNode | null {\n      if (this.children.length === 0) {\n        return null;\n      }\n      return this.children[0].findFirstTabNode();\n    }\n\n    /**\n     * Find the tab layout node which contains the local point.\n     */\n    hitTestTabNodes(x: number, y: number): TabLayoutNode | null {\n      for (let i = 0, n = this.children.length; i < n; ++i) {\n        let result = this.children[i].hitTestTabNodes(x, y);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Create a configuration object for the layout tree.\n     */\n    createConfig(): DockLayout.ISplitAreaConfig {\n      let orientation = this.orientation;\n      let sizes = this.createNormalizedSizes();\n      let children = this.children.map(child => child.createConfig());\n      return { type: 'split-area', orientation, children, sizes };\n    }\n\n    /**\n     * Sync the visibility and orientation of the handles.\n     */\n    syncHandles(): void {\n      this.handles.forEach((handle, i) => {\n        handle.setAttribute('data-orientation', this.orientation);\n        if (i === this.handles.length - 1) {\n          handle.classList.add('lm-mod-hidden');\n        } else {\n          handle.classList.remove('lm-mod-hidden');\n        }\n      });\n    }\n\n    /**\n     * Hold the current sizes of the box sizers.\n     *\n     * This sets the size hint of each sizer to its current size.\n     */\n    holdSizes(): void {\n      for (const sizer of this.sizers) {\n        sizer.sizeHint = sizer.size;\n      }\n    }\n\n    /**\n     * Recursively hold all of the sizes in the layout tree.\n     *\n     * This ignores the sizers of tab layout nodes.\n     */\n    holdAllSizes(): void {\n      for (const child of this.children) {\n        child.holdAllSizes();\n      }\n      this.holdSizes();\n    }\n\n    /**\n     * Normalize the sizes of the split layout node.\n     */\n    normalizeSizes(): void {\n      // Bail early if the sizers are empty.\n      let n = this.sizers.length;\n      if (n === 0) {\n        return;\n      }\n\n      // Hold the current sizes of the sizers.\n      this.holdSizes();\n\n      // Compute the sum of the sizes.\n      let sum = this.sizers.reduce((v, sizer) => v + sizer.sizeHint, 0);\n\n      // Normalize the sizes based on the sum.\n      if (sum === 0) {\n        for (const sizer of this.sizers) {\n          sizer.size = sizer.sizeHint = 1 / n;\n        }\n      } else {\n        for (const sizer of this.sizers) {\n          sizer.size = sizer.sizeHint /= sum;\n        }\n      }\n\n      // Mark the sizes as normalized.\n      this.normalized = true;\n    }\n\n    /**\n     * Snap the normalized sizes of the split layout node.\n     */\n    createNormalizedSizes(): number[] {\n      // Bail early if the sizers are empty.\n      let n = this.sizers.length;\n      if (n === 0) {\n        return [];\n      }\n\n      // Grab the current sizes of the sizers.\n      let sizes = this.sizers.map(sizer => sizer.size);\n\n      // Compute the sum of the sizes.\n      let sum = sizes.reduce((v, size) => v + size, 0);\n\n      // Normalize the sizes based on the sum.\n      if (sum === 0) {\n        for (let i = sizes.length - 1; i > -1; i--) {\n          sizes[i] = 1 / n;\n        }\n      } else {\n        for (let i = sizes.length - 1; i > -1; i--) {\n          sizes[i] /= sum;\n        }\n      }\n\n      // Return the normalized sizes.\n      return sizes;\n    }\n\n    /**\n     * Fit the layout tree.\n     */\n    fit(spacing: number, items: ItemMap): ElementExt.ISizeLimits {\n      // Compute the required fixed space.\n      let horizontal = this.orientation === 'horizontal';\n      let fixed = Math.max(0, this.children.length - 1) * spacing;\n\n      // Set up the limit variables.\n      let minWidth = horizontal ? fixed : 0;\n      let minHeight = horizontal ? 0 : fixed;\n      let maxWidth = Infinity;\n      let maxHeight = Infinity;\n\n      // Fit the children and update the limits.\n      for (let i = 0, n = this.children.length; i < n; ++i) {\n        let limits = this.children[i].fit(spacing, items);\n        if (horizontal) {\n          minHeight = Math.max(minHeight, limits.minHeight);\n          minWidth += limits.minWidth;\n          this.sizers[i].minSize = limits.minWidth;\n        } else {\n          minWidth = Math.max(minWidth, limits.minWidth);\n          minHeight += limits.minHeight;\n          this.sizers[i].minSize = limits.minHeight;\n        }\n      }\n\n      // Return the computed limits for the layout node.\n      return { minWidth, minHeight, maxWidth, maxHeight };\n    }\n\n    /**\n     * Update the layout tree.\n     */\n    update(\n      left: number,\n      top: number,\n      width: number,\n      height: number,\n      spacing: number,\n      items: ItemMap\n    ): void {\n      // Compute the available layout space.\n      let horizontal = this.orientation === 'horizontal';\n      let fixed = Math.max(0, this.children.length - 1) * spacing;\n      let space = Math.max(0, (horizontal ? width : height) - fixed);\n\n      // De-normalize the sizes if needed.\n      if (this.normalized) {\n        for (const sizer of this.sizers) {\n          sizer.sizeHint *= space;\n        }\n        this.normalized = false;\n      }\n\n      // Distribute the layout space to the sizers.\n      BoxEngine.calc(this.sizers, space);\n\n      // Update the geometry of the child nodes and handles.\n      for (let i = 0, n = this.children.length; i < n; ++i) {\n        let child = this.children[i];\n        let size = this.sizers[i].size;\n        let handleStyle = this.handles[i].style;\n        if (horizontal) {\n          child.update(left, top, size, height, spacing, items);\n          left += size;\n          handleStyle.top = `${top}px`;\n          handleStyle.left = `${left}px`;\n          handleStyle.width = `${spacing}px`;\n          handleStyle.height = `${height}px`;\n          left += spacing;\n        } else {\n          child.update(left, top, width, size, spacing, items);\n          top += size;\n          handleStyle.top = `${top}px`;\n          handleStyle.left = `${left}px`;\n          handleStyle.width = `${width}px`;\n          handleStyle.height = `${spacing}px`;\n          top += spacing;\n        }\n      }\n    }\n  }\n\n  export function addAria(widget: Widget, tabBar: TabBar<Widget>): void {\n    widget.node.setAttribute('role', 'tabpanel');\n    let renderer = tabBar.renderer;\n    if (renderer instanceof TabBar.Renderer) {\n      let tabId = renderer.createTabKey({\n        title: widget.title,\n        current: false,\n        zIndex: 0\n      });\n      widget.node.setAttribute('aria-labelledby', tabId);\n    }\n  }\n\n  export function removeAria(widget: Widget): void {\n    widget.node.removeAttribute('role');\n    widget.node.removeAttribute('aria-labelledby');\n  }\n\n  /**\n   * Normalize a tab area config and collect the visited widgets.\n   */\n  function normalizeTabAreaConfig(\n    config: DockLayout.ITabAreaConfig,\n    widgetSet: Set<Widget>\n  ): DockLayout.ITabAreaConfig | null {\n    // Bail early if there is no content.\n    if (config.widgets.length === 0) {\n      return null;\n    }\n\n    // Setup the filtered widgets array.\n    let widgets: Widget[] = [];\n\n    // Filter the config for unique widgets.\n    for (const widget of config.widgets) {\n      if (!widgetSet.has(widget)) {\n        widgetSet.add(widget);\n        widgets.push(widget);\n      }\n    }\n\n    // Bail if there are no effective widgets.\n    if (widgets.length === 0) {\n      return null;\n    }\n\n    // Normalize the current index.\n    let index = config.currentIndex;\n    if (index !== -1 && (index < 0 || index >= widgets.length)) {\n      index = 0;\n    }\n\n    // Return a normalized config object.\n    return { type: 'tab-area', widgets, currentIndex: index };\n  }\n\n  /**\n   * Normalize a split area config and collect the visited widgets.\n   */\n  function normalizeSplitAreaConfig(\n    config: DockLayout.ISplitAreaConfig,\n    widgetSet: Set<Widget>\n  ): DockLayout.AreaConfig | null {\n    // Set up the result variables.\n    let orientation = config.orientation;\n    let children: DockLayout.AreaConfig[] = [];\n    let sizes: number[] = [];\n\n    // Normalize the config children.\n    for (let i = 0, n = config.children.length; i < n; ++i) {\n      // Normalize the child config.\n      let child = normalizeAreaConfig(config.children[i], widgetSet);\n\n      // Ignore an empty child.\n      if (!child) {\n        continue;\n      }\n\n      // Add the child or hoist its content as appropriate.\n      if (child.type === 'tab-area' || child.orientation !== orientation) {\n        children.push(child);\n        sizes.push(Math.abs(config.sizes[i] || 0));\n      } else {\n        children.push(...child.children);\n        sizes.push(...child.sizes);\n      }\n    }\n\n    // Bail if there are no effective children.\n    if (children.length === 0) {\n      return null;\n    }\n\n    // If there is only one effective child, return that child.\n    if (children.length === 1) {\n      return children[0];\n    }\n\n    // Return a normalized config object.\n    return { type: 'split-area', orientation, children, sizes };\n  }\n\n  /**\n   * Convert a normalized tab area config into a layout tree.\n   */\n  function realizeTabAreaConfig(\n    config: DockLayout.ITabAreaConfig,\n    renderer: DockLayout.IRenderer,\n    document: Document | ShadowRoot\n  ): TabLayoutNode {\n    // Create the tab bar for the layout node.\n    let tabBar = renderer.createTabBar(document);\n\n    // Hide each widget and add it to the tab bar.\n    for (const widget of config.widgets) {\n      widget.hide();\n      tabBar.addTab(widget.title);\n      Private.addAria(widget, tabBar);\n    }\n\n    // Set the current index of the tab bar.\n    tabBar.currentIndex = config.currentIndex;\n\n    // Return the new tab layout node.\n    return new TabLayoutNode(tabBar);\n  }\n\n  /**\n   * Convert a normalized split area config into a layout tree.\n   */\n  function realizeSplitAreaConfig(\n    config: DockLayout.ISplitAreaConfig,\n    renderer: DockLayout.IRenderer,\n    document: Document | ShadowRoot\n  ): SplitLayoutNode {\n    // Create the split layout node.\n    let node = new SplitLayoutNode(config.orientation);\n\n    // Add each child to the layout node.\n    config.children.forEach((child, i) => {\n      // Create the child data for the layout node.\n      let childNode = realizeAreaConfig(child, renderer, document);\n      let sizer = createSizer(config.sizes[i]);\n      let handle = renderer.createHandle();\n\n      // Add the child data to the layout node.\n      node.children.push(childNode);\n      node.handles.push(handle);\n      node.sizers.push(sizer);\n\n      // Update the parent for the child node.\n      childNode.parent = node;\n    });\n\n    // Synchronize the handle state for the layout node.\n    node.syncHandles();\n\n    // Normalize the sizes for the layout node.\n    node.normalizeSizes();\n\n    // Return the new layout node.\n    return node;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { find } from '@lumino/algorithm';\n\nimport { MimeData } from '@lumino/coreutils';\n\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ElementExt, Platform } from '@lumino/domutils';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { ConflatableMessage, Message, MessageLoop } from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { DockLayout } from './docklayout';\n\nimport { TabBar } from './tabbar';\n\nimport { Widget } from './widget';\n\n/**\n * A widget which provides a flexible docking area for widgets.\n */\nexport class DockPanel extends Widget {\n  /**\n   * Construct a new dock panel.\n   *\n   * @param options - The options for initializing the panel.\n   */\n  constructor(options: DockPanel.IOptions = {}) {\n    super();\n    this.addClass('lm-DockPanel');\n    this._document = options.document || document;\n    this._mode = options.mode || 'multiple-document';\n    this._renderer = options.renderer || DockPanel.defaultRenderer;\n    this._edges = options.edges || Private.DEFAULT_EDGES;\n    if (options.tabsMovable !== undefined) {\n      this._tabsMovable = options.tabsMovable;\n    }\n    if (options.tabsConstrained !== undefined) {\n      this._tabsConstrained = options.tabsConstrained;\n    }\n    if (options.addButtonEnabled !== undefined) {\n      this._addButtonEnabled = options.addButtonEnabled;\n    }\n\n    // Toggle the CSS mode attribute.\n    this.dataset['mode'] = this._mode;\n\n    // Create the delegate renderer for the layout.\n    let renderer: DockPanel.IRenderer = {\n      createTabBar: () => this._createTabBar(),\n      createHandle: () => this._createHandle()\n    };\n\n    // Set up the dock layout for the panel.\n    this.layout = new DockLayout({\n      document: this._document,\n      renderer,\n      spacing: options.spacing,\n      hiddenMode: options.hiddenMode\n    });\n\n    // Set up the overlay drop indicator.\n    this.overlay = options.overlay || new DockPanel.Overlay();\n    this.node.appendChild(this.overlay.node);\n  }\n\n  /**\n   * Dispose of the resources held by the panel.\n   */\n  dispose(): void {\n    // Ensure the mouse is released.\n    this._releaseMouse();\n\n    // Hide the overlay.\n    this.overlay.hide(0);\n\n    // Cancel a drag if one is in progress.\n    if (this._drag) {\n      this._drag.dispose();\n    }\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * The method for hiding widgets.\n   */\n  get hiddenMode(): Widget.HiddenMode {\n    return (this.layout as DockLayout).hiddenMode;\n  }\n\n  /**\n   * Set the method for hiding widgets.\n   */\n  set hiddenMode(v: Widget.HiddenMode) {\n    (this.layout as DockLayout).hiddenMode = v;\n  }\n\n  /**\n   * A signal emitted when the layout configuration is modified.\n   *\n   * #### Notes\n   * This signal is emitted whenever the current layout configuration\n   * may have changed.\n   *\n   * This signal is emitted asynchronously in a collapsed fashion, so\n   * that multiple synchronous modifications results in only a single\n   * emit of the signal.\n   */\n  get layoutModified(): ISignal<this, void> {\n    return this._layoutModified;\n  }\n\n  /**\n   * A signal emitted when the add button on a tab bar is clicked.\n   *\n   */\n  get addRequested(): ISignal<this, TabBar<Widget>> {\n    return this._addRequested;\n  }\n\n  /**\n   * The overlay used by the dock panel.\n   */\n  readonly overlay: DockPanel.IOverlay;\n\n  /**\n   * The renderer used by the dock panel.\n   */\n  get renderer(): DockPanel.IRenderer {\n    return (this.layout as DockLayout).renderer;\n  }\n\n  /**\n   * Get the spacing between the widgets.\n   */\n  get spacing(): number {\n    return (this.layout as DockLayout).spacing;\n  }\n\n  /**\n   * Set the spacing between the widgets.\n   */\n  set spacing(value: number) {\n    (this.layout as DockLayout).spacing = value;\n  }\n\n  /**\n   * Get the mode for the dock panel.\n   */\n  get mode(): DockPanel.Mode {\n    return this._mode;\n  }\n\n  /**\n   * Set the mode for the dock panel.\n   *\n   * #### Notes\n   * Changing the mode is a destructive operation with respect to the\n   * panel's layout configuration. If layout state must be preserved,\n   * save the current layout config before changing the mode.\n   */\n  set mode(value: DockPanel.Mode) {\n    // Bail early if the mode does not change.\n    if (this._mode === value) {\n      return;\n    }\n\n    // Update the internal mode.\n    this._mode = value;\n\n    // Toggle the CSS mode attribute.\n    this.dataset['mode'] = value;\n\n    // Get the layout for the panel.\n    let layout = this.layout as DockLayout;\n\n    // Configure the layout for the specified mode.\n    switch (value) {\n      case 'multiple-document':\n        for (const tabBar of layout.tabBars()) {\n          tabBar.show();\n        }\n        break;\n      case 'single-document':\n        layout.restoreLayout(Private.createSingleDocumentConfig(this));\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Whether the tabs can be dragged / moved at runtime.\n   */\n  get tabsMovable(): boolean {\n    return this._tabsMovable;\n  }\n\n  /**\n   * Enable / Disable draggable / movable tabs.\n   */\n  set tabsMovable(value: boolean) {\n    this._tabsMovable = value;\n    for (const tabBar of this.tabBars()) {\n      tabBar.tabsMovable = value;\n    }\n  }\n\n  /**\n   * Whether the tabs are constrained to their source dock panel\n   */\n  get tabsConstrained(): boolean {\n    return this._tabsConstrained;\n  }\n\n  /**\n   * Constrain/Allow tabs to be dragged outside of this dock panel\n   */\n  set tabsConstrained(value: boolean) {\n    this._tabsConstrained = value;\n  }\n\n  /**\n   * Whether the add buttons for each tab bar are enabled.\n   */\n  get addButtonEnabled(): boolean {\n    return this._addButtonEnabled;\n  }\n\n  /**\n   * Set whether the add buttons for each tab bar are enabled.\n   */\n  set addButtonEnabled(value: boolean) {\n    this._addButtonEnabled = value;\n    for (const tabBar of this.tabBars()) {\n      tabBar.addButtonEnabled = value;\n    }\n  }\n\n  /**\n   * Whether the dock panel is empty.\n   */\n  get isEmpty(): boolean {\n    return (this.layout as DockLayout).isEmpty;\n  }\n\n  /**\n   * Create an iterator over the user widgets in the panel.\n   *\n   * @returns A new iterator over the user widgets in the panel.\n   *\n   * #### Notes\n   * This iterator does not include the generated tab bars.\n   */\n  *widgets(): IterableIterator<Widget> {\n    yield* (this.layout as DockLayout).widgets();\n  }\n\n  /**\n   * Create an iterator over the selected widgets in the panel.\n   *\n   * @returns A new iterator over the selected user widgets.\n   *\n   * #### Notes\n   * This iterator yields the widgets corresponding to the current tab\n   * of each tab bar in the panel.\n   */\n  *selectedWidgets(): IterableIterator<Widget> {\n    yield* (this.layout as DockLayout).selectedWidgets();\n  }\n\n  /**\n   * Create an iterator over the tab bars in the panel.\n   *\n   * @returns A new iterator over the tab bars in the panel.\n   *\n   * #### Notes\n   * This iterator does not include the user widgets.\n   */\n  *tabBars(): IterableIterator<TabBar<Widget>> {\n    yield* (this.layout as DockLayout).tabBars();\n  }\n\n  /**\n   * Create an iterator over the handles in the panel.\n   *\n   * @returns A new iterator over the handles in the panel.\n   */\n  *handles(): IterableIterator<HTMLDivElement> {\n    yield* (this.layout as DockLayout).handles();\n  }\n\n  /**\n   * Select a specific widget in the dock panel.\n   *\n   * @param widget - The widget of interest.\n   *\n   * #### Notes\n   * This will make the widget the current widget in its tab area.\n   */\n  selectWidget(widget: Widget): void {\n    // Find the tab bar which contains the widget.\n    let tabBar = find(this.tabBars(), bar => {\n      return bar.titles.indexOf(widget.title) !== -1;\n    });\n\n    // Throw an error if no tab bar is found.\n    if (!tabBar) {\n      throw new Error('Widget is not contained in the dock panel.');\n    }\n\n    // Ensure the widget is the current widget.\n    tabBar.currentTitle = widget.title;\n  }\n\n  /**\n   * Activate a specified widget in the dock panel.\n   *\n   * @param widget - The widget of interest.\n   *\n   * #### Notes\n   * This will select and activate the given widget.\n   */\n  activateWidget(widget: Widget): void {\n    this.selectWidget(widget);\n    widget.activate();\n  }\n\n  /**\n   * Save the current layout configuration of the dock panel.\n   *\n   * @returns A new config object for the current layout state.\n   *\n   * #### Notes\n   * The return value can be provided to the `restoreLayout` method\n   * in order to restore the layout to its current configuration.\n   */\n  saveLayout(): DockPanel.ILayoutConfig {\n    return (this.layout as DockLayout).saveLayout();\n  }\n\n  /**\n   * Restore the layout to a previously saved configuration.\n   *\n   * @param config - The layout configuration to restore.\n   *\n   * #### Notes\n   * Widgets which currently belong to the layout but which are not\n   * contained in the config will be unparented.\n   *\n   * The dock panel automatically reverts to `'multiple-document'`\n   * mode when a layout config is restored.\n   */\n  restoreLayout(config: DockPanel.ILayoutConfig): void {\n    // Reset the mode.\n    this._mode = 'multiple-document';\n\n    // Restore the layout.\n    (this.layout as DockLayout).restoreLayout(config);\n\n    // Flush the message loop on IE and Edge to prevent flicker.\n    if (Platform.IS_EDGE || Platform.IS_IE) {\n      MessageLoop.flush();\n    }\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Add a widget to the dock panel.\n   *\n   * @param widget - The widget to add to the dock panel.\n   *\n   * @param options - The additional options for adding the widget.\n   *\n   * #### Notes\n   * If the panel is in single document mode, the options are ignored\n   * and the widget is always added as tab in the hidden tab bar.\n   */\n  addWidget(widget: Widget, options: DockPanel.IAddOptions = {}): void {\n    // Add the widget to the layout.\n    if (this._mode === 'single-document') {\n      (this.layout as DockLayout).addWidget(widget);\n    } else {\n      (this.layout as DockLayout).addWidget(widget, options);\n    }\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   */\n  processMessage(msg: Message): void {\n    if (msg.type === 'layout-modified') {\n      this._layoutModified.emit(undefined);\n    } else {\n      super.processMessage(msg);\n    }\n  }\n\n  /**\n   * Handle the DOM events for the dock panel.\n   *\n   * @param event - The DOM event sent to the panel.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the panel's DOM node. It should\n   * not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'lm-dragenter':\n        this._evtDragEnter(event as Drag.Event);\n        break;\n      case 'lm-dragleave':\n        this._evtDragLeave(event as Drag.Event);\n        break;\n      case 'lm-dragover':\n        this._evtDragOver(event as Drag.Event);\n        break;\n      case 'lm-drop':\n        this._evtDrop(event as Drag.Event);\n        break;\n      case 'pointerdown':\n        this._evtPointerDown(event as PointerEvent);\n        break;\n      case 'pointermove':\n        this._evtPointerMove(event as PointerEvent);\n        break;\n      case 'pointerup':\n        this._evtPointerUp(event as PointerEvent);\n        break;\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('lm-dragenter', this);\n    this.node.addEventListener('lm-dragleave', this);\n    this.node.addEventListener('lm-dragover', this);\n    this.node.addEventListener('lm-drop', this);\n    this.node.addEventListener('pointerdown', this);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('lm-dragenter', this);\n    this.node.removeEventListener('lm-dragleave', this);\n    this.node.removeEventListener('lm-dragover', this);\n    this.node.removeEventListener('lm-drop', this);\n    this.node.removeEventListener('pointerdown', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'child-added'` message.\n   */\n  protected onChildAdded(msg: Widget.ChildMessage): void {\n    // Ignore the generated tab bars.\n    if (Private.isGeneratedTabBarProperty.get(msg.child)) {\n      return;\n    }\n\n    // Add the widget class to the child.\n    msg.child.addClass('lm-DockPanel-widget');\n  }\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    // Ignore the generated tab bars.\n    if (Private.isGeneratedTabBarProperty.get(msg.child)) {\n      return;\n    }\n\n    // Remove the widget class from the child.\n    msg.child.removeClass('lm-DockPanel-widget');\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Handle the `'lm-dragenter'` event for the dock panel.\n   */\n  private _evtDragEnter(event: Drag.Event): void {\n    // If the factory mime type is present, mark the event as\n    // handled in order to get the rest of the drag events.\n    if (event.mimeData.hasData('application/vnd.lumino.widget-factory')) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Handle the `'lm-dragleave'` event for the dock panel.\n   */\n  private _evtDragLeave(event: Drag.Event): void {\n    // Mark the event as handled.\n    event.preventDefault();\n\n    if (this._tabsConstrained && event.source !== this) return;\n\n    event.stopPropagation();\n\n    // The new target might be a descendant, so we might still handle the drop.\n    // Hide asynchronously so that if a lm-dragover event bubbles up to us, the\n    // hide is cancelled by the lm-dragover handler's show overlay logic.\n    this.overlay.hide(1);\n  }\n\n  /**\n   * Handle the `'lm-dragover'` event for the dock panel.\n   */\n  private _evtDragOver(event: Drag.Event): void {\n    // Mark the event as handled.\n    event.preventDefault();\n\n    // Show the drop indicator overlay and update the drop\n    // action based on the drop target zone under the mouse.\n    if (\n      (this._tabsConstrained && event.source !== this) ||\n      this._showOverlay(event.clientX, event.clientY) === 'invalid'\n    ) {\n      event.dropAction = 'none';\n    } else {\n      event.stopPropagation();\n      event.dropAction = event.proposedAction;\n    }\n  }\n\n  /**\n   * Handle the `'lm-drop'` event for the dock panel.\n   */\n  private _evtDrop(event: Drag.Event): void {\n    // Mark the event as handled.\n    event.preventDefault();\n\n    // Hide the drop indicator overlay.\n    this.overlay.hide(0);\n\n    // Bail if the proposed action is to do nothing.\n    if (event.proposedAction === 'none') {\n      event.dropAction = 'none';\n      return;\n    }\n\n    // Find the drop target under the mouse.\n    let { clientX, clientY } = event;\n    let { zone, target } = Private.findDropTarget(\n      this,\n      clientX,\n      clientY,\n      this._edges\n    );\n\n    // Bail if the drop zone is invalid.\n    if (\n      (this._tabsConstrained && event.source !== this) ||\n      zone === 'invalid'\n    ) {\n      event.dropAction = 'none';\n      return;\n    }\n\n    // Bail if the factory mime type has invalid data.\n    let mimeData = event.mimeData;\n    let factory = mimeData.getData('application/vnd.lumino.widget-factory');\n    if (typeof factory !== 'function') {\n      event.dropAction = 'none';\n      return;\n    }\n\n    // Bail if the factory does not produce a widget.\n    let widget = factory();\n    if (!(widget instanceof Widget)) {\n      event.dropAction = 'none';\n      return;\n    }\n\n    // Bail if the widget is an ancestor of the dock panel.\n    if (widget.contains(this)) {\n      event.dropAction = 'none';\n      return;\n    }\n\n    // Find the reference widget for the drop target.\n    let ref = target ? Private.getDropRef(target.tabBar) : null;\n\n    // Add the widget according to the indicated drop zone.\n    switch (zone) {\n      case 'root-all':\n        this.addWidget(widget);\n        break;\n      case 'root-top':\n        this.addWidget(widget, { mode: 'split-top' });\n        break;\n      case 'root-left':\n        this.addWidget(widget, { mode: 'split-left' });\n        break;\n      case 'root-right':\n        this.addWidget(widget, { mode: 'split-right' });\n        break;\n      case 'root-bottom':\n        this.addWidget(widget, { mode: 'split-bottom' });\n        break;\n      case 'widget-all':\n        this.addWidget(widget, { mode: 'tab-after', ref });\n        break;\n      case 'widget-top':\n        this.addWidget(widget, { mode: 'split-top', ref });\n        break;\n      case 'widget-left':\n        this.addWidget(widget, { mode: 'split-left', ref });\n        break;\n      case 'widget-right':\n        this.addWidget(widget, { mode: 'split-right', ref });\n        break;\n      case 'widget-bottom':\n        this.addWidget(widget, { mode: 'split-bottom', ref });\n        break;\n      case 'widget-tab':\n        this.addWidget(widget, { mode: 'tab-after', ref });\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Accept the proposed drop action.\n    event.dropAction = event.proposedAction;\n\n    // Stop propagation if we have not bailed so far.\n    event.stopPropagation();\n\n    // Activate the dropped widget.\n    this.activateWidget(widget);\n  }\n\n  /**\n   * Handle the `'keydown'` event for the dock panel.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Stop input events during drag.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Release the mouse if `Escape` is pressed.\n    if (event.keyCode === 27) {\n      // Finalize the mouse release.\n      this._releaseMouse();\n\n      // Schedule an emit of the layout modified signal.\n      MessageLoop.postMessage(this, Private.LayoutModified);\n    }\n  }\n\n  /**\n   * Handle the `'pointerdown'` event for the dock panel.\n   */\n  private _evtPointerDown(event: PointerEvent): void {\n    // Do nothing if the left mouse button is not pressed.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Find the handle which contains the mouse target, if any.\n    let layout = this.layout as DockLayout;\n    let target = event.target as HTMLElement;\n    let handle = find(layout.handles(), handle => handle.contains(target));\n    if (!handle) {\n      return;\n    }\n\n    // Stop the event when a handle is pressed.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    this._document.addEventListener('keydown', this, true);\n    this._document.addEventListener('pointerup', this, true);\n    this._document.addEventListener('pointermove', this, true);\n    this._document.addEventListener('contextmenu', this, true);\n\n    // Compute the offset deltas for the handle press.\n    let rect = handle.getBoundingClientRect();\n    let deltaX = event.clientX - rect.left;\n    let deltaY = event.clientY - rect.top;\n\n    // Override the cursor and store the press data.\n    let style = window.getComputedStyle(handle);\n    let override = Drag.overrideCursor(style.cursor!, this._document);\n    this._pressData = { handle, deltaX, deltaY, override };\n  }\n\n  /**\n   * Handle the `'pointermove'` event for the dock panel.\n   */\n  private _evtPointerMove(event: PointerEvent): void {\n    // Bail early if no drag is in progress.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Stop the event when dragging a handle.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Compute the desired offset position for the handle.\n    let rect = this.node.getBoundingClientRect();\n    let xPos = event.clientX - rect.left - this._pressData.deltaX;\n    let yPos = event.clientY - rect.top - this._pressData.deltaY;\n\n    // Set the handle as close to the desired position as possible.\n    let layout = this.layout as DockLayout;\n    layout.moveHandle(this._pressData.handle, xPos, yPos);\n  }\n\n  /**\n   * Handle the `'pointerup'` event for the dock panel.\n   */\n  private _evtPointerUp(event: PointerEvent): void {\n    // Do nothing if the left mouse button is not released.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event when releasing a handle.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Finalize the mouse release.\n    this._releaseMouse();\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Release the mouse grab for the dock panel.\n   */\n  private _releaseMouse(): void {\n    // Bail early if no drag is in progress.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the override cursor.\n    this._pressData.override.dispose();\n    this._pressData = null;\n\n    // Remove the extra document listeners.\n    this._document.removeEventListener('keydown', this, true);\n    this._document.removeEventListener('pointerup', this, true);\n    this._document.removeEventListener('pointermove', this, true);\n    this._document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Show the overlay indicator at the given client position.\n   *\n   * Returns the drop zone at the specified client position.\n   *\n   * #### Notes\n   * If the position is not over a valid zone, the overlay is hidden.\n   */\n  private _showOverlay(clientX: number, clientY: number): Private.DropZone {\n    // Find the dock target for the given client position.\n    let { zone, target } = Private.findDropTarget(\n      this,\n      clientX,\n      clientY,\n      this._edges\n    );\n\n    // If the drop zone is invalid, hide the overlay and bail.\n    if (zone === 'invalid') {\n      this.overlay.hide(100);\n      return zone;\n    }\n\n    // Setup the variables needed to compute the overlay geometry.\n    let top: number;\n    let left: number;\n    let right: number;\n    let bottom: number;\n    let box = ElementExt.boxSizing(this.node); // TODO cache this?\n    let rect = this.node.getBoundingClientRect();\n\n    // Compute the overlay geometry based on the dock zone.\n    switch (zone) {\n      case 'root-all':\n        top = box.paddingTop;\n        left = box.paddingLeft;\n        right = box.paddingRight;\n        bottom = box.paddingBottom;\n        break;\n      case 'root-top':\n        top = box.paddingTop;\n        left = box.paddingLeft;\n        right = box.paddingRight;\n        bottom = rect.height * Private.GOLDEN_RATIO;\n        break;\n      case 'root-left':\n        top = box.paddingTop;\n        left = box.paddingLeft;\n        right = rect.width * Private.GOLDEN_RATIO;\n        bottom = box.paddingBottom;\n        break;\n      case 'root-right':\n        top = box.paddingTop;\n        left = rect.width * Private.GOLDEN_RATIO;\n        right = box.paddingRight;\n        bottom = box.paddingBottom;\n        break;\n      case 'root-bottom':\n        top = rect.height * Private.GOLDEN_RATIO;\n        left = box.paddingLeft;\n        right = box.paddingRight;\n        bottom = box.paddingBottom;\n        break;\n      case 'widget-all':\n        top = target!.top;\n        left = target!.left;\n        right = target!.right;\n        bottom = target!.bottom;\n        break;\n      case 'widget-top':\n        top = target!.top;\n        left = target!.left;\n        right = target!.right;\n        bottom = target!.bottom + target!.height / 2;\n        break;\n      case 'widget-left':\n        top = target!.top;\n        left = target!.left;\n        right = target!.right + target!.width / 2;\n        bottom = target!.bottom;\n        break;\n      case 'widget-right':\n        top = target!.top;\n        left = target!.left + target!.width / 2;\n        right = target!.right;\n        bottom = target!.bottom;\n        break;\n      case 'widget-bottom':\n        top = target!.top + target!.height / 2;\n        left = target!.left;\n        right = target!.right;\n        bottom = target!.bottom;\n        break;\n      case 'widget-tab': {\n        const tabHeight = target!.tabBar.node.getBoundingClientRect().height;\n        top = target!.top;\n        left = target!.left;\n        right = target!.right;\n        bottom = target!.bottom + target!.height - tabHeight;\n        break;\n      }\n      default:\n        throw 'unreachable';\n    }\n\n    // Show the overlay with the computed geometry.\n    this.overlay.show({ top, left, right, bottom });\n\n    // Finally, return the computed drop zone.\n    return zone;\n  }\n\n  /**\n   * Create a new tab bar for use by the panel.\n   */\n  private _createTabBar(): TabBar<Widget> {\n    // Create the tab bar.\n    let tabBar = this._renderer.createTabBar(this._document);\n\n    // Set the generated tab bar property for the tab bar.\n    Private.isGeneratedTabBarProperty.set(tabBar, true);\n\n    // Hide the tab bar when in single document mode.\n    if (this._mode === 'single-document') {\n      tabBar.hide();\n    }\n\n    // Enforce necessary tab bar behavior.\n    // TODO do we really want to enforce *all* of these?\n    tabBar.tabsMovable = this._tabsMovable;\n    tabBar.allowDeselect = false;\n    tabBar.addButtonEnabled = this._addButtonEnabled;\n    tabBar.removeBehavior = 'select-previous-tab';\n    tabBar.insertBehavior = 'select-tab-if-needed';\n\n    // Connect the signal handlers for the tab bar.\n    tabBar.tabMoved.connect(this._onTabMoved, this);\n    tabBar.currentChanged.connect(this._onCurrentChanged, this);\n    tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);\n    tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);\n    tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);\n    tabBar.addRequested.connect(this._onTabAddRequested, this);\n\n    // Return the initialized tab bar.\n    return tabBar;\n  }\n\n  /**\n   * Create a new handle for use by the panel.\n   */\n  private _createHandle(): HTMLDivElement {\n    return this._renderer.createHandle();\n  }\n\n  /**\n   * Handle the `tabMoved` signal from a tab bar.\n   */\n  private _onTabMoved(): void {\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Handle the `currentChanged` signal from a tab bar.\n   */\n  private _onCurrentChanged(\n    sender: TabBar<Widget>,\n    args: TabBar.ICurrentChangedArgs<Widget>\n  ): void {\n    // Extract the previous and current title from the args.\n    let { previousTitle, currentTitle } = args;\n\n    // Hide the previous widget.\n    if (previousTitle) {\n      previousTitle.owner.hide();\n    }\n\n    // Show the current widget.\n    if (currentTitle) {\n      currentTitle.owner.show();\n    }\n\n    // Flush the message loop on IE and Edge to prevent flicker.\n    if (Platform.IS_EDGE || Platform.IS_IE) {\n      MessageLoop.flush();\n    }\n\n    // Schedule an emit of the layout modified signal.\n    MessageLoop.postMessage(this, Private.LayoutModified);\n  }\n\n  /**\n   * Handle the `addRequested` signal from a tab bar.\n   */\n  private _onTabAddRequested(sender: TabBar<Widget>): void {\n    this._addRequested.emit(sender);\n  }\n\n  /**\n   * Handle the `tabActivateRequested` signal from a tab bar.\n   */\n  private _onTabActivateRequested(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabActivateRequestedArgs<Widget>\n  ): void {\n    args.title.owner.activate();\n  }\n\n  /**\n   * Handle the `tabCloseRequested` signal from a tab bar.\n   */\n  private _onTabCloseRequested(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabCloseRequestedArgs<Widget>\n  ): void {\n    args.title.owner.close();\n  }\n\n  /**\n   * Handle the `tabDetachRequested` signal from a tab bar.\n   */\n  private _onTabDetachRequested(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabDetachRequestedArgs<Widget>\n  ): void {\n    // Do nothing if a drag is already in progress.\n    if (this._drag) {\n      return;\n    }\n\n    // Release the tab bar's hold on the mouse.\n    sender.releaseMouse();\n\n    // Extract the data from the args.\n    let { title, tab, clientX, clientY, offset } = args;\n\n    // Setup the mime data for the drag operation.\n    let mimeData = new MimeData();\n    let factory = () => title.owner;\n    mimeData.setData('application/vnd.lumino.widget-factory', factory);\n\n    // Create the drag image for the drag operation.\n    let dragImage = tab.cloneNode(true) as HTMLElement;\n    if (offset) {\n      dragImage.style.top = `-${offset.y}px`;\n      dragImage.style.left = `-${offset.x}px`;\n    }\n\n    // Create the drag object to manage the drag-drop operation.\n    this._drag = new Drag({\n      document: this._document,\n      mimeData,\n      dragImage,\n      proposedAction: 'move',\n      supportedActions: 'move',\n      source: this\n    });\n\n    // Hide the tab node in the original tab.\n    tab.classList.add('lm-mod-hidden');\n    let cleanup = () => {\n      this._drag = null;\n      tab.classList.remove('lm-mod-hidden');\n    };\n\n    // Start the drag operation and cleanup when done.\n    this._drag.start(clientX, clientY).then(cleanup);\n  }\n\n  private _edges: DockPanel.IEdges;\n  private _document: Document | ShadowRoot;\n  private _mode: DockPanel.Mode;\n  private _drag: Drag | null = null;\n  private _renderer: DockPanel.IRenderer;\n  private _tabsMovable: boolean = true;\n  private _tabsConstrained: boolean = false;\n  private _addButtonEnabled: boolean = false;\n  private _pressData: Private.IPressData | null = null;\n  private _layoutModified = new Signal<this, void>(this);\n\n  private _addRequested = new Signal<this, TabBar<Widget>>(this);\n}\n\n/**\n * The namespace for the `DockPanel` class statics.\n */\nexport namespace DockPanel {\n  /**\n   * An options object for creating a dock panel.\n   */\n  export interface IOptions {\n    /**\n     * The document to use with the dock panel.\n     *\n     * The default is the global `document` instance.\n     */\n\n    document?: Document | ShadowRoot;\n    /**\n     * The overlay to use with the dock panel.\n     *\n     * The default is a new `Overlay` instance.\n     */\n    overlay?: IOverlay;\n\n    /**\n     * The renderer to use for the dock panel.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer;\n\n    /**\n     * The spacing between the items in the panel.\n     *\n     * The default is `4`.\n     */\n    spacing?: number;\n\n    /**\n     * The mode for the dock panel.\n     *\n     * The default is `'multiple-document'`.\n     */\n    mode?: DockPanel.Mode;\n\n    /**\n     * The sizes of the edge drop zones, in pixels.\n     * If not given, default values will be used.\n     */\n    edges?: IEdges;\n\n    /**\n     * The method for hiding widgets.\n     *\n     * The default is `Widget.HiddenMode.Display`.\n     */\n    hiddenMode?: Widget.HiddenMode;\n\n    /**\n     * Allow tabs to be draggable / movable by user.\n     *\n     * The default is `'true'`.\n     */\n    tabsMovable?: boolean;\n\n    /**\n     * Constrain tabs to this dock panel\n     *\n     * The default is `'false'`.\n     */\n    tabsConstrained?: boolean;\n\n    /**\n     * Enable add buttons in each of the dock panel's tab bars.\n     *\n     * The default is `'false'`.\n     */\n    addButtonEnabled?: boolean;\n  }\n\n  /**\n   * The sizes of the edge drop zones, in pixels.\n   */\n  export interface IEdges {\n    /**\n     * The size of the top edge drop zone.\n     */\n    top: number;\n\n    /**\n     * The size of the right edge drop zone.\n     */\n    right: number;\n\n    /**\n     * The size of the bottom edge drop zone.\n     */\n    bottom: number;\n\n    /**\n     * The size of the left edge drop zone.\n     */\n    left: number;\n  }\n\n  /**\n   * A type alias for the supported dock panel modes.\n   */\n  export type Mode =\n    | /**\n     * The single document mode.\n     *\n     * In this mode, only a single widget is visible at a time, and that\n     * widget fills the available layout space. No tab bars are visible.\n     */\n    'single-document'\n\n    /**\n     * The multiple document mode.\n     *\n     * In this mode, multiple documents are displayed in separate tab\n     * areas, and those areas can be individually resized by the user.\n     */\n    | 'multiple-document';\n\n  /**\n   * A type alias for a layout configuration object.\n   */\n  export type ILayoutConfig = DockLayout.ILayoutConfig;\n\n  /**\n   * A type alias for the supported insertion modes.\n   */\n  export type InsertMode = DockLayout.InsertMode;\n\n  /**\n   * A type alias for the add widget options.\n   */\n  export type IAddOptions = DockLayout.IAddOptions;\n\n  /**\n   * An object which holds the geometry for overlay positioning.\n   */\n  export interface IOverlayGeometry {\n    /**\n     * The distance between the overlay and parent top edges.\n     */\n    top: number;\n\n    /**\n     * The distance between the overlay and parent left edges.\n     */\n    left: number;\n\n    /**\n     * The distance between the overlay and parent right edges.\n     */\n    right: number;\n\n    /**\n     * The distance between the overlay and parent bottom edges.\n     */\n    bottom: number;\n  }\n\n  /**\n   * An object which manages the overlay node for a dock panel.\n   */\n  export interface IOverlay {\n    /**\n     * The DOM node for the overlay.\n     */\n    readonly node: HTMLDivElement;\n\n    /**\n     * Show the overlay using the given overlay geometry.\n     *\n     * @param geo - The desired geometry for the overlay.\n     *\n     * #### Notes\n     * The given geometry values assume the node will use absolute\n     * positioning.\n     *\n     * This is called on every mouse move event during a drag in order\n     * to update the position of the overlay. It should be efficient.\n     */\n    show(geo: IOverlayGeometry): void;\n\n    /**\n     * Hide the overlay node.\n     *\n     * @param delay - The delay (in ms) before hiding the overlay.\n     *   A delay value <= 0 should hide the overlay immediately.\n     *\n     * #### Notes\n     * This is called whenever the overlay node should been hidden.\n     */\n    hide(delay: number): void;\n  }\n\n  /**\n   * A concrete implementation of `IOverlay`.\n   *\n   * This is the default overlay implementation for a dock panel.\n   */\n  export class Overlay implements IOverlay {\n    /**\n     * Construct a new overlay.\n     */\n    constructor() {\n      this.node = document.createElement('div');\n      this.node.classList.add('lm-DockPanel-overlay');\n      this.node.classList.add('lm-mod-hidden');\n      this.node.style.position = 'absolute';\n      this.node.style.contain = 'strict';\n    }\n\n    /**\n     * The DOM node for the overlay.\n     */\n    readonly node: HTMLDivElement;\n\n    /**\n     * Show the overlay using the given overlay geometry.\n     *\n     * @param geo - The desired geometry for the overlay.\n     */\n    show(geo: IOverlayGeometry): void {\n      // Update the position of the overlay.\n      let style = this.node.style;\n      style.top = `${geo.top}px`;\n      style.left = `${geo.left}px`;\n      style.right = `${geo.right}px`;\n      style.bottom = `${geo.bottom}px`;\n\n      // Clear any pending hide timer.\n      clearTimeout(this._timer);\n      this._timer = -1;\n\n      // If the overlay is already visible, we're done.\n      if (!this._hidden) {\n        return;\n      }\n\n      // Clear the hidden flag.\n      this._hidden = false;\n\n      // Finally, show the overlay.\n      this.node.classList.remove('lm-mod-hidden');\n    }\n\n    /**\n     * Hide the overlay node.\n     *\n     * @param delay - The delay (in ms) before hiding the overlay.\n     *   A delay value <= 0 will hide the overlay immediately.\n     */\n    hide(delay: number): void {\n      // Do nothing if the overlay is already hidden.\n      if (this._hidden) {\n        return;\n      }\n\n      // Hide immediately if the delay is <= 0.\n      if (delay <= 0) {\n        clearTimeout(this._timer);\n        this._timer = -1;\n        this._hidden = true;\n        this.node.classList.add('lm-mod-hidden');\n        return;\n      }\n\n      // Do nothing if a hide is already pending.\n      if (this._timer !== -1) {\n        return;\n      }\n\n      // Otherwise setup the hide timer.\n      this._timer = window.setTimeout(() => {\n        this._timer = -1;\n        this._hidden = true;\n        this.node.classList.add('lm-mod-hidden');\n      }, delay);\n    }\n\n    private _timer = -1;\n    private _hidden = true;\n  }\n\n  /**\n   * A type alias for a dock panel renderer;\n   */\n  export type IRenderer = DockLayout.IRenderer;\n\n  /**\n   * The default implementation of `IRenderer`.\n   */\n  export class Renderer implements IRenderer {\n    /**\n     * Create a new tab bar for use with a dock panel.\n     *\n     * @returns A new tab bar for a dock panel.\n     */\n    createTabBar(document?: Document | ShadowRoot): TabBar<Widget> {\n      let bar = new TabBar<Widget>({ document });\n      bar.addClass('lm-DockPanel-tabBar');\n      return bar;\n    }\n\n    /**\n     * Create a new handle node for use with a dock panel.\n     *\n     * @returns A new handle node for a dock panel.\n     */\n    createHandle(): HTMLDivElement {\n      let handle = document.createElement('div');\n      handle.className = 'lm-DockPanel-handle';\n      return handle;\n    }\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n   */\n  export const GOLDEN_RATIO = 0.618;\n\n  /**\n   * The default sizes for the edge drop zones, in pixels.\n   */\n  export const DEFAULT_EDGES = {\n    /**\n     * The size of the top edge dock zone for the root panel, in pixels.\n     * This is different from the others to distinguish between the top\n     * tab bar and the top root zone.\n     */\n    top: 12,\n\n    /**\n     * The size of the edge dock zone for the root panel, in pixels.\n     */\n    right: 40,\n\n    /**\n     * The size of the edge dock zone for the root panel, in pixels.\n     */\n    bottom: 40,\n\n    /**\n     * The size of the edge dock zone for the root panel, in pixels.\n     */\n    left: 40\n  };\n\n  /**\n   * A singleton `'layout-modified'` conflatable message.\n   */\n  export const LayoutModified = new ConflatableMessage('layout-modified');\n\n  /**\n   * An object which holds mouse press data.\n   */\n  export interface IPressData {\n    /**\n     * The handle which was pressed.\n     */\n    handle: HTMLDivElement;\n\n    /**\n     * The X offset of the press in handle coordinates.\n     */\n    deltaX: number;\n\n    /**\n     * The Y offset of the press in handle coordinates.\n     */\n    deltaY: number;\n\n    /**\n     * The disposable which will clear the override cursor.\n     */\n    override: IDisposable;\n  }\n\n  /**\n   * A type alias for a drop zone.\n   */\n  export type DropZone =\n    | /**\n     * An invalid drop zone.\n     */\n    'invalid'\n\n    /**\n     * The entirety of the root dock area.\n     */\n    | 'root-all'\n\n    /**\n     * The top portion of the root dock area.\n     */\n    | 'root-top'\n\n    /**\n     * The left portion of the root dock area.\n     */\n    | 'root-left'\n\n    /**\n     * The right portion of the root dock area.\n     */\n    | 'root-right'\n\n    /**\n     * The bottom portion of the root dock area.\n     */\n    | 'root-bottom'\n\n    /**\n     * The entirety of a tabbed widget area.\n     */\n    | 'widget-all'\n\n    /**\n     * The top portion of tabbed widget area.\n     */\n    | 'widget-top'\n\n    /**\n     * The left portion of tabbed widget area.\n     */\n    | 'widget-left'\n\n    /**\n     * The right portion of tabbed widget area.\n     */\n    | 'widget-right'\n\n    /**\n     * The bottom portion of tabbed widget area.\n     */\n    | 'widget-bottom'\n\n    /**\n     * The the bar of a tabbed widget area.\n     */\n    | 'widget-tab';\n\n  /**\n   * An object which holds the drop target zone and widget.\n   */\n  export interface IDropTarget {\n    /**\n     * The semantic zone for the mouse position.\n     */\n    zone: DropZone;\n\n    /**\n     * The tab area geometry for the drop zone, or `null`.\n     */\n    target: DockLayout.ITabAreaGeometry | null;\n  }\n\n  /**\n   * An attached property used to track generated tab bars.\n   */\n  export const isGeneratedTabBarProperty = new AttachedProperty<\n    Widget,\n    boolean\n  >({\n    name: 'isGeneratedTabBar',\n    create: () => false\n  });\n\n  /**\n   * Create a single document config for the widgets in a dock panel.\n   */\n  export function createSingleDocumentConfig(\n    panel: DockPanel\n  ): DockPanel.ILayoutConfig {\n    // Return an empty config if the panel is empty.\n    if (panel.isEmpty) {\n      return { main: null };\n    }\n\n    // Get a flat array of the widgets in the panel.\n    let widgets = Array.from(panel.widgets());\n\n    // Get the first selected widget in the panel.\n    let selected = panel.selectedWidgets().next().value;\n\n    // Compute the current index for the new config.\n    let currentIndex = selected ? widgets.indexOf(selected) : -1;\n\n    // Return the single document config.\n    return { main: { type: 'tab-area', widgets, currentIndex } };\n  }\n\n  /**\n   * Find the drop target at the given client position.\n   */\n  export function findDropTarget(\n    panel: DockPanel,\n    clientX: number,\n    clientY: number,\n    edges: DockPanel.IEdges\n  ): IDropTarget {\n    // Bail if the mouse is not over the dock panel.\n    if (!ElementExt.hitTest(panel.node, clientX, clientY)) {\n      return { zone: 'invalid', target: null };\n    }\n\n    // Look up the layout for the panel.\n    let layout = panel.layout as DockLayout;\n\n    // If the layout is empty, indicate the entire root drop zone.\n    if (layout.isEmpty) {\n      return { zone: 'root-all', target: null };\n    }\n\n    // Test the edge zones when in multiple document mode.\n    if (panel.mode === 'multiple-document') {\n      // Get the client rect for the dock panel.\n      let panelRect = panel.node.getBoundingClientRect();\n\n      // Compute the distance to each edge of the panel.\n      let pl = clientX - panelRect.left + 1;\n      let pt = clientY - panelRect.top + 1;\n      let pr = panelRect.right - clientX;\n      let pb = panelRect.bottom - clientY;\n\n      // Find the minimum distance to an edge.\n      let pd = Math.min(pt, pr, pb, pl);\n\n      // Return a root zone if the mouse is within an edge.\n      switch (pd) {\n        case pt:\n          if (pt < edges.top) {\n            return { zone: 'root-top', target: null };\n          }\n          break;\n        case pr:\n          if (pr < edges.right) {\n            return { zone: 'root-right', target: null };\n          }\n          break;\n        case pb:\n          if (pb < edges.bottom) {\n            return { zone: 'root-bottom', target: null };\n          }\n          break;\n        case pl:\n          if (pl < edges.left) {\n            return { zone: 'root-left', target: null };\n          }\n          break;\n        default:\n          throw 'unreachable';\n      }\n    }\n\n    // Hit test the dock layout at the given client position.\n    let target = layout.hitTestTabAreas(clientX, clientY);\n\n    // Bail if no target area was found.\n    if (!target) {\n      return { zone: 'invalid', target: null };\n    }\n\n    // Return the whole tab area when in single document mode.\n    if (panel.mode === 'single-document') {\n      return { zone: 'widget-all', target };\n    }\n\n    // Compute the distance to each edge of the tab area.\n    let al = target.x - target.left + 1;\n    let at = target.y - target.top + 1;\n    let ar = target.left + target.width - target.x;\n    let ab = target.top + target.height - target.y;\n\n    const tabHeight = target.tabBar.node.getBoundingClientRect().height;\n    if (at < tabHeight) {\n      return { zone: 'widget-tab', target };\n    }\n\n    // Get the X and Y edge sizes for the area.\n    let rx = Math.round(target.width / 3);\n    let ry = Math.round(target.height / 3);\n\n    // If the mouse is not within an edge, indicate the entire area.\n    if (al > rx && ar > rx && at > ry && ab > ry) {\n      return { zone: 'widget-all', target };\n    }\n\n    // Scale the distances by the slenderness ratio.\n    al /= rx;\n    at /= ry;\n    ar /= rx;\n    ab /= ry;\n\n    // Find the minimum distance to the area edge.\n    let ad = Math.min(al, at, ar, ab);\n\n    // Find the widget zone for the area edge.\n    let zone: DropZone;\n    switch (ad) {\n      case al:\n        zone = 'widget-left';\n        break;\n      case at:\n        zone = 'widget-top';\n        break;\n      case ar:\n        zone = 'widget-right';\n        break;\n      case ab:\n        zone = 'widget-bottom';\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Return the final drop target.\n    return { zone, target };\n  }\n\n  /**\n   * Get the drop reference widget for a tab bar.\n   */\n  export function getDropRef(tabBar: TabBar<Widget>): Widget | null {\n    if (tabBar.titles.length === 0) {\n      return null;\n    }\n    if (tabBar.currentTitle) {\n      return tabBar.currentTitle.owner;\n    }\n    return tabBar.titles[tabBar.titles.length - 1].owner;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { AttachedProperty } from '@lumino/properties';\n\nimport { BoxEngine, BoxSizer } from './boxengine';\n\nimport { Layout, LayoutItem } from './layout';\n\nimport { Widget } from './widget';\n\n/**\n * A layout which arranges its widgets in a grid.\n */\nexport class GridLayout extends Layout {\n  /**\n   * Construct a new grid layout.\n   *\n   * @param options - The options for initializing the layout.\n   */\n  constructor(options: GridLayout.IOptions = {}) {\n    super(options);\n    if (options.rowCount !== undefined) {\n      Private.reallocSizers(this._rowSizers, options.rowCount);\n    }\n    if (options.columnCount !== undefined) {\n      Private.reallocSizers(this._columnSizers, options.columnCount);\n    }\n    if (options.rowSpacing !== undefined) {\n      this._rowSpacing = Private.clampValue(options.rowSpacing);\n    }\n    if (options.columnSpacing !== undefined) {\n      this._columnSpacing = Private.clampValue(options.columnSpacing);\n    }\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    // Dispose of the widgets and layout items.\n    for (const item of this._items) {\n      let widget = item.widget;\n      item.dispose();\n      widget.dispose();\n    }\n\n    // Clear the layout state.\n    this._box = null;\n    this._items.length = 0;\n    this._rowStarts.length = 0;\n    this._rowSizers.length = 0;\n    this._columnStarts.length = 0;\n    this._columnSizers.length = 0;\n\n    // Dispose of the rest of the layout.\n    super.dispose();\n  }\n\n  /**\n   * Get the number of rows in the layout.\n   */\n  get rowCount(): number {\n    return this._rowSizers.length;\n  }\n\n  /**\n   * Set the number of rows in the layout.\n   *\n   * #### Notes\n   * The minimum row count is `1`.\n   */\n  set rowCount(value: number) {\n    // Do nothing if the row count does not change.\n    if (value === this.rowCount) {\n      return;\n    }\n\n    // Reallocate the row sizers.\n    Private.reallocSizers(this._rowSizers, value);\n\n    // Schedule a fit of the parent.\n    if (this.parent) {\n      this.parent.fit();\n    }\n  }\n\n  /**\n   * Get the number of columns in the layout.\n   */\n  get columnCount(): number {\n    return this._columnSizers.length;\n  }\n\n  /**\n   * Set the number of columns in the layout.\n   *\n   * #### Notes\n   * The minimum column count is `1`.\n   */\n  set columnCount(value: number) {\n    // Do nothing if the column count does not change.\n    if (value === this.columnCount) {\n      return;\n    }\n\n    // Reallocate the column sizers.\n    Private.reallocSizers(this._columnSizers, value);\n\n    // Schedule a fit of the parent.\n    if (this.parent) {\n      this.parent.fit();\n    }\n  }\n\n  /**\n   * Get the row spacing for the layout.\n   */\n  get rowSpacing(): number {\n    return this._rowSpacing;\n  }\n\n  /**\n   * Set the row spacing for the layout.\n   */\n  set rowSpacing(value: number) {\n    // Clamp the spacing to the allowed range.\n    value = Private.clampValue(value);\n\n    // Bail if the spacing does not change\n    if (this._rowSpacing === value) {\n      return;\n    }\n\n    // Update the internal spacing.\n    this._rowSpacing = value;\n\n    // Schedule a fit of the parent.\n    if (this.parent) {\n      this.parent.fit();\n    }\n  }\n\n  /**\n   * Get the column spacing for the layout.\n   */\n  get columnSpacing(): number {\n    return this._columnSpacing;\n  }\n\n  /**\n   * Set the col spacing for the layout.\n   */\n  set columnSpacing(value: number) {\n    // Clamp the spacing to the allowed range.\n    value = Private.clampValue(value);\n\n    // Bail if the spacing does not change\n    if (this._columnSpacing === value) {\n      return;\n    }\n\n    // Update the internal spacing.\n    this._columnSpacing = value;\n\n    // Schedule a fit of the parent.\n    if (this.parent) {\n      this.parent.fit();\n    }\n  }\n\n  /**\n   * Get the stretch factor for a specific row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @returns The stretch factor for the row.\n   *\n   * #### Notes\n   * This returns `-1` if the index is out of range.\n   */\n  rowStretch(index: number): number {\n    let sizer = this._rowSizers[index];\n    return sizer ? sizer.stretch : -1;\n  }\n\n  /**\n   * Set the stretch factor for a specific row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @param value - The stretch factor for the row.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  setRowStretch(index: number, value: number): void {\n    // Look up the row sizer.\n    let sizer = this._rowSizers[index];\n\n    // Bail if the index is out of range.\n    if (!sizer) {\n      return;\n    }\n\n    // Clamp the value to the allowed range.\n    value = Private.clampValue(value);\n\n    // Bail if the stretch does not change.\n    if (sizer.stretch === value) {\n      return;\n    }\n\n    // Update the sizer stretch.\n    sizer.stretch = value;\n\n    // Schedule an update of the parent.\n    if (this.parent) {\n      this.parent.update();\n    }\n  }\n\n  /**\n   * Get the stretch factor for a specific column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @returns The stretch factor for the column.\n   *\n   * #### Notes\n   * This returns `-1` if the index is out of range.\n   */\n  columnStretch(index: number): number {\n    let sizer = this._columnSizers[index];\n    return sizer ? sizer.stretch : -1;\n  }\n\n  /**\n   * Set the stretch factor for a specific column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @param value - The stretch factor for the column.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  setColumnStretch(index: number, value: number): void {\n    // Look up the column sizer.\n    let sizer = this._columnSizers[index];\n\n    // Bail if the index is out of range.\n    if (!sizer) {\n      return;\n    }\n\n    // Clamp the value to the allowed range.\n    value = Private.clampValue(value);\n\n    // Bail if the stretch does not change.\n    if (sizer.stretch === value) {\n      return;\n    }\n\n    // Update the sizer stretch.\n    sizer.stretch = value;\n\n    // Schedule an update of the parent.\n    if (this.parent) {\n      this.parent.update();\n    }\n  }\n\n  /**\n   * Create an iterator over the widgets in the layout.\n   *\n   * @returns A new iterator over the widgets in the layout.\n   */\n  *[Symbol.iterator](): IterableIterator<Widget> {\n    for (const item of this._items) {\n      yield item.widget;\n    }\n  }\n\n  /**\n   * Add a widget to the grid layout.\n   *\n   * @param widget - The widget to add to the layout.\n   *\n   * #### Notes\n   * If the widget is already contained in the layout, this is no-op.\n   */\n  addWidget(widget: Widget): void {\n    // Look up the index for the widget.\n    let i = ArrayExt.findFirstIndex(this._items, it => it.widget === widget);\n\n    // Bail if the widget is already in the layout.\n    if (i !== -1) {\n      return;\n    }\n\n    // Add the widget to the layout.\n    this._items.push(new LayoutItem(widget));\n\n    // Attach the widget to the parent.\n    if (this.parent) {\n      this.attachWidget(widget);\n    }\n  }\n\n  /**\n   * Remove a widget from the grid layout.\n   *\n   * @param widget - The widget to remove from the layout.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method does *not* modify the widget's `parent`.\n   */\n  removeWidget(widget: Widget): void {\n    // Look up the index for the widget.\n    let i = ArrayExt.findFirstIndex(this._items, it => it.widget === widget);\n\n    // Bail if the widget is not in the layout.\n    if (i === -1) {\n      return;\n    }\n\n    // Remove the widget from the layout.\n    let item = ArrayExt.removeAt(this._items, i)!;\n\n    // Detach the widget from the parent.\n    if (this.parent) {\n      this.detachWidget(widget);\n    }\n\n    // Dispose the layout item.\n    item.dispose();\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    super.init();\n    for (const widget of this) {\n      this.attachWidget(widget);\n    }\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param widget - The widget to attach to the parent.\n   */\n  protected attachWidget(widget: Widget): void {\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget's node to the parent.\n    this.parent!.node.appendChild(widget.node);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param widget - The widget to detach from the parent.\n   */\n  protected detachWidget(widget: Widget): void {\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    super.onBeforeShow(msg);\n    this.parent!.update();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.parent!.isVisible) {\n      this._update(msg.width, msg.height);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.parent!.isVisible) {\n      this._update(-1, -1);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   */\n  protected onFitRequest(msg: Message): void {\n    if (this.parent!.isAttached) {\n      this._fit();\n    }\n  }\n\n  /**\n   * Fit the layout to the total size required by the widgets.\n   */\n  private _fit(): void {\n    // Reset the min sizes of the sizers.\n    for (let i = 0, n = this.rowCount; i < n; ++i) {\n      this._rowSizers[i].minSize = 0;\n    }\n    for (let i = 0, n = this.columnCount; i < n; ++i) {\n      this._columnSizers[i].minSize = 0;\n    }\n\n    // Filter for the visible layout items.\n    let items = this._items.filter(it => !it.isHidden);\n\n    // Fit the layout items.\n    for (let i = 0, n = items.length; i < n; ++i) {\n      items[i].fit();\n    }\n\n    // Get the max row and column index.\n    let maxRow = this.rowCount - 1;\n    let maxCol = this.columnCount - 1;\n\n    // Sort the items by row span.\n    items.sort(Private.rowSpanCmp);\n\n    // Update the min sizes of the row sizers.\n    for (let i = 0, n = items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = items[i];\n\n      // Get the row bounds for the item.\n      let config = GridLayout.getCellConfig(item.widget);\n      let r1 = Math.min(config.row, maxRow);\n      let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n\n      // Distribute the minimum height to the sizers as needed.\n      Private.distributeMin(this._rowSizers, r1, r2, item.minHeight);\n    }\n\n    // Sort the items by column span.\n    items.sort(Private.columnSpanCmp);\n\n    // Update the min sizes of the column sizers.\n    for (let i = 0, n = items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = items[i];\n\n      // Get the column bounds for the item.\n      let config = GridLayout.getCellConfig(item.widget);\n      let c1 = Math.min(config.column, maxCol);\n      let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n\n      // Distribute the minimum width to the sizers as needed.\n      Private.distributeMin(this._columnSizers, c1, c2, item.minWidth);\n    }\n\n    // If no size constraint is needed, just update the parent.\n    if (this.fitPolicy === 'set-no-constraint') {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n      return;\n    }\n\n    // Set up the computed min size.\n    let minH = maxRow * this._rowSpacing;\n    let minW = maxCol * this._columnSpacing;\n\n    // Add the sizer minimums to the computed min size.\n    for (let i = 0, n = this.rowCount; i < n; ++i) {\n      minH += this._rowSizers[i].minSize;\n    }\n    for (let i = 0, n = this.columnCount; i < n; ++i) {\n      minW += this._columnSizers[i].minSize;\n    }\n\n    // Update the box sizing and add it to the computed min size.\n    let box = (this._box = ElementExt.boxSizing(this.parent!.node));\n    minW += box.horizontalSum;\n    minH += box.verticalSum;\n\n    // Update the parent's min size constraints.\n    let style = this.parent!.node.style;\n    style.minWidth = `${minW}px`;\n    style.minHeight = `${minH}px`;\n\n    // Set the dirty flag to ensure only a single update occurs.\n    this._dirty = true;\n\n    // Notify the ancestor that it should fit immediately. This may\n    // cause a resize of the parent, fulfilling the required update.\n    if (this.parent!.parent) {\n      MessageLoop.sendMessage(this.parent!.parent!, Widget.Msg.FitRequest);\n    }\n\n    // If the dirty flag is still set, the parent was not resized.\n    // Trigger the required update on the parent widget immediately.\n    if (this._dirty) {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n    }\n  }\n\n  /**\n   * Update the layout position and size of the widgets.\n   *\n   * The parent offset dimensions should be `-1` if unknown.\n   */\n  private _update(offsetWidth: number, offsetHeight: number): void {\n    // Clear the dirty flag to indicate the update occurred.\n    this._dirty = false;\n\n    // Measure the parent if the offset dimensions are unknown.\n    if (offsetWidth < 0) {\n      offsetWidth = this.parent!.node.offsetWidth;\n    }\n    if (offsetHeight < 0) {\n      offsetHeight = this.parent!.node.offsetHeight;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent!.node);\n    }\n\n    // Compute the layout area adjusted for border and padding.\n    let top = this._box.paddingTop;\n    let left = this._box.paddingLeft;\n    let width = offsetWidth - this._box.horizontalSum;\n    let height = offsetHeight - this._box.verticalSum;\n\n    // Get the max row and column index.\n    let maxRow = this.rowCount - 1;\n    let maxCol = this.columnCount - 1;\n\n    // Compute the total fixed row and column space.\n    let fixedRowSpace = maxRow * this._rowSpacing;\n    let fixedColSpace = maxCol * this._columnSpacing;\n\n    // Distribute the available space to the box sizers.\n    BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));\n    BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));\n\n    // Update the row start positions.\n    for (let i = 0, pos = top, n = this.rowCount; i < n; ++i) {\n      this._rowStarts[i] = pos;\n      pos += this._rowSizers[i].size + this._rowSpacing;\n    }\n\n    // Update the column start positions.\n    for (let i = 0, pos = left, n = this.columnCount; i < n; ++i) {\n      this._columnStarts[i] = pos;\n      pos += this._columnSizers[i].size + this._columnSpacing;\n    }\n\n    // Update the geometry of the layout items.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = this._items[i];\n\n      // Ignore hidden items.\n      if (item.isHidden) {\n        continue;\n      }\n\n      // Fetch the cell bounds for the widget.\n      let config = GridLayout.getCellConfig(item.widget);\n      let r1 = Math.min(config.row, maxRow);\n      let c1 = Math.min(config.column, maxCol);\n      let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n      let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n\n      // Compute the cell geometry.\n      let x = this._columnStarts[c1];\n      let y = this._rowStarts[r1];\n      let w = this._columnStarts[c2] + this._columnSizers[c2].size - x;\n      let h = this._rowStarts[r2] + this._rowSizers[r2].size - y;\n\n      // Update the geometry of the layout item.\n      item.update(x, y, w, h);\n    }\n  }\n\n  private _dirty = false;\n  private _rowSpacing = 4;\n  private _columnSpacing = 4;\n  private _items: LayoutItem[] = [];\n  private _rowStarts: number[] = [];\n  private _columnStarts: number[] = [];\n  private _rowSizers: BoxSizer[] = [new BoxSizer()];\n  private _columnSizers: BoxSizer[] = [new BoxSizer()];\n  private _box: ElementExt.IBoxSizing | null = null;\n}\n\n/**\n * The namespace for the `GridLayout` class statics.\n */\nexport namespace GridLayout {\n  /**\n   * An options object for initializing a grid layout.\n   */\n  export interface IOptions extends Layout.IOptions {\n    /**\n     * The initial row count for the layout.\n     *\n     * The default is `1`.\n     */\n    rowCount?: number;\n\n    /**\n     * The initial column count for the layout.\n     *\n     * The default is `1`.\n     */\n    columnCount?: number;\n\n    /**\n     * The spacing between rows in the layout.\n     *\n     * The default is `4`.\n     */\n    rowSpacing?: number;\n\n    /**\n     * The spacing between columns in the layout.\n     *\n     * The default is `4`.\n     */\n    columnSpacing?: number;\n  }\n\n  /**\n   * An object which holds the cell configuration for a widget.\n   */\n  export interface ICellConfig {\n    /**\n     * The row index for the widget.\n     */\n    readonly row: number;\n\n    /**\n     * The column index for the widget.\n     */\n    readonly column: number;\n\n    /**\n     * The row span for the widget.\n     */\n    readonly rowSpan: number;\n\n    /**\n     * The column span for the widget.\n     */\n    readonly columnSpan: number;\n  }\n\n  /**\n   * Get the cell config for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The cell config for the widget.\n   */\n  export function getCellConfig(widget: Widget): ICellConfig {\n    return Private.cellConfigProperty.get(widget);\n  }\n\n  /**\n   * Set the cell config for the given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @param value - The value for the cell config.\n   */\n  export function setCellConfig(\n    widget: Widget,\n    value: Partial<ICellConfig>\n  ): void {\n    Private.cellConfigProperty.set(widget, Private.normalizeConfig(value));\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The property descriptor for the widget cell config.\n   */\n  export const cellConfigProperty = new AttachedProperty<\n    Widget,\n    GridLayout.ICellConfig\n  >({\n    name: 'cellConfig',\n    create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),\n    changed: onChildCellConfigChanged\n  });\n\n  /**\n   * Normalize a partial cell config object.\n   */\n  export function normalizeConfig(\n    config: Partial<GridLayout.ICellConfig>\n  ): GridLayout.ICellConfig {\n    let row = Math.max(0, Math.floor(config.row || 0));\n    let column = Math.max(0, Math.floor(config.column || 0));\n    let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));\n    let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));\n    return { row, column, rowSpan, columnSpan };\n  }\n\n  /**\n   * Clamp a value to an integer >= 0.\n   */\n  export function clampValue(value: number): number {\n    return Math.max(0, Math.floor(value));\n  }\n\n  /**\n   * A sort comparison function for row spans.\n   */\n  export function rowSpanCmp(a: LayoutItem, b: LayoutItem): number {\n    let c1 = cellConfigProperty.get(a.widget);\n    let c2 = cellConfigProperty.get(b.widget);\n    return c1.rowSpan - c2.rowSpan;\n  }\n\n  /**\n   * A sort comparison function for column spans.\n   */\n  export function columnSpanCmp(a: LayoutItem, b: LayoutItem): number {\n    let c1 = cellConfigProperty.get(a.widget);\n    let c2 = cellConfigProperty.get(b.widget);\n    return c1.columnSpan - c2.columnSpan;\n  }\n\n  /**\n   * Reallocate the box sizers for the given grid dimensions.\n   */\n  export function reallocSizers(sizers: BoxSizer[], count: number): void {\n    // Coerce the count to the valid range.\n    count = Math.max(1, Math.floor(count));\n\n    // Add the missing sizers.\n    while (sizers.length < count) {\n      sizers.push(new BoxSizer());\n    }\n\n    // Remove the extra sizers.\n    if (sizers.length > count) {\n      sizers.length = count;\n    }\n  }\n\n  /**\n   * Distribute a min size constraint across a range of sizers.\n   */\n  export function distributeMin(\n    sizers: BoxSizer[],\n    i1: number,\n    i2: number,\n    minSize: number\n  ): void {\n    // Sanity check the indices.\n    if (i2 < i1) {\n      return;\n    }\n\n    // Handle the simple case of no cell span.\n    if (i1 === i2) {\n      let sizer = sizers[i1];\n      sizer.minSize = Math.max(sizer.minSize, minSize);\n      return;\n    }\n\n    // Compute the total current min size of the span.\n    let totalMin = 0;\n    for (let i = i1; i <= i2; ++i) {\n      totalMin += sizers[i].minSize;\n    }\n\n    // Do nothing if the total is greater than the required.\n    if (totalMin >= minSize) {\n      return;\n    }\n\n    // Compute the portion of the space to allocate to each sizer.\n    let portion = (minSize - totalMin) / (i2 - i1 + 1);\n\n    // Add the portion to each sizer.\n    for (let i = i1; i <= i2; ++i) {\n      sizers[i].minSize += portion;\n    }\n  }\n\n  /**\n   * The change handler for the child cell config property.\n   */\n  function onChildCellConfigChanged(child: Widget): void {\n    if (child.parent && child.parent.layout instanceof GridLayout) {\n      child.parent.fit();\n    }\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport {\n  ElementARIAAttrs,\n  ElementDataset,\n  h,\n  VirtualDOM,\n  VirtualElement\n} from '@lumino/virtualdom';\n\nimport { Menu } from './menu';\n\nimport { Title } from './title';\n\nimport { Widget } from './widget';\n\n/**\n * A widget which displays menus as a canonical menu bar.\n */\nexport class MenuBar extends Widget {\n  /**\n   * Construct a new menu bar.\n   *\n   * @param options - The options for initializing the menu bar.\n   */\n  constructor(options: MenuBar.IOptions = {}) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-MenuBar');\n    this.setFlag(Widget.Flag.DisallowLayout);\n    this.renderer = options.renderer || MenuBar.defaultRenderer;\n    this._forceItemsPosition = options.forceItemsPosition || {\n      forceX: true,\n      forceY: true\n    };\n    this._overflowMenuOptions = options.overflowMenuOptions || {\n      isVisible: true\n    };\n  }\n\n  /**\n   * Dispose of the resources held by the widget.\n   */\n  dispose(): void {\n    this._closeChildMenu();\n    this._menus.length = 0;\n    super.dispose();\n  }\n\n  /**\n   * The renderer used by the menu bar.\n   */\n  readonly renderer: MenuBar.IRenderer;\n\n  /**\n   * The child menu of the menu bar.\n   *\n   * #### Notes\n   * This will be `null` if the menu bar does not have an open menu.\n   */\n  get childMenu(): Menu | null {\n    return this._childMenu;\n  }\n\n  /**\n   * The overflow index of the menu bar.\n   */\n  get overflowIndex(): number {\n    return this._overflowIndex;\n  }\n\n  /**\n   * The overflow menu of the menu bar.\n   */\n  get overflowMenu(): Menu | null {\n    return this._overflowMenu;\n  }\n\n  /**\n   * Get the menu bar content node.\n   *\n   * #### Notes\n   * This is the node which holds the menu title nodes.\n   *\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get contentNode(): HTMLUListElement {\n    return this.node.getElementsByClassName(\n      'lm-MenuBar-content'\n    )[0] as HTMLUListElement;\n  }\n\n  /**\n   * Get the currently active menu.\n   */\n  get activeMenu(): Menu | null {\n    return this._menus[this._activeIndex] || null;\n  }\n\n  /**\n   * Set the currently active menu.\n   *\n   * #### Notes\n   * If the menu does not exist, the menu will be set to `null`.\n   */\n  set activeMenu(value: Menu | null) {\n    this.activeIndex = value ? this._menus.indexOf(value) : -1;\n  }\n\n  /**\n   * Get the index of the currently active menu.\n   *\n   * #### Notes\n   * This will be `-1` if no menu is active.\n   */\n  get activeIndex(): number {\n    return this._activeIndex;\n  }\n\n  /**\n   * Set the index of the currently active menu.\n   *\n   * #### Notes\n   * If the menu cannot be activated, the index will be set to `-1`.\n   */\n  set activeIndex(value: number) {\n    // Adjust the value for an out of range index.\n    if (value < 0 || value >= this._menus.length) {\n      value = -1;\n    }\n\n    // An empty menu cannot be active\n    if (value > -1 && this._menus[value].items.length === 0) {\n      value = -1;\n    }\n\n    // Bail early if the index will not change.\n    if (this._activeIndex === value) {\n      return;\n    }\n\n    // Update the active index.\n    this._activeIndex = value;\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * A read-only array of the menus in the menu bar.\n   */\n  get menus(): ReadonlyArray<Menu> {\n    return this._menus;\n  }\n\n  /**\n   * Open the active menu and activate its first menu item.\n   *\n   * #### Notes\n   * If there is no active menu, this is a no-op.\n   */\n  openActiveMenu(): void {\n    // Bail early if there is no active item.\n    if (this._activeIndex === -1) {\n      return;\n    }\n\n    // Open the child menu.\n    this._openChildMenu();\n\n    // Activate the first item in the child menu.\n    if (this._childMenu) {\n      this._childMenu.activeIndex = -1;\n      this._childMenu.activateNextItem();\n    }\n  }\n\n  /**\n   * Add a menu to the end of the menu bar.\n   *\n   * @param menu - The menu to add to the menu bar.\n   *\n   * #### Notes\n   * If the menu is already added to the menu bar, it will be moved.\n   */\n  addMenu(menu: Menu, update: boolean = true): void {\n    this.insertMenu(this._menus.length, menu, update);\n  }\n\n  /**\n   * Insert a menu into the menu bar at the specified index.\n   *\n   * @param index - The index at which to insert the menu.\n   *\n   * @param menu - The menu to insert into the menu bar.\n   *\n   * #### Notes\n   * The index will be clamped to the bounds of the menus.\n   *\n   * If the menu is already added to the menu bar, it will be moved.\n   */\n  insertMenu(index: number, menu: Menu, update: boolean = true): void {\n    // Close the child menu before making changes.\n    this._closeChildMenu();\n\n    // Look up the index of the menu.\n    let i = this._menus.indexOf(menu);\n\n    // Clamp the insert index to the array bounds.\n    let j = Math.max(0, Math.min(index, this._menus.length));\n\n    // If the menu is not in the array, insert it.\n    if (i === -1) {\n      // Insert the menu into the array.\n      ArrayExt.insert(this._menus, j, menu);\n\n      // Add the styling class to the menu.\n      menu.addClass('lm-MenuBar-menu');\n\n      // Connect to the menu signals.\n      menu.aboutToClose.connect(this._onMenuAboutToClose, this);\n      menu.menuRequested.connect(this._onMenuMenuRequested, this);\n      menu.title.changed.connect(this._onTitleChanged, this);\n\n      // Schedule an update of the items.\n      if (update) {\n        this.update();\n      }\n\n      // There is nothing more to do.\n      return;\n    }\n\n    // Otherwise, the menu exists in the array and should be moved.\n\n    // Adjust the index if the location is at the end of the array.\n    if (j === this._menus.length) {\n      j--;\n    }\n\n    // Bail if there is no effective move.\n    if (i === j) {\n      return;\n    }\n\n    // Move the menu to the new locations.\n    ArrayExt.move(this._menus, i, j);\n\n    // Schedule an update of the items.\n    if (update) {\n      this.update();\n    }\n  }\n\n  /**\n   * Remove a menu from the menu bar.\n   *\n   * @param menu - The menu to remove from the menu bar.\n   *\n   * #### Notes\n   * This is a no-op if the menu is not in the menu bar.\n   */\n  removeMenu(menu: Menu, update: boolean = true): void {\n    this.removeMenuAt(this._menus.indexOf(menu), update);\n  }\n\n  /**\n   * Remove the menu at a given index from the menu bar.\n   *\n   * @param index - The index of the menu to remove.\n   *\n   * #### Notes\n   * This is a no-op if the index is out of range.\n   */\n  removeMenuAt(index: number, update: boolean = true): void {\n    // Close the child menu before making changes.\n    this._closeChildMenu();\n\n    // Remove the menu from the array.\n    let menu = ArrayExt.removeAt(this._menus, index);\n\n    // Bail if the index is out of range.\n    if (!menu) {\n      return;\n    }\n\n    // Disconnect from the menu signals.\n    menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n    menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n    menu.title.changed.disconnect(this._onTitleChanged, this);\n\n    // Remove the styling class from the menu.\n    menu.removeClass('lm-MenuBar-menu');\n\n    // Schedule an update of the items.\n    if (update) {\n      this.update();\n    }\n  }\n\n  /**\n   * Remove all menus from the menu bar.\n   */\n  clearMenus(): void {\n    // Bail if there is nothing to remove.\n    if (this._menus.length === 0) {\n      return;\n    }\n\n    // Close the child menu before making changes.\n    this._closeChildMenu();\n\n    // Disconnect from the menu signals and remove the styling class.\n    for (let menu of this._menus) {\n      menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n      menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n      menu.title.changed.disconnect(this._onTitleChanged, this);\n      menu.removeClass('lm-MenuBar-menu');\n    }\n\n    // Clear the menus array.\n    this._menus.length = 0;\n\n    // Schedule an update of the items.\n    this.update();\n  }\n\n  /**\n   * Handle the DOM events for the menu bar.\n   *\n   * @param event - The DOM event sent to the menu bar.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the menu bar's DOM nodes. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'mousemove':\n        this._evtMouseMove(event as MouseEvent);\n        break;\n      case 'focusout':\n        this._evtFocusOut(event as FocusEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('keydown', this);\n    this.node.addEventListener('mousedown', this);\n    this.node.addEventListener('mousemove', this);\n    this.node.addEventListener('focusout', this);\n    this.node.addEventListener('contextmenu', this);\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('keydown', this);\n    this.node.removeEventListener('mousedown', this);\n    this.node.removeEventListener('mousemove', this);\n    this.node.removeEventListener('focusout', this);\n    this.node.removeEventListener('contextmenu', this);\n    this._closeChildMenu();\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    if (this.isAttached) {\n      this._focusItemAt(0);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    this.update();\n    super.onResize(msg);\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    let menus = this._menus;\n    let renderer = this.renderer;\n    let activeIndex = this._activeIndex;\n    let tabFocusIndex =\n      this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length\n        ? this._tabFocusIndex\n        : 0;\n    let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;\n    let totalMenuSize = 0;\n    let isVisible = false;\n\n    // Check that the overflow menu doesn't count\n    length = this._overflowMenu !== null ? length - 1 : length;\n    let content = new Array<VirtualElement>(length);\n\n    // Render visible menus\n    for (let i = 0; i < length; ++i) {\n      content[i] = renderer.renderItem({\n        title: menus[i].title,\n        active: i === activeIndex,\n        tabbable: i === tabFocusIndex,\n        disabled: menus[i].items.length === 0,\n        onfocus: () => {\n          this._tabFocusIndex = i;\n          this.activeIndex = i;\n        }\n      });\n      // Calculate size of current menu\n      totalMenuSize += this._menuItemSizes[i];\n      // Check if overflow menu is already rendered\n      if (menus[i].title.label === this._overflowMenuOptions.title) {\n        isVisible = true;\n        length--;\n      }\n    }\n    // Render overflow menu if needed and active\n    if (this._overflowMenuOptions.isVisible) {\n      if (this._overflowIndex > -1 && !isVisible) {\n        // Create overflow menu\n        if (this._overflowMenu === null) {\n          const overflowMenuTitle = this._overflowMenuOptions.title ?? '...';\n          this._overflowMenu = new Menu({ commands: new CommandRegistry() });\n          this._overflowMenu.title.label = overflowMenuTitle;\n          this._overflowMenu.title.mnemonic = 0;\n          this.addMenu(this._overflowMenu, false);\n        }\n        // Move menus to overflow menu\n        for (let i = menus.length - 2; i >= length; i--) {\n          const submenu = this.menus[i];\n          submenu.title.mnemonic = 0;\n          this._overflowMenu.insertItem(0, {\n            type: 'submenu',\n            submenu: submenu\n          });\n          this.removeMenu(submenu, false);\n        }\n        content[length] = renderer.renderItem({\n          title: this._overflowMenu.title,\n          active: length === activeIndex && menus[length].items.length !== 0,\n          tabbable: length === tabFocusIndex,\n          disabled: menus[length].items.length === 0,\n          onfocus: () => {\n            this._tabFocusIndex = length;\n            this.activeIndex = length;\n          }\n        });\n        length++;\n      } else if (this._overflowMenu !== null) {\n        // Remove submenus from overflow menu\n        let overflowMenuItems = this._overflowMenu.items;\n        let screenSize = this.node.offsetWidth;\n        let n = this._overflowMenu.items.length;\n        for (let i = 0; i < n; ++i) {\n          let index = menus.length - 1 - i;\n          if (screenSize - totalMenuSize > this._menuItemSizes[index]) {\n            let menu = overflowMenuItems[0].submenu as Menu;\n            this._overflowMenu.removeItemAt(0);\n            this.insertMenu(length, menu, false);\n            content[length] = renderer.renderItem({\n              title: menu.title,\n              active: false,\n              tabbable: length === tabFocusIndex,\n              disabled: menus[length].items.length === 0,\n              onfocus: () => {\n                this._tabFocusIndex = length;\n                this.activeIndex = length;\n              }\n            });\n            length++;\n          }\n        }\n        if (this._overflowMenu.items.length === 0) {\n          this.removeMenu(this._overflowMenu, false);\n          content.pop();\n          this._overflowMenu = null;\n          this._overflowIndex = -1;\n        }\n      }\n    }\n    VirtualDOM.render(content, this.contentNode);\n    this._updateOverflowIndex();\n  }\n\n  /**\n   * Calculate and update the current overflow index.\n   */\n  private _updateOverflowIndex(): void {\n    if (!this._overflowMenuOptions.isVisible) {\n      return;\n    }\n\n    // Get elements visible in the main menu bar\n    const itemMenus = this.contentNode.childNodes;\n    let screenSize = this.node.offsetWidth;\n    let totalMenuSize = 0;\n    let index = -1;\n    let n = itemMenus.length;\n\n    if (this._menuItemSizes.length == 0) {\n      // Check if it is the first resize and get info about menu items sizes\n      for (let i = 0; i < n; i++) {\n        let item = itemMenus[i] as HTMLLIElement;\n        // Add sizes to array\n        totalMenuSize += item.offsetWidth;\n        this._menuItemSizes.push(item.offsetWidth);\n        if (totalMenuSize > screenSize && index === -1) {\n          index = i;\n        }\n      }\n    } else {\n      // Calculate current menu size\n      for (let i = 0; i < this._menuItemSizes.length; i++) {\n        totalMenuSize += this._menuItemSizes[i];\n        if (totalMenuSize > screenSize) {\n          index = i;\n          break;\n        }\n      }\n    }\n    this._overflowIndex = index;\n  }\n\n  /**\n   * Handle the `'keydown'` event for the menu bar.\n   *\n   * #### Notes\n   * All keys are trapped except the tab key that is ignored.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Fetch the key code for the event.\n    let kc = event.keyCode;\n\n    // Reset the active index on tab, but do not trap the tab key.\n    if (kc === 9) {\n      this.activeIndex = -1;\n      return;\n    }\n\n    // A menu bar handles all other keydown events.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Enter, Space, Up Arrow, Down Arrow\n    if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {\n      // The active index may have changed (for example, user hovers over an\n      // item with the mouse), so be sure to use the focus index.\n      this.activeIndex = this._tabFocusIndex;\n      if (this.activeIndex !== this._tabFocusIndex) {\n        // Bail if the setter refused to set activeIndex to tabFocusIndex\n        // because it means that the item at tabFocusIndex cannot be opened (for\n        // example, it has an empty menu)\n        return;\n      }\n      this.openActiveMenu();\n      return;\n    }\n\n    // Escape\n    if (kc === 27) {\n      this._closeChildMenu();\n      this._focusItemAt(this.activeIndex);\n      return;\n    }\n\n    // Left or Right Arrow\n    if (kc === 37 || kc === 39) {\n      let direction = kc === 37 ? -1 : 1;\n      let start = this._tabFocusIndex + direction;\n      let n = this._menus.length;\n      for (let i = 0; i < n; i++) {\n        let index = (n + start + direction * i) % n;\n        if (this._menus[index].items.length) {\n          this._focusItemAt(index);\n          return;\n        }\n      }\n      return;\n    }\n\n    // Get the pressed key character.\n    let key = getKeyboardLayout().keyForKeydownEvent(event);\n\n    // Bail if the key is not valid.\n    if (!key) {\n      return;\n    }\n\n    // Search for the next best matching mnemonic item.\n    let start = this._activeIndex + 1;\n    let result = Private.findMnemonic(this._menus, key, start);\n\n    // Handle the requested mnemonic based on the search results.\n    // If exactly one mnemonic is matched, that menu is opened.\n    // Otherwise, the next mnemonic is activated if available,\n    // followed by the auto mnemonic if available.\n    if (result.index !== -1 && !result.multiple) {\n      this.activeIndex = result.index;\n      this.openActiveMenu();\n    } else if (result.index !== -1) {\n      this.activeIndex = result.index;\n      this._focusItemAt(this.activeIndex);\n    } else if (result.auto !== -1) {\n      this.activeIndex = result.auto;\n      this._focusItemAt(this.activeIndex);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the menu bar.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Bail if the mouse press was not on the menu bar. This can occur\n    // when the document listener is installed for an active menu bar.\n    if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {\n      return;\n    }\n\n    // Stop the propagation of the event. Immediate propagation is\n    // also stopped so that an open menu does not handle the event.\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    // Check if the mouse is over one of the menu items.\n    let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n      return ElementExt.hitTest(node, event.clientX, event.clientY);\n    });\n\n    // If the press was not on an item, close the child menu.\n    if (index === -1) {\n      this._closeChildMenu();\n      return;\n    }\n\n    // If the press was not the left mouse button, do nothing further.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Otherwise, toggle the open state of the child menu.\n    if (this._childMenu) {\n      this._closeChildMenu();\n      this.activeIndex = index;\n    } else {\n      // If we don't call preventDefault() here, then the item in the menu\n      // bar will take focus over the menu that is being opened.\n      event.preventDefault();\n      const position = this._positionForMenu(index);\n      Menu.saveWindowData();\n      // Begin DOM modifications.\n      this.activeIndex = index;\n      this._openChildMenu(position);\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the menu bar.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Check if the mouse is over one of the menu items.\n    let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n      return ElementExt.hitTest(node, event.clientX, event.clientY);\n    });\n\n    // Bail early if the active index will not change.\n    if (index === this._activeIndex) {\n      return;\n    }\n\n    // Bail early if a child menu is open and the mouse is not over\n    // an item. This allows the child menu to be kept open when the\n    // mouse is over the empty part of the menu bar.\n    if (index === -1 && this._childMenu) {\n      return;\n    }\n\n    // Get position for the new menu >before< updating active index.\n    const position =\n      index >= 0 && this._childMenu ? this._positionForMenu(index) : null;\n\n    // Before any modification, update window data.\n    Menu.saveWindowData();\n\n    // Begin DOM modifications.\n\n    // Update the active index to the hovered item.\n    this.activeIndex = index;\n\n    // Open the new menu if a menu is already open.\n    if (position) {\n      this._openChildMenu(position);\n    }\n  }\n\n  /**\n   * Find initial position for the menu based on menubar item position.\n   *\n   * NOTE: this should be called before updating active index to avoid\n   * an additional layout and style invalidation as changing active\n   * index modifies DOM.\n   */\n  private _positionForMenu(index: number): Private.IPosition {\n    let itemNode = this.contentNode.children[index];\n    let { left, bottom } = (itemNode as HTMLElement).getBoundingClientRect();\n    return {\n      top: bottom,\n      left\n    };\n  }\n\n  /**\n   * Handle the `'focusout'` event for the menu bar.\n   */\n  private _evtFocusOut(event: FocusEvent): void {\n    // Reset the active index if there is no open menu and the menubar is losing focus.\n    if (!this._childMenu && !this.node.contains(event.relatedTarget as Node)) {\n      this.activeIndex = -1;\n    }\n  }\n\n  /**\n   * Focus an item in the menu bar.\n   *\n   * #### Notes\n   * Does not open the associated menu.\n   */\n  private _focusItemAt(index: number): void {\n    const itemNode = this.contentNode.childNodes[index] as HTMLElement | void;\n    if (itemNode) {\n      itemNode.focus();\n    }\n  }\n\n  /**\n   * Open the child menu at the active index immediately.\n   *\n   * If a different child menu is already open, it will be closed,\n   * even if there is no active menu.\n   */\n  private _openChildMenu(options: { left?: number; top?: number } = {}): void {\n    // If there is no active menu, close the current menu.\n    let newMenu = this.activeMenu;\n    if (!newMenu) {\n      this._closeChildMenu();\n      return;\n    }\n\n    // Bail if there is no effective menu change.\n    let oldMenu = this._childMenu;\n    if (oldMenu === newMenu) {\n      return;\n    }\n\n    // Swap the internal menu reference.\n    this._childMenu = newMenu;\n\n    // Close the current menu, or setup for the new menu.\n    if (oldMenu) {\n      oldMenu.close();\n    } else {\n      document.addEventListener('mousedown', this, true);\n    }\n\n    // Update the tab focus index and ensure the menu bar is updated.\n    this._tabFocusIndex = this.activeIndex;\n    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n\n    // Get the positioning data for the new menu.\n    let { left, top } = options;\n    if (typeof left === 'undefined' || typeof top === 'undefined') {\n      ({ left, top } = this._positionForMenu(this._activeIndex));\n    }\n    // Begin DOM modifications\n\n    if (!oldMenu) {\n      // Continue setup for new menu\n      this.addClass('lm-mod-active');\n    }\n\n    // Open the new menu at the computed location.\n    if (newMenu.items.length > 0) {\n      newMenu.open(left, top, this._forceItemsPosition);\n    }\n  }\n\n  /**\n   * Close the child menu immediately.\n   *\n   * This is a no-op if a child menu is not open.\n   */\n  private _closeChildMenu(): void {\n    // Bail if no child menu is open.\n    if (!this._childMenu) {\n      return;\n    }\n    // Remove the active class from the menu bar.\n    this.removeClass('lm-mod-active');\n\n    // Remove the document listeners.\n    document.removeEventListener('mousedown', this, true);\n\n    // Clear the internal menu reference.\n    let menu = this._childMenu;\n    this._childMenu = null;\n\n    // Close the menu.\n    menu.close();\n\n    // Reset the active index.\n    this.activeIndex = -1;\n  }\n\n  /**\n   * Handle the `aboutToClose` signal of a menu.\n   */\n  private _onMenuAboutToClose(sender: Menu): void {\n    // Bail if the sender is not the child menu.\n    if (sender !== this._childMenu) {\n      return;\n    }\n\n    // Remove the active class from the menu bar.\n    this.removeClass('lm-mod-active');\n\n    // Remove the document listeners.\n    document.removeEventListener('mousedown', this, true);\n\n    // Clear the internal menu reference.\n    this._childMenu = null;\n\n    // Reset the active index.\n    this.activeIndex = -1;\n  }\n\n  /**\n   * Handle the `menuRequested` signal of a child menu.\n   */\n  private _onMenuMenuRequested(sender: Menu, args: 'next' | 'previous'): void {\n    // Bail if the sender is not the child menu.\n    if (sender !== this._childMenu) {\n      return;\n    }\n\n    // Look up the active index and menu count.\n    let i = this._activeIndex;\n    let n = this._menus.length;\n\n    // Active the next requested index.\n    switch (args) {\n      case 'next':\n        this.activeIndex = i === n - 1 ? 0 : i + 1;\n        break;\n      case 'previous':\n        this.activeIndex = i === 0 ? n - 1 : i - 1;\n        break;\n    }\n\n    // Open the active menu.\n    this.openActiveMenu();\n  }\n\n  /**\n   * Handle the `changed` signal of a title object.\n   */\n  private _onTitleChanged(): void {\n    this.update();\n  }\n\n  // Track the index of the item that is currently focused or hovered. -1 means nothing focused or hovered.\n  private _activeIndex = -1;\n  // Track which item can be focused using the TAB key. Unlike _activeIndex will\n  // always point to a menuitem. Whenever you update this value, it's important\n  // to follow it with an \"update-request\" message so that the `tabindex`\n  // attribute on each menubar item gets properly updated.\n  private _tabFocusIndex = 0;\n  private _forceItemsPosition: Menu.IOpenOptions;\n  private _overflowMenuOptions: IOverflowMenuOptions;\n  private _menus: Menu[] = [];\n  private _childMenu: Menu | null = null;\n  private _overflowMenu: Menu | null = null;\n  private _menuItemSizes: number[] = [];\n  private _overflowIndex: number = -1;\n}\n\n/**\n * The namespace for the `MenuBar` class statics.\n */\nexport namespace MenuBar {\n  /**\n   * An options object for creating a menu bar.\n   */\n  export interface IOptions {\n    /**\n     * A custom renderer for creating menu bar content.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: IRenderer;\n    /**\n     * Whether to force the position of the menu. The MenuBar forces the\n     * coordinates of its menus by default. With this option you can disable it.\n     *\n     * Setting to `false` will enable the logic which repositions the\n     * coordinates of the menu if it will not fit entirely on screen.\n     *\n     * The default is `true`.\n     */\n    forceItemsPosition?: Menu.IOpenOptions;\n    /**\n     * Whether to add a overflow menu if there's overflow.\n     *\n     * Setting to `true` will enable the logic that creates an overflow menu\n     * to show the menu items that don't fit entirely on the screen.\n     *\n     * The default is `true`.\n     */\n    overflowMenuOptions?: IOverflowMenuOptions;\n  }\n\n  /**\n   * An object which holds the data to render a menu bar item.\n   */\n  export interface IRenderData {\n    /**\n     * The title to be rendered.\n     */\n    readonly title: Title<Widget>;\n\n    /**\n     * Whether the item is the active item.\n     */\n    readonly active: boolean;\n\n    /**\n     * Whether the user can tab to the item.\n     */\n    readonly tabbable: boolean;\n\n    /**\n     * Whether the item is disabled.\n     *\n     * #### Notes\n     * A disabled item cannot be active.\n     * A disabled item cannot be focussed.\n     */\n    readonly disabled?: boolean;\n\n    readonly onfocus?: (event: FocusEvent) => void;\n  }\n\n  /**\n   * A renderer for use with a menu bar.\n   */\n  export interface IRenderer {\n    /**\n     * Render the virtual element for a menu bar item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     */\n    renderItem(data: IRenderData): VirtualElement;\n  }\n\n  /**\n   * The default implementation of `IRenderer`.\n   *\n   * #### Notes\n   * Subclasses are free to reimplement rendering methods as needed.\n   */\n  export class Renderer implements IRenderer {\n    /**\n     * Render the virtual element for a menu bar item.\n     *\n     * @param data - The data to use for rendering the item.\n     *\n     * @returns A virtual element representing the item.\n     */\n    renderItem(data: IRenderData): VirtualElement {\n      let className = this.createItemClass(data);\n      let dataset = this.createItemDataset(data);\n      let aria = this.createItemARIA(data);\n      return h.li(\n        {\n          className,\n          dataset,\n          ...(data.disabled ? {} : { tabindex: data.tabbable ? '0' : '-1' }),\n          onfocus: data.onfocus,\n          ...aria\n        },\n        this.renderIcon(data),\n        this.renderLabel(data)\n      );\n    }\n\n    /**\n     * Render the icon element for a menu bar item.\n     *\n     * @param data - The data to use for rendering the icon.\n     *\n     * @returns A virtual element representing the item icon.\n     */\n    renderIcon(data: IRenderData): VirtualElement {\n      let className = this.createIconClass(data);\n\n      // If data.title.icon is undefined, it will be ignored.\n      return h.div({ className }, data.title.icon!, data.title.iconLabel);\n    }\n\n    /**\n     * Render the label element for a menu item.\n     *\n     * @param data - The data to use for rendering the label.\n     *\n     * @returns A virtual element representing the item label.\n     */\n    renderLabel(data: IRenderData): VirtualElement {\n      let content = this.formatLabel(data);\n      return h.div({ className: 'lm-MenuBar-itemLabel' }, content);\n    }\n\n    /**\n     * Create the class name for the menu bar item.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the menu item.\n     */\n    createItemClass(data: IRenderData): string {\n      let name = 'lm-MenuBar-item';\n      if (data.title.className) {\n        name += ` ${data.title.className}`;\n      }\n      if (data.active && !data.disabled) {\n        name += ' lm-mod-active';\n      }\n      return name;\n    }\n\n    /**\n     * Create the dataset for a menu bar item.\n     *\n     * @param data - The data to use for the item.\n     *\n     * @returns The dataset for the menu bar item.\n     */\n    createItemDataset(data: IRenderData): ElementDataset {\n      return data.title.dataset;\n    }\n\n    /**\n     * Create the aria attributes for menu bar item.\n     *\n     * @param data - The data to use for the aria attributes.\n     *\n     * @returns The aria attributes object for the item.\n     */\n    createItemARIA(data: IRenderData): ElementARIAAttrs {\n      return {\n        role: 'menuitem',\n        'aria-haspopup': 'true',\n        'aria-disabled': data.disabled ? 'true' : 'false'\n      };\n    }\n\n    /**\n     * Create the class name for the menu bar item icon.\n     *\n     * @param data - The data to use for the class name.\n     *\n     * @returns The full class name for the item icon.\n     */\n    createIconClass(data: IRenderData): string {\n      let name = 'lm-MenuBar-itemIcon';\n      let extra = data.title.iconClass;\n      return extra ? `${name} ${extra}` : name;\n    }\n\n    /**\n     * Create the render content for the label node.\n     *\n     * @param data - The data to use for the label content.\n     *\n     * @returns The content to add to the label node.\n     */\n    formatLabel(data: IRenderData): h.Child {\n      // Fetch the label text and mnemonic index.\n      let { label, mnemonic } = data.title;\n\n      // If the index is out of range, do not modify the label.\n      if (mnemonic < 0 || mnemonic >= label.length) {\n        return label;\n      }\n\n      // Split the label into parts.\n      let prefix = label.slice(0, mnemonic);\n      let suffix = label.slice(mnemonic + 1);\n      let char = label[mnemonic];\n\n      // Wrap the mnemonic character in a span.\n      let span = h.span({ className: 'lm-MenuBar-itemMnemonic' }, char);\n\n      // Return the content parts.\n      return [prefix, span, suffix];\n    }\n  }\n\n  /**\n   * The default `Renderer` instance.\n   */\n  export const defaultRenderer = new Renderer();\n}\n\n/**\n * Options for overflow menu.\n */\nexport interface IOverflowMenuOptions {\n  /**\n   * Determines if a overflow menu appears when the menu items overflow.\n   *\n   * Defaults to `true`.\n   */\n  isVisible: boolean;\n  /**\n   * Determines the title of the overflow menu.\n   *\n   * Default: `...`.\n   */\n  title?: string;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create the DOM node for a menu bar.\n   */\n  export function createNode(): HTMLDivElement {\n    let node = document.createElement('div');\n    let content = document.createElement('ul');\n    content.className = 'lm-MenuBar-content';\n    node.appendChild(content);\n    content.setAttribute('role', 'menubar');\n    return node;\n  }\n\n  /**\n   * Position for the menu relative to top-left screen corner.\n   */\n  export interface IPosition {\n    /**\n     * Pixels right from screen origin.\n     */\n    left: number;\n    /**\n     * Pixels down from screen origin.\n     */\n    top: number;\n  }\n\n  /**\n   * The results of a mnemonic search.\n   */\n  export interface IMnemonicResult {\n    /**\n     * The index of the first matching mnemonic item, or `-1`.\n     */\n    index: number;\n\n    /**\n     * Whether multiple mnemonic items matched.\n     */\n    multiple: boolean;\n\n    /**\n     * The index of the first auto matched non-mnemonic item.\n     */\n    auto: number;\n  }\n\n  /**\n   * Find the best matching mnemonic item.\n   *\n   * The search starts at the given index and wraps around.\n   */\n  export function findMnemonic(\n    menus: ReadonlyArray<Menu>,\n    key: string,\n    start: number\n  ): IMnemonicResult {\n    // Setup the result variables.\n    let index = -1;\n    let auto = -1;\n    let multiple = false;\n\n    // Normalize the key to upper case.\n    let upperKey = key.toUpperCase();\n\n    // Search the items from the given start index.\n    for (let i = 0, n = menus.length; i < n; ++i) {\n      // Compute the wrapped index.\n      let k = (i + start) % n;\n\n      // Look up the menu title.\n      let title = menus[k].title;\n\n      // Ignore titles with an empty label.\n      if (title.label.length === 0) {\n        continue;\n      }\n\n      // Look up the mnemonic index for the label.\n      let mn = title.mnemonic;\n\n      // Handle a valid mnemonic index.\n      if (mn >= 0 && mn < title.label.length) {\n        if (title.label[mn].toUpperCase() === upperKey) {\n          if (index === -1) {\n            index = k;\n          } else {\n            multiple = true;\n          }\n        }\n        continue;\n      }\n\n      // Finally, handle the auto index if possible.\n      if (auto === -1 && title.label[0].toUpperCase() === upperKey) {\n        auto = k;\n      }\n    }\n\n    // Return the search results.\n    return { index, multiple, auto };\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { Message } from '@lumino/messaging';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { Widget } from './widget';\n\n/**\n * A widget which implements a canonical scroll bar.\n */\nexport class ScrollBar extends Widget {\n  /**\n   * Construct a new scroll bar.\n   *\n   * @param options - The options for initializing the scroll bar.\n   */\n  constructor(options: ScrollBar.IOptions = {}) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-ScrollBar');\n    this.setFlag(Widget.Flag.DisallowLayout);\n\n    // Set the orientation.\n    this._orientation = options.orientation || 'vertical';\n    this.dataset['orientation'] = this._orientation;\n\n    // Parse the rest of the options.\n    if (options.maximum !== undefined) {\n      this._maximum = Math.max(0, options.maximum);\n    }\n    if (options.page !== undefined) {\n      this._page = Math.max(0, options.page);\n    }\n    if (options.value !== undefined) {\n      this._value = Math.max(0, Math.min(options.value, this._maximum));\n    }\n  }\n\n  /**\n   * A signal emitted when the user moves the scroll thumb.\n   *\n   * #### Notes\n   * The payload is the current value of the scroll bar.\n   */\n  get thumbMoved(): ISignal<this, number> {\n    return this._thumbMoved;\n  }\n\n  /**\n   * A signal emitted when the user clicks a step button.\n   *\n   * #### Notes\n   * The payload is whether a decrease or increase is requested.\n   */\n  get stepRequested(): ISignal<this, 'decrement' | 'increment'> {\n    return this._stepRequested;\n  }\n\n  /**\n   * A signal emitted when the user clicks the scroll track.\n   *\n   * #### Notes\n   * The payload is whether a decrease or increase is requested.\n   */\n  get pageRequested(): ISignal<this, 'decrement' | 'increment'> {\n    return this._pageRequested;\n  }\n\n  /**\n   * Get the orientation of the scroll bar.\n   */\n  get orientation(): ScrollBar.Orientation {\n    return this._orientation;\n  }\n\n  /**\n   * Set the orientation of the scroll bar.\n   */\n  set orientation(value: ScrollBar.Orientation) {\n    // Do nothing if the orientation does not change.\n    if (this._orientation === value) {\n      return;\n    }\n\n    // Release the mouse before making changes.\n    this._releaseMouse();\n\n    // Update the internal orientation.\n    this._orientation = value;\n    this.dataset['orientation'] = value;\n\n    // Schedule an update the scroll bar.\n    this.update();\n  }\n\n  /**\n   * Get the current value of the scroll bar.\n   */\n  get value(): number {\n    return this._value;\n  }\n\n  /**\n   * Set the current value of the scroll bar.\n   *\n   * #### Notes\n   * The value will be clamped to the range `[0, maximum]`.\n   */\n  set value(value: number) {\n    // Clamp the value to the allowable range.\n    value = Math.max(0, Math.min(value, this._maximum));\n\n    // Do nothing if the value does not change.\n    if (this._value === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._value = value;\n\n    // Schedule an update the scroll bar.\n    this.update();\n  }\n\n  /**\n   * Get the page size of the scroll bar.\n   *\n   * #### Notes\n   * The page size is the amount of visible content in the scrolled\n   * region, expressed in data units. It determines the size of the\n   * scroll bar thumb.\n   */\n  get page(): number {\n    return this._page;\n  }\n\n  /**\n   * Set the page size of the scroll bar.\n   *\n   * #### Notes\n   * The page size will be clamped to the range `[0, Infinity]`.\n   */\n  set page(value: number) {\n    // Clamp the page size to the allowable range.\n    value = Math.max(0, value);\n\n    // Do nothing if the value does not change.\n    if (this._page === value) {\n      return;\n    }\n\n    // Update the internal page size.\n    this._page = value;\n\n    // Schedule an update the scroll bar.\n    this.update();\n  }\n\n  /**\n   * Get the maximum value of the scroll bar.\n   */\n  get maximum(): number {\n    return this._maximum;\n  }\n\n  /**\n   * Set the maximum value of the scroll bar.\n   *\n   * #### Notes\n   * The max size will be clamped to the range `[0, Infinity]`.\n   */\n  set maximum(value: number) {\n    // Clamp the value to the allowable range.\n    value = Math.max(0, value);\n\n    // Do nothing if the value does not change.\n    if (this._maximum === value) {\n      return;\n    }\n\n    // Update the internal values.\n    this._maximum = value;\n\n    // Clamp the current value to the new range.\n    this._value = Math.min(this._value, value);\n\n    // Schedule an update the scroll bar.\n    this.update();\n  }\n\n  /**\n   * The scroll bar decrement button node.\n   *\n   * #### Notes\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get decrementNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-ScrollBar-button'\n    )[0] as HTMLDivElement;\n  }\n\n  /**\n   * The scroll bar increment button node.\n   *\n   * #### Notes\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get incrementNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-ScrollBar-button'\n    )[1] as HTMLDivElement;\n  }\n\n  /**\n   * The scroll bar track node.\n   *\n   * #### Notes\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get trackNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-ScrollBar-track'\n    )[0] as HTMLDivElement;\n  }\n\n  /**\n   * The scroll bar thumb node.\n   *\n   * #### Notes\n   * Modifying this node directly can lead to undefined behavior.\n   */\n  get thumbNode(): HTMLDivElement {\n    return this.node.getElementsByClassName(\n      'lm-ScrollBar-thumb'\n    )[0] as HTMLDivElement;\n  }\n\n  /**\n   * Handle the DOM events for the scroll bar.\n   *\n   * @param event - The DOM event sent to the scroll bar.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the scroll bar's DOM node.\n   *\n   * This should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'mousemove':\n        this._evtMouseMove(event as MouseEvent);\n        break;\n      case 'mouseup':\n        this._evtMouseUp(event as MouseEvent);\n        break;\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * A method invoked on a 'before-attach' message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('mousedown', this);\n    this.update();\n  }\n\n  /**\n   * A method invoked on an 'after-detach' message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('mousedown', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A method invoked on an 'update-request' message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    // Convert the value and page into percentages.\n    let value = (this._value * 100) / this._maximum;\n    let page = (this._page * 100) / (this._page + this._maximum);\n\n    // Clamp the value and page to the relevant range.\n    value = Math.max(0, Math.min(value, 100));\n    page = Math.max(0, Math.min(page, 100));\n\n    // Fetch the thumb style.\n    let thumbStyle = this.thumbNode.style;\n\n    // Update the thumb style for the current orientation.\n    if (this._orientation === 'horizontal') {\n      thumbStyle.top = '';\n      thumbStyle.height = '';\n      thumbStyle.left = `${value}%`;\n      thumbStyle.width = `${page}%`;\n      thumbStyle.transform = `translate(${-value}%, 0%)`;\n    } else {\n      thumbStyle.left = '';\n      thumbStyle.width = '';\n      thumbStyle.top = `${value}%`;\n      thumbStyle.height = `${page}%`;\n      thumbStyle.transform = `translate(0%, ${-value}%)`;\n    }\n  }\n\n  /**\n   * Handle the `'keydown'` event for the scroll bar.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Stop all input events during drag.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Ignore anything except the `Escape` key.\n    if (event.keyCode !== 27) {\n      return;\n    }\n\n    // Fetch the previous scroll value.\n    let value = this._pressData ? this._pressData.value : -1;\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Restore the old scroll value if possible.\n    if (value !== -1) {\n      this._moveThumb(value);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the scroll bar.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Do nothing if it's not a left mouse press.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Send an activate request to the scroll bar. This can be\n    // used by message hooks to activate something relevant.\n    this.activate();\n\n    // Do nothing if the mouse is already captured.\n    if (this._pressData) {\n      return;\n    }\n\n    // Find the pressed scroll bar part.\n    let part = Private.findPart(this, event.target as HTMLElement);\n\n    // Do nothing if the part is not of interest.\n    if (!part) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Override the mouse cursor.\n    let override = Drag.overrideCursor('default');\n\n    // Set up the press data.\n    this._pressData = {\n      part,\n      override,\n      delta: -1,\n      value: -1,\n      mouseX: event.clientX,\n      mouseY: event.clientY\n    };\n\n    // Add the extra event listeners.\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Handle a thumb press.\n    if (part === 'thumb') {\n      // Fetch the thumb node.\n      let thumbNode = this.thumbNode;\n\n      // Fetch the client rect for the thumb.\n      let thumbRect = thumbNode.getBoundingClientRect();\n\n      // Update the press data delta for the current orientation.\n      if (this._orientation === 'horizontal') {\n        this._pressData.delta = event.clientX - thumbRect.left;\n      } else {\n        this._pressData.delta = event.clientY - thumbRect.top;\n      }\n\n      // Add the active class to the thumb node.\n      thumbNode.classList.add('lm-mod-active');\n\n      // Store the current value in the press data.\n      this._pressData.value = this._value;\n\n      // Finished.\n      return;\n    }\n\n    // Handle a track press.\n    if (part === 'track') {\n      // Fetch the client rect for the thumb.\n      let thumbRect = this.thumbNode.getBoundingClientRect();\n\n      // Determine the direction for the page request.\n      let dir: 'decrement' | 'increment';\n      if (this._orientation === 'horizontal') {\n        dir = event.clientX < thumbRect.left ? 'decrement' : 'increment';\n      } else {\n        dir = event.clientY < thumbRect.top ? 'decrement' : 'increment';\n      }\n\n      // Start the repeat timer.\n      this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n\n      // Emit the page requested signal.\n      this._pageRequested.emit(dir);\n\n      // Finished.\n      return;\n    }\n\n    // Handle a decrement button press.\n    if (part === 'decrement') {\n      // Add the active class to the decrement node.\n      this.decrementNode.classList.add('lm-mod-active');\n\n      // Start the repeat timer.\n      this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n\n      // Emit the step requested signal.\n      this._stepRequested.emit('decrement');\n\n      // Finished.\n      return;\n    }\n\n    // Handle an increment button press.\n    if (part === 'increment') {\n      // Add the active class to the increment node.\n      this.incrementNode.classList.add('lm-mod-active');\n\n      // Start the repeat timer.\n      this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n\n      // Emit the step requested signal.\n      this._stepRequested.emit('increment');\n\n      // Finished.\n      return;\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the scroll bar.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Do nothing if no drag is in progress.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Update the mouse position.\n    this._pressData.mouseX = event.clientX;\n    this._pressData.mouseY = event.clientY;\n\n    // Bail if the thumb is not being dragged.\n    if (this._pressData.part !== 'thumb') {\n      return;\n    }\n\n    // Get the client rect for the thumb and track.\n    let thumbRect = this.thumbNode.getBoundingClientRect();\n    let trackRect = this.trackNode.getBoundingClientRect();\n\n    // Fetch the scroll geometry based on the orientation.\n    let trackPos: number;\n    let trackSpan: number;\n    if (this._orientation === 'horizontal') {\n      trackPos = event.clientX - trackRect.left - this._pressData.delta;\n      trackSpan = trackRect.width - thumbRect.width;\n    } else {\n      trackPos = event.clientY - trackRect.top - this._pressData.delta;\n      trackSpan = trackRect.height - thumbRect.height;\n    }\n\n    // Compute the desired value from the scroll geometry.\n    let value = trackSpan === 0 ? 0 : (trackPos * this._maximum) / trackSpan;\n\n    // Move the thumb to the computed value.\n    this._moveThumb(value);\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the scroll bar.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Do nothing if it's not a left mouse release.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Release the mouse and restore the node states.\n   */\n  private _releaseMouse(): void {\n    // Bail if there is no press data.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the repeat timer.\n    clearTimeout(this._repeatTimer);\n    this._repeatTimer = -1;\n\n    // Clear the press data.\n    this._pressData.override.dispose();\n    this._pressData = null;\n\n    // Remove the extra event listeners.\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('contextmenu', this, true);\n\n    // Remove the active classes from the nodes.\n    this.thumbNode.classList.remove('lm-mod-active');\n    this.decrementNode.classList.remove('lm-mod-active');\n    this.incrementNode.classList.remove('lm-mod-active');\n  }\n\n  /**\n   * Move the thumb to the specified position.\n   */\n  private _moveThumb(value: number): void {\n    // Clamp the value to the allowed range.\n    value = Math.max(0, Math.min(value, this._maximum));\n\n    // Bail if the value does not change.\n    if (this._value === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._value = value;\n\n    // Schedule an update of the scroll bar.\n    this.update();\n\n    // Emit the thumb moved signal.\n    this._thumbMoved.emit(value);\n  }\n\n  /**\n   * A timeout callback for repeating the mouse press.\n   */\n  private _onRepeat = () => {\n    // Clear the repeat timer id.\n    this._repeatTimer = -1;\n\n    // Bail if the mouse has been released.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Look up the part that was pressed.\n    let part = this._pressData.part;\n\n    // Bail if the thumb was pressed.\n    if (part === 'thumb') {\n      return;\n    }\n\n    // Schedule the timer for another repeat.\n    this._repeatTimer = window.setTimeout(this._onRepeat, 20);\n\n    // Get the current mouse position.\n    let mouseX = this._pressData.mouseX;\n    let mouseY = this._pressData.mouseY;\n\n    // Handle a decrement button repeat.\n    if (part === 'decrement') {\n      // Bail if the mouse is not over the button.\n      if (!ElementExt.hitTest(this.decrementNode, mouseX, mouseY)) {\n        return;\n      }\n\n      // Emit the step requested signal.\n      this._stepRequested.emit('decrement');\n\n      // Finished.\n      return;\n    }\n\n    // Handle an increment button repeat.\n    if (part === 'increment') {\n      // Bail if the mouse is not over the button.\n      if (!ElementExt.hitTest(this.incrementNode, mouseX, mouseY)) {\n        return;\n      }\n\n      // Emit the step requested signal.\n      this._stepRequested.emit('increment');\n\n      // Finished.\n      return;\n    }\n\n    // Handle a track repeat.\n    if (part === 'track') {\n      // Bail if the mouse is not over the track.\n      if (!ElementExt.hitTest(this.trackNode, mouseX, mouseY)) {\n        return;\n      }\n\n      // Fetch the thumb node.\n      let thumbNode = this.thumbNode;\n\n      // Bail if the mouse is over the thumb.\n      if (ElementExt.hitTest(thumbNode, mouseX, mouseY)) {\n        return;\n      }\n\n      // Fetch the client rect for the thumb.\n      let thumbRect = thumbNode.getBoundingClientRect();\n\n      // Determine the direction for the page request.\n      let dir: 'decrement' | 'increment';\n      if (this._orientation === 'horizontal') {\n        dir = mouseX < thumbRect.left ? 'decrement' : 'increment';\n      } else {\n        dir = mouseY < thumbRect.top ? 'decrement' : 'increment';\n      }\n\n      // Emit the page requested signal.\n      this._pageRequested.emit(dir);\n\n      // Finished.\n      return;\n    }\n  };\n\n  private _value = 0;\n  private _page = 10;\n  private _maximum = 100;\n  private _repeatTimer = -1;\n  private _orientation: ScrollBar.Orientation;\n  private _pressData: Private.IPressData | null = null;\n  private _thumbMoved = new Signal<this, number>(this);\n  private _stepRequested = new Signal<this, 'decrement' | 'increment'>(this);\n  private _pageRequested = new Signal<this, 'decrement' | 'increment'>(this);\n}\n\n/**\n * The namespace for the `ScrollBar` class statics.\n */\nexport namespace ScrollBar {\n  /**\n   * A type alias for a scroll bar orientation.\n   */\n  export type Orientation = 'horizontal' | 'vertical';\n\n  /**\n   * An options object for creating a scroll bar.\n   */\n  export interface IOptions {\n    /**\n     * The orientation of the scroll bar.\n     *\n     * The default is `'vertical'`.\n     */\n    orientation?: Orientation;\n\n    /**\n     * The value for the scroll bar.\n     *\n     * The default is `0`.\n     */\n    value?: number;\n\n    /**\n     * The page size for the scroll bar.\n     *\n     * The default is `10`.\n     */\n    page?: number;\n\n    /**\n     * The maximum value for the scroll bar.\n     *\n     * The default is `100`.\n     */\n    maximum?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A type alias for the parts of a scroll bar.\n   */\n  export type ScrollBarPart = 'thumb' | 'track' | 'decrement' | 'increment';\n\n  /**\n   * An object which holds mouse press data.\n   */\n  export interface IPressData {\n    /**\n     * The scroll bar part which was pressed.\n     */\n    part: ScrollBarPart;\n\n    /**\n     * The offset of the press in thumb coordinates, or -1.\n     */\n    delta: number;\n\n    /**\n     * The scroll value at the time the thumb was pressed, or -1.\n     */\n    value: number;\n\n    /**\n     * The disposable which will clear the override cursor.\n     */\n    override: IDisposable;\n\n    /**\n     * The current X position of the mouse.\n     */\n    mouseX: number;\n\n    /**\n     * The current Y position of the mouse.\n     */\n    mouseY: number;\n  }\n\n  /**\n   * Create the DOM node for a scroll bar.\n   */\n  export function createNode(): HTMLElement {\n    let node = document.createElement('div');\n    let decrement = document.createElement('div');\n    let increment = document.createElement('div');\n    let track = document.createElement('div');\n    let thumb = document.createElement('div');\n    decrement.className = 'lm-ScrollBar-button';\n    increment.className = 'lm-ScrollBar-button';\n    decrement.dataset['action'] = 'decrement';\n    increment.dataset['action'] = 'increment';\n    track.className = 'lm-ScrollBar-track';\n    thumb.className = 'lm-ScrollBar-thumb';\n    track.appendChild(thumb);\n    node.appendChild(decrement);\n    node.appendChild(track);\n    node.appendChild(increment);\n    return node;\n  }\n\n  /**\n   * Find the scroll bar part which contains the given target.\n   */\n  export function findPart(\n    scrollBar: ScrollBar,\n    target: HTMLElement\n  ): ScrollBarPart | null {\n    // Test the thumb.\n    if (scrollBar.thumbNode.contains(target)) {\n      return 'thumb';\n    }\n\n    // Test the track.\n    if (scrollBar.trackNode.contains(target)) {\n      return 'track';\n    }\n\n    // Test the decrement button.\n    if (scrollBar.decrementNode.contains(target)) {\n      return 'decrement';\n    }\n\n    // Test the increment button.\n    if (scrollBar.incrementNode.contains(target)) {\n      return 'increment';\n    }\n\n    // Indicate no match.\n    return null;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { Panel } from './panel';\n\nimport { StackedLayout } from './stackedlayout';\n\nimport { Widget } from './widget';\n\n/**\n * A panel where visible widgets are stacked atop one another.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link StackedLayout}.\n */\nexport class StackedPanel extends Panel {\n  /**\n   * Construct a new stacked panel.\n   *\n   * @param options - The options for initializing the panel.\n   */\n  constructor(options: StackedPanel.IOptions = {}) {\n    super({ layout: Private.createLayout(options) });\n    this.addClass('lm-StackedPanel');\n  }\n\n  /**\n   * The method for hiding widgets.\n   *\n   * #### Notes\n   * If there is only one child widget, `Display` hiding mode will be used\n   * regardless of this setting.\n   */\n  get hiddenMode(): Widget.HiddenMode {\n    return (this.layout as StackedLayout).hiddenMode;\n  }\n\n  /**\n   * Set the method for hiding widgets.\n   *\n   * #### Notes\n   * If there is only one child widget, `Display` hiding mode will be used\n   * regardless of this setting.\n   */\n  set hiddenMode(v: Widget.HiddenMode) {\n    (this.layout as StackedLayout).hiddenMode = v;\n  }\n\n  /**\n   * A signal emitted when a widget is removed from a stacked panel.\n   */\n  get widgetRemoved(): ISignal<this, Widget> {\n    return this._widgetRemoved;\n  }\n\n  /**\n   * A message handler invoked on a `'child-added'` message.\n   */\n  protected onChildAdded(msg: Widget.ChildMessage): void {\n    msg.child.addClass('lm-StackedPanel-child');\n  }\n\n  /**\n   * A message handler invoked on a `'child-removed'` message.\n   */\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    msg.child.removeClass('lm-StackedPanel-child');\n    this._widgetRemoved.emit(msg.child);\n  }\n\n  private _widgetRemoved = new Signal<this, Widget>(this);\n}\n\n/**\n * The namespace for the `StackedPanel` class statics.\n */\nexport namespace StackedPanel {\n  /**\n   * An options object for creating a stacked panel.\n   */\n  export interface IOptions {\n    /**\n     * The stacked layout to use for the stacked panel.\n     *\n     * The default is a new `StackedLayout`.\n     */\n    layout?: StackedLayout;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create a stacked layout for the given panel options.\n   */\n  export function createLayout(options: StackedPanel.IOptions): StackedLayout {\n    return options.layout || new StackedLayout();\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Platform } from '@lumino/domutils';\n\nimport { MessageLoop } from '@lumino/messaging';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { BoxLayout } from './boxlayout';\n\nimport { StackedPanel } from './stackedpanel';\n\nimport { TabBar } from './tabbar';\n\nimport { Widget } from './widget';\n\n/**\n * A widget which combines a `TabBar` and a `StackedPanel`.\n *\n * #### Notes\n * This is a simple panel which handles the common case of a tab bar\n * placed next to a content area. The selected tab controls the widget\n * which is shown in the content area.\n *\n * For use cases which require more control than is provided by this\n * panel, the `TabBar` widget may be used independently.\n */\nexport class TabPanel extends Widget {\n  /**\n   * Construct a new tab panel.\n   *\n   * @param options - The options for initializing the tab panel.\n   */\n  constructor(options: TabPanel.IOptions = {}) {\n    super();\n    this.addClass('lm-TabPanel');\n\n    // Create the tab bar and stacked panel.\n    this.tabBar = new TabBar<Widget>(options);\n    this.tabBar.addClass('lm-TabPanel-tabBar');\n    this.stackedPanel = new StackedPanel();\n    this.stackedPanel.addClass('lm-TabPanel-stackedPanel');\n\n    // Connect the tab bar signal handlers.\n    this.tabBar.tabMoved.connect(this._onTabMoved, this);\n    this.tabBar.currentChanged.connect(this._onCurrentChanged, this);\n    this.tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);\n    this.tabBar.tabActivateRequested.connect(\n      this._onTabActivateRequested,\n      this\n    );\n    this.tabBar.addRequested.connect(this._onTabAddRequested, this);\n\n    // Connect the stacked panel signal handlers.\n    this.stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);\n\n    // Get the data related to the placement.\n    this._tabPlacement = options.tabPlacement || 'top';\n    let direction = Private.directionFromPlacement(this._tabPlacement);\n    let orientation = Private.orientationFromPlacement(this._tabPlacement);\n\n    // Configure the tab bar for the placement.\n    this.tabBar.orientation = orientation;\n    this.tabBar.dataset['placement'] = this._tabPlacement;\n\n    // Create the box layout.\n    let layout = new BoxLayout({ direction, spacing: 0 });\n\n    // Set the stretch factors for the child widgets.\n    BoxLayout.setStretch(this.tabBar, 0);\n    BoxLayout.setStretch(this.stackedPanel, 1);\n\n    // Add the child widgets to the layout.\n    layout.addWidget(this.tabBar);\n    layout.addWidget(this.stackedPanel);\n\n    // Install the layout on the tab panel.\n    this.layout = layout;\n  }\n\n  /**\n   * A signal emitted when the current tab is changed.\n   *\n   * #### Notes\n   * This signal is emitted when the currently selected tab is changed\n   * either through user or programmatic interaction.\n   *\n   * Notably, this signal is not emitted when the index of the current\n   * tab changes due to tabs being inserted, removed, or moved. It is\n   * only emitted when the actual current tab node is changed.\n   */\n  get currentChanged(): ISignal<this, TabPanel.ICurrentChangedArgs> {\n    return this._currentChanged;\n  }\n\n  /**\n   * Get the index of the currently selected tab.\n   *\n   * #### Notes\n   * This will be `-1` if no tab is selected.\n   */\n  get currentIndex(): number {\n    return this.tabBar.currentIndex;\n  }\n\n  /**\n   * Set the index of the currently selected tab.\n   *\n   * #### Notes\n   * If the index is out of range, it will be set to `-1`.\n   */\n  set currentIndex(value: number) {\n    this.tabBar.currentIndex = value;\n  }\n\n  /**\n   * Get the currently selected widget.\n   *\n   * #### Notes\n   * This will be `null` if there is no selected tab.\n   */\n  get currentWidget(): Widget | null {\n    let title = this.tabBar.currentTitle;\n    return title ? title.owner : null;\n  }\n\n  /**\n   * Set the currently selected widget.\n   *\n   * #### Notes\n   * If the widget is not in the panel, it will be set to `null`.\n   */\n  set currentWidget(value: Widget | null) {\n    this.tabBar.currentTitle = value ? value.title : null;\n  }\n\n  /**\n   * Get the whether the tabs are movable by the user.\n   *\n   * #### Notes\n   * Tabs can always be moved programmatically.\n   */\n  get tabsMovable(): boolean {\n    return this.tabBar.tabsMovable;\n  }\n\n  /**\n   * Set the whether the tabs are movable by the user.\n   *\n   * #### Notes\n   * Tabs can always be moved programmatically.\n   */\n  set tabsMovable(value: boolean) {\n    this.tabBar.tabsMovable = value;\n  }\n\n  /**\n   * Get the whether the add button is enabled.\n   *\n   */\n  get addButtonEnabled(): boolean {\n    return this.tabBar.addButtonEnabled;\n  }\n\n  /**\n   * Set the whether the add button is enabled.\n   *\n   */\n  set addButtonEnabled(value: boolean) {\n    this.tabBar.addButtonEnabled = value;\n  }\n\n  /**\n   * Get the tab placement for the tab panel.\n   *\n   * #### Notes\n   * This controls the position of the tab bar relative to the content.\n   */\n  get tabPlacement(): TabPanel.TabPlacement {\n    return this._tabPlacement;\n  }\n\n  /**\n   * Set the tab placement for the tab panel.\n   *\n   * #### Notes\n   * This controls the position of the tab bar relative to the content.\n   */\n  set tabPlacement(value: TabPanel.TabPlacement) {\n    // Bail if the placement does not change.\n    if (this._tabPlacement === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._tabPlacement = value;\n\n    // Get the values related to the placement.\n    let direction = Private.directionFromPlacement(value);\n    let orientation = Private.orientationFromPlacement(value);\n\n    // Configure the tab bar for the placement.\n    this.tabBar.orientation = orientation;\n    this.tabBar.dataset['placement'] = value;\n\n    // Update the layout direction.\n    (this.layout as BoxLayout).direction = direction;\n  }\n\n  /**\n   * A signal emitted when the add button on a tab bar is clicked.\n   *\n   */\n  get addRequested(): ISignal<this, TabBar<Widget>> {\n    return this._addRequested;\n  }\n\n  /**\n   * The tab bar used by the tab panel.\n   *\n   * #### Notes\n   * Modifying the tab bar directly can lead to undefined behavior.\n   */\n  readonly tabBar: TabBar<Widget>;\n\n  /**\n   * The stacked panel used by the tab panel.\n   *\n   * #### Notes\n   * Modifying the panel directly can lead to undefined behavior.\n   */\n  readonly stackedPanel: StackedPanel;\n\n  /**\n   * A read-only array of the widgets in the panel.\n   */\n  get widgets(): ReadonlyArray<Widget> {\n    return this.stackedPanel.widgets;\n  }\n\n  /**\n   * Add a widget to the end of the tab panel.\n   *\n   * @param widget - The widget to add to the tab panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   *\n   * The widget's `title` is used to populate the tab.\n   */\n  addWidget(widget: Widget): void {\n    this.insertWidget(this.widgets.length, widget);\n  }\n\n  /**\n   * Insert a widget into the tab panel at a specified index.\n   *\n   * @param index - The index at which to insert the widget.\n   *\n   * @param widget - The widget to insert into to the tab panel.\n   *\n   * #### Notes\n   * If the widget is already contained in the panel, it will be moved.\n   *\n   * The widget's `title` is used to populate the tab.\n   */\n  insertWidget(index: number, widget: Widget): void {\n    if (widget !== this.currentWidget) {\n      widget.hide();\n    }\n    this.stackedPanel.insertWidget(index, widget);\n    this.tabBar.insertTab(index, widget.title);\n\n    widget.node.setAttribute('role', 'tabpanel');\n\n    let renderer = this.tabBar.renderer;\n    if (renderer instanceof TabBar.Renderer) {\n      let tabId = renderer.createTabKey({\n        title: widget.title,\n        current: false,\n        zIndex: 0\n      });\n      widget.node.setAttribute('aria-labelledby', tabId);\n    }\n  }\n\n  /**\n   * Handle the `currentChanged` signal from the tab bar.\n   */\n  private _onCurrentChanged(\n    sender: TabBar<Widget>,\n    args: TabBar.ICurrentChangedArgs<Widget>\n  ): void {\n    // Extract the previous and current title from the args.\n    let { previousIndex, previousTitle, currentIndex, currentTitle } = args;\n\n    // Extract the widgets from the titles.\n    let previousWidget = previousTitle ? previousTitle.owner : null;\n    let currentWidget = currentTitle ? currentTitle.owner : null;\n\n    // Hide the previous widget.\n    if (previousWidget) {\n      previousWidget.hide();\n    }\n\n    // Show the current widget.\n    if (currentWidget) {\n      currentWidget.show();\n    }\n\n    // Emit the `currentChanged` signal for the tab panel.\n    this._currentChanged.emit({\n      previousIndex,\n      previousWidget,\n      currentIndex,\n      currentWidget\n    });\n\n    // Flush the message loop on IE and Edge to prevent flicker.\n    if (Platform.IS_EDGE || Platform.IS_IE) {\n      MessageLoop.flush();\n    }\n  }\n\n  /**\n   * Handle the `tabAddRequested` signal from the tab bar.\n   */\n  private _onTabAddRequested(sender: TabBar<Widget>, args: void): void {\n    this._addRequested.emit(sender);\n  }\n\n  /**\n   * Handle the `tabActivateRequested` signal from the tab bar.\n   */\n  private _onTabActivateRequested(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabActivateRequestedArgs<Widget>\n  ): void {\n    args.title.owner.activate();\n  }\n\n  /**\n   * Handle the `tabCloseRequested` signal from the tab bar.\n   */\n  private _onTabCloseRequested(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabCloseRequestedArgs<Widget>\n  ): void {\n    args.title.owner.close();\n  }\n\n  /**\n   * Handle the `tabMoved` signal from the tab bar.\n   */\n  private _onTabMoved(\n    sender: TabBar<Widget>,\n    args: TabBar.ITabMovedArgs<Widget>\n  ): void {\n    this.stackedPanel.insertWidget(args.toIndex, args.title.owner);\n  }\n\n  /**\n   * Handle the `widgetRemoved` signal from the stacked panel.\n   */\n  private _onWidgetRemoved(sender: StackedPanel, widget: Widget): void {\n    widget.node.removeAttribute('role');\n    widget.node.removeAttribute('aria-labelledby');\n    this.tabBar.removeTab(widget.title);\n  }\n\n  private _tabPlacement: TabPanel.TabPlacement;\n  private _currentChanged = new Signal<this, TabPanel.ICurrentChangedArgs>(\n    this\n  );\n\n  private _addRequested = new Signal<this, TabBar<Widget>>(this);\n}\n\n/**\n * The namespace for the `TabPanel` class statics.\n */\nexport namespace TabPanel {\n  /**\n   * A type alias for tab placement in a tab bar.\n   */\n  export type TabPlacement =\n    | /**\n     * The tabs are placed as a row above the content.\n     */\n    'top'\n\n    /**\n     * The tabs are placed as a column to the left of the content.\n     */\n    | 'left'\n\n    /**\n     * The tabs are placed as a column to the right of the content.\n     */\n    | 'right'\n\n    /**\n     * The tabs are placed as a row below the content.\n     */\n    | 'bottom';\n\n  /**\n   * An options object for initializing a tab panel.\n   */\n  export interface IOptions {\n    /**\n     * The document to use with the tab panel.\n     *\n     * The default is the global `document` instance.\n     */\n    document?: Document | ShadowRoot;\n\n    /**\n     * Whether the tabs are movable by the user.\n     *\n     * The default is `false`.\n     */\n    tabsMovable?: boolean;\n\n    /**\n     * Whether the button to add new tabs is enabled.\n     *\n     * The default is `false`.\n     */\n    addButtonEnabled?: boolean;\n\n    /**\n     * The placement of the tab bar relative to the content.\n     *\n     * The default is `'top'`.\n     */\n    tabPlacement?: TabPlacement;\n\n    /**\n     * The renderer for the panel's tab bar.\n     *\n     * The default is a shared renderer instance.\n     */\n    renderer?: TabBar.IRenderer<Widget>;\n  }\n\n  /**\n   * The arguments object for the `currentChanged` signal.\n   */\n  export interface ICurrentChangedArgs {\n    /**\n     * The previously selected index.\n     */\n    previousIndex: number;\n\n    /**\n     * The previously selected widget.\n     */\n    previousWidget: Widget | null;\n\n    /**\n     * The currently selected index.\n     */\n    currentIndex: number;\n\n    /**\n     * The currently selected widget.\n     */\n    currentWidget: Widget | null;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Convert a tab placement to tab bar orientation.\n   */\n  export function orientationFromPlacement(\n    plc: TabPanel.TabPlacement\n  ): TabBar.Orientation {\n    return placementToOrientationMap[plc];\n  }\n\n  /**\n   * Convert a tab placement to a box layout direction.\n   */\n  export function directionFromPlacement(\n    plc: TabPanel.TabPlacement\n  ): BoxLayout.Direction {\n    return placementToDirectionMap[plc];\n  }\n\n  /**\n   * A mapping of tab placement to tab bar orientation.\n   */\n  const placementToOrientationMap: { [key: string]: TabBar.Orientation } = {\n    top: 'horizontal',\n    left: 'vertical',\n    right: 'vertical',\n    bottom: 'horizontal'\n  };\n\n  /**\n   * A mapping of tab placement to box layout direction.\n   */\n  const placementToDirectionMap: { [key: string]: BoxLayout.Direction } = {\n    top: 'top-to-bottom',\n    left: 'left-to-right',\n    right: 'right-to-left',\n    bottom: 'bottom-to-top'\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { MessageLoop } from '@lumino/messaging';\n\nimport { Layout } from './layout';\n\nimport { Widget } from './widget';\n\n/**\n * A concrete layout implementation which holds a single widget.\n *\n * #### Notes\n * This class is useful for creating simple container widgets which\n * hold a single child. The child should be positioned with CSS.\n */\nexport class SingletonLayout extends Layout {\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    if (this._widget) {\n      let widget = this._widget;\n      this._widget = null;\n      widget.dispose();\n    }\n    super.dispose();\n  }\n\n  /**\n   * Get the child widget for the layout.\n   */\n  get widget(): Widget | null {\n    return this._widget;\n  }\n\n  /**\n   * Set the child widget for the layout.\n   *\n   * #### Notes\n   * Setting the child widget will cause the old child widget to be\n   * automatically disposed. If that is not desired, set the parent\n   * of the old child to `null` before assigning a new child.\n   */\n  set widget(widget: Widget | null) {\n    // Remove the widget from its current parent. This is a no-op\n    // if the widget's parent is already the layout parent widget.\n    if (widget) {\n      widget.parent = this.parent;\n    }\n\n    // Bail early if the widget does not change.\n    if (this._widget === widget) {\n      return;\n    }\n\n    // Dispose of the old child widget.\n    if (this._widget) {\n      this._widget.dispose();\n    }\n\n    // Update the internal widget.\n    this._widget = widget;\n\n    // Attach the new child widget if needed.\n    if (this.parent && widget) {\n      this.attachWidget(widget);\n    }\n  }\n\n  /**\n   * Create an iterator over the widgets in the layout.\n   *\n   * @returns A new iterator over the widgets in the layout.\n   */\n  *[Symbol.iterator](): IterableIterator<Widget> {\n    if (this._widget) {\n      yield this._widget;\n    }\n  }\n\n  /**\n   * Remove a widget from the layout.\n   *\n   * @param widget - The widget to remove from the layout.\n   *\n   * #### Notes\n   * A widget is automatically removed from the layout when its `parent`\n   * is set to `null`. This method should only be invoked directly when\n   * removing a widget from a layout which has yet to be installed on a\n   * parent widget.\n   *\n   * This method does *not* modify the widget's `parent`.\n   */\n  removeWidget(widget: Widget): void {\n    // Bail early if the widget does not exist in the layout.\n    if (this._widget !== widget) {\n      return;\n    }\n\n    // Clear the internal widget.\n    this._widget = null;\n\n    // If the layout is parented, detach the widget from the DOM.\n    if (this.parent) {\n      this.detachWidget(widget);\n    }\n  }\n\n  /**\n   * Perform layout initialization which requires the parent widget.\n   */\n  protected init(): void {\n    super.init();\n    for (const widget of this) {\n      this.attachWidget(widget);\n    }\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This method is called automatically by the single layout at the\n   * appropriate time. It should not be called directly by user code.\n   *\n   * The default implementation adds the widgets's node to the parent's\n   * node at the proper location, and sends the appropriate attach\n   * messages to the widget if the parent is attached to the DOM.\n   *\n   * Subclasses may reimplement this method to control how the widget's\n   * node is added to the parent's node.\n   */\n  protected attachWidget(widget: Widget): void {\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget's node to the parent.\n    this.parent!.node.appendChild(widget.node);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This method is called automatically by the single layout at the\n   * appropriate time. It should not be called directly by user code.\n   *\n   * The default implementation removes the widget's node from the\n   * parent's node, and sends the appropriate detach messages to the\n   * widget if the parent is attached to the DOM.\n   *\n   * Subclasses may reimplement this method to control how the widget's\n   * node is removed from the parent's node.\n   */\n  protected detachWidget(widget: Widget): void {\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n  }\n\n  private _widget: Widget | null = null;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { ElementExt } from '@lumino/domutils';\n\nimport { Message, MessageLoop } from '@lumino/messaging';\n\nimport { Layout, LayoutItem } from './layout';\n\nimport { PanelLayout } from './panellayout';\n\nimport { Widget } from './widget';\n\n/**\n * A layout where visible widgets are stacked atop one another.\n *\n * #### Notes\n * The Z-order of the visible widgets follows their layout order.\n */\nexport class StackedLayout extends PanelLayout {\n  constructor(options: StackedLayout.IOptions = {}) {\n    super(options);\n    this._hiddenMode =\n      options.hiddenMode !== undefined\n        ? options.hiddenMode\n        : Widget.HiddenMode.Display;\n  }\n\n  /**\n   * The method for hiding widgets.\n   *\n   * #### Notes\n   * If there is only one child widget, `Display` hiding mode will be used\n   * regardless of this setting.\n   */\n  get hiddenMode(): Widget.HiddenMode {\n    return this._hiddenMode;\n  }\n\n  /**\n   * Set the method for hiding widgets.\n   *\n   * #### Notes\n   * If there is only one child widget, `Display` hiding mode will be used\n   * regardless of this setting.\n   */\n  set hiddenMode(v: Widget.HiddenMode) {\n    if (this._hiddenMode === v) {\n      return;\n    }\n    this._hiddenMode = v;\n    if (this.widgets.length > 1) {\n      this.widgets.forEach(w => {\n        w.hiddenMode = this._hiddenMode;\n      });\n    }\n  }\n\n  /**\n   * Dispose of the resources held by the layout.\n   */\n  dispose(): void {\n    // Dispose of the layout items.\n    for (const item of this._items) {\n      item.dispose();\n    }\n\n    // Clear the layout state.\n    this._box = null;\n    this._items.length = 0;\n\n    // Dispose of the rest of the layout.\n    super.dispose();\n  }\n\n  /**\n   * Attach a widget to the parent's DOM node.\n   *\n   * @param index - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to attach to the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected attachWidget(index: number, widget: Widget): void {\n    // Using transform create an additional layer in the pixel pipeline\n    // to limit the number of layer, it is set only if there is more than one widget.\n    if (\n      this._hiddenMode === Widget.HiddenMode.Scale &&\n      this._items.length > 0\n    ) {\n      if (this._items.length === 1) {\n        this.widgets[0].hiddenMode = Widget.HiddenMode.Scale;\n      }\n      widget.hiddenMode = Widget.HiddenMode.Scale;\n    } else {\n      widget.hiddenMode = Widget.HiddenMode.Display;\n    }\n\n    // Create and add a new layout item for the widget.\n    ArrayExt.insert(this._items, index, new LayoutItem(widget));\n\n    // Send a `'before-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    }\n\n    // Add the widget's node to the parent.\n    this.parent!.node.appendChild(widget.node);\n\n    // Send an `'after-attach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * Move a widget in the parent's DOM node.\n   *\n   * @param fromIndex - The previous index of the widget in the layout.\n   *\n   * @param toIndex - The current index of the widget in the layout.\n   *\n   * @param widget - The widget to move in the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected moveWidget(\n    fromIndex: number,\n    toIndex: number,\n    widget: Widget\n  ): void {\n    // Move the layout item for the widget.\n    ArrayExt.move(this._items, fromIndex, toIndex);\n\n    // Post an update request for the parent widget.\n    this.parent!.update();\n  }\n\n  /**\n   * Detach a widget from the parent's DOM node.\n   *\n   * @param index - The previous index of the widget in the layout.\n   *\n   * @param widget - The widget to detach from the parent.\n   *\n   * #### Notes\n   * This is a reimplementation of the superclass method.\n   */\n  protected detachWidget(index: number, widget: Widget): void {\n    // Remove the layout item for the widget.\n    let item = ArrayExt.removeAt(this._items, index);\n\n    // Send a `'before-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    }\n\n    // Remove the widget's node from the parent.\n    this.parent!.node.removeChild(widget.node);\n\n    // Send an `'after-detach'` message if the parent is attached.\n    if (this.parent!.isAttached) {\n      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n\n    // Reset the z-index for the widget.\n    item!.widget.node.style.zIndex = '';\n\n    // Reset the hidden mode for the widget.\n    if (this._hiddenMode === Widget.HiddenMode.Scale) {\n      widget.hiddenMode = Widget.HiddenMode.Display;\n\n      // Reset the hidden mode for the first widget if necessary.\n      if (this._items.length === 1) {\n        this._items[0].widget.hiddenMode = Widget.HiddenMode.Display;\n      }\n    }\n\n    // Dispose of the layout item.\n    item!.dispose();\n\n    // Post a fit request for the parent widget.\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    super.onBeforeShow(msg);\n    this.parent!.update();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-shown'` message.\n   */\n  protected onChildShown(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'child-hidden'` message.\n   */\n  protected onChildHidden(msg: Widget.ChildMessage): void {\n    this.parent!.fit();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.parent!.isVisible) {\n      this._update(msg.width, msg.height);\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'update-request'` message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    if (this.parent!.isVisible) {\n      this._update(-1, -1);\n    }\n  }\n\n  /**\n   * A message handler invoked on a `'fit-request'` message.\n   */\n  protected onFitRequest(msg: Message): void {\n    if (this.parent!.isAttached) {\n      this._fit();\n    }\n  }\n\n  /**\n   * Fit the layout to the total size required by the widgets.\n   */\n  private _fit(): void {\n    // Set up the computed minimum size.\n    let minW = 0;\n    let minH = 0;\n\n    // Update the computed minimum size.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = this._items[i];\n\n      // Ignore hidden items.\n      if (item.isHidden) {\n        continue;\n      }\n\n      // Update the size limits for the item.\n      item.fit();\n\n      // Update the computed minimum size.\n      minW = Math.max(minW, item.minWidth);\n      minH = Math.max(minH, item.minHeight);\n    }\n\n    // Update the box sizing and add it to the computed min size.\n    let box = (this._box = ElementExt.boxSizing(this.parent!.node));\n    minW += box.horizontalSum;\n    minH += box.verticalSum;\n\n    // Update the parent's min size constraints.\n    let style = this.parent!.node.style;\n    style.minWidth = `${minW}px`;\n    style.minHeight = `${minH}px`;\n\n    // Set the dirty flag to ensure only a single update occurs.\n    this._dirty = true;\n\n    // Notify the ancestor that it should fit immediately. This may\n    // cause a resize of the parent, fulfilling the required update.\n    if (this.parent!.parent) {\n      MessageLoop.sendMessage(this.parent!.parent!, Widget.Msg.FitRequest);\n    }\n\n    // If the dirty flag is still set, the parent was not resized.\n    // Trigger the required update on the parent widget immediately.\n    if (this._dirty) {\n      MessageLoop.sendMessage(this.parent!, Widget.Msg.UpdateRequest);\n    }\n  }\n\n  /**\n   * Update the layout position and size of the widgets.\n   *\n   * The parent offset dimensions should be `-1` if unknown.\n   */\n  private _update(offsetWidth: number, offsetHeight: number): void {\n    // Clear the dirty flag to indicate the update occurred.\n    this._dirty = false;\n\n    // Compute the visible item count.\n    let nVisible = 0;\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      nVisible += +!this._items[i].isHidden;\n    }\n\n    // Bail early if there are no visible items to layout.\n    if (nVisible === 0) {\n      return;\n    }\n\n    // Measure the parent if the offset dimensions are unknown.\n    if (offsetWidth < 0) {\n      offsetWidth = this.parent!.node.offsetWidth;\n    }\n    if (offsetHeight < 0) {\n      offsetHeight = this.parent!.node.offsetHeight;\n    }\n\n    // Ensure the parent box sizing data is computed.\n    if (!this._box) {\n      this._box = ElementExt.boxSizing(this.parent!.node);\n    }\n\n    // Compute the actual layout bounds adjusted for border and padding.\n    let top = this._box.paddingTop;\n    let left = this._box.paddingLeft;\n    let width = offsetWidth - this._box.horizontalSum;\n    let height = offsetHeight - this._box.verticalSum;\n\n    // Update the widget stacking order and layout geometry.\n    for (let i = 0, n = this._items.length; i < n; ++i) {\n      // Fetch the item.\n      let item = this._items[i];\n\n      // Ignore hidden items.\n      if (item.isHidden) {\n        continue;\n      }\n\n      // Set the z-index for the widget.\n      item.widget.node.style.zIndex = `${i}`;\n\n      // Update the item geometry.\n      item.update(left, top, width, height);\n    }\n  }\n\n  private _dirty = false;\n  private _items: LayoutItem[] = [];\n  private _box: ElementExt.IBoxSizing | null = null;\n  private _hiddenMode: Widget.HiddenMode;\n}\n\n/**\n * The namespace for the `StackedLayout` class statics.\n */\nexport namespace StackedLayout {\n  /**\n   * An options object for initializing a stacked layout.\n   */\n  export interface IOptions extends Layout.IOptions {\n    /**\n     * The method for hiding widgets.\n     *\n     * The default is `Widget.HiddenMode.Display`.\n     */\n    hiddenMode?: Widget.HiddenMode;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt, find, max } from '@lumino/algorithm';\n\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { Widget } from './widget';\n\n/**\n * A class which tracks focus among a set of widgets.\n *\n * This class is useful when code needs to keep track of the most\n * recently focused widget(s) among a set of related widgets.\n */\nexport class FocusTracker<T extends Widget> implements IDisposable {\n  /**\n   * Dispose of the resources held by the tracker.\n   */\n  dispose(): void {\n    // Do nothing if the tracker is already disposed.\n    if (this._counter < 0) {\n      return;\n    }\n\n    // Mark the tracker as disposed.\n    this._counter = -1;\n\n    // Clear the connections for the tracker.\n    Signal.clearData(this);\n\n    // Remove all event listeners.\n    for (const widget of this._widgets) {\n      widget.node.removeEventListener('focus', this, true);\n      widget.node.removeEventListener('blur', this, true);\n    }\n\n    // Clear the internal data structures.\n    this._activeWidget = null;\n    this._currentWidget = null;\n    this._nodes.clear();\n    this._numbers.clear();\n    this._widgets.length = 0;\n  }\n\n  /**\n   * A signal emitted when the current widget has changed.\n   */\n  get currentChanged(): ISignal<this, FocusTracker.IChangedArgs<T>> {\n    return this._currentChanged;\n  }\n\n  /**\n   * A signal emitted when the active widget has changed.\n   */\n  get activeChanged(): ISignal<this, FocusTracker.IChangedArgs<T>> {\n    return this._activeChanged;\n  }\n\n  /**\n   * A flag indicating whether the tracker is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._counter < 0;\n  }\n\n  /**\n   * The current widget in the tracker.\n   *\n   * #### Notes\n   * The current widget is the widget among the tracked widgets which\n   * has the *descendant node* which has most recently been focused.\n   *\n   * The current widget will not be updated if the node loses focus. It\n   * will only be updated when a different tracked widget gains focus.\n   *\n   * If the current widget is removed from the tracker, the previous\n   * current widget will be restored.\n   *\n   * This behavior is intended to follow a user's conceptual model of\n   * a semantically \"current\" widget, where the \"last thing of type X\"\n   * to be interacted with is the \"current instance of X\", regardless\n   * of whether that instance still has focus.\n   */\n  get currentWidget(): T | null {\n    return this._currentWidget;\n  }\n\n  /**\n   * The active widget in the tracker.\n   *\n   * #### Notes\n   * The active widget is the widget among the tracked widgets which\n   * has the *descendant node* which is currently focused.\n   */\n  get activeWidget(): T | null {\n    return this._activeWidget;\n  }\n\n  /**\n   * A read only array of the widgets being tracked.\n   */\n  get widgets(): ReadonlyArray<T> {\n    return this._widgets;\n  }\n\n  /**\n   * Get the focus number for a particular widget in the tracker.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The focus number for the given widget, or `-1` if the\n   *   widget has not had focus since being added to the tracker, or\n   *   is not contained by the tracker.\n   *\n   * #### Notes\n   * The focus number indicates the relative order in which the widgets\n   * have gained focus. A widget with a larger number has gained focus\n   * more recently than a widget with a smaller number.\n   *\n   * The `currentWidget` will always have the largest focus number.\n   *\n   * All widgets start with a focus number of `-1`, which indicates that\n   * the widget has not been focused since being added to the tracker.\n   */\n  focusNumber(widget: T): number {\n    let n = this._numbers.get(widget);\n    return n === undefined ? -1 : n;\n  }\n\n  /**\n   * Test whether the focus tracker contains a given widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns `true` if the widget is tracked, `false` otherwise.\n   */\n  has(widget: T): boolean {\n    return this._numbers.has(widget);\n  }\n\n  /**\n   * Add a widget to the focus tracker.\n   *\n   * @param widget - The widget of interest.\n   *\n   * #### Notes\n   * A widget will be automatically removed from the tracker if it\n   * is disposed after being added.\n   *\n   * If the widget is already tracked, this is a no-op.\n   */\n  add(widget: T): void {\n    // Do nothing if the widget is already tracked.\n    if (this._numbers.has(widget)) {\n      return;\n    }\n\n    // Test whether the widget has focus.\n    let focused = widget.node.contains(document.activeElement);\n\n    // Set up the initial focus number.\n    let n = focused ? this._counter++ : -1;\n\n    // Add the widget to the internal data structures.\n    this._widgets.push(widget);\n    this._numbers.set(widget, n);\n    this._nodes.set(widget.node, widget);\n\n    // Set up the event listeners. The capturing phase must be used\n    // since the 'focus' and 'blur' events don't bubble and Firefox\n    // doesn't support the 'focusin' or 'focusout' events.\n    widget.node.addEventListener('focus', this, true);\n    widget.node.addEventListener('blur', this, true);\n\n    // Connect the disposed signal handler.\n    widget.disposed.connect(this._onWidgetDisposed, this);\n\n    // Set the current and active widgets if needed.\n    if (focused) {\n      this._setWidgets(widget, widget);\n    }\n  }\n\n  /**\n   * Remove a widget from the focus tracker.\n   *\n   * #### Notes\n   * If the widget is the `currentWidget`, the previous current widget\n   * will become the new `currentWidget`.\n   *\n   * A widget will be automatically removed from the tracker if it\n   * is disposed after being added.\n   *\n   * If the widget is not tracked, this is a no-op.\n   */\n  remove(widget: T): void {\n    // Bail early if the widget is not tracked.\n    if (!this._numbers.has(widget)) {\n      return;\n    }\n\n    // Disconnect the disposed signal handler.\n    widget.disposed.disconnect(this._onWidgetDisposed, this);\n\n    // Remove the event listeners.\n    widget.node.removeEventListener('focus', this, true);\n    widget.node.removeEventListener('blur', this, true);\n\n    // Remove the widget from the internal data structures.\n    ArrayExt.removeFirstOf(this._widgets, widget);\n    this._nodes.delete(widget.node);\n    this._numbers.delete(widget);\n\n    // Bail early if the widget is not the current widget.\n    if (this._currentWidget !== widget) {\n      return;\n    }\n\n    // Filter the widgets for those which have had focus.\n    let valid = this._widgets.filter(w => this._numbers.get(w) !== -1);\n\n    // Get the valid widget with the max focus number.\n    let previous =\n      max(valid, (first, second) => {\n        let a = this._numbers.get(first)!;\n        let b = this._numbers.get(second)!;\n        return a - b;\n      }) || null;\n\n    // Set the current and active widgets.\n    this._setWidgets(previous, null);\n  }\n\n  /**\n   * Handle the DOM events for the focus tracker.\n   *\n   * @param event - The DOM event sent to the panel.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the tracked nodes. It should\n   * not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'focus':\n        this._evtFocus(event as FocusEvent);\n        break;\n      case 'blur':\n        this._evtBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Set the current and active widgets for the tracker.\n   */\n  private _setWidgets(current: T | null, active: T | null): void {\n    // Swap the current widget.\n    let oldCurrent = this._currentWidget;\n    this._currentWidget = current;\n\n    // Swap the active widget.\n    let oldActive = this._activeWidget;\n    this._activeWidget = active;\n\n    // Emit the `currentChanged` signal if needed.\n    if (oldCurrent !== current) {\n      this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });\n    }\n\n    // Emit the `activeChanged` signal if needed.\n    if (oldActive !== active) {\n      this._activeChanged.emit({ oldValue: oldActive, newValue: active });\n    }\n  }\n\n  /**\n   * Handle the `'focus'` event for a tracked widget.\n   */\n  private _evtFocus(event: FocusEvent): void {\n    // Find the widget which gained focus, which is known to exist.\n    let widget = this._nodes.get(event.currentTarget as HTMLElement)!;\n\n    // Update the focus number if necessary.\n    if (widget !== this._currentWidget) {\n      this._numbers.set(widget, this._counter++);\n    }\n\n    // Set the current and active widgets.\n    this._setWidgets(widget, widget);\n  }\n\n  /**\n   * Handle the `'blur'` event for a tracked widget.\n   */\n  private _evtBlur(event: FocusEvent): void {\n    // Find the widget which lost focus, which is known to exist.\n    let widget = this._nodes.get(event.currentTarget as HTMLElement)!;\n\n    // Get the node which being focused after this blur.\n    let focusTarget = event.relatedTarget as HTMLElement;\n\n    // If no other node is being focused, clear the active widget.\n    if (!focusTarget) {\n      this._setWidgets(this._currentWidget, null);\n      return;\n    }\n\n    // Bail if the focus widget is not changing.\n    if (widget.node.contains(focusTarget)) {\n      return;\n    }\n\n    // If no tracked widget is being focused, clear the active widget.\n    if (!find(this._widgets, w => w.node.contains(focusTarget))) {\n      this._setWidgets(this._currentWidget, null);\n      return;\n    }\n  }\n\n  /**\n   * Handle the `disposed` signal for a tracked widget.\n   */\n  private _onWidgetDisposed(sender: T): void {\n    this.remove(sender);\n  }\n\n  private _counter = 0;\n  private _widgets: T[] = [];\n  private _activeWidget: T | null = null;\n  private _currentWidget: T | null = null;\n  private _numbers = new Map<T, number>();\n  private _nodes = new Map<HTMLElement, T>();\n  private _activeChanged = new Signal<this, FocusTracker.IChangedArgs<T>>(this);\n  private _currentChanged = new Signal<this, FocusTracker.IChangedArgs<T>>(\n    this\n  );\n}\n\n/**\n * The namespace for the `FocusTracker` class statics.\n */\nexport namespace FocusTracker {\n  /**\n   * An arguments object for the changed signals.\n   */\n  export interface IChangedArgs<T extends Widget> {\n    /**\n     * The old value for the widget.\n     */\n    oldValue: T | null;\n\n    /**\n     * The new value for the widget.\n     */\n    newValue: T | null;\n  }\n}\n"],"mappings":"2/BAoBaA,EAAbC,cAcEC,KAAQC,SAAG,EAeXD,KAAOE,QAAG,EAeVF,KAAOG,QAAGC,IAkBVJ,KAAOK,QAAG,EAcVL,KAAIM,KAAG,EAUPN,KAAIO,MAAG,C,EAMT,IAAiBC,ECo/BPC,EC/RAA,ECh0BOC,EH2GAF,gDA0XhB,KA3TiBG,KAAhB,SAAqBC,EAA6BC,GAEhD,IAAIC,EAAQF,EAAOG,OACnB,GAAc,IAAVD,EACF,OAAOD,EAIT,IAAIG,EAAW,EACXC,EAAW,EACXC,EAAY,EACZC,EAAe,EACfC,EAAe,EAGnB,IAAK,IAAIC,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACfE,EAAMD,EAAMpB,QACZsB,EAAMF,EAAMnB,QACZsB,EAAOH,EAAMrB,SACjBqB,EAAMf,MAAO,EACbe,EAAMhB,KAAOoB,KAAKF,IAAID,EAAKG,KAAKH,IAAIE,EAAMD,IAC1CN,GAAaI,EAAMhB,KACnBU,GAAYO,EACZN,GAAYO,EACRF,EAAMjB,QAAU,IAClBc,GAAgBG,EAAMjB,QACtBe,IAEH,CAGD,GAAIP,IAAUK,EACZ,OAAO,EAIT,GAAIL,GAASG,EAAU,CACrB,IAAK,IAAIK,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACnBC,EAAMhB,KAAOgB,EAAMpB,OACpB,CACD,OAAOW,EAAQG,CAChB,CAGD,GAAIH,GAASI,EAAU,CACrB,IAAK,IAAII,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACnBC,EAAMhB,KAAOgB,EAAMnB,OACpB,CACD,OAAOU,EAAQI,CAChB,CAKD,IAAIU,EAAW,IAKXC,EAAed,EAGnB,GAAID,EAAQK,EAAW,CAOrB,IAAIW,EAAYX,EAAYL,EAC5B,KAAOO,EAAe,GAAKS,EAAYF,GAAU,CAC/C,IAAIG,EAAYD,EACZE,EAAcZ,EAClB,IAAK,IAAIE,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACnB,GAAIC,EAAMf,MAA0B,IAAlBe,EAAMjB,QACtB,SAEF,IAAI2B,EAAOV,EAAMjB,QAAUyB,EAAaC,EACpCT,EAAMhB,KAAO0B,GAAOV,EAAMpB,SAC5B2B,GAAaP,EAAMhB,KAAOgB,EAAMpB,QAChCiB,GAAgBG,EAAMjB,QACtBiB,EAAMhB,KAAOgB,EAAMpB,QACnBoB,EAAMf,MAAO,EACbqB,IACAR,MAEAS,GAAaG,EACbV,EAAMhB,MAAQ0B,EAEjB,CACF,CAGD,KAAOJ,EAAe,GAAKC,EAAYF,GAAU,CAC/C,IAAIK,EAAMH,EAAYD,EACtB,IAAK,IAAIP,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACfC,EAAMf,OAGNe,EAAMhB,KAAO0B,GAAOV,EAAMpB,SAC5B2B,GAAaP,EAAMhB,KAAOgB,EAAMpB,QAChCoB,EAAMhB,KAAOgB,EAAMpB,QACnBoB,EAAMf,MAAO,EACbqB,MAEAC,GAAaG,EACbV,EAAMhB,MAAQ0B,GAEjB,CACF,CACF,KAEI,CAOH,IAAIH,EAAYhB,EAAQK,EACxB,KAAOE,EAAe,GAAKS,EAAYF,GAAU,CAC/C,IAAIG,EAAYD,EACZE,EAAcZ,EAClB,IAAK,IAAIE,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACnB,GAAIC,EAAMf,MAA0B,IAAlBe,EAAMjB,QACtB,SAEF,IAAI2B,EAAOV,EAAMjB,QAAUyB,EAAaC,EACpCT,EAAMhB,KAAO0B,GAAOV,EAAMnB,SAC5B0B,GAAaP,EAAMnB,QAAUmB,EAAMhB,KACnCa,GAAgBG,EAAMjB,QACtBiB,EAAMhB,KAAOgB,EAAMnB,QACnBmB,EAAMf,MAAO,EACbqB,IACAR,MAEAS,GAAaG,EACbV,EAAMhB,MAAQ0B,EAEjB,CACF,CAGD,KAAOJ,EAAe,GAAKC,EAAYF,GAAU,CAC/C,IAAIK,EAAMH,EAAYD,EACtB,IAAK,IAAIP,EAAI,EAAGA,EAAIP,IAASO,EAAG,CAC9B,IAAIC,EAAQV,EAAOS,GACfC,EAAMf,OAGNe,EAAMhB,KAAO0B,GAAOV,EAAMnB,SAC5B0B,GAAaP,EAAMnB,QAAUmB,EAAMhB,KACnCgB,EAAMhB,KAAOgB,EAAMnB,QACnBmB,EAAMf,MAAO,EACbqB,MAEAC,GAAaG,EACbV,EAAMhB,MAAQ0B,GAEjB,CACF,CACF,CAGD,OAAO,C,EAoBOxB,EAAAyB,OAAhB,SACErB,EACAsB,EACAC,GAGsB,IAAlBvB,EAAOG,QAA0B,IAAVoB,IAKvBA,EAAQ,EAUd,SACEvB,EACAsB,EACAC,GAGA,IAAIC,EAAY,EAChB,IAAK,IAAIf,EAAI,EAAGA,GAAKa,IAASb,EAAG,CAC/B,IAAIC,EAAQV,EAAOS,GACnBe,GAAad,EAAMnB,QAAUmB,EAAMhB,IACpC,CAGD,IAAI+B,EAAc,EAClB,IAAK,IAAIhB,EAAIa,EAAQ,EAAGI,EAAI1B,EAAOG,OAAQM,EAAIiB,IAAKjB,EAAG,CACrD,IAAIC,EAAQV,EAAOS,GACnBgB,GAAef,EAAMhB,KAAOgB,EAAMpB,OACnC,CAMD,IAAIqC,EAHJJ,EAAQT,KAAKH,IAAIY,EAAOC,EAAWC,GAInC,IAAK,IAAIhB,EAAIa,EAAOb,GAAK,GAAKkB,EAAO,IAAKlB,EAAG,CAC3C,IAAIC,EAAQV,EAAOS,GACfmB,EAAQlB,EAAMnB,QAAUmB,EAAMhB,KAC9BkC,GAASD,GACXjB,EAAMrB,SAAWqB,EAAMhB,KAAOiC,EAC9BA,EAAO,IAEPjB,EAAMrB,SAAWqB,EAAMhB,KAAOkC,EAC9BD,GAAQC,EAEX,CAGD,IAAIC,EAASN,EACb,IAAK,IAAId,EAAIa,EAAQ,EAAGI,EAAI1B,EAAOG,OAAQM,EAAIiB,GAAKG,EAAS,IAAKpB,EAAG,CACnE,IAAIC,EAAQV,EAAOS,GACfmB,EAAQlB,EAAMhB,KAAOgB,EAAMpB,QAC3BsC,GAASC,GACXnB,EAAMrB,SAAWqB,EAAMhB,KAAOmC,EAC9BA,EAAS,IAETnB,EAAMrB,SAAWqB,EAAMhB,KAAOkC,EAC9BC,GAAUD,EAEb,C,CAzDCE,CAAU9B,EAAQsB,EAAOC,GA+D7B,SACEvB,EACAsB,EACAC,GAGA,IAAIC,EAAY,EAChB,IAAK,IAAIf,EAAIa,EAAQ,EAAGI,EAAI1B,EAAOG,OAAQM,EAAIiB,IAAKjB,EAAG,CACrD,IAAIC,EAAQV,EAAOS,GACnBe,GAAad,EAAMnB,QAAUmB,EAAMhB,IACpC,CAGD,IAAI+B,EAAc,EAClB,IAAK,IAAIhB,EAAI,EAAGA,GAAKa,IAASb,EAAG,CAC/B,IAAIC,EAAQV,EAAOS,GACnBgB,GAAef,EAAMhB,KAAOgB,EAAMpB,OACnC,CAMD,IAAIqC,EAHJJ,EAAQT,KAAKH,IAAIY,EAAOC,EAAWC,GAInC,IAAK,IAAIhB,EAAIa,EAAQ,EAAGI,EAAI1B,EAAOG,OAAQM,EAAIiB,GAAKC,EAAO,IAAKlB,EAAG,CACjE,IAAIC,EAAQV,EAAOS,GACfmB,EAAQlB,EAAMnB,QAAUmB,EAAMhB,KAC9BkC,GAASD,GACXjB,EAAMrB,SAAWqB,EAAMhB,KAAOiC,EAC9BA,EAAO,IAEPjB,EAAMrB,SAAWqB,EAAMhB,KAAOkC,EAC9BD,GAAQC,EAEX,CAGD,IAAIC,EAASN,EACb,IAAK,IAAId,EAAIa,EAAOb,GAAK,GAAKoB,EAAS,IAAKpB,EAAG,CAC7C,IAAIC,EAAQV,EAAOS,GACfmB,EAAQlB,EAAMhB,KAAOgB,EAAMpB,QAC3BsC,GAASC,GACXnB,EAAMrB,SAAWqB,EAAMhB,KAAOmC,EAC9BA,EAAS,IAETnB,EAAMrB,SAAWqB,EAAMhB,KAAOkC,EAC9BC,GAAUD,EAEb,C,CA7GCG,CAAY/B,EAAQsB,GAAQC,G,QIlWrBS,EAMX7C,YAAY8C,GA+QJ7C,KAAM8C,OAAG,GACT9C,KAAQ+C,SAAG,GACX/C,KAASgD,WAAI,EACbhD,KAAKiD,WAAyCC,EAC9ClD,KAAUmD,WAAG,GACbnD,KAAUoD,WAAG,GACbpD,KAAUqD,WAAG,GACbrD,KAASsD,WAAG,EAEZtD,KAAAuD,SAAW,IAAIC,SAAmBxD,MAClCA,KAAWyD,aAAG,EAxRpBzD,KAAK0D,MAAQb,EAAQa,WACCR,IAAlBL,EAAQc,QACV3D,KAAK8C,OAASD,EAAQc,YAECT,IAArBL,EAAQe,WACV5D,KAAKgD,UAAYH,EAAQe,eAENV,IAAjBL,EAAQgB,OACV7D,KAAKiD,MAAQJ,EAAQgB,WAGGX,IAAtBL,EAAQiB,YACV9D,KAAKmD,WAAaN,EAAQiB,gBAEFZ,IAAtBL,EAAQkB,YACV/D,KAAKoD,WAAaP,EAAQkB,gBAEJb,IAApBL,EAAQmB,UACVhE,KAAK+C,SAAWF,EAAQmB,cAEAd,IAAtBL,EAAQoB,YACVjE,KAAKqD,WAAaR,EAAQoB,gBAEHf,IAArBL,EAAQqB,WACVlE,KAAKsD,UAAYT,EAAQqB,UAE3BlE,KAAKmE,SAAWtB,EAAQuB,SAAW,E,CAMjCC,cACF,OAAOrE,KAAKuD,Q,CAcVI,YACF,OAAO3D,KAAK8C,M,CAMVa,UAAMW,GACJtE,KAAK8C,SAAWwB,IAGpBtE,KAAK8C,OAASwB,EACdtE,KAAKuD,SAASgB,UAAKrB,G,CASjBU,eACF,OAAO5D,KAAKgD,S,CAMVY,aAASU,GACPtE,KAAKgD,YAAcsB,IAGvBtE,KAAKgD,UAAYsB,EACjBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBW,WACF,OAAO7D,KAAKiD,K,CASVY,SAAKS,GACHtE,KAAKiD,QAAUqB,IAGnBtE,KAAKiD,MAAQqB,EACbtE,KAAKuD,SAASgB,UAAKrB,G,CASjBY,gBACF,OAAO9D,KAAKmD,U,CASVW,cAAUQ,GACRtE,KAAKmD,aAAemB,IAGxBtE,KAAKmD,WAAamB,EAClBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBa,gBACF,OAAO/D,KAAKoD,U,CASVW,cAAUO,GACRtE,KAAKoD,aAAekB,IAGxBtE,KAAKoD,WAAakB,EAClBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBc,cACF,OAAOhE,KAAK+C,Q,CAMViB,YAAQM,GACNtE,KAAK+C,WAAauB,IAGtBtE,KAAK+C,SAAWuB,EAChBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBe,gBACF,OAAOjE,KAAKqD,U,CASVY,cAAUK,GACRtE,KAAKqD,aAAeiB,IAGxBtE,KAAKqD,WAAaiB,EAClBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBgB,eACF,OAAOlE,KAAKsD,S,CASVY,aAASI,GACPtE,KAAKsD,YAAcgB,IAGvBtE,KAAKsD,UAAYgB,EACjBtE,KAAKuD,SAASgB,UAAKrB,G,CASjBkB,cACF,OAAOpE,KAAKmE,Q,CASVC,YAAQE,GACNtE,KAAKmE,WAAaG,IAGtBtE,KAAKmE,SAAWG,EAChBtE,KAAKuD,SAASgB,UAAKrB,G,CAMjBsB,iBACF,OAAOxE,KAAKyD,W,CASdgB,UACMzE,KAAKwE,aAGTxE,KAAKyD,aAAc,EAEnBD,SAAOkB,UAAU1E,M,QHxQR2E,EAMX5E,YAAY8C,EAA2B,IAwtB/B7C,KAAM4E,OAAG,EACT5E,KAAO6E,QAAkB,KACzB7E,KAAO8E,QAAkB,KACzB9E,KAAA+E,UAAY,IAAIvB,SAAmBxD,MACnCA,KAAAgF,YAAiCL,EAAOM,WAAWC,QA3tBzDlF,KAAKmF,KAAO1E,EAAQ2E,WAAWvC,GAC/B7C,KAAKqF,SAAS,Y,CAWhBZ,UAEMzE,KAAKwE,aAKTxE,KAAKsF,QAAQX,EAAOY,KAAKC,YACzBxF,KAAK+E,UAAUR,UAAKrB,GAGhBlD,KAAKyF,OACPzF,KAAKyF,OAAS,KACLzF,KAAK0F,YACdf,EAAOgB,OAAO3F,MAIZA,KAAK6E,UACP7E,KAAK6E,QAAQJ,UACbzE,KAAK6E,QAAU,MAIjB7E,KAAK4F,MAAMnB,UAGXjB,SAAOkB,UAAU1E,MACjB6F,cAAYnB,UAAU1E,MACtB8F,mBAAiBpB,UAAU1E,M,CAMzB+F,eACF,OAAO/F,KAAK+E,S,CAWVP,iBACF,OAAOxE,KAAKgG,SAASrB,EAAOY,KAAKC,W,CAM/BE,iBACF,OAAO1F,KAAKgG,SAASrB,EAAOY,KAAKU,W,CAM/BC,eACF,OAAOlG,KAAKgG,SAASrB,EAAOY,KAAKY,S,CAU/BC,gBACF,OAAOpG,KAAKgG,SAASrB,EAAOY,KAAKc,U,CAc/BT,YACF,OAAOnF,EAAQ6F,cAAcC,IAAIvG,K,CAM/BwG,SACF,OAAOxG,KAAKmF,KAAKqB,E,CAMfA,OAAGlC,GACLtE,KAAKmF,KAAKqB,GAAKlC,C,CAMbF,cACF,OAAOpE,KAAKmF,KAAKf,O,CAMfqC,iBACF,OAAOzG,KAAKgF,W,CAMVyB,eAAWnC,GACTtE,KAAKgF,cAAgBV,IAIrBtE,KAAKkG,UAEPlG,KAAK0G,eAAc,GAGjBpC,GAASK,EAAOM,WAAW0B,MAC7B3G,KAAKmF,KAAKyB,MAAMC,WAAa,YAE7B7G,KAAKmF,KAAKyB,MAAMC,WAAa,OAG/B7G,KAAKgF,YAAcV,EAEftE,KAAKkG,UAEPlG,KAAK0G,eAAc,G,CAOnBjB,aACF,OAAOzF,KAAK8E,O,CAcVW,WAAOnB,GACT,GAAItE,KAAK8E,UAAYR,EAArB,CAGA,GAAIA,GAAStE,KAAK8G,SAASxC,GACzB,MAAM,IAAIyC,MAAM,0BAElB,GAAI/G,KAAK8E,UAAY9E,KAAK8E,QAAQN,WAAY,CAC5C,IAAIwC,EAAM,IAAIrC,EAAOsC,aAAa,gBAAiBjH,MACnD6F,cAAYqB,YAAYlH,KAAK8E,QAASkC,EACvC,CAED,GADAhH,KAAK8E,QAAUR,EACXtE,KAAK8E,UAAY9E,KAAK8E,QAAQN,WAAY,CAC5C,IAAIwC,EAAM,IAAIrC,EAAOsC,aAAa,cAAejH,MACjD6F,cAAYqB,YAAYlH,KAAK8E,QAASkC,EACvC,CACIhH,KAAKwE,YACRqB,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIC,cAd1C,C,CAqBCC,aACF,OAAOrH,KAAK6E,O,CAYVwC,WAAO/C,GACT,GAAItE,KAAK6E,UAAYP,EAArB,CAGA,GAAItE,KAAKgG,SAASrB,EAAOY,KAAK+B,gBAC5B,MAAM,IAAIP,MAAM,6BAElB,GAAI/G,KAAK6E,QACP,MAAM,IAAIkC,MAAM,gCAElB,GAAIzC,EAAOmB,OACT,MAAM,IAAIsB,MAAM,gCAElB/G,KAAK6E,QAAUP,EACfA,EAAOmB,OAASzF,IAXf,C,CAwBHuH,YACMvH,KAAK6E,gBACA7E,KAAK6E,Q,CAWhBiC,SAASU,GACP,IAAK,IAAIlD,EAAuBkD,EAAQlD,EAAOA,EAAQA,EAAMQ,QAC3D,GAAIR,IAAUtE,KACZ,OAAO,EAGX,OAAO,C,CAUTyH,SAASC,GACP,OAAO1H,KAAKmF,KAAKwC,UAAUb,SAASY,E,CAatCrC,SAASqC,GACP1H,KAAKmF,KAAKwC,UAAUC,IAAIF,E,CAa1BG,YAAYH,GACV1H,KAAKmF,KAAKwC,UAAUG,OAAOJ,E,CAiB7BK,YAAYL,EAAcM,GACxB,OAAc,IAAVA,GACFhI,KAAKmF,KAAKwC,UAAUC,IAAIF,IACjB,IAEK,IAAVM,GACFhI,KAAKmF,KAAKwC,UAAUG,OAAOJ,IACpB,GAEF1H,KAAKmF,KAAKwC,UAAUM,OAAOP,E,CASpCQ,SACErC,cAAYsC,YAAYnI,KAAM2E,EAAOwC,IAAIiB,c,CAS3CC,MACExC,cAAYsC,YAAYnI,KAAM2E,EAAOwC,IAAImB,W,CAS3CC,WACE1C,cAAYsC,YAAYnI,KAAM2E,EAAOwC,IAAIqB,gB,CAS3CC,QACE5C,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIuB,a,CAW3CC,OACE,GAAK3I,KAAKgG,SAASrB,EAAOY,KAAKY,aAG3BnG,KAAK0F,YAAgB1F,KAAKyF,SAAUzF,KAAKyF,OAAOW,WAClDP,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIyB,YAE3C5I,KAAK6I,UAAUlE,EAAOY,KAAKY,UAC3BnG,KAAK0G,eAAc,IAEf1G,KAAK0F,YAAgB1F,KAAKyF,SAAUzF,KAAKyF,OAAOW,WAClDP,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAI2B,WAEvC9I,KAAKyF,QAAQ,CACf,IAAIuB,EAAM,IAAIrC,EAAOsC,aAAa,cAAejH,MACjD6F,cAAYqB,YAAYlH,KAAKyF,OAAQuB,EACtC,C,CAWH+B,OACE,IAAI/I,KAAKgG,SAASrB,EAAOY,KAAKY,aAG1BnG,KAAK0F,YAAgB1F,KAAKyF,SAAUzF,KAAKyF,OAAOW,WAClDP,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAI6B,YAE3ChJ,KAAKsF,QAAQX,EAAOY,KAAKY,UACzBnG,KAAK0G,eAAc,IAEf1G,KAAK0F,YAAgB1F,KAAKyF,SAAUzF,KAAKyF,OAAOW,WAClDP,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAI8B,WAEvCjJ,KAAKyF,QAAQ,CACf,IAAIuB,EAAM,IAAIrC,EAAOsC,aAAa,eAAgBjH,MAClD6F,cAAYqB,YAAYlH,KAAKyF,OAAQuB,EACtC,C,CAWHkC,UAAUC,GACJA,EACFnJ,KAAK+I,OAEL/I,KAAK2I,M,CAUT3C,SAASoD,GACP,OAAgC,IAAxBpJ,KAAK4E,OAASwE,E,CASxB9D,QAAQ8D,GACNpJ,KAAK4E,QAAUwE,C,CASjBP,UAAUO,GACRpJ,KAAK4E,SAAWwE,C,CAWlBC,eAAerC,GACb,OAAQA,EAAIsC,MACV,IAAK,SACHtJ,KAAKuJ,aAAavC,GAClBhH,KAAKwJ,SAASxC,GACd,MACF,IAAK,iBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKyJ,gBAAgBzC,GACrB,MACF,IAAK,cACHhH,KAAKuJ,aAAavC,GAClBhH,KAAK0J,aAAa1C,GAClB,MACF,IAAK,cACHhH,KAAKuJ,aAAavC,GAClBhH,KAAK2J,aAAa3C,GAClB,MACF,IAAK,aACHhH,KAAKsF,QAAQX,EAAOY,KAAKc,WACzBrG,KAAKuJ,aAAavC,GAClBhH,KAAK4J,YAAY5C,GACjB,MACF,IAAK,cACHhH,KAAKuJ,aAAavC,GAClBhH,KAAK6J,aAAa7C,GAClB,MACF,IAAK,aACHhH,KAAK6I,UAAUlE,EAAOY,KAAKc,WAC3BrG,KAAKuJ,aAAavC,GAClBhH,KAAK8J,YAAY9C,GACjB,MACF,IAAK,gBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAK+J,eAAe/C,GACpB,MACF,IAAK,eACEhH,KAAKkG,UAAclG,KAAKyF,SAAUzF,KAAKyF,OAAOW,WACjDpG,KAAKsF,QAAQX,EAAOY,KAAKc,WAE3BrG,KAAKsF,QAAQX,EAAOY,KAAKU,YACzBjG,KAAKuJ,aAAavC,GAClBhH,KAAKgK,cAAchD,GACnB,MACF,IAAK,gBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKiK,eAAejD,GACpB,MACF,IAAK,eACHhH,KAAK6I,UAAUlE,EAAOY,KAAKc,WAC3BrG,KAAK6I,UAAUlE,EAAOY,KAAKU,YAC3BjG,KAAKuJ,aAAavC,GAClBhH,KAAKkK,cAAclD,GACnB,MACF,IAAK,mBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKmK,kBAAkBnD,GACvB,MACF,IAAK,gBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKoK,eAAepD,GACpB,MACF,IAAK,cACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKqK,aAAarD,GAClB,MACF,IAAK,gBACHhH,KAAKuJ,aAAavC,GAClBhH,KAAKsK,eAAetD,GACpB,MACF,QACEhH,KAAKuJ,aAAavC,G,CAeduC,aAAavC,GACjBhH,KAAK6E,SACP7E,KAAK6E,QAAQ0F,qBAAqBvD,E,CAU5BoD,eAAepD,GACnBhH,KAAKyF,OACPzF,KAAKyF,OAAS,KACLzF,KAAK0F,YACdf,EAAOgB,OAAO3F,K,CAURwJ,SAASxC,GAAyB,CAQlCyC,gBAAgBzC,GAAY,CAQ5B0C,aAAa1C,GAAY,CAQzBmD,kBAAkBnD,GAAY,CAQ9B2C,aAAa3C,GAAY,CAQzB4C,YAAY5C,GAAY,CAQxB6C,aAAa7C,GAAY,CAQzB8C,YAAY9C,GAAY,CAQxB+C,eAAe/C,GAAY,CAQ3BgD,cAAchD,GAAY,CAQ1BiD,eAAejD,GAAY,CAQ3BkD,cAAclD,GAAY,CAQ1BqD,aAAarD,GAAwB,CAQrCsD,eAAetD,GAAwB,CAEzCN,cAAcyC,GACpB,GAAIA,EACF,OAAQnJ,KAAKgF,aACX,KAAKL,EAAOM,WAAWC,QACrBlF,KAAKqF,SAAS,iBACd,MACF,KAAKV,EAAOM,WAAW0B,MACrB3G,KAAKmF,KAAKyB,MAAM4D,UAAY,WAC5BxK,KAAKmF,KAAKsF,aAAa,cAAe,QACtC,MACF,KAAK9F,EAAOM,WAAWyF,kBAErB1K,KAAKmF,KAAKyB,MAAM+D,kBAAoB,SACpC3K,KAAKmF,KAAKyB,MAAMgE,OAAS,UAI7B,OAAQ5K,KAAKgF,aACX,KAAKL,EAAOM,WAAWC,QACrBlF,KAAK6H,YAAY,iBACjB,MACF,KAAKlD,EAAOM,WAAW0B,MACrB3G,KAAKmF,KAAKyB,MAAM4D,UAAY,GAC5BxK,KAAKmF,KAAK0F,gBAAgB,eAC1B,MACF,KAAKlG,EAAOM,WAAWyF,kBAErB1K,KAAKmF,KAAKyB,MAAM+D,kBAAoB,GACpC3K,KAAKmF,KAAKyB,MAAMgE,OAAS,G,GAgBnC,SAAiBjG,GAwCf,IAAYM,EAqBAM,EA8BK4B,GAnDLlC,EAAAN,EAAUM,aAAVN,EAAAM,WAgBX,KAXCA,EAAA,qBAKAA,IAAA,iBAKAA,IAAA,0CAMUM,EAAAZ,EAAIY,OAAJZ,EAAAY,KAyBX,KArBCA,EAAA,2BAKAA,IAAA,2BAKAA,IAAA,uBAKAA,IAAA,yBAKAA,IAAA,qCAMe4B,EAAAxC,EAAGwC,MAAHxC,EAAAwC,IA2HhB,KAlHcyB,WAAa,IAAIkC,UAAQ,eAUzB3D,EAAA2B,UAAY,IAAIgC,UAAQ,cAUxB3D,EAAA6B,WAAa,IAAI8B,UAAQ,eAUzB3D,EAAA8B,UAAY,IAAI6B,UAAQ,cAQxB3D,EAAA4D,aAAe,IAAID,UAAQ,iBAQ3B3D,EAAA6D,YAAc,IAAIF,UAAQ,gBAQ1B3D,EAAA8D,aAAe,IAAIH,UAAQ,iBAQ3B3D,EAAA+D,YAAc,IAAIJ,UAAQ,gBAQ1B3D,EAAAC,cAAgB,IAAI0D,UAAQ,kBAa5B3D,EAAAiB,cAAgB,IAAI+C,qBAAmB,kBAWvChE,EAAAmB,WAAa,IAAI6C,qBAAmB,eAUpChE,EAAAqB,gBAAkB,IAAI2C,qBAAmB,oBASzChE,EAAAuB,aAAe,IAAIyC,qBAAmB,iBAMrD,MAAalE,UAAqB6D,UAQhC/K,YAAYuJ,EAAc8B,GACxBC,MAAM/B,GACNtJ,KAAKoL,MAAQA,C,EAVJzG,EAAAsC,aAAYA,EAsBzB,MAAaqE,UAAsBR,UAUjC/K,YAAYwL,EAAeC,GACzBH,MAAM,UACNrL,KAAKuL,MAAQA,EACbvL,KAAKwL,OAASA,C,EAbL7G,EAAA2G,cAAaA,EAoC1B,SAAiBA,GAIFA,EAAWG,YAAG,IAAIH,GAAe,GAAI,EACnD,CALD,CAAiBA,EAAA3G,EAAa2G,gBAAb3G,EAAA2G,cAKhB,KAmBe3G,EAAA+G,OAAhB,SACElE,EACAmE,EACAC,EAA0B,MAE1B,GAAIpE,EAAO/B,OACT,MAAM,IAAIsB,MAAM,iCAElB,GAAIS,EAAO9B,YAAc8B,EAAOrC,KAAK0G,YACnC,MAAM,IAAI9E,MAAM,+BAElB,IAAK4E,EAAKE,YACR,MAAM,IAAI9E,MAAM,yBAElBlB,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAC3CY,EAAKG,aAAatE,EAAOrC,KAAMyG,GAC/B/F,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,Y,EAY7BrG,EAAAgB,OAAhB,SAAuB6B,GACrB,GAAIA,EAAO/B,OACT,MAAM,IAAIsB,MAAM,iCAElB,IAAKS,EAAO9B,aAAe8B,EAAOrC,KAAK0G,YACrC,MAAM,IAAI9E,MAAM,2BAElBlB,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAC3CzD,EAAOrC,KAAK4G,WAAYC,YAAYxE,EAAOrC,MAC3CU,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,Y,CAE9C,CApVD,CAAiBvG,MAoVhB,KAKD,SAAUlE,GAIKA,EAAa6F,cAAG,IAAIR,mBAAwC,CACvE4B,KAAM,QACNuE,OAAQvI,GAAS,IAAId,EAAc,CAAEc,YAMvBjD,EAAA2E,WAAhB,SAA2BvC,GACzB,OAAOA,EAAQsC,MAAQ+G,SAASC,cAActJ,EAAQuJ,KAAO,M,CAEhE,CAfD,CAAU3L,MAeT,K,MC/kCqB4L,EAMpBtM,YAAY8C,EAA2B,IA4Z/B7C,KAAS+E,WAAG,EAEZ/E,KAAO8E,QAAkB,KA7Z/B9E,KAAKsM,WAAazJ,EAAQ0J,WAAa,c,CAazC9H,UACEzE,KAAK8E,QAAU,KACf9E,KAAK+E,WAAY,EACjBvB,SAAOkB,UAAU1E,MACjB8F,mBAAiBpB,UAAU1E,K,CAMzBwE,iBACF,OAAOxE,KAAK+E,S,CAMVU,aACF,OAAOzF,KAAK8E,O,CAUVW,WAAOnB,GACT,GAAItE,KAAK8E,UAAYR,EAArB,CAGA,GAAItE,KAAK8E,QACP,MAAM,IAAIiC,MAAM,gCAElB,GAAIzC,EAAO+C,SAAWrH,KACpB,MAAM,IAAI+G,MAAM,0BAElB/G,KAAK8E,QAAUR,EACftE,KAAKwM,MARJ,C,CAoBCD,gBACF,OAAOvM,KAAKsM,U,CAeVC,cAAUjI,GAEZ,GAAItE,KAAKsM,aAAehI,IAKxBtE,KAAKsM,WAAahI,EAGdtE,KAAK8E,SAAS,CAChB,IAAI8B,EAAQ5G,KAAK8E,QAAQK,KAAKyB,MAC9BA,EAAM6F,SAAW,GACjB7F,EAAM8F,UAAY,GAClB9F,EAAM+F,SAAW,GACjB/F,EAAMgG,UAAY,GAClB5M,KAAK8E,QAAQuD,KACd,C,CAsCHkC,qBAAqBvD,GACnB,OAAQA,EAAIsC,MACV,IAAK,SACHtJ,KAAKwJ,SAASxC,GACd,MACF,IAAK,iBACHhH,KAAKyJ,gBAAgBzC,GACrB,MACF,IAAK,cACHhH,KAAK0J,aAAa1C,GAClB,MACF,IAAK,cACHhH,KAAK2J,aAAa3C,GAClB,MACF,IAAK,aACHhH,KAAK4J,YAAY5C,GACjB,MACF,IAAK,cACHhH,KAAK6J,aAAa7C,GAClB,MACF,IAAK,aACHhH,KAAK8J,YAAY9C,GACjB,MACF,IAAK,gBACHhH,KAAK+J,eAAe/C,GACpB,MACF,IAAK,eACHhH,KAAKgK,cAAchD,GACnB,MACF,IAAK,gBACHhH,KAAKiK,eAAejD,GACpB,MACF,IAAK,eACHhH,KAAKkK,cAAclD,GACnB,MACF,IAAK,gBACHhH,KAAKsK,eAAetD,GACpB,MACF,IAAK,cACHhH,KAAK6M,aAAa7F,GAClB,MACF,IAAK,eACHhH,KAAK8M,cAAc9F,G,CAkBfwF,OACR,IAAK,MAAMhF,KAAUxH,KACnBwH,EAAO/B,OAASzF,KAAKyF,M,CAiBf+D,SAASxC,GACjB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQ7C,EAAO2G,cAAcG,Y,CAiB/ChC,gBAAgBzC,GACxB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQ7C,EAAO2G,cAAcG,Y,CAc/C1B,eAAe/C,GACvB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQR,E,CAc1BgD,cAAchD,GACtB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQR,E,CAc1BiD,eAAejD,GACvB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQR,E,CAc1BkD,cAAclD,GACtB,IAAK,MAAMQ,KAAUxH,KACnB6F,cAAYqB,YAAYM,EAAQR,E,CAc1B2C,aAAa3C,GACrB,IAAK,MAAMQ,KAAUxH,KACdwH,EAAOtB,UACVL,cAAYqB,YAAYM,EAAQR,E,CAe5B4C,YAAY5C,GACpB,IAAK,MAAMQ,KAAUxH,KACdwH,EAAOtB,UACVL,cAAYqB,YAAYM,EAAQR,E,CAe5B6C,aAAa7C,GACrB,IAAK,MAAMQ,KAAUxH,KACdwH,EAAOtB,UACVL,cAAYqB,YAAYM,EAAQR,E,CAe5B8C,YAAY9C,GACpB,IAAK,MAAMQ,KAAUxH,KACdwH,EAAOtB,UACVL,cAAYqB,YAAYM,EAAQR,E,CAa5BsD,eAAetD,GACvBhH,KAAK+M,aAAa/F,EAAIoE,M,CASd1B,aAAa1C,GAAY,CAQzB6F,aAAa7F,GAAwB,CAQrC8F,cAAc9F,GAAwB,GAUlD,SAAiBqF,GA4DCA,EAAAW,uBAAhB,SAAuCxF,GACrC,OAAO/G,EAAQwM,4BAA4B1G,IAAIiB,E,EAwBjC6E,EAAAa,uBAAhB,SACE1F,EACAlD,GAEA7D,EAAQwM,4BAA4BE,IAAI3F,EAAQlD,E,EAoBlC+H,EAAAe,qBAAhB,SAAqC5F,GACnC,OAAO/G,EAAQ4M,0BAA0B9G,IAAIiB,E,EAwB/B6E,EAAAiB,qBAAhB,SACE9F,EACAlD,GAEA7D,EAAQ4M,0BAA0BF,IAAI3F,EAAQlD,E,CAEjD,CA5ID,CAAiB+H,MA4IhB,K,MAWYkB,EAUXxN,YAAYyH,GAwMJxH,KAAIwN,KAAGC,IACPzN,KAAK0N,MAAGD,IACRzN,KAAM2N,OAAGF,IACTzN,KAAO4N,QAAGH,IACVzN,KAAS6N,UAAG,EACZ7N,KAAU8N,WAAG,EACb9N,KAAS+N,UAAG3N,IACZJ,KAAUgO,WAAG5N,IACbJ,KAAS+E,WAAG,EA/MlB/E,KAAKwH,OAASA,EACdxH,KAAKwH,OAAOrC,KAAKyB,MAAMqH,SAAW,WAClCjO,KAAKwH,OAAOrC,KAAKyB,MAAMsH,QAAU,Q,CASnCzJ,UAEE,GAAIzE,KAAK+E,UACP,OAIF/E,KAAK+E,WAAY,EAGjB,IAAI6B,EAAQ5G,KAAKwH,OAAOrC,KAAKyB,MAC7BA,EAAMqH,SAAW,GACjBrH,EAAMuH,IAAM,GACZvH,EAAMwH,KAAO,GACbxH,EAAM2E,MAAQ,GACd3E,EAAM4E,OAAS,GACf5E,EAAMsH,QAAU,E,CAcdzB,eACF,OAAOzM,KAAK6N,S,CASVnB,gBACF,OAAO1M,KAAK8N,U,CASVnB,eACF,OAAO3M,KAAK+N,S,CASVnB,gBACF,OAAO5M,KAAKgO,U,CAMVxJ,iBACF,OAAOxE,KAAK+E,S,CAMVmB,eACF,OAAOlG,KAAKwH,OAAOtB,Q,CAMjBE,gBACF,OAAOpG,KAAKwH,OAAOpB,S,CAMjBV,iBACF,OAAO1F,KAAKwH,OAAO9B,U,CAMrB2C,MACE,IAAIgG,EAASC,aAAWC,WAAWvO,KAAKwH,OAAOrC,MAC/CnF,KAAK6N,UAAYQ,EAAO5B,SACxBzM,KAAK8N,WAAaO,EAAO3B,UACzB1M,KAAK+N,UAAYM,EAAO1B,SACxB3M,KAAKgO,WAAaK,EAAOzB,S,CAc3B1E,OAAOkG,EAAcD,EAAa5C,EAAeC,GAE/C,IAAIgD,EAAS9M,KAAKF,IAAIxB,KAAK6N,UAAWnM,KAAKH,IAAIgK,EAAOvL,KAAK+N,YACvDU,EAAS/M,KAAKF,IAAIxB,KAAK8N,WAAYpM,KAAKH,IAAIiK,EAAQxL,KAAKgO,aAG7D,GAAIQ,EAASjD,EACX,OAAQc,EAAOW,uBAAuBhN,KAAKwH,SACzC,IAAK,OACH,MACF,IAAK,SACH4G,IAAS7C,EAAQiD,GAAU,EAC3B,MACF,IAAK,QACHJ,GAAQ7C,EAAQiD,EAChB,MACF,QACE,KAAM,cAKZ,GAAIC,EAASjD,EACX,OAAQa,EAAOe,qBAAqBpN,KAAKwH,SACvC,IAAK,MACH,MACF,IAAK,SACH2G,IAAQ3C,EAASiD,GAAU,EAC3B,MACF,IAAK,SACHN,GAAO3C,EAASiD,EAChB,MACF,QACE,KAAM,cAKZ,IAAIC,GAAU,EACV9H,EAAQ5G,KAAKwH,OAAOrC,KAAKyB,MA6B7B,GA1BI5G,KAAKwN,OAASW,IAChBnO,KAAKwN,KAAOW,EACZvH,EAAMuH,IAAM,GAAGA,OAIbnO,KAAK0N,QAAUU,IACjBpO,KAAK0N,MAAQU,EACbxH,EAAMwH,KAAO,GAAGA,OAIdpO,KAAK2N,SAAWa,IAClBE,GAAU,EACV1O,KAAK2N,OAASa,EACd5H,EAAM2E,MAAQ,GAAGiD,OAIfxO,KAAK4N,UAAYa,IACnBC,GAAU,EACV1O,KAAK4N,QAAUa,EACf7H,EAAM4E,OAAS,GAAGiD,OAIhBC,EAAS,CACX,IAAI1H,EAAM,IAAIrC,EAAO2G,cAAckD,EAAQC,GAC3C5I,cAAYqB,YAAYlH,KAAKwH,OAAQR,EACtC,C,GAiBL,SAAUvG,GA4BR,SAASkO,EAAmBvD,GACtBA,EAAM3F,QAAU2F,EAAM3F,OAAO4B,QAC/B+D,EAAM3F,OAAOyC,Q,CA1BJzH,EAA2BwM,4BAAG,IAAInH,mBAG7C,CACA4B,KAAM,sBACNuE,OAAQ,IAAM,SACd5H,QAASsK,IAMElO,EAAyB4M,0BAAG,IAAIvH,mBAG3C,CACA4B,KAAM,oBACNuE,OAAQ,IAAM,MACd5H,QAASsK,GAWZ,CAjCD,CAAUlO,MAiCT,KG70BK,MAAOmO,UAAoBvC,EAAjCtM,c,oBA6RUC,KAAQ6O,SAAa,E,CAlR7BpK,UACE,KAAOzE,KAAK6O,SAAS9N,OAAS,GAC5Bf,KAAK6O,SAASC,MAAOrK,UAEvB4G,MAAM5G,S,CAMJsK,cACF,OAAO/O,KAAK6O,Q,CAQd,EAAEG,OAAOC,kBACAjP,KAAK6O,Q,CAWdK,UAAU1H,GACRxH,KAAKmP,aAAanP,KAAK6O,SAAS9N,OAAQyG,E,CAkB1C2H,aAAajN,EAAesF,GAG1BA,EAAO/B,OAASzF,KAAKyF,OAGrB,IAAIpE,EAAIrB,KAAK6O,SAASO,QAAQ5H,GAG1B6H,EAAI3N,KAAKF,IAAI,EAAGE,KAAKH,IAAIW,EAAOlC,KAAK6O,SAAS9N,SAGlD,IAAW,IAAPM,EAUF,OARAiO,WAASC,OAAOvP,KAAK6O,SAAUQ,EAAG7H,QAG9BxH,KAAKyF,QACPzF,KAAKwP,aAAaH,EAAG7H,IAUrB6H,IAAMrP,KAAK6O,SAAS9N,QACtBsO,IAIEhO,IAAMgO,IAKVC,WAASG,KAAKzP,KAAK6O,SAAUxN,EAAGgO,GAG5BrP,KAAKyF,QACPzF,KAAK0P,WAAWrO,EAAGgO,EAAG7H,G,CAiB1BuF,aAAavF,GACXxH,KAAK2P,eAAe3P,KAAK6O,SAASO,QAAQ5H,G,CAmB5CmI,eAAezN,GAEb,IAAIsF,EAAS8H,WAASM,SAAS5P,KAAK6O,SAAU3M,GAG1CsF,GAAUxH,KAAKyF,QACjBzF,KAAK6P,aAAa3N,EAAOsF,E,CAOnBgF,OACRnB,MAAMmB,OACN,IAAItK,EAAQ,EACZ,IAAK,MAAMsF,KAAUxH,KACnBA,KAAKwP,aAAatN,IAASsF,E,CAsBrBgI,aAAatN,EAAesF,GAEpC,IAAIoE,EAAM5L,KAAKyF,OAAQN,KAAKoC,SAASrF,GAGjClC,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAK2G,aAAatE,EAAOrC,KAAMyG,GAGxC5L,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,Y,CAwBrC0E,WACRI,EACAC,EACAvI,GAGIxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7C,IAAIU,EAAM5L,KAAKyF,OAAQN,KAAKoC,SAASwI,GAGjC/P,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAK2G,aAAatE,EAAOrC,KAAMyG,GAGxC5L,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,Y,CAsBrC6E,aAAa3N,EAAesF,GAEhCxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,Y,GF7SjD,SAAiBxK,GAICA,EAAAsP,eAAhB,SAA+B1L,GAC7B,OAAO5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,G,CAEjC,CAPD,CAAiB5D,MAOhB,KAED,IGqxBUD,ECxiBAA,EClKAA,EC6WAA,ECWAA,ECmJAA,EC9ZAA,EC4yBAA,ECsXAA,ECtqCAA,EZpLVyP,EAAexP,EGgBT,MAAOyP,UAAoBvB,EAM/B7O,YAAY8C,GACVwI,QA8pBQrL,KAAYoQ,aAAG,EACjBpQ,KAAMqQ,OAAG,EACTrQ,KAAQsQ,SAAG,EACXtQ,KAAMuQ,QAAG,EACTvQ,KAAewQ,iBAAG,EAClBxQ,KAAOyQ,QAAe,GACtBzQ,KAAM0Q,OAAiB,GACvB1Q,KAAQ2Q,SAAqB,GAC7B3Q,KAAI4Q,KAAiC,KACrC5Q,KAAU6Q,WAA0B,QACpC7Q,KAAY8Q,aAA4B,aAvqB9C9Q,KAAK+Q,SAAWlO,EAAQkO,cACI7N,IAAxBL,EAAQmO,cACVhR,KAAK8Q,aAAejO,EAAQmO,kBAEJ9N,IAAtBL,EAAQoO,YACVjR,KAAK6Q,WAAahO,EAAQoO,gBAEJ/N,IAApBL,EAAQqO,UACVlR,KAAKsQ,SAAW5P,EAAMsP,eAAenN,EAAQqO,S,CAOjDzM,UAEE,IAAK,MAAM0M,KAAQnR,KAAK0Q,OACtBS,EAAK1M,UAIPzE,KAAK4Q,KAAO,KACZ5Q,KAAK0Q,OAAO3P,OAAS,EACrBf,KAAKyQ,QAAQ1P,OAAS,EACtBf,KAAK2Q,SAAS5P,OAAS,EAGvBsK,MAAM5G,S,CAWJuM,kBACF,OAAOhR,KAAK8Q,Y,CAMVE,gBAAY1M,GACVtE,KAAK8Q,eAAiBxM,IAG1BtE,KAAK8Q,aAAexM,EACftE,KAAKyF,SAGVzF,KAAKyF,OAAOrB,QAAqB,YAAIE,EACrCtE,KAAKyF,OAAO4C,O,CAYV4I,gBACF,OAAOjR,KAAK6Q,U,CAYVI,cAAU3M,GACRtE,KAAK6Q,aAAevM,IAGxBtE,KAAK6Q,WAAavM,EACbtE,KAAKyF,SAGVzF,KAAKyF,OAAOrB,QAAmB,UAAIE,EACnCtE,KAAKyF,OAAOyC,U,CAMVgJ,cACF,OAAOlR,KAAKsQ,Q,CAMVY,YAAQ5M,GACVA,EAAQ5D,EAAMsP,eAAe1L,GACzBtE,KAAKsQ,WAAahM,IAGtBtE,KAAKsQ,SAAWhM,EACXtE,KAAKyF,QAGVzF,KAAKyF,OAAO4C,M,CAMV+I,cACF,OAAOpR,KAAK2Q,Q,CAUdU,gBACE,OAAOrR,KAAKyQ,QAAQa,KAAIhQ,GAASA,EAAMhB,M,CAczCiR,gBACE,OAAO9Q,EAAQ+Q,UAAUxR,KAAKyQ,QAAQa,KAAIhQ,GAASA,EAAMhB,O,CAe3DmR,iBAAiBC,EAAiBxJ,GAAS,GAEzC,IAAI5F,EAAItC,KAAKyQ,QAAQ1P,OACjB4Q,EAAOD,EAAME,MAAM,EAAGtP,GAC1B,KAAOqP,EAAK5Q,OAASuB,GACnBqP,EAAKE,KAAK,GAIZ,IAAIC,EAASrR,EAAQ+Q,UAAUG,GAG/B,IAAK,IAAItQ,EAAI,EAAGA,EAAIiB,IAAKjB,EAAG,CAC1B,IAAIC,EAAQtB,KAAKyQ,QAAQpP,GACzBC,EAAMrB,SAAW6R,EAAOzQ,GACxBC,EAAMhB,KAAOwR,EAAOzQ,EACrB,CAGDrB,KAAKwQ,iBAAkB,EAGnBtI,GAAUlI,KAAKyF,QACjBzF,KAAKyF,OAAOyC,Q,CAiBhB6J,WAAW7P,EAAe+L,GAExB,IAMI9L,EANA6P,EAAShS,KAAK2Q,SAASzO,GAC3B,GAAK8P,IAAUA,EAAOrK,UAAUb,SAAS,mBAOvC3E,EADwB,eAAtBnC,KAAK8Q,aACC7C,EAAW+D,EAAOC,WAElBhE,EAAW+D,EAAOE,UAId,IAAV/P,GAAJ,CAKA,IAAK,IAAIb,KAAStB,KAAKyQ,QACjBnP,EAAMhB,KAAO,IACfgB,EAAMrB,SAAWqB,EAAMhB,MAK3BE,YAAUyB,OAAOjC,KAAKyQ,QAASvO,EAAOC,GAGlCnC,KAAKyF,QACPzF,KAAKyF,OAAOyC,QAdb,C,CAqBOsE,OACRxM,KAAKyF,OAAQrB,QAAqB,YAAIpE,KAAKgR,YAC3ChR,KAAKyF,OAAQrB,QAAmB,UAAIpE,KAAKiR,UACzC5F,MAAMmB,M,CAaEgD,aAAatN,EAAesF,GAEpC,IAAI2J,EAAO,IAAI5D,EAAW/F,GACtBwK,EAASvR,EAAQ0R,aAAanS,KAAK+Q,UACnCqB,EAAU3R,EAAQ4R,YAAYrS,KAAKyQ,SACnCnP,EAAQb,EAAQ6R,YAAYF,GAGhC9C,WAASC,OAAOvP,KAAK0Q,OAAQxO,EAAOiP,GACpC7B,WAASC,OAAOvP,KAAKyQ,QAASvO,EAAOZ,GACrCgO,WAASC,OAAOvP,KAAK2Q,SAAUzO,EAAO8P,GAGlChS,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MACrCnF,KAAKyF,OAAQN,KAAKoN,YAAYP,GAG1BhS,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,aAI7ChL,KAAKyF,OAAQ4C,K,CAeLqH,WACRI,EACAC,EACAvI,GAGA8H,WAASG,KAAKzP,KAAK0Q,OAAQZ,EAAWC,GACtCT,WAASG,KAAKzP,KAAKyQ,QAASX,EAAWC,GACvCT,WAASG,KAAKzP,KAAK2Q,SAAUb,EAAWC,GAGxC/P,KAAKyF,OAAQ4C,K,CAaLwH,aAAa3N,EAAesF,GAEpC,IAAI2J,EAAO7B,WAASM,SAAS5P,KAAK0Q,OAAQxO,GACtC8P,EAAS1C,WAASM,SAAS5P,KAAK2Q,SAAUzO,GAC9CoN,WAASM,SAAS5P,KAAKyQ,QAASvO,GAG5BlC,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MACrCnF,KAAKyF,OAAQN,KAAK6G,YAAYgG,GAG1BhS,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7CiG,EAAM1M,UAGNzE,KAAKyF,OAAQ4C,K,CAMLsB,aAAa3C,GACrBqE,MAAM1B,aAAa3C,GACnBhH,KAAKyF,OAAQyC,Q,CAML6B,eAAe/C,GACvBqE,MAAMtB,eAAe/C,GACrBhH,KAAKyF,OAAQ4C,K,CAMLwE,aAAa7F,GACrBhH,KAAKyF,OAAQ4C,K,CAMLyE,cAAc9F,GACtBhH,KAAKyF,OAAQ4C,K,CAMLmB,SAASxC,GACbhH,KAAKyF,OAAQW,WACfpG,KAAKwS,QAAQxL,EAAIuE,MAAOvE,EAAIwE,O,CAOtB/B,gBAAgBzC,GACpBhH,KAAKyF,OAAQW,WACfpG,KAAKwS,SAAS,GAAI,E,CAOZ9I,aAAa1C,GACjBhH,KAAKyF,OAAQC,YACf1F,KAAKyS,M,CAeCC,mBACRrR,EACAsR,EACAvE,EACAD,EACA3C,EACAD,EACAjL,GAEA,MAAM6Q,EAAOnR,KAAK0Q,OAAOrP,GACzB,GAAI8P,EAAKjL,SACP,OAIF,IAAI0M,EAAc5S,KAAK2Q,SAAStP,GAAGuF,MAG/B+L,GACFvE,GAAQpO,KAAKoQ,aACbe,EAAKjJ,OAAOkG,EAAMD,EAAK7N,EAAMkL,GAC7B4C,GAAQ9N,EACRsS,EAAYzE,IAAM,GAAGA,MACrByE,EAAYxE,KAAO,GAAGA,MACtBwE,EAAYrH,MAAQ,GAAGvL,KAAKsQ,aAC5BsC,EAAYpH,OAAS,GAAGA,QAExB2C,GAAOnO,KAAKoQ,aACZe,EAAKjJ,OAAOkG,EAAMD,EAAK5C,EAAOjL,GAC9B6N,GAAO7N,EACPsS,EAAYzE,IAAM,GAAGA,MACrByE,EAAYxE,KAAO,GAAGA,MACtBwE,EAAYrH,MAAQ,GAAGA,MACvBqH,EAAYpH,OAAS,GAAGxL,KAAKsQ,a,CAOzBmC,OAEN,IAAII,EAAW,EACXC,GAAmB,EACvB,IAAK,IAAIzR,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAC3CrB,KAAK0Q,OAAOrP,GAAG6E,SACjBlG,KAAK2Q,SAAStP,GAAGsG,UAAUC,IAAI,kBAE/B5H,KAAK2Q,SAAStP,GAAGsG,UAAUG,OAAO,iBAClCgL,EAAkBzR,EAClBwR,MAKqB,IAArBC,GACF9S,KAAK2Q,SAASmC,GAAiBnL,UAAUC,IAAI,iBAI/C5H,KAAKqQ,OACHrQ,KAAKsQ,SAAW5O,KAAKF,IAAI,EAAGqR,EAAW,GACvC7S,KAAKoQ,aAAepQ,KAAK0Q,OAAO3P,OAGlC,IAAIgS,EAA6B,eAAtB/S,KAAK8Q,aACZkC,EAAOD,EAAO/S,KAAKqQ,OAAS,EAC5B4C,EAAOF,EAAO,EAAI/S,KAAKqQ,OAG3B,IAAK,IAAIhP,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GACnBC,EAAQtB,KAAKyQ,QAAQpP,GAGrBC,EAAMhB,KAAO,IACfgB,EAAMrB,SAAWqB,EAAMhB,MAIrB6Q,EAAKjL,UACP5E,EAAMpB,QAAU,EAChBoB,EAAMnB,QAAU,IAKlBgR,EAAK9I,MAGL/G,EAAMjB,QAAU8P,EAAY+C,WAAW/B,EAAK3J,QAGxCuL,GACFzR,EAAMpB,QAAUiR,EAAK1E,SACrBnL,EAAMnB,QAAUgR,EAAKxE,SACrBqG,GAAQ7B,EAAK1E,SACbwG,EAAOvR,KAAKF,IAAIyR,EAAM9B,EAAKzE,aAE3BpL,EAAMpB,QAAUiR,EAAKzE,UACrBpL,EAAMnB,QAAUgR,EAAKvE,UACrBqG,GAAQ9B,EAAKzE,UACbsG,EAAOtR,KAAKF,IAAIwR,EAAM7B,EAAK1E,WAE9B,CAGD,IAAI0G,EAAOnT,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,MACzD6N,GAAQG,EAAIE,cACZJ,GAAQE,EAAIG,YAGZ,IAAI1M,EAAQ5G,KAAKyF,OAAQN,KAAKyB,MAC9BA,EAAM6F,SAAW,GAAGuG,MACpBpM,EAAM8F,UAAY,GAAGuG,MAGrBjT,KAAKuQ,QAAS,EAIVvQ,KAAKyF,OAAQA,QACfI,cAAYqB,YAAYlH,KAAKyF,OAAQA,OAASd,EAAOwC,IAAImB,YAKvDtI,KAAKuQ,QACP1K,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,c,CAS7CoK,QAAQe,EAAqBC,GAEnCxT,KAAKuQ,QAAS,EAGd,IAAIsC,EAAW,EACf,IAAK,IAAIxR,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAC/CwR,KAAc7S,KAAK0Q,OAAOrP,GAAG6E,SAI/B,GAAiB,IAAb2M,GAAwC,IAAtB7S,KAAKoQ,aACzB,OAIEmD,EAAc,IAChBA,EAAcvT,KAAKyF,OAAQN,KAAKoO,aAE9BC,EAAe,IACjBA,EAAexT,KAAKyF,OAAQN,KAAKqO,cAI9BxT,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,OAIhD,IAAIgJ,EAAMnO,KAAK4Q,KAAK6C,WAChBrF,EAAOpO,KAAK4Q,KAAK8C,YACjBnI,EAAQgI,EAAcvT,KAAK4Q,KAAKyC,cAChC7H,EAASgI,EAAexT,KAAK4Q,KAAK0C,YAGlCK,EAAQ,EACRC,EAAS,EACTb,EAA6B,eAAtB/S,KAAK8Q,aAEhB,GAAI+B,EAAW,EAAG,CAEhB,IAAIhS,EAUJ,GAPEA,EAFEkS,EAEMrR,KAAKF,IAAI,EAAG+J,EAAQvL,KAAKqQ,QAGzB3O,KAAKF,IAAI,EAAGgK,EAASxL,KAAKqQ,QAIhCrQ,KAAKwQ,gBAAiB,CACxB,IAAK,IAAIlP,KAAStB,KAAKyQ,QACrBnP,EAAMrB,UAAYY,EAEpBb,KAAKwQ,iBAAkB,CACxB,CAGD,IAAIrO,EAAQ3B,YAAUG,KAAKX,KAAKyQ,QAAS5P,GAGzC,GAAIsB,EAAQ,EACV,OAAQnC,KAAK6Q,YACX,IAAK,QACH,MACF,IAAK,SACH8C,EAAQ,EACRC,EAASzR,EAAQ,EACjB,MACF,IAAK,MACHwR,EAAQ,EACRC,EAASzR,EACT,MACF,IAAK,UACHwR,EAAQxR,EAAQ0Q,EAChBe,EAAS,EACT,MACF,QACE,KAAM,cAGb,CAGD,IAAK,IAAIvS,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,MAGMf,EAHON,KAAK0Q,OAAOrP,GAGP6E,SAAW,EAAIlG,KAAKyQ,QAAQpP,GAAGf,KAAOqT,EAExD3T,KAAK0S,mBACHrR,EACA0R,EACAA,EAAO3E,EAAOwF,EAASxF,EACvB2E,EAAO5E,EAAMA,EAAMyF,EACnBpI,EACAD,EACAjL,GAGF,MAAMuT,EACJ7T,KAAKoQ,cACJpQ,KAAK2Q,SAAStP,GAAGsG,UAAUb,SAAS,iBACjC,EACA9G,KAAKsQ,UAEPyC,EACF3E,GAAQ9N,EAAOuT,EAEf1F,GAAO7N,EAAOuT,CAEjB,C,GAmBL,SAAiB1D,GA6DCA,EAAA+C,WAAhB,SAA2B1L,GACzB,OAAO/G,EAAQqT,gBAAgBvN,IAAIiB,E,EAUrB2I,EAAA4D,WAAhB,SAA2BvM,EAAgBlD,GACzC7D,EAAQqT,gBAAgB3G,IAAI3F,EAAQlD,E,CAEvC,CA3ED,CAAiB6L,MA2EhB,KAKD,SAAU1P,GAIKA,EAAeqT,gBAAG,IAAIhO,mBAAiC,CAClE4B,KAAM,UACNuE,OAAQ,IAAM,EACd+H,OAAQ,CAACtQ,EAAOY,IAAU5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,IACjDD,QA+CF,SAA8B+G,GACxBA,EAAM3F,QAAU2F,EAAM3F,OAAO4B,kBAAkB8I,GACjD/E,EAAM3F,OAAO4C,K,IA3CD5H,EAAA6R,YAAhB,SAA4BhS,GAC1B,IAAIgB,EAAQ,IAAIxB,EAEhB,OADAwB,EAAMrB,SAAWyB,KAAKuO,MAAM3P,GACrBgB,C,EAMOb,EAAA0R,aAAhB,SACEpB,GAEA,IAAIiB,EAASjB,EAASoB,eAItB,OAHAH,EAAOpL,MAAMqH,SAAW,WAExB+D,EAAOpL,MAAMsH,QAAU,QAChB8D,C,EAMOvR,EAAA4R,YAAhB,SAA4BzR,GAC1B,OAAOA,EAAOqT,QAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAE7T,MAAM,GAAKM,EAAOG,QAAU,C,EAMnDN,EAAA+Q,UAAhB,SAA0B4C,GACxB,IAAI9R,EAAI8R,EAAOrT,OACf,GAAU,IAANuB,EACF,MAAO,GAET,IAAI+R,EAAMD,EAAOH,QAAO,CAACK,EAAGC,IAAMD,EAAI5S,KAAK8S,IAAID,IAAI,GACnD,OAAe,IAARF,EAAYD,EAAO9C,KAAI4C,GAAK,EAAI5R,IAAK8R,EAAO9C,KAAI4C,GAAKA,EAAIG,G,CAWnE,CA5DD,CAAU5T,MA4DT,KCh1BK,MAAOgU,UAAwBtE,EAWnCpQ,YAAY8C,GACVwI,MAAM,IAAKxI,EAASmO,YAAanO,EAAQmO,aAAe,aA6KlDhR,KAAO0U,QAAkB,GA5K/B1U,KAAK2U,WAAa9R,EAAQ8R,YAAc,E,CAMtCA,iBACF,OAAO3U,KAAKoQ,Y,CAEVuE,eAAWrQ,GACbA,EAAQ5D,EAAMsP,eAAe1L,GACzBtE,KAAKoQ,eAAiB9L,IAG1BtE,KAAKoQ,aAAe9L,EACftE,KAAKyF,QAGVzF,KAAKyF,OAAO4C,M,CAMVuM,aACF,OAAO5U,KAAK0U,O,CAMdjQ,UACMzE,KAAKwE,aAKTxE,KAAK0U,QAAQ3T,OAAS,EAGtBsK,MAAM5G,U,CAQDoQ,YAAY3S,EAAesF,GAChC,MAAMsN,EAAW9U,KAAK0U,QAAQxS,GACxB6S,EAAWD,EAASnN,UAAUb,SAAS,mBACvCkO,EAAWvU,EAAQwU,YAAYjV,KAAK+Q,SAAUvJ,EAAO5B,MAAOmP,GAClE/U,KAAK0U,QAAQxS,GAAS8S,EAGtBhV,KAAKyF,OAAQN,KAAK+P,aAAaF,EAAUF,E,CAkB3C3F,aAAajN,EAAesF,GACrBA,EAAOhB,KACVgB,EAAOhB,GAAK,MAAM2O,OAAKC,WAEzB/J,MAAM8D,aAAajN,EAAOsF,E,CAUlBgI,aAAatN,EAAesF,GACpC,MAAM5B,EAAQnF,EAAQwU,YAAYjV,KAAK+Q,SAAUvJ,EAAO5B,OAExD0J,WAASC,OAAOvP,KAAK0U,QAASxS,EAAO0D,GAGrC5F,KAAKyF,OAAQN,KAAKoN,YAAY3M,GAE9B4B,EAAOrC,KAAKsF,aAAa,OAAQ,UACjCjD,EAAOrC,KAAKsF,aAAa,kBAAmB7E,EAAMY,IAElD6E,MAAMmE,aAAatN,EAAOsF,E,CAYlBkI,WACRI,EACAC,EACAvI,GAEA8H,WAASG,KAAKzP,KAAK0U,QAAS5E,EAAWC,GACvC1E,MAAMqE,WAAWI,EAAWC,EAASvI,E,CAa7BqI,aAAa3N,EAAesF,GACpC,MAAM5B,EAAQ0J,WAASM,SAAS5P,KAAK0U,QAASxS,GAE9ClC,KAAKyF,OAAQN,KAAK6G,YAAYpG,GAE9ByF,MAAMwE,aAAa3N,EAAOsF,E,CAclBkL,mBACRrR,EACAsR,EACAvE,EACAD,EACA3C,EACAD,EACAjL,GAEA,MAAM+U,EAAarV,KAAK0U,QAAQrT,GAAGuF,MAGnCyO,EAAWlH,IAAM,GAAGA,MACpBkH,EAAWjH,KAAO,GAAGA,MACrBiH,EAAW7J,OAAS,GAAGxL,KAAKoQ,iBAE1BiF,EAAW9J,MADToH,EACiB,GAAGnH,MAEH,GAAGD,MAGxBF,MAAMqH,mBAAmBrR,EAAGsR,EAAcvE,EAAMD,EAAK3C,EAAQD,EAAOjL,E,GAsDxE,SAAUG,GAQQA,EAAAwU,YAAhB,SACElE,EACAuE,EACAP,GAAoB,GAEpB,MAAMnP,EAAQmL,EAASwE,mBAAmBD,GAS1C,OARA1P,EAAMgB,MAAMqH,SAAW,WACvBrI,EAAMgB,MAAMsH,QAAU,SACtBtI,EAAM6E,aAAa,aAAc,GAAG6K,EAAK3R,iBACzCiC,EAAM6E,aAAa,gBAAiBsK,EAAW,OAAS,SACxDnP,EAAM6E,aAAa,gBAAiB6K,EAAK5R,MAAM8C,IAC3CuO,GACFnP,EAAM+B,UAAUC,IAAI,mBAEfhC,C,CAEV,CAxBD,CAAUnF,MAwBT,KC5PK,MAAO+U,UAAc7Q,EAMzB5E,YAAY8C,EAA0B,IACpCwI,QACArL,KAAKqF,SAAS,YACdrF,KAAKqH,OAAS5G,EAAQgV,aAAa5S,E,CAMjCkM,cACF,OAAQ/O,KAAKqH,OAAuB0H,O,CAWtCG,UAAU1H,GACPxH,KAAKqH,OAAuB6H,UAAU1H,E,CAazC2H,aAAajN,EAAesF,GACzBxH,KAAKqH,OAAuB8H,aAAajN,EAAOsF,E,GAwBrD,SAAU/G,GAIQA,EAAAgV,aAAhB,SAA6B5S,GAC3B,OAAOA,EAAQwE,QAAU,IAAIuH,C,CAEhC,CAPD,CAAUnO,MAOT,KCjEK,MAAOiV,UAAmBF,EAM9BzV,YAAY8C,EAA+B,IACzCwI,MAAM,CAAEhE,OAAQ5G,EAAQgV,aAAa5S,KAgT/B7C,KAAA2V,aAAe,IAAInS,SAAkBxD,MACrCA,KAAU4V,WAA8B,KAhT9C5V,KAAKqF,SAAS,gB,CAMhBZ,UACEzE,KAAK6V,gBACLxK,MAAM5G,S,CAMJuM,kBACF,OAAQhR,KAAKqH,OAAuB2J,W,CAMlCA,gBAAY1M,GACbtE,KAAKqH,OAAuB2J,YAAc1M,C,CAYzC2M,gBACF,OAAQjR,KAAKqH,OAAuB4J,S,CAYlCA,cAAU3M,GACXtE,KAAKqH,OAAuB4J,UAAY3M,C,CAMvC4M,cACF,OAAQlR,KAAKqH,OAAuB6J,O,CAMlCA,YAAQ5M,GACTtE,KAAKqH,OAAuB6J,QAAU5M,C,CAMrCyM,eACF,OAAQ/Q,KAAKqH,OAAuB0J,Q,CAMlC+E,kBACF,OAAO9V,KAAK2V,Y,CAMVvE,cACF,OAAQpR,KAAKqH,OAAuB+J,O,CActCG,gBACE,OAAQvR,KAAKqH,OAAuBkK,e,CAetCE,iBAAiBC,EAAiBxJ,GAAS,GACxClI,KAAKqH,OAAuBoK,iBAAiBC,EAAOxJ,E,CAavD6N,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,cACHtJ,KAAKiW,gBAAgBD,GACrB,MACF,IAAK,cACHhW,KAAKkW,gBAAgBF,GACrB,MACF,IAAK,YACHhW,KAAKmW,cAAcH,GACnB,MACF,IAAK,UACHhW,KAAKoW,YAAYJ,GACjB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,cAAevW,K,CAMlCkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CA,KAAK6V,e,CAMGxL,aAAarD,GACrBA,EAAIoE,MAAM/F,SAAS,uBACnBrF,KAAK6V,e,CAMGvL,eAAetD,GACvBA,EAAIoE,MAAMvD,YAAY,uBACtB7H,KAAK6V,e,CAMCO,YAAYJ,GAEdhW,KAAK4V,aACPI,EAAMK,iBACNL,EAAMM,mBAIc,KAAlBN,EAAMS,SACRzW,KAAK6V,e,CAODI,gBAAgBD,GAEtB,GAAqB,IAAjBA,EAAMU,OACR,OAIF,IAqBIvU,EArBAkF,EAASrH,KAAKqH,OACdnF,EAAQoN,WAASqH,eAAetP,EAAO+J,SAASY,GAC3CA,EAAOlL,SAASkP,EAAMY,UAI/B,IAAe,IAAX1U,EACF,OAIF8T,EAAMK,iBACNL,EAAMM,kBAGNpK,SAASqK,iBAAiB,YAAavW,MAAM,GAC7CkM,SAASqK,iBAAiB,cAAevW,MAAM,GAC/CkM,SAASqK,iBAAiB,UAAWvW,MAAM,GAC3CkM,SAASqK,iBAAiB,cAAevW,MAAM,GAI/C,IAAIgS,EAAS3K,EAAO+J,QAAQlP,GACxB2U,EAAO7E,EAAO8E,wBAEhB3U,EADyB,eAAvBkF,EAAO2J,YACDgF,EAAMe,QAAUF,EAAKzI,KAErB4H,EAAMgB,QAAUH,EAAK1I,IAI/B,IAAIvH,EAAQqQ,OAAOC,iBAAiBlF,GAChCmF,EAAWC,OAAKC,eAAezQ,EAAM0Q,QACzCtX,KAAK4V,WAAa,CAAE1T,QAAOC,QAAOgV,W,CAM5BjB,gBAAgBF,GAMtB,IAAIuB,EAJJvB,EAAMK,iBACNL,EAAMM,kBAIN,IAAIjP,EAASrH,KAAKqH,OACdwP,EAAO7W,KAAKmF,KAAK2R,wBAEnBS,EADyB,eAAvBlQ,EAAO2J,YACHgF,EAAMe,QAAUF,EAAKzI,KAAOpO,KAAK4V,WAAYzT,MAE7C6T,EAAMgB,QAAUH,EAAK1I,IAAMnO,KAAK4V,WAAYzT,MAIpDkF,EAAO0K,WAAW/R,KAAK4V,WAAY1T,MAAOqV,E,CAMpCpB,cAAcH,GAEC,IAAjBA,EAAMU,SAKVV,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK6V,gB,CAMCA,gBAED7V,KAAK4V,aAKV5V,KAAK4V,WAAWuB,SAAS1S,UACzBzE,KAAK4V,WAAa,KAGlB5V,KAAK2V,aAAapR,OAGlB2H,SAASsK,oBAAoB,UAAWxW,MAAM,GAC9CkM,SAASsK,oBAAoB,YAAaxW,MAAM,GAChDkM,SAASsK,oBAAoB,cAAexW,MAAM,GAClDkM,SAASsK,oBAAoB,cAAexW,MAAM,G,GAUtD,SAAiB0V,GA6Df,MAAa8B,EAMXrF,eACE,IAAIH,EAAS9F,SAASC,cAAc,OAEpC,OADA6F,EAAO/N,UAAY,uBACZ+N,C,EATE0D,EAAA8B,SAAQA,EAgBR9B,EAAA+B,gBAAkB,IAAID,EASnB9B,EAAAxC,WAAhB,SAA2B1L,GACzB,OAAO2I,EAAY+C,WAAW1L,E,EAUhBkO,EAAA3B,WAAhB,SAA2BvM,EAAgBlD,GACzC6L,EAAY4D,WAAWvM,EAAQlD,E,CAElC,CApGD,CAAiBoR,MAoGhB,KAKD,SAAUjV,GAwBQA,EAAAgV,aAAhB,SAA6B5S,GAC3B,OACEA,EAAQwE,QACR,IAAI8I,EAAY,CACdY,SAAUlO,EAAQkO,UAAY2E,EAAW+B,gBACzCzG,YAAanO,EAAQmO,YACrBC,UAAWpO,EAAQoO,UACnBC,QAASrO,EAAQqO,S,CAIxB,CAnCD,CAAUzQ,MAmCT,KCvdK,MAAOiX,UAAuBhC,EAMlC3V,YAAY8C,EAAmC,IAC7CwI,MAAM,IAAKxI,EAASwE,OAAQ5G,EAAQgV,aAAa5S,KAgU3C7C,KAAA2X,kBAA6C,IAAIC,QACjD5X,KAAA6X,kBAAoB,IAAIrU,SAAqBxD,MAhUnDA,KAAKqF,SAAS,oB,CAMZ0L,eACF,OAAQ/Q,KAAKqH,OAA2B0J,Q,CAStC4D,iBACF,OAAQ3U,KAAKqH,OAA2BsN,U,CAEtCA,eAAWrQ,GACZtE,KAAKqH,OAA2BsN,WAAarQ,C,CAM5CsQ,aACF,OAAQ5U,KAAKqH,OAA2BuN,M,CAMtCkD,uBACF,OAAO9X,KAAK6X,iB,CAWd3I,UAAU1H,GACR6D,MAAM6D,UAAU1H,GAChBA,EAAO5B,MAAMvB,QAAQ0T,QAAQ/X,KAAKgY,gBAAiBhY,K,CAWrDiY,SAAS/V,GACP,MAAMsF,EAAUxH,KAAKqH,OAA2B0H,QAAQ7M,GAEpDsF,IAAWA,EAAOtB,UACpBlG,KAAKkY,iBAAiBhW,E,CAY1BiW,OAAOjW,GACL,MAAMsF,EAAUxH,KAAKqH,OAA2B0H,QAAQ7M,GAEpDsF,GAAUA,EAAOtB,UACnBlG,KAAKkY,iBAAiBhW,E,CAc1BiN,aAAajN,EAAesF,GAC1B6D,MAAM8D,aAAajN,EAAOsF,GAC1BA,EAAO5B,MAAMvB,QAAQ0T,QAAQ/X,KAAKgY,gBAAiBhY,K,CAarD+V,YAAYC,GAEV,OADA3K,MAAM0K,YAAYC,GACVA,EAAM1M,MACZ,IAAK,QACHtJ,KAAKoY,UAAUpC,GACf,MACF,IAAK,UACHhW,KAAKqY,cAAcrC,G,CAQfjM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,QAASvW,MACpCA,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCqL,MAAMtB,eAAe/C,E,CAMbkD,cAAclD,GACtBqE,MAAMnB,cAAclD,GACpBhH,KAAKmF,KAAKqR,oBAAoB,QAASxW,MACvCA,KAAKmF,KAAKqR,oBAAoB,UAAWxW,K,CAMnCgY,gBAAgBM,GACtB,MAAMpW,EAAQoN,WAASqH,eAAe3W,KAAK+O,SAASvH,GAC3CA,EAAOV,SAASwR,EAAO5U,SAG5BxB,GAAS,IACVlC,KAAKqH,OAA2BwN,YAAY3S,EAAOoW,EAAO5U,OAC3D1D,KAAKkI,S,CAkBDqQ,mBAAmBrW,GACzB,MAAMmF,EAASrH,KAAKqH,OAEdG,EAASH,EAAO0H,QAAQ7M,GAC9B,IAAKsF,EACH,OAEF,MAAMtB,EAAWsB,EAAOtB,SAClBsS,EAAcnR,EAAOgK,gBACrBlP,GAAS+D,GAAY,EAAI,GAAKlG,KAAKkR,QACnChQ,EAAYsX,EAAYvE,QAC5B,CAACwE,EAAcC,IAAiBD,EAAOC,IAGzC,IAAIC,EAAU,IAAIH,GAElB,GAAKtS,EAeE,CAEL,MAAM0S,EAAe5Y,KAAK2X,kBAAkBpR,IAAIiB,GAChD,IAAKoR,EAEH,OAEFD,EAAQzW,IAAU0W,EAElB,MAAMC,EAAmBF,EACtBrH,KAAIwH,GAAMA,EAAKF,EAAe,IAC9BG,aAAY,IACW,IAAtBF,EAGFF,EAAQK,SAAQ,CAACC,EAAGC,KACdA,IAAQhX,IACVyW,EAAQO,IACLV,EAAYU,GAAOhY,GAAc0X,EAAezW,GACpD,IAGHwW,EAAQE,IAAqBD,EAAezW,CAE/C,KAvCc,CAEb,MAAMgX,EAAcX,EAAYtW,GAEhClC,KAAK2X,kBAAkBxK,IAAI3F,EAAQ2R,GACnCR,EAAQzW,GAAS,EAEjB,MAAM2W,EAAmBF,EAAQrH,KAAIwH,GAAMA,EAAK,IAAGC,aAAY,GAC/D,IAA0B,IAAtBF,EAEF,OAGFF,EAAQE,GACNL,EAAYK,GAAoBM,EAAchX,CACjD,CAyBD,OAAOwW,EAAQrH,KAAIwH,GAAMA,GAAM5X,EAAYiB,I,CAKrCiW,UAAUpC,GAChB,MAAMY,EAASZ,EAAMY,OAErB,GAAIA,EAAQ,CACV,MAAM1U,EAAQoN,WAASqH,eAAe3W,KAAK4U,QAAQhP,GAC1CA,EAAMkB,SAAS8P,KAGpB1U,GAAS,IACX8T,EAAMK,iBACNL,EAAMM,kBACNtW,KAAKkY,iBAAiBhW,GAEzB,C,CAMKmW,cAAcrC,GACpB,GAAIA,EAAMoD,iBACR,OAGF,MAAMxC,EAASZ,EAAMY,OACrB,IAAIyC,GAAU,EACd,GAAIzC,EAAQ,CACV,MAAM1U,EAAQoN,WAASqH,eAAe3W,KAAK4U,QAAQhP,GAC1CA,EAAMkB,SAAS8P,KAGxB,GAAI1U,GAAS,EAAG,CACd,MAAMuU,EAAUT,EAAMS,QAAQ6C,WAG9B,GAAItD,EAAMuD,IAAIC,MAAM,gBAAkB/C,EAAQ+C,MAAM,SAClD5C,EAAO6C,QACPJ,GAAU,OACL,GACgB,eAArBrZ,KAAKgR,YACDgF,EAAMuD,IAAIC,MAAM,yBAA2B/C,EAAQ+C,MAAM,SACzDxD,EAAMuD,IAAIC,MAAM,sBAAwB/C,EAAQ+C,MAAM,SAC1D,CAEA,MAAME,EACJ1D,EAAMuD,IAAIC,MAAM,sBAAwB/C,EAAQ+C,MAAM,UACjD,EACD,EACAzY,EAASf,KAAK4U,OAAO7T,OACrB4Y,GAAYzX,EAAQnB,EAAS2Y,GAAa3Y,EAEhDf,KAAK4U,OAAO+E,GAAUC,QACtBP,GAAU,CACX,KAAwB,QAAdrD,EAAMuD,KAA6B,OAAZ9C,GAEhCzW,KAAK4U,OAAO5U,KAAK4U,OAAO7T,OAAS,GAAG6Y,QACpCP,GAAU,GACa,SAAdrD,EAAMuD,KAA8B,OAAZ9C,IAEjCzW,KAAK4U,OAAO,GAAGgF,QACfP,GAAU,EAEb,CAEGA,GACFrD,EAAMK,gBAET,C,CAGK6B,iBAAiBhW,GACvB,MAAM0D,EAAQ5F,KAAK4U,OAAO1S,GACpBsF,EAAUxH,KAAKqH,OAA2B0H,QAAQ7M,GAElDyW,EAAU3Y,KAAKuY,mBAAmBrW,GACpCyW,GACF3Y,KAAKyR,iBAAiBkH,GAAS,GAG7BnR,EAAOtB,UACTN,EAAM+B,UAAUC,IAAI,mBACpBhC,EAAM6E,aAAa,gBAAiB,QACpCjD,EAAOmB,SAEP/C,EAAM+B,UAAUG,OAAO,mBACvBlC,EAAM6E,aAAa,gBAAiB,SACpCjD,EAAOuB,QAIT/I,KAAK6X,kBAAkBtT,KAAKrC,E,GAUhC,SAAiBwV,GAiCf,MAAaF,UAAiB9B,EAAW8B,SACvCzX,cACEsL,QAMOrL,KAAc6Z,eAAG,0BA8DlB7Z,KAAQ8Z,SAAG,EACX9Z,KAAA+Z,WAAa,IAAInC,QApEvB5X,KAAKga,QAAUxC,EAASyC,U,CAc1BC,mBAAmB5E,GACjB,OAAOpJ,SAASC,cAAc,O,CAUhCoJ,mBAAmBD,GACjB,MAAMtD,EAAS9F,SAASC,cAAc,MACtC6F,EAAOvH,aAAa,WAAY,KAChCuH,EAAOxL,GAAKxG,KAAKma,eAAe7E,GAChCtD,EAAO/N,UAAYjE,KAAK6Z,eACxB,IAAK,MAAMO,KAAS9E,EAAKlR,QACvB4N,EAAO5N,QAAQgW,GAAS9E,EAAKlR,QAAQgW,GAGrBpI,EAAOO,YAAYvS,KAAKka,mBAAmB5E,IACnDrR,UAAY,mCAEtB,MAAMN,EAAQqO,EAAOO,YAAYrG,SAASC,cAAc,SAKxD,OAJAxI,EAAMM,UAAY,+BAClBN,EAAM0W,YAAc/E,EAAK3R,MACzBA,EAAMiC,MAAQ0P,EAAKtR,SAAWsR,EAAK3R,MAE5BqO,C,CAcTmI,eAAe7E,GACb,IAAIiE,EAAMvZ,KAAK+Z,WAAWxT,IAAI+O,GAK9B,YAJYpS,IAARqW,IACFA,EAAM,aAAavZ,KAAKga,SAASha,KAAK8Z,aACtC9Z,KAAK+Z,WAAW5M,IAAImI,EAAMiE,IAErBA,C,EAGM/B,EAAUyC,WAAG,EApEjBvC,EAAAF,SAAQA,EA6ERE,EAAAD,gBAAkB,IAAID,CACpC,CA/GD,CAAiBE,MA+GhB,KAED,SAAUjX,GAOQA,EAAAgV,aAAhB,SACE5S,GAEA,OACEA,EAAQwE,QACR,IAAIoN,EAAgB,CAClB1D,SAAUlO,EAAQkO,UAAY2G,EAAeD,gBAC7CzG,YAAanO,EAAQmO,YACrBC,UAAWpO,EAAQoO,UACnBC,QAASrO,EAAQqO,QACjByD,WAAY9R,EAAQ8R,Y,CAI3B,CArBD,CAAUlU,MAqBT,KCxcK,MAAO6Z,UAAkB1L,EAM7B7O,YAAY8C,EAA8B,IACxCwI,QAydMrL,KAAMqQ,OAAG,EACTrQ,KAAQsQ,SAAG,EACXtQ,KAAMuQ,QAAG,EACTvQ,KAAOyQ,QAAe,GACtBzQ,KAAM0Q,OAAiB,GACvB1Q,KAAI4Q,KAAiC,KACrC5Q,KAAU6Q,WAAwB,QAClC7Q,KAAUua,WAAwB,qBA/ddrX,IAAtBL,EAAQ6W,YACV1Z,KAAKua,WAAa1X,EAAQ6W,gBAEFxW,IAAtBL,EAAQoO,YACVjR,KAAK6Q,WAAahO,EAAQoO,gBAEJ/N,IAApBL,EAAQqO,UACVlR,KAAKsQ,SAAW5P,EAAMsP,eAAenN,EAAQqO,S,CAOjDzM,UAEE,IAAK,MAAM0M,KAAQnR,KAAK0Q,OACtBS,EAAK1M,UAIPzE,KAAK4Q,KAAO,KACZ5Q,KAAK0Q,OAAO3P,OAAS,EACrBf,KAAKyQ,QAAQ1P,OAAS,EAGtBsK,MAAM5G,S,CAMJiV,gBACF,OAAO1Z,KAAKua,U,CAMVb,cAAUpV,GACRtE,KAAKua,aAAejW,IAGxBtE,KAAKua,WAAajW,EACbtE,KAAKyF,SAGVzF,KAAKyF,OAAOrB,QAAmB,UAAIE,EACnCtE,KAAKyF,OAAO4C,O,CAYV4I,gBACF,OAAOjR,KAAK6Q,U,CAYVI,cAAU3M,GACRtE,KAAK6Q,aAAevM,IAGxBtE,KAAK6Q,WAAavM,EACbtE,KAAKyF,SAGVzF,KAAKyF,OAAOrB,QAAmB,UAAIE,EACnCtE,KAAKyF,OAAOyC,U,CAMVgJ,cACF,OAAOlR,KAAKsQ,Q,CAMVY,YAAQ5M,GACVA,EAAQ5D,EAAMsP,eAAe1L,GACzBtE,KAAKsQ,WAAahM,IAGtBtE,KAAKsQ,SAAWhM,EACXtE,KAAKyF,QAGVzF,KAAKyF,OAAO4C,M,CAMJmE,OACRxM,KAAKyF,OAAQrB,QAAmB,UAAIpE,KAAK0Z,UACzC1Z,KAAKyF,OAAQrB,QAAmB,UAAIpE,KAAKiR,UACzC5F,MAAMmB,M,CAaEgD,aAAatN,EAAesF,GAEpC8H,WAASC,OAAOvP,KAAK0Q,OAAQxO,EAAO,IAAIqL,EAAW/F,IAGnD8H,WAASC,OAAOvP,KAAKyQ,QAASvO,EAAO,IAAIpC,GAGrCE,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,aAI7ChL,KAAKyF,OAAQ4C,K,CAeLqH,WACRI,EACAC,EACAvI,GAGA8H,WAASG,KAAKzP,KAAK0Q,OAAQZ,EAAWC,GAGtCT,WAASG,KAAKzP,KAAKyQ,QAASX,EAAWC,GAGvC/P,KAAKyF,OAAQyC,Q,CAaL2H,aAAa3N,EAAesF,GAEpC,IAAI2J,EAAO7B,WAASM,SAAS5P,KAAK0Q,OAAQxO,GAG1CoN,WAASM,SAAS5P,KAAKyQ,QAASvO,GAG5BlC,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7CiG,EAAM1M,UAGNzE,KAAKyF,OAAQ4C,K,CAMLsB,aAAa3C,GACrBqE,MAAM1B,aAAa3C,GACnBhH,KAAKyF,OAAQyC,Q,CAML6B,eAAe/C,GACvBqE,MAAMtB,eAAe/C,GACrBhH,KAAKyF,OAAQ4C,K,CAMLwE,aAAa7F,GACrBhH,KAAKyF,OAAQ4C,K,CAMLyE,cAAc9F,GACtBhH,KAAKyF,OAAQ4C,K,CAMLmB,SAASxC,GACbhH,KAAKyF,OAAQW,WACfpG,KAAKwS,QAAQxL,EAAIuE,MAAOvE,EAAIwE,O,CAOtB/B,gBAAgBzC,GACpBhH,KAAKyF,OAAQW,WACfpG,KAAKwS,SAAS,GAAI,E,CAOZ9I,aAAa1C,GACjBhH,KAAKyF,OAAQC,YACf1F,KAAKyS,M,CAODA,OAEN,IAAII,EAAW,EACf,IAAK,IAAIxR,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAC/CwR,KAAc7S,KAAK0Q,OAAOrP,GAAG6E,SAI/BlG,KAAKqQ,OAASrQ,KAAKsQ,SAAW5O,KAAKF,IAAI,EAAGqR,EAAW,GAGrD,IAAIE,EAAOtS,EAAQkS,aAAa3S,KAAKua,YACjCvH,EAAOD,EAAO/S,KAAKqQ,OAAS,EAC5B4C,EAAOF,EAAO,EAAI/S,KAAKqQ,OAG3B,IAAK,IAAIhP,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GACnBC,EAAQtB,KAAKyQ,QAAQpP,GAGrB8P,EAAKjL,UACP5E,EAAMpB,QAAU,EAChBoB,EAAMnB,QAAU,IAKlBgR,EAAK9I,MAGL/G,EAAMrB,SAAWqa,EAAUE,aAAarJ,EAAK3J,QAC7ClG,EAAMjB,QAAUia,EAAUpH,WAAW/B,EAAK3J,QAGtCuL,GACFzR,EAAMpB,QAAUiR,EAAK1E,SACrBnL,EAAMnB,QAAUgR,EAAKxE,SACrBqG,GAAQ7B,EAAK1E,SACbwG,EAAOvR,KAAKF,IAAIyR,EAAM9B,EAAKzE,aAE3BpL,EAAMpB,QAAUiR,EAAKzE,UACrBpL,EAAMnB,QAAUgR,EAAKvE,UACrBqG,GAAQ9B,EAAKzE,UACbsG,EAAOtR,KAAKF,IAAIwR,EAAM7B,EAAK1E,WAE9B,CAGD,IAAI0G,EAAOnT,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,MACzD6N,GAAQG,EAAIE,cACZJ,GAAQE,EAAIG,YAGZ,IAAI1M,EAAQ5G,KAAKyF,OAAQN,KAAKyB,MAC9BA,EAAM6F,SAAW,GAAGuG,MACpBpM,EAAM8F,UAAY,GAAGuG,MAGrBjT,KAAKuQ,QAAS,EAIVvQ,KAAKyF,OAAQA,QACfI,cAAYqB,YAAYlH,KAAKyF,OAAQA,OAASd,EAAOwC,IAAImB,YAKvDtI,KAAKuQ,QACP1K,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,c,CAS7CoK,QAAQe,EAAqBC,GAEnCxT,KAAKuQ,QAAS,EAGd,IAAIsC,EAAW,EACf,IAAK,IAAIxR,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAC/CwR,KAAc7S,KAAK0Q,OAAOrP,GAAG6E,SAI/B,GAAiB,IAAb2M,EACF,OAIEU,EAAc,IAChBA,EAAcvT,KAAKyF,OAAQN,KAAKoO,aAE9BC,EAAe,IACjBA,EAAexT,KAAKyF,OAAQN,KAAKqO,cAI9BxT,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,OAIhD,IAMIhD,EANAgM,EAAMnO,KAAK4Q,KAAK6C,WAChBrF,EAAOpO,KAAK4Q,KAAK8C,YACjBnI,EAAQgI,EAAcvT,KAAK4Q,KAAKyC,cAChC7H,EAASgI,EAAexT,KAAK4Q,KAAK0C,YAItC,OAAQtT,KAAKua,YACX,IAAK,gBACHpY,EAAQ3B,YAAUG,KAAKX,KAAKyQ,QAAS/O,KAAKF,IAAI,EAAG+J,EAAQvL,KAAKqQ,SAC9D,MACF,IAAK,gBACHlO,EAAQ3B,YAAUG,KAAKX,KAAKyQ,QAAS/O,KAAKF,IAAI,EAAGgK,EAASxL,KAAKqQ,SAC/D,MACF,IAAK,gBACHlO,EAAQ3B,YAAUG,KAAKX,KAAKyQ,QAAS/O,KAAKF,IAAI,EAAG+J,EAAQvL,KAAKqQ,SAC9DjC,GAAQ7C,EACR,MACF,IAAK,gBACHpJ,EAAQ3B,YAAUG,KAAKX,KAAKyQ,QAAS/O,KAAKF,IAAI,EAAGgK,EAASxL,KAAKqQ,SAC/DlC,GAAO3C,EACP,MACF,QACE,KAAM,cAIV,IAAImI,EAAQ,EACRC,EAAS,EAGb,GAAIzR,EAAQ,EACV,OAAQnC,KAAK6Q,YACX,IAAK,QACH,MACF,IAAK,SACH8C,EAAQ,EACRC,EAASzR,EAAQ,EACjB,MACF,IAAK,MACHwR,EAAQ,EACRC,EAASzR,EACT,MACF,IAAK,UACHwR,EAAQxR,EAAQ0Q,EAChBe,EAAS,EACT,MACF,QACE,KAAM,cAKZ,IAAK,IAAIvS,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GAGvB,GAAI8P,EAAKjL,SACP,SAIF,IAAI5F,EAAON,KAAKyQ,QAAQpP,GAAGf,KAG3B,OAAQN,KAAKua,YACX,IAAK,gBACHpJ,EAAKjJ,OAAOkG,EAAOwF,EAAQzF,EAAK7N,EAAOqT,EAAOnI,GAC9C4C,GAAQ9N,EAAOqT,EAAQ3T,KAAKsQ,SAC5B,MACF,IAAK,gBACHa,EAAKjJ,OAAOkG,EAAMD,EAAMyF,EAAQrI,EAAOjL,EAAOqT,GAC9CxF,GAAO7N,EAAOqT,EAAQ3T,KAAKsQ,SAC3B,MACF,IAAK,gBACHa,EAAKjJ,OAAOkG,EAAOwF,EAAStT,EAAOqT,EAAOxF,EAAK7N,EAAOqT,EAAOnI,GAC7D4C,GAAQ9N,EAAOqT,EAAQ3T,KAAKsQ,SAC5B,MACF,IAAK,gBACHa,EAAKjJ,OAAOkG,EAAMD,EAAMyF,EAAStT,EAAOqT,EAAOpI,EAAOjL,EAAOqT,GAC7DxF,GAAO7N,EAAOqT,EAAQ3T,KAAKsQ,SAC3B,MACF,QACE,KAAM,cAEX,C,GAgBL,SAAiBgK,GAgDCA,EAAApH,WAAhB,SAA2B1L,GACzB,OAAO/G,EAAQqT,gBAAgBvN,IAAIiB,E,EAUrB8S,EAAAvG,WAAhB,SAA2BvM,EAAgBlD,GACzC7D,EAAQqT,gBAAgB3G,IAAI3F,EAAQlD,E,EAUtBgW,EAAAE,aAAhB,SAA6BhT,GAC3B,OAAO/G,EAAQga,kBAAkBlU,IAAIiB,E,EAUvB8S,EAAAI,aAAhB,SAA6BlT,EAAgBlD,GAC3C7D,EAAQga,kBAAkBtN,IAAI3F,EAAQlD,E,CAEzC,CApFD,CAAiBgW,MAoFhB,KAKD,SAAU7Z,GAsCR,SAASka,EAAqBvP,GACxBA,EAAM3F,QAAU2F,EAAM3F,OAAO4B,kBAAkBiT,GACjDlP,EAAM3F,OAAO4C,K,CApCJ5H,EAAeqT,gBAAG,IAAIhO,mBAAiC,CAClE4B,KAAM,UACNuE,OAAQ,IAAM,EACd+H,OAAQ,CAACtQ,EAAOY,IAAU5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,IACjDD,QAASsW,IAMEla,EAAiBga,kBAAG,IAAI3U,mBAAiC,CACpE4B,KAAM,YACNuE,OAAQ,IAAM,EACd+H,OAAQ,CAACtQ,EAAOY,IAAU5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,IACjDD,QAASsW,IAMKla,EAAAkS,aAAhB,SAA6BiI,GAC3B,MAAe,kBAARA,GAAmC,kBAARA,C,EAMpBna,EAAAoa,aAAhB,SAA6BvW,GAC3B,OAAO5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,G,CAWjC,CA3CD,CAAU7D,MA2CT,KC1nBK,MAAOqa,UAAiBtF,EAM5BzV,YAAY8C,EAA6B,IACvCwI,MAAM,CAAEhE,OAAQ5G,EAAQgV,aAAa5S,KACrC7C,KAAKqF,SAAS,c,CAMZqU,gBACF,OAAQ1Z,KAAKqH,OAAqBqS,S,CAMhCA,cAAUpV,GACXtE,KAAKqH,OAAqBqS,UAAYpV,C,CAYrC2M,gBACF,OAAQjR,KAAKqH,OAAqB4J,S,CAYhCA,cAAU3M,GACXtE,KAAKqH,OAAqB4J,UAAY3M,C,CAMrC4M,cACF,OAAQlR,KAAKqH,OAAqB6J,O,CAMhCA,YAAQ5M,GACTtE,KAAKqH,OAAqB6J,QAAU5M,C,CAM7B+F,aAAarD,GACrBA,EAAIoE,MAAM/F,SAAS,oB,CAMXiF,eAAetD,GACvBA,EAAIoE,MAAMvD,YAAY,oB,GAO1B,SAAiBiT,GAqDCA,EAAA5H,WAAhB,SAA2B1L,GACzB,OAAO8S,EAAUpH,WAAW1L,E,EAUdsT,EAAA/G,WAAhB,SAA2BvM,EAAgBlD,GACzCgW,EAAUvG,WAAWvM,EAAQlD,E,EAUfwW,EAAAN,aAAhB,SAA6BhT,GAC3B,OAAO8S,EAAUE,aAAahT,E,EAUhBsT,EAAAJ,aAAhB,SAA6BlT,EAAgBlD,GAC3CgW,EAAUI,aAAalT,EAAQlD,E,CAElC,CAzFD,CAAiBwW,MAyFhB,KAKD,SAAUra,GAIQA,EAAAgV,aAAhB,SAA6B5S,GAC3B,OAAOA,EAAQwE,QAAU,IAAIiT,EAAUzX,E,CAE1C,CAPD,CAAUpC,MAOT,KC9KK,MAAOsa,UAAuBpW,EAMlC5E,YAAY8C,GACVwI,MAAM,CAAElG,KAAM1E,EAAQ2E,eAsehBpF,KAAYgb,cAAI,EAChBhb,KAAM0Q,OAA2B,GACjC1Q,KAAQib,SAAkC,KAvehDjb,KAAKqF,SAAS,qBACdrF,KAAKsF,QAAQX,EAAOY,KAAK+B,gBACzBtH,KAAKkb,SAAWrY,EAAQqY,SACxBlb,KAAK+Q,SAAWlO,EAAQkO,UAAYgK,EAAetD,gBACnDzX,KAAKkb,SAASC,eAAepD,QAAQ/X,KAAKob,iBAAkBpb,MAC5DA,KAAKkb,SAASG,kBAAkBtD,QAAQ/X,KAAKob,iBAAkBpb,K,CAMjEyE,UACEzE,KAAK0Q,OAAO3P,OAAS,EACrBf,KAAKib,SAAW,KAChB5P,MAAM5G,S,CAmBJ6W,iBACF,OAAOtb,KAAKmF,KAAKoW,uBACf,4BACA,E,CASAC,gBACF,OAAOxb,KAAKmF,KAAKoW,uBACf,2BACA,E,CAWAE,kBACF,OAAOzb,KAAKmF,KAAKoW,uBACf,6BACA,E,CAMAG,YACF,OAAO1b,KAAK0Q,M,CAUdiL,QAAQ9Y,GAEN,IAAIsO,EAAO1Q,EAAQmb,WAAW5b,KAAKkb,SAAUrY,GAS7C,OANA7C,KAAK0Q,OAAOmB,KAAKV,GAGjBnR,KAAK6b,UAGE1K,C,CAUT2K,SAASJ,GACP,MAAMK,EAAWL,EAAMpK,KAAIH,GAAQ1Q,EAAQmb,WAAW5b,KAAKkb,SAAU/J,KAGrE,OAFA4K,EAAS/C,SAAQ7H,GAAQnR,KAAK0Q,OAAOmB,KAAKV,KAC1CnR,KAAK6b,UACEE,C,CAWTC,WAAW7K,GACTnR,KAAKic,aAAajc,KAAK0Q,OAAOtB,QAAQ+B,G,CAWxC8K,aAAa/Z,GAEAoN,WAASM,SAAS5P,KAAK0Q,OAAQxO,IAQ1ClC,KAAK6b,S,CAMPK,aAE6B,IAAvBlc,KAAK0Q,OAAO3P,SAKhBf,KAAK0Q,OAAO3P,OAAS,EAGrBf,KAAK6b,U,CAgBPA,UAEE,GADA7b,KAAKib,SAAW,KACa,KAAzBjb,KAAKwb,UAAUlX,MAAc,CACnBtE,KAAKmF,KAAKoW,uBACpB,iBACA,GACI3U,MAAMuV,QAAU,SACvB,KAAM,CACOnc,KAAKmF,KAAKoW,uBACpB,iBACA,GACI3U,MAAMuV,QAAU,MACvB,CACDnc,KAAKkI,Q,CAaP6N,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,QACHtJ,KAAKoY,UAAUpC,GACf,MACF,IAAK,UACHhW,KAAKoW,YAAYJ,GACjB,MACF,IAAK,QACHhW,KAAK6b,UACL,MACF,IAAK,QACL,IAAK,OACH7b,KAAKoc,iB,CAQDrS,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,QAASvW,MACpCA,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCA,KAAKmF,KAAKoR,iBAAiB,QAASvW,MACpCA,KAAKmF,KAAKoR,iBAAiB,QAASvW,MAAM,GAC1CA,KAAKmF,KAAKoR,iBAAiB,OAAQvW,MAAM,E,CAMjCkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,QAASxW,MACvCA,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAKmF,KAAKqR,oBAAoB,QAASxW,MACvCA,KAAKmF,KAAKqR,oBAAoB,QAASxW,MAAM,GAC7CA,KAAKmF,KAAKqR,oBAAoB,OAAQxW,MAAM,E,CAMpC4J,YAAY5C,GACpBhH,KAAKkI,SACLmD,MAAMzB,YAAY5C,E,CAMVmD,kBAAkBnD,GAC1B,GAAIhH,KAAK0F,WAAY,CACnB,IAAI2W,EAAQrc,KAAKwb,UACjBa,EAAMzC,QACNyC,EAAMC,QACP,C,CAMO7S,gBAAgBzC,GACxB,GAAIhH,KAAKkG,SACP,OAIF,IAAIqW,EAAQvc,KAAKwb,UAAUlX,MACvBmX,EAAczb,KAAKyb,YAGnBe,EAAUxc,KAAKib,SAYnB,GAXKuB,IAEHA,EAAUxc,KAAKib,SAAWxa,EAAQgc,OAAOzc,KAAK0Q,OAAQ6L,GAGtDvc,KAAKgb,aAAeuB,EAChBjN,WAASqH,eAAe6F,EAAS/b,EAAQic,cACxC,IAIFH,GAA4B,IAAnBC,EAAQzb,OAEpB,YADA4b,aAAWC,OAAO,KAAMnB,GAK1B,GAAIc,GAA4B,IAAnBC,EAAQzb,OAAc,CACjC,IAAI8b,EAAU7c,KAAK+Q,SAAS+L,mBAAmB,CAAEP,UAEjD,YADAI,aAAWC,OAAOC,EAASpB,EAE5B,CAGD,IAAI1K,EAAW/Q,KAAK+Q,SAChBgM,EAAc/c,KAAKgb,aACnB6B,EAAU,IAAIG,MAAsBR,EAAQzb,QAChD,IAAK,IAAIM,EAAI,EAAGiB,EAAIka,EAAQzb,OAAQM,EAAIiB,IAAKjB,EAAG,CAC9C,IAAI4b,EAAST,EAAQnb,GACrB,GAAoB,WAAhB4b,EAAO3T,KAAmB,CAC5B,IAAI4T,EAAUD,EAAOC,QACjBC,EAAWF,EAAOE,SACtBN,EAAQxb,GAAK0P,EAASqM,aAAa,CAAED,WAAUD,WAChD,KAAM,CACL,IAAI/L,EAAO8L,EAAO9L,KACd+L,EAAUD,EAAOC,QACjBG,EAAShc,IAAM0b,EACnBF,EAAQxb,GAAK0P,EAASuM,WAAW,CAAEnM,OAAM+L,UAASG,UACnD,CACF,CAMD,GAHAV,aAAWC,OAAOC,EAASpB,GAGvBsB,EAAc,GAAKA,GAAeP,EAAQzb,OAC5C0a,EAAY8B,UAAY,MACnB,CACL,IAAIC,EAAU/B,EAAYlU,SAASwV,GACnCzO,aAAWmP,uBAAuBhC,EAAa+B,EAChD,C,CAMKpF,UAAUpC,GAEhB,GAAqB,IAAjBA,EAAMU,OACR,OAIF,GAAKV,EAAMY,OAAuBjP,UAAUb,SAAS,iBAGnD,OAFA9G,KAAKwb,UAAUlX,MAAQ,QACvBtE,KAAK6b,UAKP,IAAI3Z,EAAQoN,WAASqH,eAAe3W,KAAKyb,YAAYlU,UAAUpC,GACtDA,EAAK2B,SAASkP,EAAMY,WAId,IAAX1U,IAKJ8T,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK0d,SAASxb,G,CAMRkU,YAAYJ,GAClB,KAAIA,EAAM2H,QAAU3H,EAAM4H,SAAW5H,EAAM6H,SAAW7H,EAAM8H,UAG5D,OAAQ9H,EAAMS,SACZ,KAAK,GACHT,EAAMK,iBACNL,EAAMM,kBACNtW,KAAK0d,SAAS1d,KAAKgb,cACnB,MACF,KAAK,GACHhF,EAAMK,iBACNL,EAAMM,kBACNtW,KAAK+d,wBACL,MACF,KAAK,GACH/H,EAAMK,iBACNL,EAAMM,kBACNtW,KAAKge,oB,CAQHA,oBAEN,IAAKhe,KAAKib,UAAqC,IAAzBjb,KAAKib,SAASla,OAClC,OAIF,IAAIkd,EAAKje,KAAKgb,aACV1Y,EAAItC,KAAKib,SAASla,OAClBmd,EAAQD,EAAK3b,EAAI,EAAI2b,EAAK,EAAI,EAC9BE,EAAiB,IAAVD,EAAc5b,EAAI,EAAI4b,EAAQ,EACzCle,KAAKgb,aAAe1L,WAASqH,eAC3B3W,KAAKib,SACLxa,EAAQic,YACRwB,EACAC,GAIFne,KAAKkI,Q,CAMC6V,wBAEN,IAAK/d,KAAKib,UAAqC,IAAzBjb,KAAKib,SAASla,OAClC,OAIF,IAAIkd,EAAKje,KAAKgb,aACV1Y,EAAItC,KAAKib,SAASla,OAClBmd,EAAQD,GAAM,EAAI3b,EAAI,EAAI2b,EAAK,EAC/BE,EAAOD,IAAU5b,EAAI,EAAI,EAAI4b,EAAQ,EACzCle,KAAKgb,aAAe1L,WAAS8O,cAC3Bpe,KAAKib,SACLxa,EAAQic,YACRwB,EACAC,GAIFne,KAAKkI,Q,CAMCwV,SAASxb,GAEf,IAAKlC,KAAKib,SACR,OAIF,IAAIoD,EAAOre,KAAKib,SAAS/Y,GACzB,GAAKmc,EAAL,CAKA,GAAkB,WAAdA,EAAK/U,KAAmB,CAC1B,IAAI+S,EAAQrc,KAAKwb,UAIjB,OAHAa,EAAM/X,MAAQ,GAAG+Z,EAAKlB,SAASmB,iBAC/BjC,EAAMzC,aACN5Z,KAAK6b,SAEN,CAGIwC,EAAKlN,KAAKoN,YAKfve,KAAKkb,SAASsD,QAAQH,EAAKlN,KAAKsN,QAASJ,EAAKlN,KAAKuN,MAGnD1e,KAAKwb,UAAUlX,MAAQ,GAGvBtE,KAAK6b,UAvBJ,C,CA6BKO,iBACN,IAAIuC,EAAUzS,SAAS0S,gBAAkB5e,KAAKwb,UAC9Cxb,KAAK+H,YAAY,iBAAkB4W,E,CAM7BvD,mBACNpb,KAAK6b,S,GAWT,SAAiBd,GAiOf,MAAavD,EAQX4F,aAAa9H,GACX,IAAIuH,EAAU7c,KAAK6e,aAAavJ,GAChC,OAAOwJ,IAAEC,GAAG,CAAE9a,UAAW,4BAA8B4Y,E,CAUzDS,WAAWhI,GACT,IAAIrR,EAAYjE,KAAKgf,gBAAgB1J,GACjClR,EAAUpE,KAAKif,kBAAkB3J,GACrC,OAAIA,EAAKnE,KAAK+N,aACLJ,IAAEC,GACP,CACE9a,YACAG,UACA+a,KAAM,mBACN,eAAgB,GAAG7J,EAAKnE,KAAKiO,aAE/Bpf,KAAKqf,eAAe/J,GACpBtV,KAAKsf,kBAAkBhK,GACvBtV,KAAKuf,mBAAmBjK,IAGrBwJ,IAAEC,GACP,CACE9a,YACAG,UACA+a,KAAM,YAERnf,KAAKqf,eAAe/J,GACpBtV,KAAKsf,kBAAkBhK,GACvBtV,KAAKuf,mBAAmBjK,G,CAW5BwH,mBAAmBxH,GACjB,IAAIuH,EAAU7c,KAAKwf,mBAAmBlK,GACtC,OAAOwJ,IAAEC,GAAG,CAAE9a,UAAW,kCAAoC4Y,E,CAU/DwC,eAAe/J,GACb,IAAIrR,EAAYjE,KAAKyf,gBAAgBnK,GAGrC,OAAOwJ,IAAEY,IAAI,CAAEzb,aAAaqR,EAAKnE,KAAKtN,KAAOyR,EAAKnE,KAAKpN,U,CAUzDub,kBAAkBhK,GAChB,OAAOwJ,IAAEY,IACP,CAAEzb,UAAW,iCACbjE,KAAK2f,gBAAgBrK,GACrBtV,KAAK4f,kBAAkBtK,G,CAW3BqK,gBAAgBrK,GACd,IAAIuH,EAAU7c,KAAK6f,gBAAgBvK,GACnC,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,+BAAiC4Y,E,CAU7D+C,kBAAkBtK,GAChB,IAAIuH,EAAU7c,KAAK8f,kBAAkBxK,GACrC,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,iCAAmC4Y,E,CAU/D0C,mBAAmBjK,GACjB,IAAIuH,EAAU7c,KAAK+f,mBAAmBzK,GACtC,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,kCAAoC4Y,E,CAUhEmC,gBAAgB1J,GAEd,IAAI5N,EAAO,yBAGN4N,EAAKnE,KAAKoN,YACb7W,GAAQ,oBAEN4N,EAAKnE,KAAKiO,YACZ1X,GAAQ,mBAEN4N,EAAK+H,SACP3V,GAAQ,kBAIV,IAAIiM,EAAQ2B,EAAKnE,KAAKlN,UAMtB,OALI0P,IACFjM,GAAQ,IAAIiM,KAIPjM,C,CAUTuX,kBAAkB3J,GAChB,MAAO,IAAKA,EAAKnE,KAAK/M,QAASqa,QAASnJ,EAAKnE,KAAKsN,Q,CAUpDgB,gBAAgBnK,GACd,IAAI5N,EAAO,6BACPiM,EAAQ2B,EAAKnE,KAAKrN,UACtB,OAAO6P,EAAQ,GAAGjM,KAAQiM,IAAUjM,C,CAUtCmX,aAAavJ,GACX,OAAKA,EAAK4H,SAAmC,IAAxB5H,EAAK4H,QAAQnc,OAG3Bif,YAAUC,UAAU3K,EAAK6H,SAAU7H,EAAK4H,QAAS4B,IAAEoB,MAFjD5K,EAAK6H,Q,CAYhBqC,mBAAmBlK,GACjB,MAAO,iCAAiCA,EAAKiH,Q,CAU/CwD,mBAAmBzK,GACjB,IAAI6K,EAAK7K,EAAKnE,KAAKiP,WACnB,OAAOD,EAAKE,kBAAgBC,gBAAgBH,EAAGI,MAAQ,I,CAUzDV,gBAAgBvK,GACd,OAAKA,EAAK4H,SAAmC,IAAxB5H,EAAK4H,QAAQnc,OAG3Bif,YAAUC,UAAU3K,EAAKnE,KAAKxN,MAAO2R,EAAK4H,QAAS4B,IAAEoB,MAFnD5K,EAAKnE,KAAKxN,K,CAYrBmc,kBAAkBxK,GAChB,OAAOA,EAAKnE,KAAKnN,O,EAhPR+W,EAAAvD,SAAQA,EAuPRuD,EAAAtD,gBAAkB,IAAID,CACpC,CAzdD,CAAiBuD,MAydhB,KAKD,SAAUta,GAuNR,SAAS+f,EACPrP,EACAoL,GAGA,IAAIY,EAAWhM,EAAKgM,SAASmB,cAEzBmC,EAAS,GAAGtD,KADJhM,EAAKxN,MAAM2a,gBAInBoC,EAAQtgB,IACR8c,EAA2B,KAG3ByD,EAAM,QAIV,OAAa,CAEX,IAAIC,EAAWD,EAAIE,KAAKJ,GAGxB,IAAKG,EACH,MAIF,IAAIpH,EAAQwG,YAAUc,iBAAiBL,EAAQlE,EAAOqE,EAAS1e,OAG/D,IAAKsX,EACH,MAIEA,EAAMkH,OAASA,IACjBA,EAAQlH,EAAMkH,MACdxD,EAAU1D,EAAM0D,QAEnB,CAGD,IAAKA,GAAWwD,IAAUtgB,IACxB,OAAO,KAIT,IAAI2gB,EAAQ5D,EAASpc,OAAS,EAG1BsO,EAAIC,WAAS0R,WAAW9D,EAAS6D,GAAO,CAACzM,EAAGC,IAAMD,EAAIC,IAGtD0M,EAAkB/D,EAAQtL,MAAM,EAAGvC,GACnC6R,EAAehE,EAAQtL,MAAMvC,GAGjC,IAAK,IAAIhO,EAAI,EAAGiB,EAAI4e,EAAangB,OAAQM,EAAIiB,IAAKjB,EAChD6f,EAAa7f,IAAM0f,EAIrB,OAA+B,IAA3BE,EAAgBlgB,OACX,CACLogB,UAA0B,EAC1BF,gBAAiB,KACjBC,eACAR,QACAvP,QAKwB,IAAxB+P,EAAangB,OACR,CACLogB,UAA6B,EAC7BF,kBACAC,aAAc,KACdR,QACAvP,QAKG,CACLgQ,UAA0B,EAC1BF,kBACAC,eACAR,QACAvP,O,CAOJ,SAASiQ,EAAS9M,EAAWC,GAE3B,IAAI8M,EAAK/M,EAAE6M,UAAY5M,EAAE4M,UACzB,GAAW,IAAPE,EACF,OAAOA,EAIT,IAAIC,EAAKhN,EAAEoM,MAAQnM,EAAEmM,MACrB,GAAW,IAAPY,EACF,OAAOA,EAIT,IAAIC,EAAK,EACLC,EAAK,EACT,OAAQlN,EAAE6M,WACR,OACEI,EAAKjN,EAAE4M,aAAc,GACrBM,EAAKjN,EAAE2M,aAAc,GACrB,MACF,KAAwB,EACxB,OACEK,EAAKjN,EAAE2M,gBAAiB,GACxBO,EAAKjN,EAAE0M,gBAAiB,GAK5B,GAAIM,IAAOC,EACT,OAAOD,EAAKC,EAId,IAAIC,EAAKnN,EAAEnD,KAAKgM,SAASuE,cAAcnN,EAAEpD,KAAKgM,UAC9C,GAAW,IAAPsE,EACF,OAAOA,EAIT,IAAIE,EAAKrN,EAAEnD,KAAKyQ,KACZC,EAAKtN,EAAEpD,KAAKyQ,KAChB,OAAID,IAAOE,EACFF,EAAKE,GAAM,EAAI,EAIjBvN,EAAEnD,KAAKxN,MAAM+d,cAAcnN,EAAEpD,KAAKxN,M,CAnW3BlD,EAAA2E,WAAhB,WACE,IAAID,EAAO+G,SAASC,cAAc,OAC9BsQ,EAASvQ,SAASC,cAAc,OAChC2V,EAAU5V,SAASC,cAAc,OACjCkQ,EAAQnQ,SAASC,cAAc,SAC/B0Q,EAAU3Q,SAASC,cAAc,MACjC4V,EAAQ7V,SAASC,cAAc,UAcnC,OAbAsQ,EAAOxY,UAAY,2BACnB6d,EAAQ7d,UAAY,4BACpBoY,EAAMpY,UAAY,0BAClB8d,EAAM9d,UAAY,gBAElB4Y,EAAQ5Y,UAAY,4BACpB4Y,EAAQpS,aAAa,OAAQ,QAC7B4R,EAAM2F,YAAa,EACnBF,EAAQvP,YAAY8J,GACpByF,EAAQvP,YAAYwP,GACpBtF,EAAOlK,YAAYuP,GACnB3c,EAAKoN,YAAYkK,GACjBtX,EAAKoN,YAAYsK,GACV1X,C,EAMO1E,EAAAmb,WAAhB,SACEV,EACArY,GAEA,OAAO,IAAIof,EAAY/G,EAAUrY,E,EAmDnBpC,EAAAgc,OAAhB,SACEf,EACAa,GAGA,IAAI2F,EAyEN,SAAoBxG,EAA+Ba,GA/C3B4F,EAiDC5F,EAAvBA,EAhDO4F,EAAKC,QAAQ,OAAQ,IAAI9D,cADlC,IAAwB6D,EAoDtB,IAAID,EAAmB,GAGvB,IAAK,IAAI7gB,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EAAG,CAE5C,IAAI8P,EAAOuK,EAAMra,GACjB,IAAK8P,EAAK/K,UACR,SAIF,IAAKmW,EAAO,CACV2F,EAAOrQ,KAAK,CACVsP,UAA4B,EAC5BF,gBAAiB,KACjBC,aAAc,KACdR,MAAO,EACPvP,SAEF,QACD,CAGD,IAAIuP,EAAQF,EAAYrP,EAAMoL,GAGzBmE,IAMAvP,EAAKoN,YACRmC,EAAMA,OAAS,KAIjBwB,EAAOrQ,KAAK6O,GACb,CAGD,OAAOwB,C,CAvHMG,CAAW3G,EAAOa,GAM/B,OAHA2F,EAAOI,KAAKlB,GAgRd,SAAuBc,GAErB,IAAIK,EAAU,IAAIvF,MAAMkF,EAAOnhB,QAC/BuO,WAASkT,KAAKD,GAAS,GAGvB,IAAI/F,EAA0B,GAG9B,IAAK,IAAInb,EAAI,EAAGiB,EAAI4f,EAAOnhB,OAAQM,EAAIiB,IAAKjB,EAAG,CAE7C,GAAIkhB,EAAQlhB,GACV,SAIF,IAAI8P,KAAEA,EAAI8P,gBAAEA,GAAoBiB,EAAO7gB,GAGnC8b,EAAWhM,EAAKgM,SAGpBX,EAAQ3K,KAAK,CAAEvI,KAAM,SAAU6T,WAAUD,QAAS+D,IAGlD,IAAK,IAAI5R,EAAIhO,EAAGgO,EAAI/M,IAAK+M,EAAG,CAE1B,GAAIkT,EAAQlT,GACV,SAIF,IAAI8B,KAAEA,EAAI+P,aAAEA,GAAiBgB,EAAO7S,GAGhC8B,EAAKgM,WAAaA,IAKtBX,EAAQ3K,KAAK,CAAEvI,KAAM,OAAQ6H,OAAM+L,QAASgE,IAG5CqB,EAAQlT,IAAK,EACd,CACF,CAGD,OAAOmN,C,CA7TAiG,CAAcP,E,EAMPzhB,EAAAic,YAAhB,SAA4BO,GAC1B,MAAuB,SAAhBA,EAAO3T,MAAmB2T,EAAO9L,KAAKoN,S,EA4T/C,MAAM0D,EAIJliB,YACEmb,EACArY,GAEA7C,KAAK0iB,UAAYxH,EACjBlb,KAAKmd,SAA6Bta,EAAQsa,SA9T5BwF,OAAOP,QAAQ,OAAQ,KA+TrCpiB,KAAKye,QAAU5b,EAAQ4b,QACvBze,KAAK0e,KAAO7b,EAAQ6b,MAAQkE,UAAQC,YACpC7iB,KAAK4hB,UAAwB1e,IAAjBL,EAAQ+e,KAAqB/e,EAAQ+e,KAAOxhB,G,CA0BtDuD,YACF,OAAO3D,KAAK0iB,UAAU/e,MAAM3D,KAAKye,QAASze,KAAK0e,K,CAM7C7a,WACF,OAAO7D,KAAK0iB,UAAU7e,KAAK7D,KAAKye,QAASze,KAAK0e,K,CAM5C5a,gBACF,OAAO9D,KAAK0iB,UAAU5e,UAAU9D,KAAKye,QAASze,KAAK0e,K,CAMjD3a,gBACF,OAAO/D,KAAK0iB,UAAU3e,UAAU/D,KAAKye,QAASze,KAAK0e,K,CAMjD1a,cACF,OAAOhE,KAAK0iB,UAAU1e,QAAQhE,KAAKye,QAASze,KAAK0e,K,CAM/Cza,gBACF,OAAOjE,KAAK0iB,UAAUze,UAAUjE,KAAKye,QAASze,KAAK0e,K,CAMjDta,cACF,OAAOpE,KAAK0iB,UAAUte,QAAQpE,KAAKye,QAASze,KAAK0e,K,CAM/CH,gBACF,OAAOve,KAAK0iB,UAAUnE,UAAUve,KAAKye,QAASze,KAAK0e,K,CAMjDU,gBACF,OAAOpf,KAAK0iB,UAAUtD,UAAUpf,KAAKye,QAASze,KAAK0e,K,CAMjDQ,mBACF,OAAOlf,KAAK0iB,UAAUxD,aAAalf,KAAKye,QAASze,KAAK0e,K,CAMpDtY,gBACF,OAAOpG,KAAK0iB,UAAUtc,UAAUpG,KAAKye,QAASze,KAAK0e,K,CAMjD0B,iBACF,IAAI3B,QAAEA,EAAOC,KAAEA,GAAS1e,KACxB,OACEsP,WAASwT,cAAc9iB,KAAK0iB,UAAUK,aAAa5C,GAC1CA,EAAG1B,UAAYA,GAAWmE,UAAQI,UAAU7C,EAAGzB,KAAMA,MACxD,I,EAMb,CAjiBD,CAAUje,MAiiBT,KCv+CK,MAAOwiB,UAAate,EAMxB5E,YAAY8C,GACVwI,MAAM,CAAElG,KAAM1E,EAAQ2E,eAk3BhBpF,KAAWkjB,aAAI,EACfljB,KAAYgb,cAAI,EAChBhb,KAAYmjB,aAAG,EACfnjB,KAAaojB,cAAG,EAChBpjB,KAAM0Q,OAAiB,GACvB1Q,KAAUqjB,WAAgB,KAC1BrjB,KAAWsjB,YAAgB,KAC3BtjB,KAAAujB,cAAgB,IAAI/f,SAAmBxD,MACvCA,KAAAwjB,eAAiB,IAAIhgB,SAAkCxD,MAz3B7DA,KAAKqF,SAAS,WACdrF,KAAKsF,QAAQX,EAAOY,KAAK+B,gBACzBtH,KAAKkb,SAAWrY,EAAQqY,SACxBlb,KAAK+Q,SAAWlO,EAAQkO,UAAYkS,EAAKxL,e,CAM3ChT,UACEzE,KAAKyI,QACLzI,KAAK0Q,OAAO3P,OAAS,EACrBsK,MAAM5G,S,CAaJgf,mBACF,OAAOzjB,KAAKujB,a,CAeVG,oBACF,OAAO1jB,KAAKwjB,c,CAmBVG,iBACF,OAAO3jB,KAAKsjB,W,CASVM,gBACF,OAAO5jB,KAAKqjB,U,CAMVQ,eAEF,IAAIC,EAAa9jB,KACjB,KAAO8jB,EAAKR,aACVQ,EAAOA,EAAKR,YAEd,OAAOQ,C,CAMLC,eAEF,IAAID,EAAa9jB,KACjB,KAAO8jB,EAAKT,YACVS,EAAOA,EAAKT,WAEd,OAAOS,C,CAWLrI,kBACF,OAAOzb,KAAKmF,KAAKoW,uBACf,mBACA,E,CAMAyI,iBACF,OAAOhkB,KAAK0Q,OAAO1Q,KAAKgb,eAAiB,I,CASvCgJ,eAAW1f,GACbtE,KAAK+c,YAAczY,EAAQtE,KAAK0Q,OAAOtB,QAAQ9K,IAAU,C,CASvDyY,kBACF,OAAO/c,KAAKgb,Y,CASV+B,gBAAYzY,IAEVA,EAAQ,GAAKA,GAAStE,KAAK0Q,OAAO3P,UACpCuD,GAAS,IAII,IAAXA,GAAiB7D,EAAQic,YAAY1c,KAAK0Q,OAAOpM,MACnDA,GAAS,GAIPtE,KAAKgb,eAAiB1W,IAK1BtE,KAAKgb,aAAe1W,EAIlBtE,KAAKgb,cAAgB,GACrBhb,KAAKyb,YAAYwI,WAAWjkB,KAAKgb,eAEhChb,KAAKyb,YAAYwI,WAAWjkB,KAAKgb,cAA8BpB,QAIlE5Z,KAAKkI,S,CAMHwT,YACF,OAAO1b,KAAK0Q,M,CASdwT,mBACE,IAAI5hB,EAAItC,KAAK0Q,OAAO3P,OAChBkd,EAAKje,KAAKgb,aACVkD,EAAQD,EAAK3b,EAAI,EAAI2b,EAAK,EAAI,EAC9BE,EAAiB,IAAVD,EAAc5b,EAAI,EAAI4b,EAAQ,EACzCle,KAAK+c,YAAczN,WAASqH,eAC1B3W,KAAK0Q,OACLjQ,EAAQic,YACRwB,EACAC,E,CAUJgG,uBACE,IAAI7hB,EAAItC,KAAK0Q,OAAO3P,OAChBkd,EAAKje,KAAKgb,aACVkD,EAAQD,GAAM,EAAI3b,EAAI,EAAI2b,EAAK,EAC/BE,EAAOD,IAAU5b,EAAI,EAAI,EAAI4b,EAAQ,EACzCle,KAAK+c,YAAczN,WAAS8O,cAC1Bpe,KAAK0Q,OACLjQ,EAAQic,YACRwB,EACAC,E,CAiBJiG,oBAEE,IAAKpkB,KAAK0F,WACR,OAIF,IAAIyL,EAAOnR,KAAKgkB,WAChB,IAAK7S,EACH,OAQF,GAJAnR,KAAKqkB,mBACLrkB,KAAKskB,oBAGa,YAAdnT,EAAK7H,KAEP,YADAtJ,KAAKukB,gBAAe,GAKtBvkB,KAAK6jB,SAASpb,QAGd,IAAIgW,QAAEA,EAAOC,KAAEA,GAASvN,EACpBnR,KAAKkb,SAASqD,UAAUE,EAASC,GACnC1e,KAAKkb,SAASsD,QAAQC,EAASC,GAE/B8F,QAAQC,IAAI,YAAYhG,kB,CAW5B9C,QAAQ9Y,GACN,OAAO7C,KAAK0kB,WAAW1kB,KAAK0Q,OAAO3P,OAAQ8B,E,CAe7C6hB,WAAWxiB,EAAeW,GAEpB7C,KAAK0F,YACP1F,KAAKyI,QAIPzI,KAAK+c,aAAe,EAGpB,IAAI1b,EAAIK,KAAKF,IAAI,EAAGE,KAAKH,IAAIW,EAAOlC,KAAK0Q,OAAO3P,SAG5CoQ,EAAO1Q,EAAQmb,WAAW5b,KAAM6C,GASpC,OANAyM,WAASC,OAAOvP,KAAK0Q,OAAQrP,EAAG8P,GAGhCnR,KAAKkI,SAGEiJ,C,CAWT6K,WAAW7K,GACTnR,KAAKic,aAAajc,KAAK0Q,OAAOtB,QAAQ+B,G,CAWxC8K,aAAa/Z,GAEPlC,KAAK0F,YACP1F,KAAKyI,QAIPzI,KAAK+c,aAAe,EAGTzN,WAASM,SAAS5P,KAAK0Q,OAAQxO,IAQ1ClC,KAAKkI,Q,CAMPgU,aAEMlc,KAAK0F,YACP1F,KAAKyI,QAIPzI,KAAK+c,aAAe,EAGO,IAAvB/c,KAAK0Q,OAAO3P,SAKhBf,KAAK0Q,OAAO3P,OAAS,EAGrBf,KAAKkI,S,CAmBPyc,KAAKC,EAAWC,EAAWhiB,EAA6B,IAEtD,GAAI7C,KAAK0F,WACP,OAIF,IAAIof,EAASjiB,EAAQiiB,SAAU,EAC3BC,EAASliB,EAAQkiB,SAAU,EAG/BtkB,EAAQukB,aAAahlB,KAAM4kB,EAAGC,EAAGC,EAAQC,GAGzC/kB,KAAKuI,U,CAaPwN,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,UACHtJ,KAAKoW,YAAYJ,GACjB,MACF,IAAK,UACHhW,KAAKilB,YAAYjP,GACjB,MACF,IAAK,YACHhW,KAAKklB,cAAclP,GACnB,MACF,IAAK,aACHhW,KAAKmlB,eAAenP,GACpB,MACF,IAAK,aACHhW,KAAKolB,eAAepP,GACpB,MACF,IAAK,YACHhW,KAAKqlB,cAAcrP,GACnB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCA,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCA,KAAKmF,KAAKoR,iBAAiB,YAAavW,MACxCA,KAAKmF,KAAKoR,iBAAiB,aAAcvW,MACzCA,KAAKmF,KAAKoR,iBAAiB,aAAcvW,MACzCA,KAAKmF,KAAKoR,iBAAiB,cAAevW,MAC1CkM,SAASqK,iBAAiB,YAAavW,MAAM,E,CAMrCkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAKmF,KAAKqR,oBAAoB,YAAaxW,MAC3CA,KAAKmF,KAAKqR,oBAAoB,aAAcxW,MAC5CA,KAAKmF,KAAKqR,oBAAoB,aAAcxW,MAC5CA,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CkM,SAASsK,oBAAoB,YAAaxW,MAAM,E,CAMxCmK,kBAAkBnD,GACtBhH,KAAK0F,YACP1F,KAAKmF,KAAKyU,O,CAOJnQ,gBAAgBzC,GACxB,IAAI0U,EAAQ1b,KAAK0Q,OACbK,EAAW/Q,KAAK+Q,SAChBgM,EAAc/c,KAAKgb,aACnBsK,EAAiB7kB,EAAQ8kB,iBAAiB7J,GAC1CmB,EAAU,IAAIG,MAAsBtB,EAAM3a,QAC9C,IAAK,IAAIM,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EAAG,CAC5C,IAAI8P,EAAOuK,EAAMra,GACbgc,EAAShc,IAAM0b,EACfyI,EAAYF,EAAejkB,GAC/Bwb,EAAQxb,GAAK0P,EAASuM,WAAW,CAC/BnM,OACAkM,SACAmI,YACAC,QAAS,KACPzlB,KAAK+c,YAAc1b,CAAC,GAGzB,CACDsb,aAAWC,OAAOC,EAAS7c,KAAKyb,Y,CAMxBrR,eAAepD,GAEvBhH,KAAKqkB,mBACLrkB,KAAKskB,oBAGLtkB,KAAK+c,aAAe,EAGpB,IAAI6G,EAAY5jB,KAAKqjB,WACjBO,IACF5jB,KAAKkjB,aAAe,EACpBljB,KAAKqjB,WAAa,KAClBO,EAAUN,YAAc,KACxBM,EAAUnb,SAIZ,IAAIkb,EAAa3jB,KAAKsjB,YAClBK,IACF3jB,KAAKsjB,YAAc,KACnBK,EAAWT,aAAe,EAC1BS,EAAWN,WAAa,KACxBM,EAAWpb,YAITvI,KAAK0F,YACP1F,KAAKujB,cAAchf,UAAKrB,GAI1BmI,MAAMjB,eAAepD,E,CASfoP,YAAYJ,GAElBA,EAAMK,iBACNL,EAAMM,kBAGN,IAAIoP,EAAK1P,EAAMS,QAGf,GAAW,KAAPiP,EAEF,YADA1lB,KAAKokB,oBAKP,GAAW,KAAPsB,EAEF,YADA1lB,KAAKyI,QAKP,GAAW,KAAPid,EAMF,YALI1lB,KAAKsjB,YACPtjB,KAAKyI,QAELzI,KAAKwjB,eAAejf,KAAK,aAM7B,GAAW,KAAPmhB,EAEF,YADA1lB,KAAKmkB,uBAKP,GAAW,KAAPuB,EAAW,CACb,IAAIvU,EAAOnR,KAAKgkB,WAMhB,YALI7S,GAAsB,YAAdA,EAAK7H,KACftJ,KAAKokB,oBAELpkB,KAAK6jB,SAASL,eAAejf,KAAK,QAGrC,CAGD,GAAW,KAAPmhB,EAEF,YADA1lB,KAAKkkB,mBAKP,IAAI3K,EAAMoM,sBAAoBC,mBAAmB5P,GAGjD,IAAKuD,EACH,OAIF,IAAI2E,EAAQle,KAAKgb,aAAe,EAC5BiC,EAASxc,EAAQolB,aAAa7lB,KAAK0Q,OAAQ6I,EAAK2E,IAM9B,IAAlBjB,EAAO/a,OAAiB+a,EAAO6I,UAGN,IAAlB7I,EAAO/a,MAChBlC,KAAK+c,YAAcE,EAAO/a,OACA,IAAjB+a,EAAO8I,OAChB/lB,KAAK+c,YAAcE,EAAO8I,OAL1B/lB,KAAK+c,YAAcE,EAAO/a,MAC1BlC,KAAKokB,oB,CAcDa,YAAYjP,GACG,IAAjBA,EAAMU,SAGVV,EAAMK,iBACNL,EAAMM,kBACNtW,KAAKokB,oB,CASCc,cAAclP,GAEpB,IAAI9T,EAAQoN,WAASqH,eAAe3W,KAAKyb,YAAYlU,UAAUpC,GACtDmJ,aAAW0X,QAAQ7gB,EAAM6Q,EAAMe,QAASf,EAAMgB,WAIvD,GAAI9U,IAAUlC,KAAKgb,aACjB,OAQF,GAJAhb,KAAK+c,YAAc7a,EACnBA,EAAQlC,KAAK+c,YAGT7a,IAAUlC,KAAKkjB,YAGjB,OAFAljB,KAAKqkB,wBACLrkB,KAAKskB,qBAKmB,IAAtBtkB,KAAKkjB,aACPljB,KAAKimB,mBAIPjmB,KAAKqkB,mBAGL,IAAIlT,EAAOnR,KAAKgkB,WACX7S,GAAsB,YAAdA,EAAK7H,MAAuB6H,EAAK+U,SAK9ClmB,KAAKmmB,iB,CASChB,eAAenP,GAErB,IAAK,IAAI8N,EAAO9jB,KAAKsjB,YAAaQ,EAAMA,EAAOA,EAAKR,YAClDQ,EAAKO,mBACLP,EAAKQ,oBACLR,EAAK/G,YAAc+G,EAAKZ,W,CAUpBkC,eAAepP,GAKrB,GAHAhW,KAAKqkB,oBAGArkB,KAAKqjB,WAER,YADArjB,KAAK+c,aAAe,GAKtB,IAAIhG,QAAEA,EAAOC,QAAEA,GAAYhB,EACvB1H,aAAW0X,QAAQhmB,KAAKqjB,WAAWle,KAAM4R,EAASC,GACpDhX,KAAKskB,qBAKPtkB,KAAK+c,aAAe,EACpB/c,KAAKimB,mB,CASCZ,cAAcrP,GAEhBhW,KAAKsjB,cAQL7iB,EAAQ2lB,aAAapmB,KAAMgW,EAAMe,QAASf,EAAMgB,UAClDhB,EAAMK,iBACNL,EAAMM,mBAENtW,KAAKyI,Q,CAUD8b,eAAe8B,GAAgB,GAErC,IAAIlV,EAAOnR,KAAKgkB,WAChB,IAAK7S,GAAsB,YAAdA,EAAK7H,OAAuB6H,EAAK+U,QAE5C,YADAlmB,KAAKsmB,kBAKP,IAAIJ,EAAU/U,EAAK+U,QACnB,GAAIA,IAAYlmB,KAAKqjB,WACnB,OAIFJ,EAAKsD,iBAGLvmB,KAAKsmB,kBAGLtmB,KAAKqjB,WAAa6C,EAClBlmB,KAAKkjB,YAAcljB,KAAKgb,aAGxBkL,EAAQ5C,YAActjB,KAGtB6F,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIiB,eACzC,IAAIoe,EAAWxmB,KAAKyb,YAAYlU,SAASvH,KAAKgb,cAG9Cva,EAAQgmB,YAAYP,EAASM,GAGzBH,IACFH,EAAQnJ,aAAe,EACvBmJ,EAAQhC,oBAIVgC,EAAQ3d,U,CAQF+d,kBACFtmB,KAAKqjB,YACPrjB,KAAKqjB,WAAW5a,O,CAOZ0d,kBACoB,IAAtBnmB,KAAKmjB,eACPnjB,KAAKmjB,aAAelM,OAAOyP,YAAW,KACpC1mB,KAAKmjB,aAAe,EACpBnjB,KAAKukB,gBAAgB,GACpB9jB,EAAQkmB,a,CAOPV,mBACqB,IAAvBjmB,KAAKojB,gBACPpjB,KAAKojB,cAAgBnM,OAAOyP,YAAW,KACrC1mB,KAAKojB,cAAgB,EACrBpjB,KAAKsmB,iBAAiB,GACrB7lB,EAAQkmB,a,CAOPtC,mBACoB,IAAtBrkB,KAAKmjB,eACPyD,aAAa5mB,KAAKmjB,cAClBnjB,KAAKmjB,aAAe,E,CAOhBmB,oBACqB,IAAvBtkB,KAAKojB,gBACPwD,aAAa5mB,KAAKojB,eAClBpjB,KAAKojB,cAAgB,E,CAazByD,wBACEpmB,EAAQ8lB,gB,GAiBZ,SAAiBtD,GAsNf,MAAazL,EAQX8F,WAAWhI,GACT,IAAIrR,EAAYjE,KAAKgf,gBAAgB1J,GACjClR,EAAUpE,KAAKif,kBAAkB3J,GACjCwR,EAAO9mB,KAAK+mB,eAAezR,GAC/B,OAAOwJ,IAAEC,GACP,CACE9a,YACAG,UACA4iB,SAAU,IACVvB,QAASnQ,EAAKmQ,WACXqB,GAEL9mB,KAAKinB,WAAW3R,GAChBtV,KAAKknB,YAAY5R,GACjBtV,KAAKmnB,eAAe7R,GACpBtV,KAAKonB,cAAc9R,G,CAWvB2R,WAAW3R,GACT,IAAIrR,EAAYjE,KAAKyf,gBAAgBnK,GAGrC,OAAOwJ,IAAEY,IAAI,CAAEzb,aAAaqR,EAAKnE,KAAKtN,KAAOyR,EAAKnE,KAAKpN,U,CAUzDmjB,YAAY5R,GACV,IAAIuH,EAAU7c,KAAKqnB,YAAY/R,GAC/B,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,qBAAuB4Y,E,CAUnDsK,eAAe7R,GACb,IAAIuH,EAAU7c,KAAKsnB,eAAehS,GAClC,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,wBAA0B4Y,E,CAUtDuK,cAAc9R,GACZ,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,2B,CAU5B+a,gBAAgB1J,GAEd,IAAI5N,EAAO,eAGN4N,EAAKnE,KAAKoN,YACb7W,GAAQ,oBAEN4N,EAAKnE,KAAKiO,YACZ1X,GAAQ,mBAEL4N,EAAKnE,KAAK/K,YACbsB,GAAQ,kBAEN4N,EAAK+H,SACP3V,GAAQ,kBAEN4N,EAAKkQ,YACP9d,GAAQ,qBAIV,IAAIiM,EAAQ2B,EAAKnE,KAAKlN,UAMtB,OALI0P,IACFjM,GAAQ,IAAIiM,KAIPjM,C,CAUTuX,kBAAkB3J,GAChB,IAAI2H,GACA3T,KAAEA,EAAImV,QAAEA,EAAOra,QAAEA,GAAYkR,EAAKnE,KAMtC,OAJE8L,EADW,YAAT3T,EACO,IAAKlF,EAASkF,OAAMmV,WAEpB,IAAKra,EAASkF,QAElB2T,C,CAUTwC,gBAAgBnK,GACd,IAAI5N,EAAO,mBACPiM,EAAQ2B,EAAKnE,KAAKrN,UACtB,OAAO6P,EAAQ,GAAGjM,KAAQiM,IAAUjM,C,CAUtCqf,eAAezR,GACb,IAAIwR,EAA0C,GAC9C,OAAQxR,EAAKnE,KAAK7H,MAChB,IAAK,YACHwd,EAAK3H,KAAO,eACZ,MACF,IAAK,UACH2H,EAAK,iBAAmB,OACnBxR,EAAKnE,KAAKoN,YACbuI,EAAK,iBAAmB,QAE1B,MACF,QACOxR,EAAKnE,KAAKoN,YACbuI,EAAK,iBAAmB,QAE1BA,EAAK3H,KAAO,WAEhB,OAAO2H,C,CAUTO,YAAY/R,GAEV,IAAI3R,MAAEA,EAAKC,SAAEA,GAAa0R,EAAKnE,KAG/B,GAAIvN,EAAW,GAAKA,GAAYD,EAAM5C,OACpC,OAAO4C,EAIT,IAAI4jB,EAAS5jB,EAAMiO,MAAM,EAAGhO,GACxB4jB,EAAS7jB,EAAMiO,MAAMhO,EAAW,GAChC6jB,EAAO9jB,EAAMC,GAMjB,MAAO,CAAC2jB,EAHGzI,IAAE4I,KAAK,CAAEzjB,UAAW,wBAA0BwjB,GAGnCD,E,CAUxBF,eAAehS,GACb,IAAI6K,EAAK7K,EAAKnE,KAAKiP,WACnB,OAAOD,EAAKE,kBAAgBC,gBAAgBH,EAAGI,MAAQ,I,EAlN9C0C,EAAAzL,SAAQA,EAyNRyL,EAAAxL,gBAAkB,IAAID,CACpC,CAhbD,CAAiByL,MAgbhB,KAKD,SAAUxiB,GAIKA,EAAWkmB,YAAG,IAKdlmB,EAAeknB,gBAAG,EAE/B,IAAIC,EAA+C,KAC/CC,EAAgC,EAEpC,SAASC,IAEP,OAAID,EAAwB,GAC1BA,IACOD,GAEFG,G,CAiCT,SAAgBrL,EAAYvL,GAC1B,MAAqB,cAAdA,EAAK7H,MAAwB6H,EAAKoN,WAAapN,EAAK/K,S,CAkF7D,SAAS2hB,IACP,MAAO,CACLC,YAAa/Q,OAAO+Q,YACpBC,YAAahR,OAAOgR,YACpBC,YAAahc,SAASic,gBAAgBD,YACtCE,aAAclc,SAASic,gBAAgBC,a,CA7G3B3nB,EAAA8lB,eAAhB,WACEqB,EAA2BG,IAC3BF,G,EAMcpnB,EAAA2E,WAAhB,WACE,IAAID,EAAO+G,SAASC,cAAc,OAC9B0Q,EAAU3Q,SAASC,cAAc,MAKrC,OAJA0Q,EAAQ5Y,UAAY,kBACpBkB,EAAKoN,YAAYsK,GACjBA,EAAQpS,aAAa,OAAQ,QAC7BtF,EAAKkjB,SAAW,EACTljB,C,EAMO1E,EAAAic,YAAWA,EAOXjc,EAAAmb,WAAhB,SACElY,EACAb,GAEA,OAAO,IAAIylB,EAAS5kB,EAAMwX,SAAUrY,E,EAMtBpC,EAAA2lB,aAAhB,SAA6BtC,EAAYc,EAAWC,GAClD,IAAK,IAAIlT,EAAoBmS,EAAMnS,EAAMA,EAAOA,EAAKiS,UACnD,GAAItV,aAAW0X,QAAQrU,EAAKxM,KAAMyf,EAAGC,GACnC,OAAO,EAGX,OAAO,C,EAMOpkB,EAAA8kB,iBAAhB,SACE7J,GAGA,IAAIuB,EAAS,IAAID,MAAetB,EAAM3a,QACtCuO,WAASkT,KAAKvF,GAAQ,GAGtB,IAAIsL,EAAK,EACLjmB,EAAIoZ,EAAM3a,OACd,KAAOwnB,EAAKjmB,IAAKimB,EAAI,CACnB,IAAIpX,EAAOuK,EAAM6M,GACjB,GAAKpX,EAAK/K,UAAV,CAGA,GAAkB,cAAd+K,EAAK7H,KACP,MAEF2T,EAAOsL,IAAM,CAJZ,CAKF,CAGD,IAAIC,EAAKlmB,EAAI,EACb,KAAOkmB,GAAM,IAAKA,EAAI,CACpB,IAAIrX,EAAOuK,EAAM8M,GACjB,GAAKrX,EAAK/K,UAAV,CAGA,GAAkB,cAAd+K,EAAK7H,KACP,MAEF2T,EAAOuL,IAAM,CAJZ,CAKF,CAGD,IAAIzf,GAAO,EACX,OAASwf,EAAKC,GAAI,CAChB,IAAIrX,EAAOuK,EAAM6M,GACZpX,EAAK/K,YAGQ,cAAd+K,EAAK7H,KACPP,GAAO,EACEA,EACTkU,EAAOsL,IAAM,EAEbxf,GAAO,EAEV,CAGD,OAAOkU,C,EAeOxc,EAAAukB,aAAhB,SACElB,EACAc,EACAC,EACAC,EACAC,GAGA,MAAM0D,EAAaX,IACnB,IAAIY,EAAKD,EAAWT,YAChBW,EAAKF,EAAWR,YAChBW,EAAKH,EAAWP,YAChBW,EAAKJ,EAAWL,aAGpBviB,cAAYqB,YAAY4c,EAAMnf,EAAOwC,IAAIiB,eAGzC,IAAIwE,EAAYic,GAAM9D,EAASF,EAAI,GAG/B1f,EAAO2e,EAAK3e,KACZyB,EAAQzB,EAAKyB,MAGjBA,EAAMkiB,QAAU,IAChBliB,EAAMgG,UAAY,GAAGA,MAGrBjI,EAAO+G,OAAOoY,EAAM5X,SAAS6c,MAG7B,IAAIxd,MAAEA,EAAKC,OAAEA,GAAWrG,EAAK2R,yBAGxBgO,GAAUF,EAAIrZ,EAAQmd,EAAKE,IAC9BhE,EAAI8D,EAAKE,EAAKrd,IAIXwZ,GAAUF,EAAIrZ,EAASmd,EAAKE,IAC3BhE,EAAI8D,EAAKE,EACXhE,EAAI8D,EAAKE,EAAKrd,EAEdqZ,GAAQrZ,GAKZ5E,EAAM4D,UAAY,aAAa9I,KAAKF,IAAI,EAAGojB,SAASljB,KAAKF,IAAI,EAAGqjB,OAGhEje,EAAMkiB,QAAU,G,EAMFroB,EAAAgmB,YAAhB,SAA4BP,EAAeM,GAEzC,MAAMiC,EAAaX,IACnB,IAAIY,EAAKD,EAAWT,YAChBW,EAAKF,EAAWR,YAChBW,EAAKH,EAAWP,YAChBW,EAAKJ,EAAWL,aAGpBviB,cAAYqB,YAAYgf,EAASvhB,EAAOwC,IAAIiB,eAG5C,IAAIwE,EAAYic,EAGZ1jB,EAAO+gB,EAAQ/gB,KACfyB,EAAQzB,EAAKyB,MAGjBA,EAAMkiB,QAAU,IAChBliB,EAAMgG,UAAY,GAAGA,MAGrBjI,EAAO+G,OAAOwa,EAASha,SAAS6c,MAGhC,IAAIxd,MAAEA,EAAKC,OAAEA,GAAWrG,EAAK2R,wBAGzB3D,EAAM7E,aAAW8E,UAAU8S,EAAQ/gB,MAGnC6jB,EAAWxC,EAAS1P,wBAGpB8N,EAAIoE,EAASC,MAAQxoB,EAAAknB,gBAGrB/C,EAAIrZ,EAAQmd,EAAKE,IACnBhE,EAAIoE,EAAS5a,KAAO3N,EAAAknB,gBAAkBpc,GAIxC,IAAIsZ,EAAImE,EAAS7a,IAAMgF,EAAI+V,UAAY/V,EAAIM,WAGvCoR,EAAIrZ,EAASmd,EAAKE,IACpBhE,EAAImE,EAASG,OAAShW,EAAIiW,aAAejW,EAAIkW,cAAgB7d,GAI/D5E,EAAM4D,UAAY,aAAa9I,KAAKF,IAAI,EAAGojB,SAASljB,KAAKF,IAAI,EAAGqjB,OAGhEje,EAAMkiB,QAAU,G,EA4BFroB,EAAAolB,aAAhB,SACEnK,EACAnC,EACA2E,GAGA,IAAIhc,GAAS,EACT6jB,GAAQ,EACRD,GAAW,EAGXwD,EAAW/P,EAAIgQ,cAGnB,IAAK,IAAIloB,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EAAG,CAE5C,IAAImoB,GAAKnoB,EAAI6c,GAAS5b,EAGlB6O,EAAOuK,EAAM8N,GAGjB,IAAK9M,EAAYvL,GACf,SAIF,IAAIxN,EAAQwN,EAAKxN,MACjB,GAAqB,IAAjBA,EAAM5C,OACR,SAIF,IAAI0oB,EAAKtY,EAAKvN,SAGV6lB,GAAM,GAAKA,EAAK9lB,EAAM5C,OACpB4C,EAAM8lB,GAAIF,gBAAkBD,KACf,IAAXpnB,EACFA,EAAQsnB,EAER1D,GAAW,IAOH,IAAVC,GAAepiB,EAAM,GAAG4lB,gBAAkBD,IAC5CvD,EAAOyD,EAEV,CAGD,MAAO,CAAEtnB,QAAO4jB,WAAUC,O,EAM5B,MAAMuC,EAIJvoB,YAAYmb,EAA2BrY,GACrC7C,KAAK0iB,UAAYxH,EACjBlb,KAAKsJ,KAAOzG,EAAQyG,MAAQ,UAC5BtJ,KAAKye,QAAU5b,EAAQ4b,SAAW,GAClCze,KAAK0e,KAAO7b,EAAQ6b,MAAQkE,UAAQC,YACpC7iB,KAAKkmB,QAAUrjB,EAAQqjB,SAAW,I,CA0BhCviB,YACF,MAAkB,YAAd3D,KAAKsJ,KACAtJ,KAAK0iB,UAAU/e,MAAM3D,KAAKye,QAASze,KAAK0e,MAE/B,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAMjC,MAErB,E,CAMLC,eACF,MAAkB,YAAd5D,KAAKsJ,KACAtJ,KAAK0iB,UAAU9e,SAAS5D,KAAKye,QAASze,KAAK0e,MAElC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAMhC,UAEpB,C,CAMNC,WACF,MAAkB,YAAd7D,KAAKsJ,KACAtJ,KAAK0iB,UAAU7e,KAAK7D,KAAKye,QAASze,KAAK0e,MAE9B,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAM/B,UAD5B,C,CASEC,gBACF,MAAkB,YAAd9D,KAAKsJ,KACAtJ,KAAK0iB,UAAU5e,UAAU9D,KAAKye,QAASze,KAAK0e,MAEnC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAM9B,UAErB,E,CAMLC,gBACF,MAAkB,YAAd/D,KAAKsJ,KACAtJ,KAAK0iB,UAAU3e,UAAU/D,KAAKye,QAASze,KAAK0e,MAEnC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAM7B,UAErB,E,CAMLC,cACF,MAAkB,YAAdhE,KAAKsJ,KACAtJ,KAAK0iB,UAAU1e,QAAQhE,KAAKye,QAASze,KAAK0e,MAEjC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAM5B,QAErB,E,CAMLC,gBACF,MAAkB,YAAdjE,KAAKsJ,KACAtJ,KAAK0iB,UAAUze,UAAUjE,KAAKye,QAASze,KAAK0e,MAEnC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAM3B,UAErB,E,CAMLG,cACF,MAAkB,YAAdpE,KAAKsJ,KACAtJ,KAAK0iB,UAAUte,QAAQpE,KAAKye,QAASze,KAAK0e,MAEjC,YAAd1e,KAAKsJ,MAAsBtJ,KAAKkmB,QAC3BlmB,KAAKkmB,QAAQtgB,MAAMxB,QAErB,E,CAMLma,gBACF,MAAkB,YAAdve,KAAKsJ,KACAtJ,KAAK0iB,UAAUnE,UAAUve,KAAKye,QAASze,KAAK0e,MAEnC,YAAd1e,KAAKsJ,MACiB,OAAjBtJ,KAAKkmB,O,CAQZ9G,gBACF,MAAkB,YAAdpf,KAAKsJ,MACAtJ,KAAK0iB,UAAUtD,UAAUpf,KAAKye,QAASze,KAAK0e,K,CAQnDtY,gBACF,MAAkB,YAAdpG,KAAKsJ,KACAtJ,KAAK0iB,UAAUtc,UAAUpG,KAAKye,QAASze,KAAK0e,MAEnC,YAAd1e,KAAKsJ,MACiB,OAAjBtJ,KAAKkmB,O,CAQZ9F,iBACF,GAAkB,YAAdpgB,KAAKsJ,KAAoB,CAC3B,IAAImV,QAAEA,EAAOC,KAAEA,GAAS1e,KACxB,OACEsP,WAASwT,cAAc9iB,KAAK0iB,UAAUK,aAAa5C,GAC1CA,EAAG1B,UAAYA,GAAWmE,UAAQI,UAAU7C,EAAGzB,KAAMA,MACxD,IAET,CACD,OAAO,I,EAKZ,CAzhBD,CAAUje,MAyhBT,MC/rDD,SAAUA,GAoJR,SAASipB,EAAYpV,EAAUC,GAE7B,IAAIoN,EAAKrN,EAAEsN,KACPC,EAAKtN,EAAEqN,KACX,OAAID,IAAOE,EACFF,EAAKE,GAAM,EAAI,EAIjBvN,EAAE9N,GAAK+N,EAAE/N,E,CAMlB,SAASmjB,EAAQrV,EAAUC,GAEzB,IAAIqV,EAAKC,WAASC,qBAAqBxV,EAAEyV,UACrCC,EAAKH,WAASC,qBAAqBvV,EAAEwV,UACzC,OAAIH,IAAOI,EACFA,EAAKJ,EAIPF,EAAYpV,EAAGC,E,CApJR9T,EAAAmb,WAAhB,SACE/Y,EACA2D,GAEA,IAAIujB,EA2GN,SAA0BA,GACxB,IAA+B,IAA3BA,EAAS3a,QAAQ,KACnB,MAAM,IAAIrI,MAAM,mCAAmCgjB,KAErD,IAAKF,WAASI,QAAQF,GACpB,MAAM,IAAIhjB,MAAM,qBAAqBgjB,KAEvC,OAAOA,C,CAlHQG,CAAiBrnB,EAAQknB,UACpCnI,OAAwB1e,IAAjBL,EAAQ+e,KAAqB/e,EAAQ+e,KAAOxhB,IACvD,MAAO,IAAKyC,EAASknB,WAAUnI,OAAMpb,K,EAQvB/F,EAAA4hB,WAAhB,SACE3G,EACA1F,EACAmU,EACAC,GAGA,IAAIxT,EAASZ,EAAMY,OAGnB,IAAKA,EACH,OAAO,KAIT,IAAIyT,EAAgBrU,EAAMqU,cAG1B,IAAKA,EACH,OAAO,KAOT,IAAKA,EAAcvjB,SAAS8P,KAC1BA,EAAS1K,SAASoe,iBAAiBtU,EAAMe,QAASf,EAAMgB,UACnDJ,IAAWyT,EAAcvjB,SAAS8P,IACrC,OAAO,KAKX,IAAIqG,EAAkB,GAGlBsN,EAAsC7O,EAAM9J,QAGhD,KAAkB,OAAXgF,GAAiB,CAEtB,IAAI4T,EAAmB,GAGvB,IAAK,IAAInpB,EAAI,EAAGiB,EAAIioB,EAAexpB,OAAQM,EAAIiB,IAAKjB,EAAG,CAErD,IAAI8P,EAAOoZ,EAAelpB,GAGrB8P,IAKA0Y,WAASW,QAAQ5T,EAAQzF,EAAK4Y,YAKnCS,EAAQ3Y,KAAKV,GAGboZ,EAAelpB,GAAK,MACrB,CAWD,GARuB,IAAnBmpB,EAAQzpB,SACNopB,GACFK,EAAQlI,KAAK8H,EAAiBT,EAAUD,GAE1CzM,EAAOpL,QAAQ2Y,IAIb5T,IAAWyT,EACb,MAIFzT,EAASA,EAAO6T,aACjB,CAOD,OALKN,GACHlN,EAAOqF,KAAK8H,EAAiBT,EAAUD,GAIlCzM,C,CAgDV,CA9KD,CAAUxc,MA8KT,KC7UD,MAAMiqB,EAAa,CACjB,YACA,UACA,aACA,YACA,OACA,OAWI,MAAOC,UAAkBhmB,EAM7B5E,YAAY8C,EAA8B,IACxCwI,MAAM,CAAElG,KAAM1E,EAAQ2E,eA6wChBpF,KAAa4qB,eAAI,EACjB5qB,KAAO0U,QAAe,GAGtB1U,KAAe6qB,iBAAY,EAC3B7qB,KAAc8qB,eAAoB,KAClC9qB,KAAS+qB,UAA6B,KACtC/qB,KAAiBgrB,mBAAY,EAC7BhrB,KAAAirB,UAAY,IAAIznB,SAAsCxD,MACtDA,KAAAkrB,gBAAkB,IAAI1nB,SAC5BxD,MAEMA,KAAAmrB,cAAgB,IAAI3nB,SAAmBxD,MACvCA,KAAAorB,mBAAqB,IAAI5nB,SAG/BxD,MACMA,KAAAqrB,oBAAsB,IAAI7nB,SAGhCxD,MACMA,KAAAsrB,sBAAwB,IAAI9nB,SAGlCxD,MApyCAA,KAAKqF,SAAS,aACdrF,KAAKyb,YAAYhR,aAAa,OAAQ,WACtCzK,KAAKsF,QAAQX,EAAOY,KAAK+B,gBACzBtH,KAAKurB,UAAY1oB,EAAQqJ,UAAYA,SACrClM,KAAKwrB,YAAc3oB,EAAQ2oB,cAAe,EAC1CxrB,KAAKyrB,eAAiB5oB,EAAQ4oB,iBAAkB,EAChDzrB,KAAK0rB,cAAgB7oB,EAAQ6oB,gBAAiB,EAC9C1rB,KAAK2rB,iBAAmB9oB,EAAQ8oB,mBAAoB,EACpD3rB,KAAK4rB,eAAiB/oB,EAAQ+oB,gBAAkB,uBAChD5rB,KAAK0H,KAAO7E,EAAQ6E,MAAQ,GAC5B1H,KAAKgR,YAAcnO,EAAQmO,aAAe,aAC1ChR,KAAK6rB,eAAiBhpB,EAAQgpB,gBAAkB,mBAChD7rB,KAAK+Q,SAAWlO,EAAQkO,UAAY4Z,EAAOlT,e,CAM7ChT,UACEzE,KAAK6V,gBACL7V,KAAK0U,QAAQ3T,OAAS,EACtBf,KAAK8qB,eAAiB,KACtBzf,MAAM5G,S,CAcJqnB,qBACF,OAAO9rB,KAAKkrB,e,CAWVa,eACF,OAAO/rB,KAAKirB,S,CAYVe,2BAIF,OAAOhsB,KAAKsrB,qB,CAMVW,mBACF,OAAOjsB,KAAKmrB,a,CASVe,wBACF,OAAOlsB,KAAKorB,kB,CAeVe,yBACF,OAAOnsB,KAAKqrB,mB,CAaVnf,eACF,OAAOlM,KAAKurB,S,CAeVE,qBACF,OAAOzrB,KAAK6qB,e,CAOVY,mBAAennB,GACjBtE,KAAK6qB,gBAAkBvmB,C,CA2BrB8nB,mBACF,OAAOpsB,KAAK0U,QAAQ1U,KAAK4qB,gBAAkB,I,CASzCwB,iBAAa9nB,GACftE,KAAKqsB,aAAe/nB,EAAQtE,KAAK0U,QAAQtF,QAAQ9K,IAAU,C,CASzD+nB,mBACF,OAAOrsB,KAAK4qB,a,CASVyB,iBAAa/nB,GAOf,IALIA,EAAQ,GAAKA,GAAStE,KAAK0U,QAAQ3T,UACrCuD,GAAS,GAIPtE,KAAK4qB,gBAAkBtmB,EACzB,OAIF,IAAIgoB,EAAKtsB,KAAK4qB,cACV2B,EAAKvsB,KAAK0U,QAAQ4X,IAAO,KAGzBE,EAAKloB,EACLmoB,EAAKzsB,KAAK0U,QAAQ8X,IAAO,KAG7BxsB,KAAK4qB,cAAgB4B,EACrBxsB,KAAK8qB,eAAiByB,EAGtBvsB,KAAKkI,SAGLlI,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAeJ,EACfK,cAAeJ,EACfF,aAAcG,EACdJ,aAAcK,G,CAOd/kB,WACF,OAAO1H,KAAK4sB,K,CAMVllB,SAAKpD,GACPtE,KAAK4sB,MAAQtoB,EACTA,EACFtE,KAAKyb,YAAYhR,aAAa,aAAcnG,GAE5CtE,KAAKyb,YAAY5Q,gBAAgB,a,CAUjCmG,kBACF,OAAOhR,KAAK8Q,Y,CASVE,gBAAY1M,GAEVtE,KAAK8Q,eAAiBxM,IAK1BtE,KAAK6V,gBAGL7V,KAAK8Q,aAAexM,EACpBtE,KAAKoE,QAAqB,YAAIE,EAC9BtE,KAAKyb,YAAYhR,aAAa,mBAAoBnG,G,CAMhDqnB,uBACF,OAAO3rB,KAAKgrB,iB,CAMVW,qBAAiBrnB,GAEftE,KAAKgrB,oBAAsB1mB,IAI/BtE,KAAKgrB,kBAAoB1mB,EACrBA,EACFtE,KAAK6sB,cAAcllB,UAAUG,OAAO,iBAEpC9H,KAAK6sB,cAAcllB,UAAUC,IAAI,iB,CAOjCgN,aACF,OAAO5U,KAAK0U,O,CAWV+G,kBACF,OAAOzb,KAAKmF,KAAKoW,uBACf,qBACA,E,CAWAsR,oBACF,OAAO7sB,KAAKmF,KAAKoW,uBACf,uBACA,E,CAcJuR,OAAOxoB,GACL,OAAOtE,KAAK+sB,UAAU/sB,KAAK0U,QAAQ3T,OAAQuD,E,CAkB7CyoB,UAAU7qB,EAAeoC,GAEvBtE,KAAK6V,gBAGL,IAAIjQ,EAAQnF,EAAQusB,QAAQ1oB,GAGxBjD,EAAIrB,KAAK0U,QAAQtF,QAAQxJ,GAGzByJ,EAAI3N,KAAKF,IAAI,EAAGE,KAAKH,IAAIW,EAAOlC,KAAK0U,QAAQ3T,SAGjD,OAAW,IAAPM,GAEFiO,WAASC,OAAOvP,KAAK0U,QAASrF,EAAGzJ,GAGjCA,EAAMvB,QAAQ0T,QAAQ/X,KAAKgY,gBAAiBhY,MAG5CA,KAAKkI,SAGLlI,KAAKitB,wBAAwB5d,EAAGzJ,GAGzBA,IAMLyJ,IAAMrP,KAAK0U,QAAQ3T,QACrBsO,IAIEhO,IAAMgO,IAKVC,WAASG,KAAKzP,KAAK0U,QAASrT,EAAGgO,GAG/BrP,KAAKkI,SAGLlI,KAAKktB,sBAAsB7rB,EAAGgO,IAVrBzJ,E,CAwBXunB,UAAUvnB,GACR5F,KAAKotB,YAAYptB,KAAK0U,QAAQtF,QAAQxJ,G,CAWxCwnB,YAAYlrB,GAEVlC,KAAK6V,gBAGL,IAAIjQ,EAAQ0J,WAASM,SAAS5P,KAAK0U,QAASxS,GAGvC0D,IAKLA,EAAMvB,QAAQgpB,WAAWrtB,KAAKgY,gBAAiBhY,MAG3C4F,IAAU5F,KAAK8qB,iBACjB9qB,KAAK8qB,eAAiB,MAIxB9qB,KAAKkI,SAGLlI,KAAKstB,wBAAwBprB,EAAO0D,G,CAMtC2nB,YAEE,GAA4B,IAAxBvtB,KAAK0U,QAAQ3T,OACf,OAIFf,KAAK6V,gBAGL,IAAK,IAAIjQ,KAAS5F,KAAK0U,QACrB9O,EAAMvB,QAAQgpB,WAAWrtB,KAAKgY,gBAAiBhY,MAIjD,IAAIssB,EAAKtsB,KAAKqsB,aACVE,EAAKvsB,KAAKosB,aAGdpsB,KAAK4qB,eAAiB,EACtB5qB,KAAK8qB,eAAiB,KAGtB9qB,KAAK0U,QAAQ3T,OAAS,EAGtBf,KAAKkI,UAGO,IAARokB,GAKJtsB,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAeJ,EACfK,cAAeJ,EACfF,cAAe,EACfD,aAAc,M,CAWlBoB,eACExtB,KAAK6V,e,CAcPE,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,cACHtJ,KAAKiW,gBAAgBD,GACrB,MACF,IAAK,cACHhW,KAAKkW,gBAAgBF,GACrB,MACF,IAAK,YACHhW,KAAKmW,cAAcH,GACnB,MACF,IAAK,WACHhW,KAAKytB,aAAazX,GAClB,MACF,IAAK,UACHA,EAAM0X,aAAeC,MAAMC,gBACvB5tB,KAAK6tB,qBAAqB7X,GAC1BhW,KAAKoW,YAAYJ,GACrB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,cAAevW,MAC1CA,KAAKmF,KAAKoR,iBAAiB,WAAYvW,MACvCA,KAAKmF,KAAKoR,iBAAiB,UAAWvW,K,CAM9BkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CA,KAAKmF,KAAKqR,oBAAoB,WAAYxW,MAC1CA,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAK6V,e,CAMGpM,gBAAgBzC,G,MACxB,IAAI4N,EAAS5U,KAAK0U,QACd3D,EAAW/Q,KAAK+Q,SAChBqb,EAAepsB,KAAKosB,aACpBvP,EAAU,IAAIG,MAAsBpI,EAAO7T,QAK/C,MAAM+sB,EAEJ,QADAC,EAAA/tB,KAAKguB,6BACL,IAAAD,IAAC/tB,KAAK4qB,eAAiB,EAAI5qB,KAAK4qB,cAAgB,EAElD,IAAK,IAAIvpB,EAAI,EAAGiB,EAAIsS,EAAO7T,OAAQM,EAAIiB,IAAKjB,EAAG,CAC7C,IAAIuE,EAAQgP,EAAOvT,GACf4sB,EAAUroB,IAAUwmB,EACpBxhB,EAASqjB,EAAU3rB,EAAIA,EAAIjB,EAAI,EAC/BgnB,EAAWyF,IAAwBzsB,EAAI,GAAK,EAChDwb,EAAQxb,GAAK0P,EAASmd,UAAU,CAAEtoB,QAAOqoB,UAASrjB,SAAQyd,YAC3D,CACD1L,aAAWC,OAAOC,EAAS7c,KAAKyb,Y,CAQ1BuS,sBACN,IAAI9rB,EAAQ,KACZ,MAAMisB,EAAenuB,KAAKyb,YAAY2S,cAAc,oBASpD,OARID,EACFjsB,EAAQ,IAAIlC,KAAKyb,YAAYlU,UAAU6H,QAAQ+e,GAE/CnuB,KAAKgrB,mBAC2C,MAAhDhrB,KAAK6sB,cAAcwB,aAAa,cAEhCnsB,GAAS,GAEJA,C,CAMDurB,aAAazX,GAEnB,IAAKhW,KAAKyrB,eACR,OAGF,IAAI6C,EAAOtuB,KAAKyb,YAAYlU,SAGxBrF,EAAQoN,WAASqH,eAAe2X,GAAMC,GACjCjgB,aAAW0X,QAAQuI,EAAKvY,EAAMe,QAASf,EAAMgB,WAItD,IAAe,IAAX9U,EACF,OAGF,IAAI0D,EAAQ5F,KAAK4U,OAAO1S,GACpByB,EAAQ2qB,EAAKpsB,GAAOksB,cAAc,uBACtC,GAAIzqB,GAASA,EAAMmD,SAASkP,EAAMY,QAAwB,CACxD,IAAItS,EAAQsB,EAAMjC,OAAS,GAGvB6qB,EAAW7qB,EAAM8qB,UACrB9qB,EAAM8qB,UAAY,GAElB,IAAIpS,EAAQnQ,SAASC,cAAc,SACnCkQ,EAAM1U,UAAUC,IAAI,sBACpByU,EAAM/X,MAAQA,EACdX,EAAM4O,YAAY8J,GAElB,IAAIqS,EAAS,KACXrS,EAAM7F,oBAAoB,OAAQkY,GAClC/qB,EAAM8qB,UAAYD,EAClBxuB,KAAKmF,KAAKoR,iBAAiB,UAAWvW,KAAK,EAG7Cqc,EAAM9F,iBAAiB,YAAaP,GAClCA,EAAMM,oBAER+F,EAAM9F,iBAAiB,OAAQmY,GAC/BrS,EAAM9F,iBAAiB,WAAYP,IACf,UAAdA,EAAMuD,KACY,KAAhB8C,EAAM/X,QACRsB,EAAMjC,MAAQiC,EAAM5B,QAAUqY,EAAM/X,OAEtCoqB,KACuB,WAAd1Y,EAAMuD,KACfmV,GACD,IAEH1uB,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCqc,EAAMC,SACND,EAAMzC,QAEFjW,EAAM4D,SAASxG,OAAS,GACzB4C,EAAM4D,SAAS,GAAmBqS,OAEtC,C,CAMKiU,qBAAqB7X,GACvBA,EAAM0X,aAAeC,MAAMC,kBAK/B5X,EAAMK,iBACNL,EAAMM,kBAGY,WAAdN,EAAMuD,KACRvZ,KAAK6V,gB,CAODO,YAAYJ,G,UAElB,GAAkB,QAAdA,EAAMuD,KAAiBvD,EAAM0X,aAAeC,MAAMC,gBAKtD,GACgB,UAAd5X,EAAMuD,KACQ,aAAdvD,EAAMuD,KACQ,MAAdvD,EAAMuD,IACN,CAEA,MAAMoV,EAAiBziB,SAAS0S,cAGhC,GACE5e,KAAK2rB,kBACL3rB,KAAK6sB,cAAc/lB,SAAS6nB,GAE5B3Y,EAAMK,iBACNL,EAAMM,kBACNtW,KAAKmrB,cAAc5mB,WACd,CACL,MAAMrC,EAAQoN,WAASqH,eAAe3W,KAAKyb,YAAYlU,UAAUgnB,GAC/DA,EAAIznB,SAAS6nB,KAEXzsB,GAAS,IACX8T,EAAMK,iBACNL,EAAMM,kBACNtW,KAAKqsB,aAAenqB,EAEvB,CAEF,MAAM,GAAIwoB,EAAWkE,SAAS5Y,EAAMuD,KAAM,CAEzC,MAAMsV,EAAuB,IAAI7uB,KAAKyb,YAAYlU,UAKlD,GAJIvH,KAAK2rB,kBACPkD,EAAUhd,KAAK7R,KAAK6sB,eAGlBgC,EAAU9tB,QAAU,EACtB,OAEFiV,EAAMK,iBACNL,EAAMM,kBAGN,IAMIwY,EANAC,EAAeF,EAAUzf,QAAQlD,SAAS0S,gBACxB,IAAlBmQ,IACFA,EAAe/uB,KAAK4qB,eAML,eAAd5U,EAAMuD,KAA8C,eAAtBvZ,KAAK8Q,cACrB,cAAdkF,EAAMuD,KAA6C,aAAtBvZ,KAAK8Q,aAEnCge,EAA6C,QAA/Bf,EAAAc,EAAUE,EAAe,UAAM,IAAAhB,IAAAc,EAAU,GAExC,cAAd7Y,EAAMuD,KAA6C,eAAtBvZ,KAAK8Q,cACpB,YAAdkF,EAAMuD,KAA2C,aAAtBvZ,KAAK8Q,aAEjCge,EAC6B,QAA3BE,EAAAH,EAAUE,EAAe,UAAE,IAAAC,IAAIH,EAAUA,EAAU9tB,OAAS,GACvC,SAAdiV,EAAMuD,IACfuV,EAAcD,EAAU,GACD,QAAd7Y,EAAMuD,MACfuV,EAAcD,EAAUA,EAAU9tB,OAAS,IAIzC+tB,IACqB,QAAvBG,EAAAJ,EAAUE,UAAa,IAAAE,KAAExkB,aAAa,WAAY,MAClDqkB,WAAarkB,aAAa,WAAY,KACrCqkB,EAA4BlV,QAEhC,C,CAMK3D,gBAAgBD,GAEtB,GAAqB,IAAjBA,EAAMU,QAAiC,IAAjBV,EAAMU,OAC9B,OAIF,GAAI1W,KAAK+qB,UACP,OAIF,GACG/U,EAAMY,OAAuBjP,UAAUb,SAAS,sBAEjD,OAIF,IAAIooB,EACFlvB,KAAK2rB,kBACL3rB,KAAK6sB,cAAc/lB,SAASkP,EAAMY,QAGhC0X,EAAOtuB,KAAKyb,YAAYlU,SAGxBrF,EAAQoN,WAASqH,eAAe2X,GAAMC,GACjCjgB,aAAW0X,QAAQuI,EAAKvY,EAAMe,QAASf,EAAMgB,WAItD,IAAe,IAAX9U,IAAiBgtB,EACnB,OA6BF,GAzBAlZ,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK+qB,UAAY,CACfwD,IAAKD,EAAKpsB,GACVA,MAAOA,EACPitB,OAAQnZ,EAAMe,QACdqY,OAAQpZ,EAAMgB,QACdqY,QAAS,EACTC,SAAU,EACVC,aAAc,EACdC,aAAc,EACdC,UAAW,KACXC,YAAa,KACbvY,SAAU,KACVwY,YAAY,EACZC,aAAa,EACbC,iBAAiB,GAInB7vB,KAAKkM,SAASqK,iBAAiB,YAAavW,MAAM,GAG7B,IAAjBgW,EAAMU,QAAgBwY,EACxB,OAIF,IAAIrrB,EAAOyqB,EAAKpsB,GAAOksB,cAAcpuB,KAAK+Q,SAAS+e,mBAC/CjsB,GAAQA,EAAKiD,SAASkP,EAAMY,UAK5B5W,KAAKwrB,cACPxrB,KAAKkM,SAASqK,iBAAiB,cAAevW,MAAM,GACpDA,KAAKkM,SAASqK,iBAAiB,UAAWvW,MAAM,GAChDA,KAAKkM,SAASqK,iBAAiB,cAAevW,MAAM,IAIlDA,KAAK0rB,eAAiB1rB,KAAKqsB,eAAiBnqB,EAC9ClC,KAAKqsB,cAAgB,EAErBrsB,KAAKqsB,aAAenqB,GAIK,IAAvBlC,KAAKqsB,cAKTrsB,KAAKsrB,sBAAsB/mB,KAAK,CAC9BrC,MAAOlC,KAAKqsB,aACZzmB,MAAO5F,KAAKosB,e,CAORlW,gBAAgBF,GAEtB,IAAIV,EAAOtV,KAAK+qB,UAChB,IAAKzV,EACH,OAIFU,EAAMK,iBACNL,EAAMM,kBAGN,IAAIgY,EAAOtuB,KAAKyb,YAAYlU,SAG5B,GAAK+N,EAAKqa,YAAelvB,EAAQsvB,aAAaza,EAAMU,GAApD,CAKA,IAAKV,EAAKqa,WAAY,CAEpB,IAAIK,EAAU1a,EAAKiZ,IAAIzX,wBACG,eAAtB9W,KAAK8Q,cACPwE,EAAK+Z,OAAS/Z,EAAKiZ,IAAItc,WACvBqD,EAAKga,QAAUU,EAAQzkB,MACvB+J,EAAKia,YAAcja,EAAK6Z,OAASa,EAAQ5hB,OAEzCkH,EAAK+Z,OAAS/Z,EAAKiZ,IAAIrc,UACvBoD,EAAKga,QAAUU,EAAQxkB,OACvB8J,EAAKia,YAAcja,EAAK8Z,OAASY,EAAQ7hB,KAE3CmH,EAAK2a,eAAiB,CACpBrL,EAAGtP,EAAK6Z,OAASa,EAAQ5hB,KACzByW,EAAGvP,EAAK8Z,OAASY,EAAQ7hB,KAE3BmH,EAAKma,UAAYhvB,EAAQyvB,cAAc5B,EAAMtuB,KAAK8Q,cAClDwE,EAAKoa,YAAc1vB,KAAKyb,YAAY3E,wBACpCxB,EAAK6B,SAAWC,OAAKC,eAAe,WAGpC/B,EAAKiZ,IAAI5mB,UAAUC,IAAI,mBACvB5H,KAAKqF,SAAS,mBAGdiQ,EAAKqa,YAAa,CACnB,CAGD,IAAKra,EAAKua,iBAAmBpvB,EAAQ0vB,eAAe7a,EAAMU,GAAQ,CAEhEV,EAAKua,iBAAkB,EAGvB,IAAI3tB,EAAQoT,EAAKpT,MACb6U,EAAUf,EAAMe,QAChBC,EAAUhB,EAAMgB,QAChBuX,EAAMD,EAAKpsB,GACX0D,EAAQ5F,KAAK0U,QAAQxS,GAazB,GAVAlC,KAAKqrB,oBAAoB9mB,KAAK,CAC5BrC,QACA0D,QACA2oB,MACAxX,UACAC,UACApD,OAAQ0B,EAAK2a,iBAIX3a,EAAKsa,YACP,MAEH,CAGDnvB,EAAQ2vB,WAAW9B,EAAMhZ,EAAMU,EAAOhW,KAAK8Q,aA5D1C,C,CAkEKqF,cAAcH,GAEpB,GAAqB,IAAjBA,EAAMU,QAAiC,IAAjBV,EAAMU,OAC9B,OAIF,MAAMpB,EAAOtV,KAAK+qB,UAClB,IAAKzV,EACH,OAcF,GAVAU,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAKkM,SAASsK,oBAAoB,cAAexW,MAAM,GACvDA,KAAKkM,SAASsK,oBAAoB,YAAaxW,MAAM,GACrDA,KAAKkM,SAASsK,oBAAoB,UAAWxW,MAAM,GACnDA,KAAKkM,SAASsK,oBAAoB,cAAexW,MAAM,IAGlDsV,EAAKqa,WAAY,CAQpB,GANA3vB,KAAK+qB,UAAY,KAIf/qB,KAAK2rB,kBACL3rB,KAAK6sB,cAAc/lB,SAASkP,EAAMY,QAGlC,YADA5W,KAAKmrB,cAAc5mB,UAAKrB,GAK1B,IAAIorB,EAAOtuB,KAAKyb,YAAYlU,SAGxBrF,EAAQoN,WAASqH,eAAe2X,GAAMC,GACjCjgB,aAAW0X,QAAQuI,EAAKvY,EAAMe,QAASf,EAAMgB,WAItD,GAAI9U,IAAUoT,EAAKpT,MACjB,OAIF,IAAI0D,EAAQ5F,KAAK0U,QAAQxS,GACzB,IAAK0D,EAAM1B,SACT,OAIF,GAAqB,IAAjB8R,EAAMU,OAER,YADA1W,KAAKorB,mBAAmB7mB,KAAK,CAAErC,QAAO0D,UAKxC,IAAI/B,EAAOyqB,EAAKpsB,GAAOksB,cAAcpuB,KAAK+Q,SAAS+e,mBACnD,OAAIjsB,GAAQA,EAAKiD,SAASkP,EAAMY,aAC9B5W,KAAKorB,mBAAmB7mB,KAAK,CAAErC,QAAO0D,eAKxC,CACD,CAGD,GAAqB,IAAjBoQ,EAAMU,OACR,OAIFjW,EAAQ4vB,oBAAoB/a,EAAMtV,KAAK8Q,cAGvCwE,EAAKiZ,IAAI5mB,UAAUG,OAAO,mBAG1B,IAAIwoB,EAAW7vB,EAAQ8vB,wBAAwBjb,EAAKiZ,KAGpD7H,YAAW,KAET,GAAIpR,EAAKsa,YACP,OAIF5vB,KAAK+qB,UAAY,KAGjBtqB,EAAQ+vB,kBAAkBxwB,KAAKyb,YAAYlU,SAAUvH,KAAK8Q,cAG1DwE,EAAK6B,SAAU1S,UAGfzE,KAAK6H,YAAY,mBAGjB,IAAIxG,EAAIiU,EAAKpT,MACTmN,EAAIiG,EAAKka,aACF,IAAPngB,GAAYhO,IAAMgO,IAKtBC,WAASG,KAAKzP,KAAK0U,QAASrT,EAAGgO,GAG/BrP,KAAKktB,sBAAsB7rB,EAAGgO,GAG9BrP,KAAKirB,UAAU1mB,KAAK,CAClBuL,UAAWzO,EACX0O,QAASV,EACTzJ,MAAO5F,KAAK0U,QAAQrF,KAItBxJ,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIiB,eAAc,GACtDkoB,E,CAMGza,gBAEN,IAAIP,EAAOtV,KAAK+qB,UACXzV,IAKLtV,KAAK+qB,UAAY,KAGjB/qB,KAAKkM,SAASsK,oBAAoB,cAAexW,MAAM,GACvDA,KAAKkM,SAASsK,oBAAoB,YAAaxW,MAAM,GACrDA,KAAKkM,SAASsK,oBAAoB,UAAWxW,MAAM,GACnDA,KAAKkM,SAASsK,oBAAoB,cAAexW,MAAM,GAIvDsV,EAAKsa,aAAc,EAGdta,EAAKqa,aAKVlvB,EAAQ+vB,kBAAkBxwB,KAAKyb,YAAYlU,SAAUvH,KAAK8Q,cAG1DwE,EAAK6B,SAAU1S,UAGf6Q,EAAKiZ,IAAI5mB,UAAUG,OAAO,mBAC1B9H,KAAK6H,YAAY,oB,CASXolB,wBAAwB5rB,EAAWuE,GAEzC,IAAI6mB,EAAKzsB,KAAKosB,aACVI,EAAKxsB,KAAK4qB,cACV6F,EAAKzwB,KAAK4rB,eAMd,GAAW,eAAP6E,GAA+B,yBAAPA,IAAyC,IAARjE,EAS3D,OARAxsB,KAAK4qB,cAAgBvpB,EACrBrB,KAAK8qB,eAAiB2B,OACtBzsB,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAeF,EACfG,cAAeF,EACfJ,aAAchrB,EACd+qB,aAAcxmB,IAMd4mB,GAAMnrB,GACRrB,KAAK4qB,e,CAUDsC,sBAAsB7rB,EAAWgO,GACnCrP,KAAK4qB,gBAAkBvpB,EACzBrB,KAAK4qB,cAAgBvb,EACZrP,KAAK4qB,cAAgBvpB,GAAKrB,KAAK4qB,eAAiBvb,EACzDrP,KAAK4qB,gBACI5qB,KAAK4qB,cAAgBvpB,GAAKrB,KAAK4qB,eAAiBvb,GACzDrP,KAAK4qB,e,CAUD0C,wBAAwBjsB,EAAWuE,GAEzC,IAAI4mB,EAAKxsB,KAAK4qB,cACV6F,EAAKzwB,KAAK6rB,eAGd,GAAIW,IAAOnrB,EAAX,CAUA,GAA4B,IAAxBrB,KAAK0U,QAAQ3T,OAQf,OAPAf,KAAK4qB,eAAiB,OACtB5qB,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAerrB,EACfsrB,cAAe/mB,EACfymB,cAAe,EACfD,aAAc,OAMlB,GAAW,qBAAPqE,EAQF,OAPAzwB,KAAK4qB,cAAgBlpB,KAAKH,IAAIF,EAAGrB,KAAK0U,QAAQ3T,OAAS,QACvDf,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAerrB,EACfsrB,cAAe/mB,EACfymB,aAAcrsB,KAAK4qB,cACnBwB,aAAcpsB,KAAKosB,eAMvB,GAAW,sBAAPqE,EAQF,OAPAzwB,KAAK4qB,cAAgBlpB,KAAKF,IAAI,EAAGH,EAAI,QACrCrB,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAerrB,EACfsrB,cAAe/mB,EACfymB,aAAcrsB,KAAK4qB,cACnBwB,aAAcpsB,KAAKosB,eAMvB,GAAW,wBAAPqE,EAaF,OAZIzwB,KAAK8qB,gBACP9qB,KAAK4qB,cAAgB5qB,KAAK0U,QAAQtF,QAAQpP,KAAK8qB,gBAC/C9qB,KAAK8qB,eAAiB,MAEtB9qB,KAAK4qB,cAAgBlpB,KAAKH,IAAIF,EAAGrB,KAAK0U,QAAQ3T,OAAS,QAEzDf,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAerrB,EACfsrB,cAAe/mB,EACfymB,aAAcrsB,KAAK4qB,cACnBwB,aAAcpsB,KAAKosB,eAMvBpsB,KAAK4qB,eAAiB,EACtB5qB,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,cAAerrB,EACfsrB,cAAe/mB,EACfymB,cAAe,EACfD,aAAc,MA/Df,MAJKI,EAAKnrB,GACPrB,KAAK4qB,e,CAyEH5S,gBAAgBM,GACtBtY,KAAKkI,Q,EAygBT,IAAUzH,ECjYAA,ECjFAA,EC1oBAA,ECkaAA,EC9aAA,EChoBAA,EC6XAA,GPo4BV,SAAiBkqB,GA0Sf,MAAanT,EACXzX,cAMSC,KAAiB8vB,kBAAG,0BAoKrB9vB,KAAM0wB,OAAG,EACT1wB,KAAA2wB,SAAW,IAAI/Y,QA1KrB5X,KAAKga,QAAUxC,EAASyC,U,CAc1BiU,UAAU5Y,GACR,IAAI1P,EAAQ0P,EAAK1P,MAAM5B,QACnBuV,EAAMvZ,KAAK4wB,aAAatb,GACxB9O,EAAK+S,EACL3S,EAAQ5G,KAAK6wB,eAAevb,GAC5BrR,EAAYjE,KAAK8wB,eAAexb,GAChClR,EAAUpE,KAAK+wB,iBAAiBzb,GAChCwR,EAAO9mB,KAAKgxB,cAAc1b,GAC9B,OAAIA,EAAK1P,MAAM1B,SACN4a,IAAEC,GACP,CAAEvY,KAAI+S,MAAKtV,YAAW2B,QAAOgB,QAAOxC,aAAY0iB,GAChD9mB,KAAKinB,WAAW3R,GAChBtV,KAAKknB,YAAY5R,GACjBtV,KAAKixB,gBAAgB3b,IAGhBwJ,IAAEC,GACP,CAAEvY,KAAI+S,MAAKtV,YAAW2B,QAAOgB,QAAOxC,aAAY0iB,GAChD9mB,KAAKinB,WAAW3R,GAChBtV,KAAKknB,YAAY5R,G,CAYvB2R,WAAW3R,GACT,MAAM1P,MAAEA,GAAU0P,EAClB,IAAIrR,EAAYjE,KAAKyf,gBAAgBnK,GAGrC,OAAOwJ,IAAEY,IAAI,CAAEzb,aAAa2B,EAAM/B,KAAO+B,EAAM7B,U,CAUjDmjB,YAAY5R,GACV,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,sBAAwBqR,EAAK1P,MAAMjC,M,CAU/DstB,gBAAgB3b,GACd,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,0B,CAe5B2sB,aAAatb,GACX,IAAIiE,EAAMvZ,KAAK2wB,SAASpqB,IAAI+O,EAAK1P,OAKjC,YAJY1C,IAARqW,IACFA,EAAM,WAAWvZ,KAAKga,SAASha,KAAK0wB,WACpC1wB,KAAK2wB,SAASxjB,IAAImI,EAAK1P,MAAO2T,IAEzBA,C,CAUTsX,eAAevb,GACb,MAAO,CAAE1K,OAAQ,GAAG0K,EAAK1K,S,CAU3BkmB,eAAexb,GACb,IAAI5N,EAAO,gBAUX,OATI4N,EAAK1P,MAAM3B,YACbyD,GAAQ,IAAI4N,EAAK1P,MAAM3B,aAErBqR,EAAK1P,MAAM1B,WACbwD,GAAQ,oBAEN4N,EAAK2Y,UACPvmB,GAAQ,mBAEHA,C,CAUTqpB,iBAAiBzb,GACf,OAAOA,EAAK1P,MAAMxB,O,CAUpB4sB,cAAc1b,G,MACZ,MAAO,CACL6J,KAAM,MACN,gBAAiB7J,EAAK2Y,QAAQ3U,WAC9B0N,SAAU,GAAgB,QAAb+G,EAAAzY,EAAK+S,gBAAQ,IAAA0F,IAAI,O,CAWlCtO,gBAAgBnK,GACd,IAAI5N,EAAO,oBACPiM,EAAQ2B,EAAK1P,MAAM9B,UACvB,OAAO6P,EAAQ,GAAGjM,KAAQiM,IAAUjM,C,EAGvB8P,EAAUyC,WAAG,EAzKjB0Q,EAAAnT,SAAQA,EAkLRmT,EAAAlT,gBAAkB,IAAID,EAKtBmT,EAAiBuG,kBAAG,sBAClC,CAleD,CAAiBvG,MAkehB,KAKD,SAAUlqB,GAIKA,EAAc0wB,eAAG,EAKjB1wB,EAAgB2wB,iBAAG,GAyHhB3wB,EAAA2E,WAAhB,WACE,IAAID,EAAO+G,SAASC,cAAc,OAC9B0Q,EAAU3Q,SAASC,cAAc,MACrC0Q,EAAQpS,aAAa,OAAQ,WAC7BoS,EAAQ5Y,UAAY,oBACpBkB,EAAKoN,YAAYsK,GAEjB,IAAIjV,EAAMsE,SAASC,cAAc,OAKjC,OAJAvE,EAAI3D,UAAY,oCAChB2D,EAAI6C,aAAa,WAAY,MAC7B7C,EAAI6C,aAAa,OAAQ,UACzBtF,EAAKoN,YAAY3K,GACVzC,C,EAMO1E,EAAAusB,QAAhB,SAA2B1oB,GACzB,OAAOA,aAAiB1B,EAAQ0B,EAAQ,IAAI1B,EAAS0B,E,EAMvC7D,EAAA8vB,wBAAhB,SAAwChC,GACtC,IAAI3nB,EAAQqQ,OAAOC,iBAAiBqX,GACpC,OAAO,KAAQ8C,WAAWzqB,EAAM0qB,qBAAwB,E,EAM1C7wB,EAAAyvB,cAAhB,SACE5B,EACAtd,GAEA,IAAI3J,EAAS,IAAI2V,MAAkBsR,EAAKvtB,QACxC,IAAK,IAAIM,EAAI,EAAGiB,EAAIgsB,EAAKvtB,OAAQM,EAAIiB,IAAKjB,EAAG,CAC3C,IAAI8D,EAAOmpB,EAAKjtB,GACZuF,EAAQqQ,OAAOC,iBAAiB/R,GAElCkC,EAAOhG,GADW,eAAhB2P,EACU,CACVuG,IAAKpS,EAAK8M,WACV3R,KAAM6E,EAAKoO,YACXge,OAAQF,WAAWzqB,EAAM4qB,aAAgB,GAG/B,CACVja,IAAKpS,EAAK+M,UACV5R,KAAM6E,EAAKqO,aACX+d,OAAQF,WAAWzqB,EAAM6qB,YAAe,EAG7C,CACD,OAAOpqB,C,EAMO5G,EAAAsvB,aAAhB,SAA6Bza,EAAiBU,GAC5C,IAAI0b,EAAKhwB,KAAK8S,IAAIwB,EAAMe,QAAUzB,EAAK6Z,QACnCwC,EAAKjwB,KAAK8S,IAAIwB,EAAMgB,QAAU1B,EAAK8Z,QACvC,OAAOsC,GAAMjxB,EAAA0wB,gBAAkBQ,GAAMlxB,EAAA0wB,c,EAMvB1wB,EAAA0vB,eAAhB,SAA+B7a,EAAiBU,GAC9C,IAAIa,EAAOvB,EAAKoa,YAChB,OACE1Z,EAAMe,QAAUF,EAAKzI,KAAO3N,EAAA2wB,kBAC5Bpb,EAAMe,SAAWF,EAAKoS,MAAQxoB,EAAA2wB,kBAC9Bpb,EAAMgB,QAAUH,EAAK1I,IAAM1N,EAAA2wB,kBAC3Bpb,EAAMgB,SAAWH,EAAKsS,OAAS1oB,EAAA2wB,gB,EAOnB3wB,EAAA2vB,WAAhB,SACE9B,EACAhZ,EACAU,EACAhF,GAGA,IAAI4gB,EACAC,EACAC,EACAC,EACgB,eAAhB/gB,GACF4gB,EAAWtc,EAAK6Z,OAChB0C,EAAW7b,EAAMe,QAAUzB,EAAKoa,YAAathB,KAC7C0jB,EAAY9b,EAAMe,QAClBgb,EAAazc,EAAKoa,YAAankB,QAE/BqmB,EAAWtc,EAAK8Z,OAChByC,EAAW7b,EAAMgB,QAAU1B,EAAKoa,YAAavhB,IAC7C2jB,EAAY9b,EAAMgB,QAClB+a,EAAazc,EAAKoa,YAAalkB,QAIjC,IAAIgkB,EAAcla,EAAKpT,MACnB8vB,EAAYH,EAAWvc,EAAKia,YAC5B0C,EAAYD,EAAY1c,EAAKga,QAGjC,IAAK,IAAIjuB,EAAI,EAAGiB,EAAIgsB,EAAKvtB,OAAQM,EAAIiB,IAAKjB,EAAG,CAC3C,IAAI6wB,EACA7qB,EAASiO,EAAKma,UAAWpuB,GACzB8wB,EAAY9qB,EAAOkQ,KAAOlQ,EAAO/G,MAAQ,GAC7C,GAAIe,EAAIiU,EAAKpT,OAAS8vB,EAAYG,EAChCD,EAAQ,GAAG5c,EAAKga,QAAUha,EAAKma,UAAWpuB,EAAI,GAAGkwB,WACjD/B,EAAc9tB,KAAKH,IAAIiuB,EAAanuB,QAC/B,GAAIA,EAAIiU,EAAKpT,OAAS+vB,EAAYE,EACvCD,GAAY5c,EAAKga,QAAUjoB,EAAOkqB,OAA1B,KACR/B,EAAc9tB,KAAKF,IAAIguB,EAAanuB,QAC/B,GAAIA,IAAMiU,EAAKpT,MAAO,CAC3B,IAAIkwB,EAAQN,EAAYF,EACpBpvB,EAAQuvB,GAAczc,EAAK+Z,OAAS/Z,EAAKga,SAC7C4C,EAAQ,GAAGxwB,KAAKF,KAAK8T,EAAK+Z,OAAQ3tB,KAAKH,IAAI6wB,EAAO5vB,OACnD,MACC0vB,EAAQ,GAEU,eAAhBlhB,EACDsd,EAAKjtB,GAAmBuF,MAAMwH,KAAO8jB,EAErC5D,EAAKjtB,GAAmBuF,MAAMuH,IAAM+jB,CAExC,CAGD5c,EAAKka,YAAcA,C,EAML/uB,EAAA4vB,oBAAhB,SACE/a,EACAtE,GAGA,IAAI+gB,EAQAK,EACJ,GAPEL,EADkB,eAAhB/gB,EACWsE,EAAKoa,YAAankB,MAElB+J,EAAKoa,YAAalkB,OAK7B8J,EAAKka,cAAgBla,EAAKpT,MAC5BkwB,EAAQ,OACH,GAAI9c,EAAKka,YAAcla,EAAKpT,MAAO,CACxC,IAAImwB,EAAM/c,EAAKma,UAAWna,EAAKka,aAC/B4C,EAAQC,EAAI9a,IAAM8a,EAAI/xB,KAAOgV,EAAKga,QAAUha,EAAK+Z,MAClD,KAAM,CAEL+C,EADU9c,EAAKma,UAAWna,EAAKka,aACnBjY,IAAMjC,EAAK+Z,MACxB,CAGD,IAAI7sB,EAAQuvB,GAAczc,EAAK+Z,OAAS/Z,EAAKga,SACzCgD,EAAQ5wB,KAAKF,KAAK8T,EAAK+Z,OAAQ3tB,KAAKH,IAAI6wB,EAAO5vB,IAG/B,eAAhBwO,EACFsE,EAAKiZ,IAAI3nB,MAAMwH,KAAO,GAAGkkB,MAEzBhd,EAAKiZ,IAAI3nB,MAAMuH,IAAM,GAAGmkB,K,EAOZ7xB,EAAA+vB,kBAAhB,SACElC,EACAtd,GAEA,IAAK,MAAMud,KAAOD,EACI,eAAhBtd,EACDud,EAAoB3nB,MAAMwH,KAAO,GAEjCmgB,EAAoB3nB,MAAMuH,IAAM,E,CAIxC,CApUD,CAAU1N,MAoUT,KChnEK,MAAO8xB,UAAmBlmB,EAM9BtM,YAAY8C,GACVwI,QAumCMrL,KAAQsQ,SAAG,EACXtQ,KAAMuQ,QAAG,EACTvQ,KAAKwyB,MAA8B,KACnCxyB,KAAI4Q,KAAiC,KAGrC5Q,KAAA0Q,OAA0B,IAAI+hB,IA5mCpCzyB,KAAK+Q,SAAWlO,EAAQkO,cACA7N,IAApBL,EAAQqO,UACVlR,KAAKsQ,SAAW5P,EAAMsP,eAAenN,EAAQqO,UAE/ClR,KAAKurB,UAAY1oB,EAAQqJ,UAAYA,SACrClM,KAAKgF,iBACoB9B,IAAvBL,EAAQ4D,WACJ5D,EAAQ4D,WACR9B,EAAOM,WAAWC,O,CAS1BT,UAEE,IAAIsK,EAAU/O,KAAKgP,OAAOC,YAG1BjP,KAAK0Q,OAAOsI,SAAQ7H,IAClBA,EAAK1M,SAAS,IAIhBzE,KAAK4Q,KAAO,KACZ5Q,KAAKwyB,MAAQ,KACbxyB,KAAK0Q,OAAOqR,QAGZ,IAAK,MAAMva,KAAUuH,EACnBvH,EAAO/C,UAIT4G,MAAM5G,S,CAeJgC,iBACF,OAAOzG,KAAKgF,W,CAEVyB,eAAWyN,GACb,GAAIlU,KAAKgF,cAAgBkP,EAAzB,CAGAlU,KAAKgF,YAAckP,EACnB,IAAK,MAAMwe,KAAO1yB,KAAK2yB,UACrB,GAAID,EAAI9d,OAAO7T,OAAS,EACtB,IAAK,MAAM6E,KAAS8sB,EAAI9d,OACtBhP,EAAMlC,MAAM+C,WAAazG,KAAKgF,WALnC,C,CAcCkM,cACF,OAAOlR,KAAKsQ,Q,CAMVY,YAAQ5M,GACVA,EAAQ5D,EAAMsP,eAAe1L,GACzBtE,KAAKsQ,WAAahM,IAGtBtE,KAAKsQ,SAAWhM,EACXtE,KAAKyF,QAGVzF,KAAKyF,OAAO4C,M,CAMVuqB,cACF,OAAsB,OAAf5yB,KAAKwyB,K,CAWd,CAACxjB,OAAOC,YACN,OAAOjP,KAAKwyB,MAAQxyB,KAAKwyB,MAAMK,iBAAmBC,S,CAWpD/jB,UACE,OAAO/O,KAAKwyB,MAAQxyB,KAAKwyB,MAAMO,kBAAoBD,S,CAYrDE,kBACE,OAAOhzB,KAAKwyB,MAAQxyB,KAAKwyB,MAAMS,sBAAwBH,S,CAWzDH,UACE,OAAO3yB,KAAKwyB,MAAQxyB,KAAKwyB,MAAMU,cAAgBJ,S,CAQjD1hB,UACE,OAAOpR,KAAKwyB,MAAQxyB,KAAKwyB,MAAMW,cAAgBL,S,CAuBjD/gB,WAAWC,EAAwBohB,EAAiBC,GAElD,IAAIlqB,EAAS6I,EAAOrK,UAAUb,SAAS,iBACvC,IAAK9G,KAAKwyB,OAASrpB,EACjB,OAIF,IAMIhH,EANAmT,EAAOtV,KAAKwyB,MAAMc,cAActhB,GAC/BsD,IAOHnT,EAD4B,eAA1BmT,EAAKnQ,KAAK6L,YACJoiB,EAAUphB,EAAOC,WAEjBohB,EAAUrhB,EAAOE,UAIb,IAAV/P,IAKJmT,EAAKnQ,KAAKouB,YAGV/yB,YAAUyB,OAAOqT,EAAKnQ,KAAKvE,OAAQ0U,EAAKpT,MAAOC,GAG3CnC,KAAKyF,QACPzF,KAAKyF,OAAOyC,U,CAahBsrB,aAEE,OAAKxzB,KAAKwyB,OAKVxyB,KAAKwyB,MAAMiB,eAGJ,CAAEC,KAAM1zB,KAAKwyB,MAAMmB,iBAPjB,CAAED,KAAM,K,CAmBnBE,cAAcC,GAEZ,IAGIC,EAHAC,EAAY,IAAIC,IAKlBF,EADED,EAAOH,KACIjzB,EAAQwzB,oBAAoBJ,EAAOH,KAAMK,GAEzC,KAIf,IAAIG,EAAal0B,KAAK+O,UAClBolB,EAAan0B,KAAK2yB,UAClByB,EAAap0B,KAAKoR,UAGtBpR,KAAKwyB,MAAQ,KAGb,IAAK,MAAMhrB,KAAU0sB,EACdH,EAAUM,IAAI7sB,KACjBA,EAAO/B,OAAS,MAKpB,IAAK,MAAM6uB,KAAUH,EACnBG,EAAO7vB,UAIT,IAAK,MAAMuN,KAAUoiB,EACfpiB,EAAOjG,YACTiG,EAAOjG,WAAWC,YAAYgG,GAKlC,IAAK,MAAMxK,KAAUusB,EACnBvsB,EAAO/B,OAASzF,KAAKyF,OAKrBzF,KAAKwyB,MADHsB,EACWrzB,EAAQ8zB,kBACnBT,EACA,CAEEU,aAAetoB,GACblM,KAAKy0B,gBACPtiB,aAAc,IAAMnS,KAAK00B,iBAE3B10B,KAAKurB,WAGM,KAIVvrB,KAAKyF,SAKVsuB,EAAU/a,SAAQxR,IAChBxH,KAAKwP,aAAahI,EAAO,IAI3BxH,KAAKyF,OAAO4C,M,CAed6G,UAAU1H,EAAgB3E,EAAkC,IAE1D,IAAI+I,EAAM/I,EAAQ+I,KAAO,KACrB+oB,EAAO9xB,EAAQ8xB,MAAQ,YAGvBC,EAAwC,KAM5C,GALI50B,KAAKwyB,OAAS5mB,IAChBgpB,EAAU50B,KAAKwyB,MAAMqC,YAAYjpB,IAI/BA,IAAQgpB,EACV,MAAM,IAAI7tB,MAAM,0CAOlB,OAHAS,EAAO/B,OAASzF,KAAKyF,OAGbkvB,GACN,IAAK,YACH30B,KAAK80B,WAAWttB,EAAQoE,EAAKgpB,GAAS,GACtC,MACF,IAAK,aACH50B,KAAK80B,WAAWttB,EAAQoE,EAAKgpB,GAAS,GACtC,MACF,IAAK,YACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,YAAY,GACpD,MACF,IAAK,aACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,cAAc,GACtD,MACF,IAAK,cACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,cAAc,GACtD,MACF,IAAK,eACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,YAAY,GACpD,MACF,IAAK,YACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,YAAY,GAAO,GAC3D,MACF,IAAK,aACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,cAAc,GAAO,GAC7D,MACF,IAAK,cACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,cAAc,GAAM,GAC5D,MACF,IAAK,eACH50B,KAAK+0B,aAAavtB,EAAQoE,EAAKgpB,EAAS,YAAY,GAAM,GAKzD50B,KAAKyF,SAKVzF,KAAKwP,aAAahI,GAGlBxH,KAAKyF,OAAO4C,M,CAgBd0E,aAAavF,GAEXxH,KAAKg1B,cAAcxtB,GAGdxH,KAAKyF,SAKVzF,KAAK6P,aAAarI,GAGlBxH,KAAKyF,OAAO4C,M,CAad4sB,gBACEle,EACAC,GAGA,IAAKhX,KAAKwyB,QAAUxyB,KAAKyF,SAAWzF,KAAKyF,OAAOW,UAC9C,OAAO,KAIJpG,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAON,OAI/C,IAAI0R,EAAO7W,KAAKyF,OAAON,KAAK2R,wBACxB8N,EAAI7N,EAAUF,EAAKzI,KAAOpO,KAAK4Q,KAAKskB,WACpCrQ,EAAI7N,EAAUH,EAAK1I,IAAMnO,KAAK4Q,KAAKsY,UAGnCiM,EAAUn1B,KAAKwyB,MAAM4C,gBAAgBxQ,EAAGC,GAG5C,IAAKsQ,EACH,OAAO,KAIT,IAAIb,OAAEA,EAAMnmB,IAAEA,EAAGC,KAAEA,EAAI7C,MAAEA,EAAKC,OAAEA,GAAW2pB,EAGvCE,EAAcr1B,KAAK4Q,KAAKskB,WAAal1B,KAAK4Q,KAAK0kB,YAC/CC,EAAev1B,KAAK4Q,KAAKsY,UAAYlpB,KAAK4Q,KAAKwY,aAKnD,MAAO,CAAEkL,SAAQ1P,IAAGC,IAAG1W,MAAKC,OAAM6a,MAJtBpS,EAAKtL,MAAQ8pB,GAAejnB,EAAO7C,GAIN4d,OAH5BtS,EAAKrL,OAAS+pB,GAAgBpnB,EAAM3C,GAGAD,QAAOC,S,CAMhDgB,OAERnB,MAAMmB,OAGN,IAAK,MAAMhF,KAAUxH,KACnBA,KAAKwP,aAAahI,GAIpB,IAAK,MAAMwK,KAAUhS,KAAKoR,UACxBpR,KAAKyF,OAAQN,KAAKoN,YAAYP,GAIhChS,KAAKyF,OAAQ4C,K,CAWLmH,aAAahI,GAEjBxH,KAAKyF,OAAQN,OAASqC,EAAOrC,KAAK4G,aAKtC/L,KAAK0Q,OAAOvD,IAAI3F,EAAQ,IAAI+F,EAAW/F,IAGnCxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,a,CAYrC6E,aAAarI,GAErB,GAAIxH,KAAKyF,OAAQN,OAASqC,EAAOrC,KAAK4G,WACpC,OAIE/L,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7C,IAAIiG,EAAOnR,KAAK0Q,OAAOnK,IAAIiB,GACvB2J,IACFnR,KAAK0Q,OAAO8kB,OAAOhuB,GACnB2J,EAAK1M,U,CAOCkF,aAAa3C,GACrBqE,MAAM1B,aAAa3C,GACnBhH,KAAKyF,OAAQyC,Q,CAML6B,eAAe/C,GACvBqE,MAAMtB,eAAe/C,GACrBhH,KAAKyF,OAAQ4C,K,CAMLwE,aAAa7F,GACrBhH,KAAKyF,OAAQ4C,K,CAMLyE,cAAc9F,GACtBhH,KAAKyF,OAAQ4C,K,CAMLmB,SAASxC,GACbhH,KAAKyF,OAAQW,WACfpG,KAAKwS,QAAQxL,EAAIuE,MAAOvE,EAAIwE,O,CAOtB/B,gBAAgBzC,GACpBhH,KAAKyF,OAAQW,WACfpG,KAAKwS,SAAS,GAAI,E,CAOZ9I,aAAa1C,GACjBhH,KAAKyF,OAAQC,YACf1F,KAAKyS,M,CAYDuiB,cAAcxtB,GAEpB,IAAKxH,KAAKwyB,MACR,OAIF,IAAI2C,EAAUn1B,KAAKwyB,MAAMqC,YAAYrtB,GAGrC,IAAK2tB,EACH,OAMF,GAHA10B,EAAQg1B,WAAWjuB,GAGf2tB,EAAQb,OAAO1f,OAAO7T,OAAS,EAAG,CAEpC,GADAo0B,EAAQb,OAAOnH,UAAU3lB,EAAO5B,OAE9B5F,KAAKgF,cAAgBL,EAAOM,WAAW0B,OACP,GAAhCwuB,EAAQb,OAAO1f,OAAO7T,OACtB,CACuBo0B,EAAQb,OAAO1f,OAAO,GAAGlR,MACjC+C,WAAa9B,EAAOM,WAAWC,OAC/C,CACD,MACD,CAQD,GAHAiwB,EAAQb,OAAO7vB,UAGXzE,KAAKwyB,QAAU2C,EAEjB,YADAn1B,KAAKwyB,MAAQ,MAOfxyB,KAAKwyB,MAAMiB,eAGX,IAAIiC,EAAYP,EAAQ1vB,OACxB0vB,EAAQ1vB,OAAS,KAGjB,IAAIpE,EAAIiO,WAASqmB,cAAcD,EAAUnuB,SAAU4tB,GAC/CnjB,EAAS1C,WAASM,SAAS8lB,EAAUtkB,QAAS/P,GASlD,GARAiO,WAASM,SAAS8lB,EAAU90B,OAAQS,GAGhC2Q,EAAOjG,YACTiG,EAAOjG,WAAWC,YAAYgG,GAI5B0jB,EAAUnuB,SAASxG,OAAS,EAE9B,YADA20B,EAAUE,cAOZ,IAAIC,EAAcH,EAAUjwB,OAC5BiwB,EAAUjwB,OAAS,KAGnB,IAAIqwB,EAAYJ,EAAUnuB,SAAS,GAC/BwuB,EAAcL,EAAUtkB,QAAQ,GAapC,GAVAskB,EAAUnuB,SAASxG,OAAS,EAC5B20B,EAAUtkB,QAAQrQ,OAAS,EAC3B20B,EAAU90B,OAAOG,OAAS,EAGtBg1B,EAAYhqB,YACdgqB,EAAYhqB,WAAWC,YAAY+pB,GAIjC/1B,KAAKwyB,QAAUkD,EAGjB,OAFAI,EAAUrwB,OAAS,UACnBzF,KAAKwyB,MAAQsD,GAKf,IAAI/pB,EAAa8pB,EAGbxmB,EAAItD,EAAWxE,SAAS6H,QAAQsmB,GAGpC,GAAII,aAAqBr1B,EAAQu1B,cAG/B,OAFAF,EAAUrwB,OAASsG,OACnBA,EAAWxE,SAAS8H,GAAKymB,GAK3B,IAAIG,EAAc3mB,WAASM,SAAS7D,EAAWqF,QAAS/B,GACxDC,WAASM,SAAS7D,EAAWxE,SAAU8H,GACvCC,WAASM,SAAS7D,EAAWnL,OAAQyO,GAGjC4mB,EAAYlqB,YACdkqB,EAAYlqB,WAAWC,YAAYiqB,GAKrC,IAAK,IAAI50B,EAAI,EAAGiB,EAAIwzB,EAAUvuB,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACzD,IAAI60B,EAASJ,EAAUvuB,SAASlG,GAC5B80B,EAAUL,EAAU1kB,QAAQ/P,GAC5B+0B,EAASN,EAAUl1B,OAAOS,GAC9BiO,WAASC,OAAOxD,EAAWxE,SAAU8H,EAAIhO,EAAG60B,GAC5C5mB,WAASC,OAAOxD,EAAWqF,QAAS/B,EAAIhO,EAAG80B,GAC3C7mB,WAASC,OAAOxD,EAAWnL,OAAQyO,EAAIhO,EAAG+0B,GAC1CF,EAAOzwB,OAASsG,CACjB,CAGD+pB,EAAUvuB,SAASxG,OAAS,EAC5B+0B,EAAU1kB,QAAQrQ,OAAS,EAC3B+0B,EAAUl1B,OAAOG,OAAS,EAC1B+0B,EAAUrwB,OAAS,KAGnBsG,EAAW6pB,a,CAMLS,eAAe7uB,GACrB,IAAI2tB,EAAU,IAAI10B,EAAQu1B,cAAch2B,KAAKy0B,iBAG7C,OAFAU,EAAQb,OAAOxH,OAAOtlB,EAAO5B,OAC7BnF,EAAQ61B,QAAQ9uB,EAAQ2tB,EAAQb,QACzBa,C,CASDL,WACNttB,EACAoE,EACAgpB,EACA2B,GAGA,GAAI/uB,IAAWoE,EACb,OAIF,IAAK5L,KAAKwyB,MAAO,CACf,IAAI2C,EAAU,IAAI10B,EAAQu1B,cAAch2B,KAAKy0B,iBAI7C,OAHAU,EAAQb,OAAOxH,OAAOtlB,EAAO5B,OAC7B5F,KAAKwyB,MAAQ2C,OACb10B,EAAQ61B,QAAQ9uB,EAAQ2tB,EAAQb,OAEjC,CAeD,IAAIpyB,EASJ,GArBK0yB,IACHA,EAAU50B,KAAKwyB,MAAMgE,qBAK8B,IAAjD5B,EAAQN,OAAO1f,OAAOxF,QAAQ5H,EAAO5B,SACvC5F,KAAKg1B,cAAcxtB,GACnBA,EAAOuB,QAMP7G,EADE0J,EACMgpB,EAAQN,OAAO1f,OAAOxF,QAAQxD,EAAIhG,OAElCgvB,EAAQN,OAAOjI,aAKrBrsB,KAAKgF,cAAgBL,EAAOM,WAAW0B,MACzC,GAAqC,IAAjCiuB,EAAQN,OAAO1f,OAAO7T,OAExByG,EAAOf,WAAa9B,EAAOM,WAAWC,aACjC,GAAoC,GAAhC0vB,EAAQN,OAAO1f,OAAO7T,OAAa,CAErB6zB,EAAQN,OAAO1f,OAAO,GAAGlR,MACjC+C,WAAa9B,EAAOM,WAAW0B,KAC/C,MAECa,EAAOf,WAAa9B,EAAOM,WAAW0B,WAIxCa,EAAOf,WAAazG,KAAKgF,YAI3B4vB,EAAQN,OAAOvH,UAAU7qB,GAASq0B,EAAQ,EAAI,GAAI/uB,EAAO5B,OACzDnF,EAAQ61B,QAAQ9uB,EAAQotB,EAAQN,O,CAS1BS,aACNvtB,EACAoE,EACAgpB,EACA5jB,EACAulB,EACAE,GAAiB,GAGjB,GAAIjvB,IAAWoE,GAAOgpB,GAA4C,IAAjCA,EAAQN,OAAO1f,OAAO7T,OACrD,OAOF,GAHAf,KAAKg1B,cAAcxtB,IAGdxH,KAAKwyB,MAER,YADAxyB,KAAKwyB,MAAQxyB,KAAKq2B,eAAe7uB,IAKnC,IAAKotB,IAAYA,EAAQnvB,OAAQ,CAE/B,IAAIixB,EAAO12B,KAAK22B,WAAW3lB,GAGvB3P,EAAIk1B,EAAQG,EAAKnvB,SAASxG,OAAS,EAGvC21B,EAAKE,iBAGL,IAAIt1B,EAAQb,EAAQ6R,YAAYsiB,EAAU,EAAIn0B,EAAQo2B,cAGlD1B,EAAUn1B,KAAKq2B,eAAe7uB,GAWlC,OAVA8H,WAASC,OAAOmnB,EAAKnvB,SAAUlG,EAAG8zB,GAClC7lB,WAASC,OAAOmnB,EAAK91B,OAAQS,EAAGC,GAChCgO,WAASC,OAAOmnB,EAAKtlB,QAAS/P,EAAGrB,KAAK00B,iBACtCS,EAAQ1vB,OAASixB,EAGjBA,EAAKE,sBAGLF,EAAKd,aAEN,CAGD,IAAIF,EAAYd,EAAQnvB,OAIxB,GAAIiwB,EAAU1kB,cAAgBA,EAAa,CAEzC,IAAI3P,EAAIq0B,EAAUnuB,SAAS6H,QAAQwlB,GAGnC,GAAI6B,EAAO,CACT,IAAIpnB,EAAIhO,GAAKk1B,EAAQ,GAAK,GACtBO,EAAUpB,EAAUnuB,SAAS8H,GACjC,GAAIynB,aAAmBr2B,EAAQu1B,cAG7B,OAFAh2B,KAAK80B,WAAWttB,EAAQ,KAAMsvB,GAAS,SACrCA,EAAQxC,OAAOjI,YAGpB,CAGDqJ,EAAUkB,iBAGV,IAAIziB,EAAKuhB,EAAU90B,OAAOS,GAAGpB,UAAY,EAGrCoP,EAAIhO,GAAKk1B,EAAQ,EAAI,GACrBpB,EAAUn1B,KAAKq2B,eAAe7uB,GAQlC,OAPA8H,WAASC,OAAOmmB,EAAUnuB,SAAU8H,EAAG8lB,GACvC7lB,WAASC,OAAOmmB,EAAU90B,OAAQyO,EAAG5O,EAAQ6R,YAAY6B,IACzD7E,WAASC,OAAOmmB,EAAUtkB,QAAS/B,EAAGrP,KAAK00B,iBAC3CS,EAAQ1vB,OAASiwB,OAGjBA,EAAUE,aAEX,CAGD,IAAIv0B,EAAIiO,WAASqmB,cAAcD,EAAUnuB,SAAUqtB,GAG/CkB,EAAY,IAAIr1B,EAAQs2B,gBAAgB/lB,GAC5C8kB,EAAUkB,YAAa,EAGvBlB,EAAUvuB,SAASsK,KAAK+iB,GACxBkB,EAAUl1B,OAAOiR,KAAKpR,EAAQ6R,YAAY,KAC1CwjB,EAAU1kB,QAAQS,KAAK7R,KAAK00B,iBAC5BE,EAAQnvB,OAASqwB,EAGjB,IAAIzmB,EAAIknB,EAAQ,EAAI,EAChBpB,EAAUn1B,KAAKq2B,eAAe7uB,GAClC8H,WAASC,OAAOumB,EAAUvuB,SAAU8H,EAAG8lB,GACvC7lB,WAASC,OAAOumB,EAAUl1B,OAAQyO,EAAG5O,EAAQ6R,YAAY,KACzDhD,WAASC,OAAOumB,EAAU1kB,QAAS/B,EAAGrP,KAAK00B,iBAC3CS,EAAQ1vB,OAASqwB,EAGjBA,EAAUF,cAGVtmB,WAASC,OAAOmmB,EAAUnuB,SAAUlG,EAAGy0B,GACvCA,EAAUrwB,OAASiwB,C,CAMbiB,WACN3lB,GAGA,IAAIimB,EAAUj3B,KAAKwyB,MACnB,GAAIyE,aAAmBx2B,EAAQs2B,iBACzBE,EAAQjmB,cAAgBA,EAC1B,OAAOimB,EAKX,IAAIC,EAAWl3B,KAAKwyB,MAAQ,IAAI/xB,EAAQs2B,gBAAgB/lB,GAWxD,OARIimB,IACFC,EAAQ3vB,SAASsK,KAAKolB,GACtBC,EAAQt2B,OAAOiR,KAAKpR,EAAQ6R,YAAY,IACxC4kB,EAAQ9lB,QAAQS,KAAK7R,KAAK00B,iBAC1BuC,EAAQxxB,OAASyxB,GAIZA,C,CAMDzkB,OAEN,IAAIO,EAAO,EACPC,EAAO,EAGX,GAAIjT,KAAKwyB,MAAO,CACd,IAAInkB,EAASrO,KAAKwyB,MAAMnqB,IAAIrI,KAAKsQ,SAAUtQ,KAAK0Q,QAChDsC,EAAO3E,EAAO5B,SACdwG,EAAO5E,EAAO3B,SACf,CAGD,IAAIyG,EAAOnT,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,MACzD6N,GAAQG,EAAIE,cACZJ,GAAQE,EAAIG,YAGZ,IAAI1M,EAAQ5G,KAAKyF,OAAQN,KAAKyB,MAC9BA,EAAM6F,SAAW,GAAGuG,MACpBpM,EAAM8F,UAAY,GAAGuG,MAGrBjT,KAAKuQ,QAAS,EAIVvQ,KAAKyF,OAAQA,QACfI,cAAYqB,YAAYlH,KAAKyF,OAAQA,OAASd,EAAOwC,IAAImB,YAKvDtI,KAAKuQ,QACP1K,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,c,CAS7CoK,QAAQe,EAAqBC,GAKnC,GAHAxT,KAAKuQ,QAAS,GAGTvQ,KAAKwyB,MACR,OAIEjf,EAAc,IAChBA,EAAcvT,KAAKyF,OAAQN,KAAKoO,aAE9BC,EAAe,IACjBA,EAAexT,KAAKyF,OAAQN,KAAKqO,cAI9BxT,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,OAIhD,IAAIyf,EAAI5kB,KAAK4Q,KAAK6C,WACdoR,EAAI7kB,KAAK4Q,KAAK8C,YACdnI,EAAQgI,EAAcvT,KAAK4Q,KAAKyC,cAChC7H,EAASgI,EAAexT,KAAK4Q,KAAK0C,YAGtCtT,KAAKwyB,MAAMtqB,OAAO0c,EAAGC,EAAGtZ,EAAOC,EAAQxL,KAAKsQ,SAAUtQ,KAAK0Q,O,CASrD+jB,gBAEN,IAAIH,EAASt0B,KAAK+Q,SAASyjB,aAAax0B,KAAKurB,WAW7C,OARA+I,EAAOtjB,YAAc,aAGjBhR,KAAKyF,QACPzF,KAAKwP,aAAa8kB,GAIbA,C,CASDI,gBAEN,IAAI1iB,EAAShS,KAAK+Q,SAASoB,eAGvBvL,EAAQoL,EAAOpL,MAcnB,OAbAA,EAAMqH,SAAW,WACjBrH,EAAMsH,QAAU,SAChBtH,EAAMuH,IAAM,IACZvH,EAAMwH,KAAO,IACbxH,EAAM2E,MAAQ,IACd3E,EAAM4E,OAAS,IAGXxL,KAAKyF,QACPzF,KAAKyF,OAAON,KAAKoN,YAAYP,GAIxBA,C,GAgUX,SAAUvR,GAwBR,SAAgB6R,EAAY7Q,GAC1B,IAAIH,EAAQ,IAAIxB,EAGhB,OAFAwB,EAAMrB,SAAWwB,EACjBH,EAAMhB,KAAOmB,EACNH,C,CAMT,SAAgB2yB,EACdJ,EACAE,GAEA,IAAI9W,EAMJ,OAJEA,EADkB,aAAhB4W,EAAOvqB,KAooBb,SACEuqB,EACAE,GAGA,GAA8B,IAA1BF,EAAO9kB,QAAQhO,OACjB,OAAO,KAIT,IAAIgO,EAAoB,GAGxB,IAAK,MAAMvH,KAAUqsB,EAAO9kB,QACrBglB,EAAUM,IAAI7sB,KACjBusB,EAAUnsB,IAAIJ,GACduH,EAAQ8C,KAAKrK,IAKjB,GAAuB,IAAnBuH,EAAQhO,OACV,OAAO,KAIT,IAAImB,EAAQ2xB,EAAOxH,cACJ,IAAXnqB,IAAiBA,EAAQ,GAAKA,GAAS6M,EAAQhO,UACjDmB,EAAQ,GAIV,MAAO,CAAEoH,KAAM,WAAYyF,UAASsd,aAAcnqB,E,CAnqBvCi1B,CAAuBtD,EAAQE,GAyqB5C,SACEF,EACAE,GAGA,IAAI/iB,EAAc6iB,EAAO7iB,YACrBzJ,EAAoC,GACpCmK,EAAkB,GAGtB,IAAK,IAAIrQ,EAAI,EAAGiB,EAAIuxB,EAAOtsB,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CAEtD,IAAI+J,EAAQ6oB,EAAoBJ,EAAOtsB,SAASlG,GAAI0yB,GAG/C3oB,IAKc,aAAfA,EAAM9B,MAAuB8B,EAAM4F,cAAgBA,GACrDzJ,EAASsK,KAAKzG,GACdsG,EAAMG,KAAKnQ,KAAK8S,IAAIqf,EAAOniB,MAAMrQ,IAAM,MAEvCkG,EAASsK,QAAQzG,EAAM7D,UACvBmK,EAAMG,QAAQzG,EAAMsG,QAEvB,CAGD,GAAwB,IAApBnK,EAASxG,OACX,OAAO,KAIT,GAAwB,IAApBwG,EAASxG,OACX,OAAOwG,EAAS,GAIlB,MAAO,CAAE+B,KAAM,aAAc0H,cAAazJ,WAAUmK,Q,CA/sBzC0lB,CAAyBvD,EAAQE,GAErC9W,C,CAMT,SAAgBsX,EACdV,EACA9iB,EACA7E,GAEA,IAAI/G,EAMJ,OAJEA,EADkB,aAAhB0uB,EAAOvqB,KAusBb,SACEuqB,EACA9iB,EACA7E,GAGA,IAAIooB,EAASvjB,EAASyjB,aAAatoB,GAGnC,IAAK,MAAM1E,KAAUqsB,EAAO9kB,QAC1BvH,EAAOuB,OACPurB,EAAOxH,OAAOtlB,EAAO5B,OACrBnF,EAAQ61B,QAAQ9uB,EAAQ8sB,GAO1B,OAHAA,EAAOjI,aAAewH,EAAOxH,aAGtB,IAAI2J,EAAc1B,E,CAztBhB+C,CAAqBxD,EAAQ9iB,EAAU7E,GA+tBlD,SACE2nB,EACA9iB,EACA7E,GAGA,IAAI/G,EAAO,IAAI4xB,EAAgBlD,EAAO7iB,aAyBtC,OAtBA6iB,EAAOtsB,SAASyR,SAAQ,CAAC5N,EAAO/J,KAE9B,IAAIy0B,EAAYvB,EAAkBnpB,EAAO2F,EAAU7E,GAC/C5K,EAAQgR,EAAYuhB,EAAOniB,MAAMrQ,IACjC2Q,EAASjB,EAASoB,eAGtBhN,EAAKoC,SAASsK,KAAKikB,GACnB3wB,EAAKiM,QAAQS,KAAKG,GAClB7M,EAAKvE,OAAOiR,KAAKvQ,GAGjBw0B,EAAUrwB,OAASN,CAAI,IAIzBA,EAAKywB,cAGLzwB,EAAKyxB,iBAGEzxB,C,CA5vBEmyB,CAAuBzD,EAAQ9iB,EAAU7E,GAE3C/G,C,CAzDI1E,EAAYo2B,aAAG,KAoBZp2B,EAAA6R,YAAWA,EAUX7R,EAAAwzB,oBAAmBA,EAgBnBxzB,EAAA8zB,kBAAiBA,EAiBjC,MAAayB,EAMXj2B,YAAYu0B,GAYZt0B,KAAMyF,OAA2B,KAyOzBzF,KAAIwN,KAAG,EACPxN,KAAK0N,MAAG,EACR1N,KAAM2N,OAAG,EACT3N,KAAO4N,QAAG,EAvPhB,IAAI2pB,EAAW,IAAIz3B,EACf03B,EAAc,IAAI13B,EACtBy3B,EAASl3B,QAAU,EACnBm3B,EAAYn3B,QAAU,EACtBL,KAAKs0B,OAASA,EACdt0B,KAAKY,OAAS,CAAC22B,EAAUC,E,CAqBvBrpB,UACF,OAAOnO,KAAKwN,I,CAMVY,WACF,OAAOpO,KAAK0N,K,CAMVnC,YACF,OAAOvL,KAAK2N,M,CAMVnC,aACF,OAAOxL,KAAK4N,O,CAMdilB,wBACQ7yB,KAAKs0B,aACJt0B,KAAK+yB,iB,CAMdA,mBACE,IAAK,MAAMntB,KAAS5F,KAAKs0B,OAAO1f,aACxBhP,EAAMlC,K,CAOhBuvB,uBACE,IAAIrtB,EAAQ5F,KAAKs0B,OAAOlI,aACpBxmB,UACIA,EAAMlC,M,CAOhBwvB,qBACQlzB,KAAKs0B,M,CAObnB,e,CAOA0B,YAAYrtB,GACV,OAAqD,IAA9CxH,KAAKs0B,OAAO1f,OAAOxF,QAAQ5H,EAAO5B,OAAgB5F,KAAO,I,CAMlEszB,cACEthB,GAEA,OAAO,I,CAMTwkB,mBACE,OAAOx2B,I,CAMTo1B,gBAAgBxQ,EAAWC,GACzB,OAAID,EAAI5kB,KAAK0N,OAASkX,GAAK5kB,KAAK0N,MAAQ1N,KAAK2N,QAGzCkX,EAAI7kB,KAAKwN,MAAQqX,GAAK7kB,KAAKwN,KAAOxN,KAAK4N,QAFlC,KAKF5N,I,CAMT2zB,eAGE,MAAO,CAAErqB,KAAM,WAAYyF,QAFb/O,KAAKs0B,OAAO1f,OAAOtD,KAAI1L,GAASA,EAAMlC,QAEhB2oB,aADjBrsB,KAAKs0B,OAAOjI,a,CASjCoH,e,CAOAprB,IAAI6I,EAAiBwK,GAEnB,IAAIjP,EAAW,EACXC,EAAY,EAKZ+qB,EAAa/b,EAAMnV,IAAIvG,KAAKs0B,QAG5BrG,EAAUjuB,KAAKs0B,OAAOlI,aACtBsL,EAAazJ,EAAUvS,EAAMnV,IAAI0nB,EAAQvqB,YAASR,GAGjDy0B,EAAaH,GAAex3B,KAAKY,OAmCtC,OAhCI62B,GACFA,EAAWpvB,MAITqvB,GACFA,EAAWrvB,MAITovB,IAAeA,EAAWvxB,UAC5BuG,EAAW/K,KAAKF,IAAIiL,EAAUgrB,EAAWhrB,UACzCC,GAAa+qB,EAAW/qB,UACxBirB,EAAYz3B,QAAUu3B,EAAW/qB,UACjCirB,EAAYx3B,QAAUs3B,EAAW7qB,YAEjC+qB,EAAYz3B,QAAU,EACtBy3B,EAAYx3B,QAAU,GAIpBu3B,IAAeA,EAAWxxB,UAC5BuG,EAAW/K,KAAKF,IAAIiL,EAAUirB,EAAWjrB,UACzCC,GAAagrB,EAAWhrB,UACxB8qB,EAAYt3B,QAAUw3B,EAAWhrB,UACjC8qB,EAAYr3B,QAAUC,MAEtBo3B,EAAYt3B,QAAU,EACtBs3B,EAAYr3B,QAAUC,KAIjB,CAAEqM,WAAUC,YAAWC,SA9CfvM,SA8CyBwM,UA7CxBxM,S,CAmDlB8H,OACEkG,EACAD,EACA5C,EACAC,EACA0F,EACAwK,GAGA1b,KAAKwN,KAAOW,EACZnO,KAAK0N,MAAQU,EACbpO,KAAK2N,OAASpC,EACdvL,KAAK4N,QAAUpC,EAGf,IAAIisB,EAAa/b,EAAMnV,IAAIvG,KAAKs0B,QAG5BrG,EAAUjuB,KAAKs0B,OAAOlI,aACtBsL,EAAazJ,EAAUvS,EAAMnV,IAAI0nB,EAAQvqB,YAASR,EAMtD,GAHA1C,YAAUG,KAAKX,KAAKY,OAAQ4K,GAGxBisB,IAAeA,EAAWvxB,SAAU,CACtC,IAAI5F,EAAON,KAAKY,OAAO,GAAGN,KAC1Bm3B,EAAWvvB,OAAOkG,EAAMD,EAAK5C,EAAOjL,GACpC6N,GAAO7N,CACR,CAGD,GAAIo3B,IAAeA,EAAWxxB,SAAU,CACtC,IAAI5F,EAAON,KAAKY,OAAO,GAAGN,KAC1Bo3B,EAAWxvB,OAAOkG,EAAMD,EAAK5C,EAAOjL,EACrC,C,EAxPQG,EAAAu1B,cAAaA,EAoQ1B,MAAae,EAMXh3B,YAAYiR,GAOZhR,KAAMyF,OAA2B,KAKjCzF,KAAUg3B,YAAG,EAUJh3B,KAAQuH,SAAiB,GAKzBvH,KAAMY,OAAe,GAKrBZ,KAAOoR,QAAqB,GA/BnCpR,KAAKgR,YAAcA,C,CAoCrB6hB,kBACE,IAAK,MAAMznB,KAASpL,KAAKuH,eAChB6D,EAAMynB,gB,CAOjBE,mBACE,IAAK,MAAM3nB,KAASpL,KAAKuH,eAChB6D,EAAM2nB,iB,CAOjBE,uBACE,IAAK,MAAM7nB,KAASpL,KAAKuH,eAChB6D,EAAM6nB,qB,CAOjBC,eACE,IAAK,MAAM9nB,KAASpL,KAAKuH,eAChB6D,EAAM8nB,a,CAOjBC,qBACSnzB,KAAKoR,QACZ,IAAK,MAAMhG,KAASpL,KAAKuH,eAChB6D,EAAM+nB,a,CAOjB0B,YAAYrtB,GACV,IAAK,IAAInG,EAAI,EAAGiB,EAAItC,KAAKuH,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACpD,IAAI4b,EAASjd,KAAKuH,SAASlG,GAAGwzB,YAAYrtB,GAC1C,GAAIyV,EACF,OAAOA,CAEV,CACD,OAAO,I,CAMTqW,cACEthB,GAEA,IAAI9P,EAAQlC,KAAKoR,QAAQhC,QAAQ4C,GACjC,IAAe,IAAX9P,EACF,MAAO,CAAEA,QAAOiD,KAAMnF,MAExB,IAAK,IAAIqB,EAAI,EAAGiB,EAAItC,KAAKuH,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACpD,IAAI4b,EAASjd,KAAKuH,SAASlG,GAAGiyB,cAActhB,GAC5C,GAAIiL,EACF,OAAOA,CAEV,CACD,OAAO,I,CAMTuZ,mBACE,OAA6B,IAAzBx2B,KAAKuH,SAASxG,OACT,KAEFf,KAAKuH,SAAS,GAAGivB,kB,CAM1BpB,gBAAgBxQ,EAAWC,GACzB,IAAK,IAAIxjB,EAAI,EAAGiB,EAAItC,KAAKuH,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACpD,IAAI4b,EAASjd,KAAKuH,SAASlG,GAAG+zB,gBAAgBxQ,EAAGC,GACjD,GAAI5H,EACF,OAAOA,CAEV,CACD,OAAO,I,CAMT0W,eACE,IAAI3iB,EAAchR,KAAKgR,YACnBU,EAAQ1R,KAAK43B,wBAEjB,MAAO,CAAEtuB,KAAM,aAAc0H,cAAazJ,SAD3BvH,KAAKuH,SAAS+J,KAAIlG,GAASA,EAAMuoB,iBACIjiB,Q,CAMtDkkB,cACE51B,KAAKoR,QAAQ4H,SAAQ,CAAChH,EAAQ3Q,KAC5B2Q,EAAOvH,aAAa,mBAAoBzK,KAAKgR,aACzC3P,IAAMrB,KAAKoR,QAAQrQ,OAAS,EAC9BiR,EAAOrK,UAAUC,IAAI,iBAErBoK,EAAOrK,UAAUG,OAAO,gBACzB,G,CASLyrB,YACE,IAAK,MAAMjyB,KAAStB,KAAKY,OACvBU,EAAMrB,SAAWqB,EAAMhB,I,CAS3BmzB,eACE,IAAK,MAAMroB,KAASpL,KAAKuH,SACvB6D,EAAMqoB,eAERzzB,KAAKuzB,W,CAMPqD,iBAEE,IAAIt0B,EAAItC,KAAKY,OAAOG,OACpB,GAAU,IAANuB,EACF,OAIFtC,KAAKuzB,YAGL,IAAIlf,EAAMrU,KAAKY,OAAOqT,QAAO,CAACC,EAAG5S,IAAU4S,EAAI5S,EAAMrB,UAAU,GAG/D,GAAY,IAARoU,EACF,IAAK,MAAM/S,KAAStB,KAAKY,OACvBU,EAAMhB,KAAOgB,EAAMrB,SAAW,EAAIqC,OAGpC,IAAK,MAAMhB,KAAStB,KAAKY,OACvBU,EAAMhB,KAAOgB,EAAMrB,UAAYoU,EAKnCrU,KAAKg3B,YAAa,C,CAMpBY,wBAEE,IAAIt1B,EAAItC,KAAKY,OAAOG,OACpB,GAAU,IAANuB,EACF,MAAO,GAIT,IAAIoP,EAAQ1R,KAAKY,OAAO0Q,KAAIhQ,GAASA,EAAMhB,OAGvC+T,EAAM3C,EAAMuC,QAAO,CAACC,EAAG5T,IAAS4T,EAAI5T,GAAM,GAG9C,GAAY,IAAR+T,EACF,IAAK,IAAIhT,EAAIqQ,EAAM3Q,OAAS,EAAGM,GAAK,EAAGA,IACrCqQ,EAAMrQ,GAAK,EAAIiB,OAGjB,IAAK,IAAIjB,EAAIqQ,EAAM3Q,OAAS,EAAGM,GAAK,EAAGA,IACrCqQ,EAAMrQ,IAAMgT,EAKhB,OAAO3C,C,CAMTrJ,IAAI6I,EAAiBwK,GAEnB,IAAImc,EAAkC,eAArB73B,KAAKgR,YAClB8mB,EAAQp2B,KAAKF,IAAI,EAAGxB,KAAKuH,SAASxG,OAAS,GAAKmQ,EAGhDzE,EAAWorB,EAAaC,EAAQ,EAChCprB,EAAYmrB,EAAa,EAAIC,EAKjC,IAAK,IAAIz2B,EAAI,EAAGiB,EAAItC,KAAKuH,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACpD,IAAIgN,EAASrO,KAAKuH,SAASlG,GAAGgH,IAAI6I,EAASwK,GACvCmc,GACFnrB,EAAYhL,KAAKF,IAAIkL,EAAW2B,EAAO3B,WACvCD,GAAY4B,EAAO5B,SACnBzM,KAAKY,OAAOS,GAAGnB,QAAUmO,EAAO5B,WAEhCA,EAAW/K,KAAKF,IAAIiL,EAAU4B,EAAO5B,UACrCC,GAAa2B,EAAO3B,UACpB1M,KAAKY,OAAOS,GAAGnB,QAAUmO,EAAO3B,UAEnC,CAGD,MAAO,CAAED,WAAUC,YAAWC,SAlBfvM,SAkByBwM,UAjBxBxM,S,CAuBlB8H,OACEkG,EACAD,EACA5C,EACAC,EACA0F,EACAwK,GAGA,IAAImc,EAAkC,eAArB73B,KAAKgR,YAClB8mB,EAAQp2B,KAAKF,IAAI,EAAGxB,KAAKuH,SAASxG,OAAS,GAAKmQ,EAChDrQ,EAAQa,KAAKF,IAAI,GAAIq2B,EAAatsB,EAAQC,GAAUssB,GAGxD,GAAI93B,KAAKg3B,WAAY,CACnB,IAAK,MAAM11B,KAAStB,KAAKY,OACvBU,EAAMrB,UAAYY,EAEpBb,KAAKg3B,YAAa,CACnB,CAGDx2B,YAAUG,KAAKX,KAAKY,OAAQC,GAG5B,IAAK,IAAIQ,EAAI,EAAGiB,EAAItC,KAAKuH,SAASxG,OAAQM,EAAIiB,IAAKjB,EAAG,CACpD,IAAI+J,EAAQpL,KAAKuH,SAASlG,GACtBf,EAAON,KAAKY,OAAOS,GAAGf,KACtBsS,EAAc5S,KAAKoR,QAAQ/P,GAAGuF,MAC9BixB,GACFzsB,EAAMlD,OAAOkG,EAAMD,EAAK7N,EAAMkL,EAAQ0F,EAASwK,GAC/CtN,GAAQ9N,EACRsS,EAAYzE,IAAM,GAAGA,MACrByE,EAAYxE,KAAO,GAAGA,MACtBwE,EAAYrH,MAAQ,GAAG2F,MACvB0B,EAAYpH,OAAS,GAAGA,MACxB4C,GAAQ8C,IAER9F,EAAMlD,OAAOkG,EAAMD,EAAK5C,EAAOjL,EAAM4Q,EAASwK,GAC9CvN,GAAO7N,EACPsS,EAAYzE,IAAM,GAAGA,MACrByE,EAAYxE,KAAO,GAAGA,MACtBwE,EAAYrH,MAAQ,GAAGA,MACvBqH,EAAYpH,OAAS,GAAG0F,MACxB/C,GAAO+C,EAEV,C,EA3UQzQ,EAAAs2B,gBAAeA,EA+UZt2B,EAAA61B,QAAhB,SAAwB9uB,EAAgB8sB,GACtC9sB,EAAOrC,KAAKsF,aAAa,OAAQ,YACjC,IAAIsG,EAAWujB,EAAOvjB,SACtB,GAAIA,aAAoB4Z,EAAOnT,SAAU,CACvC,IAAIugB,EAAQhnB,EAAS6f,aAAa,CAChChrB,MAAO4B,EAAO5B,MACdqoB,SAAS,EACTrjB,OAAQ,IAEVpD,EAAOrC,KAAKsF,aAAa,kBAAmBstB,EAC7C,C,EAGat3B,EAAAg1B,WAAhB,SAA2BjuB,GACzBA,EAAOrC,KAAK0F,gBAAgB,QAC5BrD,EAAOrC,KAAK0F,gBAAgB,kB,CAoJ/B,CAzzBD,CAAUpK,MAyzBT,KCnuEK,MAAOu3B,UAAkBrzB,EAM7B5E,YAAY8C,EAA8B,IACxCwI,QA+/BMrL,KAAKi4B,MAAgB,KAErBj4B,KAAYk4B,cAAY,EACxBl4B,KAAgBm4B,kBAAY,EAC5Bn4B,KAAiBgrB,mBAAY,EAC7BhrB,KAAU4V,WAA8B,KACxC5V,KAAAo4B,gBAAkB,IAAI50B,SAAmBxD,MAEzCA,KAAAmrB,cAAgB,IAAI3nB,SAA6BxD,MAtgCvDA,KAAKqF,SAAS,gBACdrF,KAAKurB,UAAY1oB,EAAQqJ,UAAYA,SACrClM,KAAKq4B,MAAQx1B,EAAQ8xB,MAAQ,oBAC7B30B,KAAKs4B,UAAYz1B,EAAQkO,UAAYinB,EAAUvgB,gBAC/CzX,KAAKu4B,OAAS11B,EAAQ21B,OAAS/3B,EAAQg4B,mBACXv1B,IAAxBL,EAAQ2oB,cACVxrB,KAAKk4B,aAAer1B,EAAQ2oB,kBAEEtoB,IAA5BL,EAAQ61B,kBACV14B,KAAKm4B,iBAAmBt1B,EAAQ61B,sBAEDx1B,IAA7BL,EAAQ8oB,mBACV3rB,KAAKgrB,kBAAoBnoB,EAAQ8oB,kBAInC3rB,KAAKoE,QAAc,KAAIpE,KAAKq4B,MAG5B,IAAItnB,EAAgC,CAClCyjB,aAAc,IAAMx0B,KAAKy0B,gBACzBtiB,aAAc,IAAMnS,KAAK00B,iBAI3B10B,KAAKqH,OAAS,IAAIkrB,EAAW,CAC3BrmB,SAAUlM,KAAKurB,UACfxa,WACAG,QAASrO,EAAQqO,QACjBzK,WAAY5D,EAAQ4D,aAItBzG,KAAK24B,QAAU91B,EAAQ81B,SAAW,IAAIX,EAAUY,QAChD54B,KAAKmF,KAAKoN,YAAYvS,KAAK24B,QAAQxzB,K,CAMrCV,UAEEzE,KAAK6V,gBAGL7V,KAAK24B,QAAQ5vB,KAAK,GAGd/I,KAAKi4B,OACPj4B,KAAKi4B,MAAMxzB,UAIb4G,MAAM5G,S,CAMJgC,iBACF,OAAQzG,KAAKqH,OAAsBZ,U,CAMjCA,eAAWyN,GACZlU,KAAKqH,OAAsBZ,WAAayN,C,CAcvC2kB,qBACF,OAAO74B,KAAKo4B,e,CAOVnM,mBACF,OAAOjsB,KAAKmrB,a,CAWVpa,eACF,OAAQ/Q,KAAKqH,OAAsB0J,Q,CAMjCG,cACF,OAAQlR,KAAKqH,OAAsB6J,O,CAMjCA,YAAQ5M,GACTtE,KAAKqH,OAAsB6J,QAAU5M,C,CAMpCqwB,WACF,OAAO30B,KAAKq4B,K,CAWV1D,SAAKrwB,GAEP,GAAItE,KAAKq4B,QAAU/zB,EACjB,OAIFtE,KAAKq4B,MAAQ/zB,EAGbtE,KAAKoE,QAAc,KAAIE,EAGvB,IAAI+C,EAASrH,KAAKqH,OAGlB,OAAQ/C,GACN,IAAK,oBACH,IAAK,MAAMgwB,KAAUjtB,EAAOsrB,UAC1B2B,EAAO3rB,OAET,MACF,IAAK,kBACHtB,EAAOusB,cAAcnzB,EAAQq4B,2BAA2B94B,OACxD,MACF,QACE,KAAM,cAIV6F,cAAYsC,YAAYnI,KAAMS,EAAQs4B,e,CAMpCvN,kBACF,OAAOxrB,KAAKk4B,Y,CAMV1M,gBAAYlnB,GACdtE,KAAKk4B,aAAe5zB,EACpB,IAAK,MAAMgwB,KAAUt0B,KAAK2yB,UACxB2B,EAAO9I,YAAclnB,C,CAOrBo0B,sBACF,OAAO14B,KAAKm4B,gB,CAMVO,oBAAgBp0B,GAClBtE,KAAKm4B,iBAAmB7zB,C,CAMtBqnB,uBACF,OAAO3rB,KAAKgrB,iB,CAMVW,qBAAiBrnB,GACnBtE,KAAKgrB,kBAAoB1mB,EACzB,IAAK,MAAMgwB,KAAUt0B,KAAK2yB,UACxB2B,EAAO3I,iBAAmBrnB,C,CAO1BsuB,cACF,OAAQ5yB,KAAKqH,OAAsBurB,O,CAWrC7jB,iBACU/O,KAAKqH,OAAsB0H,S,CAYrCikB,yBACUhzB,KAAKqH,OAAsB2rB,iB,CAWrCL,iBACU3yB,KAAKqH,OAAsBsrB,S,CAQrCvhB,iBACUpR,KAAKqH,OAAsB+J,S,CAWrC4nB,aAAaxxB,GAEX,IAAI8sB,EAAS2E,OAAKj5B,KAAK2yB,WAAWD,IACa,IAAtCA,EAAI9d,OAAOxF,QAAQ5H,EAAO5B,SAInC,IAAK0uB,EACH,MAAM,IAAIvtB,MAAM,8CAIlButB,EAAOlI,aAAe5kB,EAAO5B,K,CAW/BszB,eAAe1xB,GACbxH,KAAKg5B,aAAaxxB,GAClBA,EAAOe,U,CAYTirB,aACE,OAAQxzB,KAAKqH,OAAsBmsB,Y,CAerCI,cAAcC,GAEZ7zB,KAAKq4B,MAAQ,oBAGZr4B,KAAKqH,OAAsBusB,cAAcC,IAGtCsF,WAASC,SAAWD,WAASE,QAC/BxzB,cAAYyzB,QAIdzzB,cAAYsC,YAAYnI,KAAMS,EAAQs4B,e,CAcxC7pB,UAAU1H,EAAgB3E,EAAiC,IAEtC,oBAAf7C,KAAKq4B,MACNr4B,KAAKqH,OAAsB6H,UAAU1H,GAErCxH,KAAKqH,OAAsB6H,UAAU1H,EAAQ3E,GAIhDgD,cAAYsC,YAAYnI,KAAMS,EAAQs4B,e,CAQxC1vB,eAAerC,GACI,oBAAbA,EAAIsC,KACNtJ,KAAKo4B,gBAAgB7zB,UAAKrB,GAE1BmI,MAAMhC,eAAerC,E,CAczB+O,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,eACHtJ,KAAKu5B,cAAcvjB,GACnB,MACF,IAAK,eACHhW,KAAKw5B,cAAcxjB,GACnB,MACF,IAAK,cACHhW,KAAKy5B,aAAazjB,GAClB,MACF,IAAK,UACHhW,KAAK05B,SAAS1jB,GACd,MACF,IAAK,cACHhW,KAAKiW,gBAAgBD,GACrB,MACF,IAAK,cACHhW,KAAKkW,gBAAgBF,GACrB,MACF,IAAK,YACHhW,KAAKmW,cAAcH,GACnB,MACF,IAAK,UACHhW,KAAKoW,YAAYJ,GACjB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,eAAgBvW,MAC3CA,KAAKmF,KAAKoR,iBAAiB,eAAgBvW,MAC3CA,KAAKmF,KAAKoR,iBAAiB,cAAevW,MAC1CA,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCA,KAAKmF,KAAKoR,iBAAiB,cAAevW,K,CAMlCkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,eAAgBxW,MAC9CA,KAAKmF,KAAKqR,oBAAoB,eAAgBxW,MAC9CA,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CA,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CA,KAAK6V,e,CAMGxL,aAAarD,GAEjBvG,EAAQk5B,0BAA0BpzB,IAAIS,EAAIoE,QAK9CpE,EAAIoE,MAAM/F,SAAS,sB,CAMXiF,eAAetD,GAEnBvG,EAAQk5B,0BAA0BpzB,IAAIS,EAAIoE,SAK9CpE,EAAIoE,MAAMvD,YAAY,uBAGtBhC,cAAYsC,YAAYnI,KAAMS,EAAQs4B,gB,CAMhCQ,cAAcvjB,GAGhBA,EAAM4jB,SAASC,QAAQ,2CACzB7jB,EAAMK,iBACNL,EAAMM,kB,CAOFkjB,cAAcxjB,GAEpBA,EAAMK,iBAEFrW,KAAKm4B,kBAAoBniB,EAAMyK,SAAWzgB,OAE9CgW,EAAMM,kBAKNtW,KAAK24B,QAAQ5vB,KAAK,G,CAMZ0wB,aAAazjB,GAEnBA,EAAMK,iBAKHrW,KAAKm4B,kBAAoBniB,EAAMyK,SAAWzgB,MACS,YAApDA,KAAK85B,aAAa9jB,EAAMe,QAASf,EAAMgB,SAEvChB,EAAM+jB,WAAa,QAEnB/jB,EAAMM,kBACNN,EAAM+jB,WAAa/jB,EAAMgkB,e,CAOrBN,SAAS1jB,GAQf,GANAA,EAAMK,iBAGNrW,KAAK24B,QAAQ5vB,KAAK,GAGW,SAAzBiN,EAAMgkB,eAER,YADAhkB,EAAM+jB,WAAa,QAKrB,IAAIhjB,QAAEA,EAAOC,QAAEA,GAAYhB,GACvBikB,KAAEA,EAAIrjB,OAAEA,GAAWnW,EAAQy5B,eAC7Bl6B,KACA+W,EACAC,EACAhX,KAAKu4B,QAIP,GACGv4B,KAAKm4B,kBAAoBniB,EAAMyK,SAAWzgB,MAClC,YAATi6B,EAGA,YADAjkB,EAAM+jB,WAAa,QAKrB,IACII,EADWnkB,EAAM4jB,SACEQ,QAAQ,yCAC/B,GAAuB,mBAAZD,EAET,YADAnkB,EAAM+jB,WAAa,QAKrB,IAAIvyB,EAAS2yB,IACb,KAAM3yB,aAAkB7C,GAEtB,YADAqR,EAAM+jB,WAAa,QAKrB,GAAIvyB,EAAOV,SAAS9G,MAElB,YADAgW,EAAM+jB,WAAa,QAKrB,IAAInuB,EAAMgL,EAASnW,EAAQ45B,WAAWzjB,EAAO0d,QAAU,KAGvD,OAAQ2F,GACN,IAAK,WACHj6B,KAAKkP,UAAU1H,GACf,MACF,IAAK,WACHxH,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,cAC/B,MACF,IAAK,YACH30B,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,eAC/B,MACF,IAAK,aACH30B,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,gBAC/B,MACF,IAAK,cACH30B,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,iBAC/B,MACF,IAAK,aAeL,IAAK,aACH30B,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,YAAa/oB,QAC5C,MAdF,IAAK,aACH5L,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,YAAa/oB,QAC5C,MACF,IAAK,cACH5L,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,aAAc/oB,QAC7C,MACF,IAAK,eACH5L,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,cAAe/oB,QAC9C,MACF,IAAK,gBACH5L,KAAKkP,UAAU1H,EAAQ,CAAEmtB,KAAM,eAAgB/oB,QAC/C,MAIF,QACE,KAAM,cAIVoK,EAAM+jB,WAAa/jB,EAAMgkB,eAGzBhkB,EAAMM,kBAGNtW,KAAKk5B,eAAe1xB,E,CAMd4O,YAAYJ,GAElBA,EAAMK,iBACNL,EAAMM,kBAGgB,KAAlBN,EAAMS,UAERzW,KAAK6V,gBAGLhQ,cAAYsC,YAAYnI,KAAMS,EAAQs4B,gB,CAOlC9iB,gBAAgBD,GAEtB,GAAqB,IAAjBA,EAAMU,OACR,OAIF,IAAIrP,EAASrH,KAAKqH,OACduP,EAASZ,EAAMY,OACf5E,EAASinB,OAAK5xB,EAAO+J,WAAWY,GAAUA,EAAOlL,SAAS8P,KAC9D,IAAK5E,EACH,OAIFgE,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAKurB,UAAUhV,iBAAiB,UAAWvW,MAAM,GACjDA,KAAKurB,UAAUhV,iBAAiB,YAAavW,MAAM,GACnDA,KAAKurB,UAAUhV,iBAAiB,cAAevW,MAAM,GACrDA,KAAKurB,UAAUhV,iBAAiB,cAAevW,MAAM,GAGrD,IAAI6W,EAAO7E,EAAO8E,wBACdwjB,EAAStkB,EAAMe,QAAUF,EAAKzI,KAC9BmsB,EAASvkB,EAAMgB,QAAUH,EAAK1I,IAG9BvH,EAAQqQ,OAAOC,iBAAiBlF,GAChCmF,EAAWC,OAAKC,eAAezQ,EAAM0Q,OAAStX,KAAKurB,WACvDvrB,KAAK4V,WAAa,CAAE5D,SAAQsoB,SAAQC,SAAQpjB,W,CAMtCjB,gBAAgBF,GAEtB,IAAKhW,KAAK4V,WACR,OAIFI,EAAMK,iBACNL,EAAMM,kBAGN,IAAIO,EAAO7W,KAAKmF,KAAK2R,wBACjB0jB,EAAOxkB,EAAMe,QAAUF,EAAKzI,KAAOpO,KAAK4V,WAAW0kB,OACnDG,EAAOzkB,EAAMgB,QAAUH,EAAK1I,IAAMnO,KAAK4V,WAAW2kB,OAGzCv6B,KAAKqH,OACX0K,WAAW/R,KAAK4V,WAAW5D,OAAQwoB,EAAMC,E,CAM1CtkB,cAAcH,GAEC,IAAjBA,EAAMU,SAKVV,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK6V,gBAGLhQ,cAAYsC,YAAYnI,KAAMS,EAAQs4B,gB,CAMhCljB,gBAED7V,KAAK4V,aAKV5V,KAAK4V,WAAWuB,SAAS1S,UACzBzE,KAAK4V,WAAa,KAGlB5V,KAAKurB,UAAU/U,oBAAoB,UAAWxW,MAAM,GACpDA,KAAKurB,UAAU/U,oBAAoB,YAAaxW,MAAM,GACtDA,KAAKurB,UAAU/U,oBAAoB,cAAexW,MAAM,GACxDA,KAAKurB,UAAU/U,oBAAoB,cAAexW,MAAM,G,CAWlD85B,aAAa/iB,EAAiBC,GAEpC,IAcI7I,EACAC,EACA6a,EACAE,GAjBA8Q,KAAEA,EAAIrjB,OAAEA,GAAWnW,EAAQy5B,eAC7Bl6B,KACA+W,EACAC,EACAhX,KAAKu4B,QAIP,GAAa,YAAT0B,EAEF,OADAj6B,KAAK24B,QAAQ5vB,KAAK,KACXkxB,EAQT,IAAI9mB,EAAM7E,aAAW8E,UAAUpT,KAAKmF,MAChC0R,EAAO7W,KAAKmF,KAAK2R,wBAGrB,OAAQmjB,GACN,IAAK,WACH9rB,EAAMgF,EAAIM,WACVrF,EAAO+E,EAAIO,YACXuV,EAAQ9V,EAAIunB,aACZvR,EAAShW,EAAIkW,cACb,MACF,IAAK,WACHlb,EAAMgF,EAAIM,WACVrF,EAAO+E,EAAIO,YACXuV,EAAQ9V,EAAIunB,aACZvR,EAAStS,EAAKrL,OAAS/K,EAAQo2B,aAC/B,MACF,IAAK,YACH1oB,EAAMgF,EAAIM,WACVrF,EAAO+E,EAAIO,YACXuV,EAAQpS,EAAKtL,MAAQ9K,EAAQo2B,aAC7B1N,EAAShW,EAAIkW,cACb,MACF,IAAK,aACHlb,EAAMgF,EAAIM,WACVrF,EAAOyI,EAAKtL,MAAQ9K,EAAQo2B,aAC5B5N,EAAQ9V,EAAIunB,aACZvR,EAAShW,EAAIkW,cACb,MACF,IAAK,cACHlb,EAAM0I,EAAKrL,OAAS/K,EAAQo2B,aAC5BzoB,EAAO+E,EAAIO,YACXuV,EAAQ9V,EAAIunB,aACZvR,EAAShW,EAAIkW,cACb,MACF,IAAK,aACHlb,EAAMyI,EAAQzI,IACdC,EAAOwI,EAAQxI,KACf6a,EAAQrS,EAAQqS,MAChBE,EAASvS,EAAQuS,OACjB,MACF,IAAK,aACHhb,EAAMyI,EAAQzI,IACdC,EAAOwI,EAAQxI,KACf6a,EAAQrS,EAAQqS,MAChBE,EAASvS,EAAQuS,OAASvS,EAAQpL,OAAS,EAC3C,MACF,IAAK,cACH2C,EAAMyI,EAAQzI,IACdC,EAAOwI,EAAQxI,KACf6a,EAAQrS,EAAQqS,MAAQrS,EAAQrL,MAAQ,EACxC4d,EAASvS,EAAQuS,OACjB,MACF,IAAK,eACHhb,EAAMyI,EAAQzI,IACdC,EAAOwI,EAAQxI,KAAOwI,EAAQrL,MAAQ,EACtC0d,EAAQrS,EAAQqS,MAChBE,EAASvS,EAAQuS,OACjB,MACF,IAAK,gBACHhb,EAAMyI,EAAQzI,IAAMyI,EAAQpL,OAAS,EACrC4C,EAAOwI,EAAQxI,KACf6a,EAAQrS,EAAQqS,MAChBE,EAASvS,EAAQuS,OACjB,MACF,IAAK,aAAc,CACjB,MAAMwR,EAAY/jB,EAAQ0d,OAAOnvB,KAAK2R,wBAAwBtL,OAC9D2C,EAAMyI,EAAQzI,IACdC,EAAOwI,EAAQxI,KACf6a,EAAQrS,EAAQqS,MAChBE,EAASvS,EAAQuS,OAASvS,EAAQpL,OAASmvB,EAC3C,KACD,CACD,QACE,KAAM,cAOV,OAHA36B,KAAK24B,QAAQhwB,KAAK,CAAEwF,MAAKC,OAAM6a,QAAOE,WAG/B8Q,C,CAMDxF,gBAEN,IAAIH,EAASt0B,KAAKs4B,UAAU9D,aAAax0B,KAAKurB,WA2B9C,OAxBA9qB,EAAQk5B,0BAA0BxsB,IAAImnB,GAAQ,GAG3B,oBAAft0B,KAAKq4B,OACP/D,EAAOvrB,OAKTurB,EAAO9I,YAAcxrB,KAAKk4B,aAC1B5D,EAAO5I,eAAgB,EACvB4I,EAAO3I,iBAAmB3rB,KAAKgrB,kBAC/BsJ,EAAOzI,eAAiB,sBACxByI,EAAO1I,eAAiB,uBAGxB0I,EAAOvI,SAAShU,QAAQ/X,KAAK46B,YAAa56B,MAC1Cs0B,EAAOxI,eAAe/T,QAAQ/X,KAAK66B,kBAAmB76B,MACtDs0B,EAAOpI,kBAAkBnU,QAAQ/X,KAAK86B,qBAAsB96B,MAC5Ds0B,EAAOnI,mBAAmBpU,QAAQ/X,KAAK+6B,sBAAuB/6B,MAC9Ds0B,EAAOtI,qBAAqBjU,QAAQ/X,KAAKg7B,wBAAyBh7B,MAClEs0B,EAAOrI,aAAalU,QAAQ/X,KAAKi7B,mBAAoBj7B,MAG9Cs0B,C,CAMDI,gBACN,OAAO10B,KAAKs4B,UAAUnmB,c,CAMhByoB,cACN/0B,cAAYsC,YAAYnI,KAAMS,EAAQs4B,e,CAMhC8B,kBACNviB,EACAoG,GAGA,IAAIiO,cAAEA,EAAaP,aAAEA,GAAiB1N,EAGlCiO,GACFA,EAAcjpB,MAAMqF,OAIlBqjB,GACFA,EAAa1oB,MAAMiF,QAIjBwwB,WAASC,SAAWD,WAASE,QAC/BxzB,cAAYyzB,QAIdzzB,cAAYsC,YAAYnI,KAAMS,EAAQs4B,e,CAMhCkC,mBAAmB3iB,GACzBtY,KAAKmrB,cAAc5mB,KAAK+T,E,CAMlB0iB,wBACN1iB,EACAoG,GAEAA,EAAK9Y,MAAMlC,MAAM6E,U,CAMXuyB,qBACNxiB,EACAoG,GAEAA,EAAK9Y,MAAMlC,MAAM+E,O,CAMXsyB,sBACNziB,EACAoG,GAGA,GAAI1e,KAAKi4B,MACP,OAIF3f,EAAOkV,eAGP,IAAI5nB,MAAEA,EAAK2oB,IAAEA,EAAGxX,QAAEA,EAAOC,QAAEA,EAAOpD,OAAEA,GAAW8K,EAG3Ckb,EAAW,IAAIsB,WAEnBtB,EAASuB,QAAQ,yCADH,IAAMv1B,EAAMlC,QAI1B,IAAI03B,EAAY7M,EAAI8M,WAAU,GAC1BznB,IACFwnB,EAAUx0B,MAAMuH,IAAM,IAAIyF,EAAOiR,MACjCuW,EAAUx0B,MAAMwH,KAAO,IAAIwF,EAAOgR,OAIpC5kB,KAAKi4B,MAAQ,IAAI7gB,OAAK,CACpBlL,SAAUlM,KAAKurB,UACfqO,WACAwB,YACApB,eAAgB,OAChBsB,iBAAkB,OAClB7a,OAAQzgB,OAIVuuB,EAAI5mB,UAAUC,IAAI,iBAOlB5H,KAAKi4B,MAAM/Z,MAAMnH,EAASC,GAASukB,MANrB,KACZv7B,KAAKi4B,MAAQ,KACb1J,EAAI5mB,UAAUG,OAAO,gBAAgB,G,GAwB3C,SAAiBkwB,GAwMFA,EAAAY,QAAb,MAIE74B,cA4EQC,KAAMw7B,QAAI,EACVx7B,KAAOy7B,SAAG,EA5EhBz7B,KAAKmF,KAAO+G,SAASC,cAAc,OACnCnM,KAAKmF,KAAKwC,UAAUC,IAAI,wBACxB5H,KAAKmF,KAAKwC,UAAUC,IAAI,iBACxB5H,KAAKmF,KAAKyB,MAAMqH,SAAW,WAC3BjO,KAAKmF,KAAKyB,MAAMsH,QAAU,Q,CAa5BvF,KAAK+yB,GAEH,IAAI90B,EAAQ5G,KAAKmF,KAAKyB,MACtBA,EAAMuH,IAAM,GAAGutB,EAAIvtB,QACnBvH,EAAMwH,KAAO,GAAGstB,EAAIttB,SACpBxH,EAAMqiB,MAAQ,GAAGyS,EAAIzS,UACrBriB,EAAMuiB,OAAS,GAAGuS,EAAIvS,WAGtBvC,aAAa5mB,KAAKw7B,QAClBx7B,KAAKw7B,QAAU,EAGVx7B,KAAKy7B,UAKVz7B,KAAKy7B,SAAU,EAGfz7B,KAAKmF,KAAKwC,UAAUG,OAAO,iB,CAS7BiB,KAAK4yB,GAEH,IAAI37B,KAAKy7B,QAKT,OAAIE,GAAS,GACX/U,aAAa5mB,KAAKw7B,QAClBx7B,KAAKw7B,QAAU,EACfx7B,KAAKy7B,SAAU,OACfz7B,KAAKmF,KAAKwC,UAAUC,IAAI,wBAKL,IAAjB5H,KAAKw7B,SAKTx7B,KAAKw7B,OAASvkB,OAAOyP,YAAW,KAC9B1mB,KAAKw7B,QAAU,EACfx7B,KAAKy7B,SAAU,EACfz7B,KAAKmF,KAAKwC,UAAUC,IAAI,gBAAgB,GACvC+zB,I,GAeP,MAAankB,EAMXgd,aAAatoB,GACX,IAAIwmB,EAAM,IAAI/H,EAAe,CAAEze,aAE/B,OADAwmB,EAAIrtB,SAAS,uBACNqtB,C,CAQTvgB,eACE,IAAIH,EAAS9F,SAASC,cAAc,OAEpC,OADA6F,EAAO/N,UAAY,sBACZ+N,C,EApBEgmB,EAAAxgB,SAAQA,EA2BRwgB,EAAAvgB,gBAAkB,IAAID,CACpC,CAhUD,CAAiBwgB,MAgUhB,KAKD,SAAUv3B,GAIKA,EAAYo2B,aAAG,KAKfp2B,EAAAg4B,cAAgB,CAM3BtqB,IAAK,GAKL8a,MAAO,GAKPE,OAAQ,GAKR/a,KAAM,IAMK3N,EAAAs4B,eAAiB,IAAI5tB,qBAAmB,mBA6GxC1K,EAAyBk5B,0BAAG,IAAI7zB,mBAG3C,CACA4B,KAAM,oBACNuE,OAAQ,KAAM,IAMAxL,EAAAq4B,2BAAhB,SACE8C,GAGA,GAAIA,EAAMhJ,QACR,MAAO,CAAEc,KAAM,MAIjB,IAAI3kB,EAAUiO,MAAM6e,KAAKD,EAAM7sB,WAG3B+sB,EAAWF,EAAM5I,kBAAkB+I,OAAOz3B,MAG1C+nB,EAAeyP,EAAW/sB,EAAQK,QAAQ0sB,IAAa,EAG3D,MAAO,CAAEpI,KAAM,CAAEpqB,KAAM,WAAYyF,UAASsd,gB,EAM9B5rB,EAAAy5B,eAAhB,SACE0B,EACA7kB,EACAC,EACAwhB,GAGA,IAAKlqB,aAAW0X,QAAQ4V,EAAMz2B,KAAM4R,EAASC,GAC3C,MAAO,CAAEijB,KAAM,UAAWrjB,OAAQ,MAIpC,IAAIvP,EAASu0B,EAAMv0B,OAGnB,GAAIA,EAAOurB,QACT,MAAO,CAAEqH,KAAM,WAAYrjB,OAAQ,MAIrC,GAAmB,sBAAfglB,EAAMjH,KAA8B,CAEtC,IAAIqH,EAAYJ,EAAMz2B,KAAK2R,wBAGvBmlB,EAAKllB,EAAUilB,EAAU5tB,KAAO,EAChCme,EAAKvV,EAAUglB,EAAU7tB,IAAM,EAC/B+tB,EAAKF,EAAU/S,MAAQlS,EACvBolB,EAAKH,EAAU7S,OAASnS,EAM5B,OAHStV,KAAKH,IAAIgrB,EAAI2P,EAAIC,EAAIF,IAI5B,KAAK1P,EACH,GAAIA,EAAKiM,EAAMrqB,IACb,MAAO,CAAE8rB,KAAM,WAAYrjB,OAAQ,MAErC,MACF,KAAKslB,EACH,GAAIA,EAAK1D,EAAMvP,MACb,MAAO,CAAEgR,KAAM,aAAcrjB,OAAQ,MAEvC,MACF,KAAKulB,EACH,GAAIA,EAAK3D,EAAMrP,OACb,MAAO,CAAE8Q,KAAM,cAAerjB,OAAQ,MAExC,MACF,KAAKqlB,EACH,GAAIA,EAAKzD,EAAMpqB,KACb,MAAO,CAAE6rB,KAAM,YAAarjB,OAAQ,MAEtC,MACF,QACE,KAAM,cAEX,CAGD,IAAIA,EAASvP,EAAO4tB,gBAAgBle,EAASC,GAG7C,IAAKJ,EACH,MAAO,CAAEqjB,KAAM,UAAWrjB,OAAQ,MAIpC,GAAmB,oBAAfglB,EAAMjH,KACR,MAAO,CAAEsF,KAAM,aAAcrjB,UAI/B,IAAIwlB,EAAKxlB,EAAOgO,EAAIhO,EAAOxI,KAAO,EAC9BiuB,EAAKzlB,EAAOiO,EAAIjO,EAAOzI,IAAM,EAC7BmuB,EAAK1lB,EAAOxI,KAAOwI,EAAOrL,MAAQqL,EAAOgO,EACzC2X,EAAK3lB,EAAOzI,IAAMyI,EAAOpL,OAASoL,EAAOiO,EAG7C,GAAIwX,EADczlB,EAAO0d,OAAOnvB,KAAK2R,wBAAwBtL,OAE3D,MAAO,CAAEyuB,KAAM,aAAcrjB,UAI/B,IAkBIqjB,EAlBAuC,EAAK96B,KAAK+6B,MAAM7lB,EAAOrL,MAAQ,GAC/BmxB,EAAKh7B,KAAK+6B,MAAM7lB,EAAOpL,OAAS,GAGpC,GAAI4wB,EAAKI,GAAMF,EAAKE,GAAMH,EAAKK,GAAMH,EAAKG,EACxC,MAAO,CAAEzC,KAAM,aAAcrjB,UAc/B,OAVAwlB,GAAMI,EACNH,GAAMK,EACNJ,GAAME,EACND,GAAMG,EAGGh7B,KAAKH,IAAI66B,EAAIC,EAAIC,EAAIC,IAK5B,KAAKH,EACHnC,EAAO,cACP,MACF,KAAKoC,EACHpC,EAAO,aACP,MACF,KAAKqC,EACHrC,EAAO,eACP,MACF,KAAKsC,EACHtC,EAAO,gBACP,MACF,QACE,KAAM,cAIV,MAAO,CAAEA,OAAMrjB,S,EAMDnW,EAAA45B,WAAhB,SAA2B/F,GACzB,OAA6B,IAAzBA,EAAO1f,OAAO7T,OACT,KAELuzB,EAAOlI,aACFkI,EAAOlI,aAAa1oB,MAEtB4wB,EAAO1f,OAAO0f,EAAO1f,OAAO7T,OAAS,GAAG2C,K,CAElD,CA7TD,CAAUjD,MA6TT,KC9pDK,MAAOk8B,WAAmBtwB,EAM9BtM,YAAY8C,EAA+B,IACzCwI,MAAMxI,GA0mBA7C,KAAMuQ,QAAG,EACTvQ,KAAW48B,YAAG,EACd58B,KAAc68B,eAAG,EACjB78B,KAAM0Q,OAAiB,GACvB1Q,KAAU88B,WAAa,GACvB98B,KAAa+8B,cAAa,GAC1B/8B,KAAAg9B,WAAyB,CAAC,IAAIl9B,GAC9BE,KAAAi9B,cAA4B,CAAC,IAAIn9B,GACjCE,KAAI4Q,KAAiC,UAjnBlB1N,IAArBL,EAAQq6B,UACVz8B,EAAQ08B,cAAcn9B,KAAKg9B,WAAYn6B,EAAQq6B,eAErBh6B,IAAxBL,EAAQu6B,aACV38B,EAAQ08B,cAAcn9B,KAAKi9B,cAAep6B,EAAQu6B,kBAEzBl6B,IAAvBL,EAAQw6B,aACVr9B,KAAK48B,YAAcn8B,EAAQ68B,WAAWz6B,EAAQw6B,kBAElBn6B,IAA1BL,EAAQ06B,gBACVv9B,KAAK68B,eAAiBp8B,EAAQ68B,WAAWz6B,EAAQ06B,e,CAOrD94B,UAEE,IAAK,MAAM0M,KAAQnR,KAAK0Q,OAAQ,CAC9B,IAAIlJ,EAAS2J,EAAK3J,OAClB2J,EAAK1M,UACL+C,EAAO/C,SACR,CAGDzE,KAAK4Q,KAAO,KACZ5Q,KAAK0Q,OAAO3P,OAAS,EACrBf,KAAK88B,WAAW/7B,OAAS,EACzBf,KAAKg9B,WAAWj8B,OAAS,EACzBf,KAAK+8B,cAAch8B,OAAS,EAC5Bf,KAAKi9B,cAAcl8B,OAAS,EAG5BsK,MAAM5G,S,CAMJy4B,eACF,OAAOl9B,KAAKg9B,WAAWj8B,M,CASrBm8B,aAAS54B,GAEPA,IAAUtE,KAAKk9B,WAKnBz8B,EAAQ08B,cAAcn9B,KAAKg9B,WAAY14B,GAGnCtE,KAAKyF,QACPzF,KAAKyF,OAAO4C,M,CAOZ+0B,kBACF,OAAOp9B,KAAKi9B,cAAcl8B,M,CASxBq8B,gBAAY94B,GAEVA,IAAUtE,KAAKo9B,cAKnB38B,EAAQ08B,cAAcn9B,KAAKi9B,cAAe34B,GAGtCtE,KAAKyF,QACPzF,KAAKyF,OAAO4C,M,CAOZg1B,iBACF,OAAOr9B,KAAK48B,W,CAMVS,eAAW/4B,GAEbA,EAAQ7D,EAAQ68B,WAAWh5B,GAGvBtE,KAAK48B,cAAgBt4B,IAKzBtE,KAAK48B,YAAct4B,EAGftE,KAAKyF,QACPzF,KAAKyF,OAAO4C,M,CAOZk1B,oBACF,OAAOv9B,KAAK68B,c,CAMVU,kBAAcj5B,GAEhBA,EAAQ7D,EAAQ68B,WAAWh5B,GAGvBtE,KAAK68B,iBAAmBv4B,IAK5BtE,KAAK68B,eAAiBv4B,EAGlBtE,KAAKyF,QACPzF,KAAKyF,OAAO4C,M,CAchBm1B,WAAWt7B,GACT,IAAIZ,EAAQtB,KAAKg9B,WAAW96B,GAC5B,OAAOZ,EAAQA,EAAMjB,SAAW,C,CAalCo9B,cAAcv7B,EAAeoC,GAE3B,IAAIhD,EAAQtB,KAAKg9B,WAAW96B,GAGvBZ,IAKLgD,EAAQ7D,EAAQ68B,WAAWh5B,GAGvBhD,EAAMjB,UAAYiE,IAKtBhD,EAAMjB,QAAUiE,EAGZtE,KAAKyF,QACPzF,KAAKyF,OAAOyC,U,CAchBw1B,cAAcx7B,GACZ,IAAIZ,EAAQtB,KAAKi9B,cAAc/6B,GAC/B,OAAOZ,EAAQA,EAAMjB,SAAW,C,CAalCs9B,iBAAiBz7B,EAAeoC,GAE9B,IAAIhD,EAAQtB,KAAKi9B,cAAc/6B,GAG1BZ,IAKLgD,EAAQ7D,EAAQ68B,WAAWh5B,GAGvBhD,EAAMjB,UAAYiE,IAKtBhD,EAAMjB,QAAUiE,EAGZtE,KAAKyF,QACPzF,KAAKyF,OAAOyC,U,CAShB,EAAE8G,OAAOC,YACP,IAAK,MAAMkC,KAAQnR,KAAK0Q,aAChBS,EAAK3J,M,CAYf0H,UAAU1H,IAKG,IAHH8H,WAASqH,eAAe3W,KAAK0Q,QAAQktB,GAAMA,EAAGp2B,SAAWA,MAQjExH,KAAK0Q,OAAOmB,KAAK,IAAItE,EAAW/F,IAG5BxH,KAAKyF,QACPzF,KAAKwP,aAAahI,G,CAiBtBuF,aAAavF,GAEX,IAAInG,EAAIiO,WAASqH,eAAe3W,KAAK0Q,QAAQktB,GAAMA,EAAGp2B,SAAWA,IAGjE,IAAW,IAAPnG,EACF,OAIF,IAAI8P,EAAO7B,WAASM,SAAS5P,KAAK0Q,OAAQrP,GAGtCrB,KAAKyF,QACPzF,KAAK6P,aAAarI,GAIpB2J,EAAK1M,S,CAMG+H,OACRnB,MAAMmB,OACN,IAAK,MAAMhF,KAAUxH,KACnBA,KAAKwP,aAAahI,E,CASZgI,aAAahI,GAEjBxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,aAI7ChL,KAAKyF,OAAQ4C,K,CAQLwH,aAAarI,GAEjBxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7ClL,KAAKyF,OAAQ4C,K,CAMLsB,aAAa3C,GACrBqE,MAAM1B,aAAa3C,GACnBhH,KAAKyF,OAAQyC,Q,CAML6B,eAAe/C,GACvBqE,MAAMtB,eAAe/C,GACrBhH,KAAKyF,OAAQ4C,K,CAMLwE,aAAa7F,GACrBhH,KAAKyF,OAAQ4C,K,CAMLyE,cAAc9F,GACtBhH,KAAKyF,OAAQ4C,K,CAMLmB,SAASxC,GACbhH,KAAKyF,OAAQW,WACfpG,KAAKwS,QAAQxL,EAAIuE,MAAOvE,EAAIwE,O,CAOtB/B,gBAAgBzC,GACpBhH,KAAKyF,OAAQW,WACfpG,KAAKwS,SAAS,GAAI,E,CAOZ9I,aAAa1C,GACjBhH,KAAKyF,OAAQC,YACf1F,KAAKyS,M,CAODA,OAEN,IAAK,IAAIpR,EAAI,EAAGiB,EAAItC,KAAKk9B,SAAU77B,EAAIiB,IAAKjB,EAC1CrB,KAAKg9B,WAAW37B,GAAGnB,QAAU,EAE/B,IAAK,IAAImB,EAAI,EAAGiB,EAAItC,KAAKo9B,YAAa/7B,EAAIiB,IAAKjB,EAC7CrB,KAAKi9B,cAAc57B,GAAGnB,QAAU,EAIlC,IAAIwb,EAAQ1b,KAAK0Q,OAAOmtB,QAAOD,IAAOA,EAAG13B,WAGzC,IAAK,IAAI7E,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EACzCqa,EAAMra,GAAGgH,MAIX,IAAIy1B,EAAS99B,KAAKk9B,SAAW,EACzBa,EAAS/9B,KAAKo9B,YAAc,EAGhC1hB,EAAM4G,KAAK7hB,EAAQu9B,YAGnB,IAAK,IAAI38B,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EAAG,CAE5C,IAAI8P,EAAOuK,EAAMra,GAGbwyB,EAAS8I,GAAWsB,cAAc9sB,EAAK3J,QACvCma,EAAKjgB,KAAKH,IAAIsyB,EAAOqK,IAAKJ,GAC1Bjc,EAAKngB,KAAKH,IAAIsyB,EAAOqK,IAAMrK,EAAOsK,QAAU,EAAGL,GAGnDr9B,EAAQ29B,cAAcp+B,KAAKg9B,WAAYrb,EAAIE,EAAI1Q,EAAKzE,UACrD,CAGDgP,EAAM4G,KAAK7hB,EAAQ49B,eAGnB,IAAK,IAAIh9B,EAAI,EAAGiB,EAAIoZ,EAAM3a,OAAQM,EAAIiB,IAAKjB,EAAG,CAE5C,IAAI8P,EAAOuK,EAAMra,GAGbwyB,EAAS8I,GAAWsB,cAAc9sB,EAAK3J,QACvC82B,EAAK58B,KAAKH,IAAIsyB,EAAO0K,OAAQR,GAC7BS,EAAK98B,KAAKH,IAAIsyB,EAAO0K,OAAS1K,EAAO4K,WAAa,EAAGV,GAGzDt9B,EAAQ29B,cAAcp+B,KAAKi9B,cAAeqB,EAAIE,EAAIrtB,EAAK1E,SACxD,CAGD,GAAuB,sBAAnBzM,KAAKuM,UAEP,YADA1G,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,eAKnD,IAAI6K,EAAO6qB,EAAS99B,KAAK48B,YACrB5pB,EAAO+qB,EAAS/9B,KAAK68B,eAGzB,IAAK,IAAIx7B,EAAI,EAAGiB,EAAItC,KAAKk9B,SAAU77B,EAAIiB,IAAKjB,EAC1C4R,GAAQjT,KAAKg9B,WAAW37B,GAAGnB,QAE7B,IAAK,IAAImB,EAAI,EAAGiB,EAAItC,KAAKo9B,YAAa/7B,EAAIiB,IAAKjB,EAC7C2R,GAAQhT,KAAKi9B,cAAc57B,GAAGnB,QAIhC,IAAIiT,EAAOnT,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,MACzD6N,GAAQG,EAAIE,cACZJ,GAAQE,EAAIG,YAGZ,IAAI1M,EAAQ5G,KAAKyF,OAAQN,KAAKyB,MAC9BA,EAAM6F,SAAW,GAAGuG,MACpBpM,EAAM8F,UAAY,GAAGuG,MAGrBjT,KAAKuQ,QAAS,EAIVvQ,KAAKyF,OAAQA,QACfI,cAAYqB,YAAYlH,KAAKyF,OAAQA,OAASd,EAAOwC,IAAImB,YAKvDtI,KAAKuQ,QACP1K,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,c,CAS7CoK,QAAQe,EAAqBC,GAEnCxT,KAAKuQ,QAAS,EAGVgD,EAAc,IAChBA,EAAcvT,KAAKyF,OAAQN,KAAKoO,aAE9BC,EAAe,IACjBA,EAAexT,KAAKyF,OAAQN,KAAKqO,cAI9BxT,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,OAIhD,IAAIgJ,EAAMnO,KAAK4Q,KAAK6C,WAChBrF,EAAOpO,KAAK4Q,KAAK8C,YACjBnI,EAAQgI,EAAcvT,KAAK4Q,KAAKyC,cAChC7H,EAASgI,EAAexT,KAAK4Q,KAAK0C,YAGlCwqB,EAAS99B,KAAKk9B,SAAW,EACzBa,EAAS/9B,KAAKo9B,YAAc,EAG5BsB,EAAgBZ,EAAS99B,KAAK48B,YAC9B+B,EAAgBZ,EAAS/9B,KAAK68B,eAGlCr8B,YAAUG,KAAKX,KAAKg9B,WAAYt7B,KAAKF,IAAI,EAAGgK,EAASkzB,IACrDl+B,YAAUG,KAAKX,KAAKi9B,cAAev7B,KAAKF,IAAI,EAAG+J,EAAQozB,IAGvD,IAAK,IAAIt9B,EAAI,EAAGkW,EAAMpJ,EAAK7L,EAAItC,KAAKk9B,SAAU77B,EAAIiB,IAAKjB,EACrDrB,KAAK88B,WAAWz7B,GAAKkW,EACrBA,GAAOvX,KAAKg9B,WAAW37B,GAAGf,KAAON,KAAK48B,YAIxC,IAAK,IAAIv7B,EAAI,EAAGkW,EAAMnJ,EAAM9L,EAAItC,KAAKo9B,YAAa/7B,EAAIiB,IAAKjB,EACzDrB,KAAK+8B,cAAc17B,GAAKkW,EACxBA,GAAOvX,KAAKi9B,cAAc57B,GAAGf,KAAON,KAAK68B,eAI3C,IAAK,IAAIx7B,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GAGvB,GAAI8P,EAAKjL,SACP,SAIF,IAAI2tB,EAAS8I,GAAWsB,cAAc9sB,EAAK3J,QACvCma,EAAKjgB,KAAKH,IAAIsyB,EAAOqK,IAAKJ,GAC1BQ,EAAK58B,KAAKH,IAAIsyB,EAAO0K,OAAQR,GAC7Blc,EAAKngB,KAAKH,IAAIsyB,EAAOqK,IAAMrK,EAAOsK,QAAU,EAAGL,GAC/CU,EAAK98B,KAAKH,IAAIsyB,EAAO0K,OAAS1K,EAAO4K,WAAa,EAAGV,GAGrDnZ,EAAI5kB,KAAK+8B,cAAcuB,GACvBzZ,EAAI7kB,KAAK88B,WAAWnb,GACpBid,EAAI5+B,KAAK+8B,cAAcyB,GAAMx+B,KAAKi9B,cAAcuB,GAAIl+B,KAAOskB,EAC3D9F,EAAI9e,KAAK88B,WAAWjb,GAAM7hB,KAAKg9B,WAAWnb,GAAIvhB,KAAOukB,EAGzD1T,EAAKjJ,OAAO0c,EAAGC,EAAG+Z,EAAG9f,EACtB,C,GAiBL,SAAiB6d,GAkECA,EAAAsB,cAAhB,SAA8Bz2B,GAC5B,OAAO/G,EAAQo+B,mBAAmBt4B,IAAIiB,E,EAUxBm1B,EAAAmC,cAAhB,SACEt3B,EACAlD,GAEA7D,EAAQo+B,mBAAmB1xB,IAAI3F,EAAQ/G,EAAQs+B,gBAAgBz6B,G,CAElE,CAnFD,CAAiBq4B,QAmFhB,KAKD,SAAUl8B,GAIKA,EAAkBo+B,mBAAG,IAAI/4B,mBAGpC,CACA4B,KAAM,aACNuE,OAAQ,MAASiyB,IAAK,EAAGK,OAAQ,EAAGJ,QAAS,EAAGM,WAAY,IAC5Dp6B,QAuGF,SAAkC+G,GAC5BA,EAAM3F,QAAU2F,EAAM3F,OAAO4B,kBAAkBs1B,IACjDvxB,EAAM3F,OAAO4C,K,IAnGD5H,EAAAs+B,gBAAhB,SACElL,GAMA,MAAO,CAAEqK,IAJCx8B,KAAKF,IAAI,EAAGE,KAAKuO,MAAM4jB,EAAOqK,KAAO,IAIjCK,OAHD78B,KAAKF,IAAI,EAAGE,KAAKuO,MAAM4jB,EAAO0K,QAAU,IAG/BJ,QAFRz8B,KAAKF,IAAI,EAAGE,KAAKuO,MAAM4jB,EAAOsK,SAAW,IAExBM,WADd/8B,KAAKF,IAAI,EAAGE,KAAKuO,MAAM4jB,EAAO4K,YAAc,I,EAO/Ch+B,EAAA68B,WAAhB,SAA2Bh5B,GACzB,OAAO5C,KAAKF,IAAI,EAAGE,KAAKuO,MAAM3L,G,EAMhB7D,EAAAu9B,WAAhB,SAA2B1pB,EAAeC,GACxC,IAAI+pB,EAAK79B,EAAAo+B,mBAAmBt4B,IAAI+N,EAAE9M,QAC9Bg3B,EAAK/9B,EAAAo+B,mBAAmBt4B,IAAIgO,EAAE/M,QAClC,OAAO82B,EAAGH,QAAUK,EAAGL,O,EAMT19B,EAAA49B,cAAhB,SAA8B/pB,EAAeC,GAC3C,IAAI+pB,EAAK79B,EAAAo+B,mBAAmBt4B,IAAI+N,EAAE9M,QAC9Bg3B,EAAK/9B,EAAAo+B,mBAAmBt4B,IAAIgO,EAAE/M,QAClC,OAAO82B,EAAGG,WAAaD,EAAGC,U,EAMZh+B,EAAA08B,cAAhB,SAA8Bv8B,EAAoBE,GAKhD,IAHAA,EAAQY,KAAKF,IAAI,EAAGE,KAAKuO,MAAMnP,IAGxBF,EAAOG,OAASD,GACrBF,EAAOiR,KAAK,IAAI/R,GAIdc,EAAOG,OAASD,IAClBF,EAAOG,OAASD,E,EAOJL,EAAA29B,cAAhB,SACEx9B,EACA2gB,EACAC,EACAthB,GAGA,GAAIshB,EAAKD,EACP,OAIF,GAAIA,IAAOC,EAAI,CACb,IAAIlgB,EAAQV,EAAO2gB,GAEnB,YADAjgB,EAAMpB,QAAUwB,KAAKF,IAAIF,EAAMpB,QAASA,GAEzC,CAGD,IAAIc,EAAW,EACf,IAAK,IAAIK,EAAIkgB,EAAIlgB,GAAKmgB,IAAMngB,EAC1BL,GAAYJ,EAAOS,GAAGnB,QAIxB,GAAIc,GAAYd,EACd,OAIF,IAAI8+B,GAAW9+B,EAAUc,IAAawgB,EAAKD,EAAK,GAGhD,IAAK,IAAIlgB,EAAIkgB,EAAIlgB,GAAKmgB,IAAMngB,EAC1BT,EAAOS,GAAGnB,SAAW8+B,C,CAY1B,CAtHD,CAAUv+B,MAsHT,KCn0BK,MAAOw+B,WAAgBt6B,EAM3B5E,YAAY8C,EAA4B,IACtCwI,MAAM,CAAElG,KAAM1E,EAAQ2E,eA+1BhBpF,KAAYgb,cAAI,EAKhBhb,KAAck/B,eAAG,EAGjBl/B,KAAMm/B,OAAW,GACjBn/B,KAAUqjB,WAAgB,KAC1BrjB,KAAao/B,cAAgB,KAC7Bp/B,KAAcq/B,eAAa,GAC3Br/B,KAAcs/B,gBAAY,EA12BhCt/B,KAAKqF,SAAS,cACdrF,KAAKsF,QAAQX,EAAOY,KAAK+B,gBACzBtH,KAAK+Q,SAAWlO,EAAQkO,UAAYkuB,GAAQxnB,gBAC5CzX,KAAKu/B,oBAAsB18B,EAAQ28B,oBAAsB,CACvD1a,QAAQ,EACRC,QAAQ,GAEV/kB,KAAKy/B,qBAAuB58B,EAAQ68B,qBAAuB,CACzDt5B,WAAW,E,CAOf3B,UACEzE,KAAKsmB,kBACLtmB,KAAKm/B,OAAOp+B,OAAS,EACrBsK,MAAM5G,S,CAcJmf,gBACF,OAAO5jB,KAAKqjB,U,CAMVsc,oBACF,OAAO3/B,KAAKs/B,c,CAMVM,mBACF,OAAO5/B,KAAKo/B,a,CAWV3jB,kBACF,OAAOzb,KAAKmF,KAAKoW,uBACf,sBACA,E,CAMAskB,iBACF,OAAO7/B,KAAKm/B,OAAOn/B,KAAKgb,eAAiB,I,CASvC6kB,eAAWv7B,GACbtE,KAAK+c,YAAczY,EAAQtE,KAAKm/B,OAAO/vB,QAAQ9K,IAAU,C,CASvDyY,kBACF,OAAO/c,KAAKgb,Y,CASV+B,gBAAYzY,IAEVA,EAAQ,GAAKA,GAAStE,KAAKm/B,OAAOp+B,UACpCuD,GAAS,GAIPA,GAAS,GAAyC,IAApCtE,KAAKm/B,OAAO76B,GAAOoX,MAAM3a,SACzCuD,GAAS,GAIPtE,KAAKgb,eAAiB1W,IAK1BtE,KAAKgb,aAAe1W,EAGpBtE,KAAKkI,S,CAMH43B,YACF,OAAO9/B,KAAKm/B,M,CASdY,kBAE6B,IAAvB//B,KAAKgb,eAKThb,KAAKukB,iBAGDvkB,KAAKqjB,aACPrjB,KAAKqjB,WAAWtG,aAAe,EAC/B/c,KAAKqjB,WAAWa,oB,CAYpB8b,QAAQlc,EAAY5b,GAAkB,GACpClI,KAAKigC,WAAWjgC,KAAKm/B,OAAOp+B,OAAQ+iB,EAAM5b,E,CAe5C+3B,WAAW/9B,EAAe4hB,EAAY5b,GAAkB,GAEtDlI,KAAKsmB,kBAGL,IAAIjlB,EAAIrB,KAAKm/B,OAAO/vB,QAAQ0U,GAGxBzU,EAAI3N,KAAKF,IAAI,EAAGE,KAAKH,IAAIW,EAAOlC,KAAKm/B,OAAOp+B,SAGhD,IAAW,IAAPM,EAkBF,OAhBAiO,WAASC,OAAOvP,KAAKm/B,OAAQ9vB,EAAGyU,GAGhCA,EAAKze,SAAS,mBAGdye,EAAKL,aAAa1L,QAAQ/X,KAAKkgC,oBAAqBlgC,MACpD8jB,EAAKJ,cAAc3L,QAAQ/X,KAAKmgC,qBAAsBngC,MACtD8jB,EAAKle,MAAMvB,QAAQ0T,QAAQ/X,KAAKgY,gBAAiBhY,WAG7CkI,GACFlI,KAAKkI,UAULmH,IAAMrP,KAAKm/B,OAAOp+B,QACpBsO,IAIEhO,IAAMgO,IAKVC,WAASG,KAAKzP,KAAKm/B,OAAQ99B,EAAGgO,GAG1BnH,GACFlI,KAAKkI,S,CAYTk4B,WAAWtc,EAAY5b,GAAkB,GACvClI,KAAKqgC,aAAargC,KAAKm/B,OAAO/vB,QAAQ0U,GAAO5b,E,CAW/Cm4B,aAAan+B,EAAegG,GAAkB,GAE5ClI,KAAKsmB,kBAGL,IAAIxC,EAAOxU,WAASM,SAAS5P,KAAKm/B,OAAQj9B,GAGrC4hB,IAKLA,EAAKL,aAAa4J,WAAWrtB,KAAKkgC,oBAAqBlgC,MACvD8jB,EAAKJ,cAAc2J,WAAWrtB,KAAKmgC,qBAAsBngC,MACzD8jB,EAAKle,MAAMvB,QAAQgpB,WAAWrtB,KAAKgY,gBAAiBhY,MAGpD8jB,EAAKjc,YAAY,mBAGbK,GACFlI,KAAKkI,S,CAOTo4B,aAEE,GAA2B,IAAvBtgC,KAAKm/B,OAAOp+B,OAAhB,CAKAf,KAAKsmB,kBAGL,IAAK,IAAIxC,KAAQ9jB,KAAKm/B,OACpBrb,EAAKL,aAAa4J,WAAWrtB,KAAKkgC,oBAAqBlgC,MACvD8jB,EAAKJ,cAAc2J,WAAWrtB,KAAKmgC,qBAAsBngC,MACzD8jB,EAAKle,MAAMvB,QAAQgpB,WAAWrtB,KAAKgY,gBAAiBhY,MACpD8jB,EAAKjc,YAAY,mBAInB7H,KAAKm/B,OAAOp+B,OAAS,EAGrBf,KAAKkI,QAjBJ,C,CA8BH6N,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,UACHtJ,KAAKoW,YAAYJ,GACjB,MACF,IAAK,YACHhW,KAAKqlB,cAAcrP,GACnB,MACF,IAAK,YACHhW,KAAKklB,cAAclP,GACnB,MACF,IAAK,WACHhW,KAAKugC,aAAavqB,GAClB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,UAAWvW,MACtCA,KAAKmF,KAAKoR,iBAAiB,YAAavW,MACxCA,KAAKmF,KAAKoR,iBAAiB,YAAavW,MACxCA,KAAKmF,KAAKoR,iBAAiB,WAAYvW,MACvCA,KAAKmF,KAAKoR,iBAAiB,cAAevW,K,CAMlCkK,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,UAAWxW,MACzCA,KAAKmF,KAAKqR,oBAAoB,YAAaxW,MAC3CA,KAAKmF,KAAKqR,oBAAoB,YAAaxW,MAC3CA,KAAKmF,KAAKqR,oBAAoB,WAAYxW,MAC1CA,KAAKmF,KAAKqR,oBAAoB,cAAexW,MAC7CA,KAAKsmB,iB,CAMGnc,kBAAkBnD,GACtBhH,KAAK0F,YACP1F,KAAKwgC,aAAa,E,CAOZh3B,SAASxC,GACjBhH,KAAKkI,SACLmD,MAAM7B,SAASxC,E,CAMPyC,gBAAgBzC,G,MACxB,IAAI84B,EAAQ9/B,KAAKm/B,OACbpuB,EAAW/Q,KAAK+Q,SAChBgM,EAAc/c,KAAKgb,aACnBylB,EACFzgC,KAAKk/B,gBAAkB,GAAKl/B,KAAKk/B,eAAiBY,EAAM/+B,OACpDf,KAAKk/B,eACL,EACFn+B,EAASf,KAAKs/B,gBAAkB,EAAIt/B,KAAKs/B,eAAiBQ,EAAM/+B,OAChE2/B,EAAgB,EAChBt6B,GAAY,EAGhBrF,EAAgC,OAAvBf,KAAKo/B,cAAyBr+B,EAAS,EAAIA,EACpD,IAAI8b,EAAU,IAAIG,MAAsBjc,GAGxC,IAAK,IAAIM,EAAI,EAAGA,EAAIN,IAAUM,EAC5Bwb,EAAQxb,GAAK0P,EAASuM,WAAW,CAC/B1X,MAAOk6B,EAAMz+B,GAAGuE,MAChByX,OAAQhc,IAAM0b,EACd4jB,SAAUt/B,IAAMo/B,EAChBG,SAAoC,IAA1Bd,EAAMz+B,GAAGqa,MAAM3a,OACzB0kB,QAAS,KACPzlB,KAAKk/B,eAAiB79B,EACtBrB,KAAK+c,YAAc1b,CAAC,IAIxBq/B,GAAiB1gC,KAAKq/B,eAAeh+B,GAEjCy+B,EAAMz+B,GAAGuE,MAAMjC,QAAU3D,KAAKy/B,qBAAqB75B,QACrDQ,GAAY,EACZrF,KAIJ,GAAIf,KAAKy/B,qBAAqBr5B,UAC5B,GAAIpG,KAAKs/B,gBAAkB,IAAMl5B,EAAW,CAE1C,GAA2B,OAAvBpG,KAAKo/B,cAAwB,CAC/B,MAAMyB,EAAuD,QAAnC9S,EAAA/tB,KAAKy/B,qBAAqB75B,aAAS,IAAAmoB,IAAA,MAC7D/tB,KAAKo/B,cAAgB,IAAInc,EAAK,CAAE/H,SAAU,IAAImF,oBAC9CrgB,KAAKo/B,cAAcx5B,MAAMjC,MAAQk9B,EACjC7gC,KAAKo/B,cAAcx5B,MAAMhC,SAAW,EACpC5D,KAAKggC,QAAQhgC,KAAKo/B,eAAe,EAClC,CAED,IAAK,IAAI/9B,EAAIy+B,EAAM/+B,OAAS,EAAGM,GAAKN,EAAQM,IAAK,CAC/C,MAAM6kB,EAAUlmB,KAAK8/B,MAAMz+B,GAC3B6kB,EAAQtgB,MAAMhC,SAAW,EACzB5D,KAAKo/B,cAAc1a,WAAW,EAAG,CAC/Bpb,KAAM,UACN4c,QAASA,IAEXlmB,KAAKogC,WAAWla,GAAS,EAC1B,CACDrJ,EAAQ9b,GAAUgQ,EAASuM,WAAW,CACpC1X,MAAO5F,KAAKo/B,cAAcx5B,MAC1ByX,OAAQtc,IAAWgc,GAA8C,IAA/B+iB,EAAM/+B,GAAQ2a,MAAM3a,OACtD4/B,SAAU5/B,IAAW0/B,EACrBG,SAAyC,IAA/Bd,EAAM/+B,GAAQ2a,MAAM3a,OAC9B0kB,QAAS,KACPzlB,KAAKk/B,eAAiBn+B,EACtBf,KAAK+c,YAAchc,CAAM,IAG7BA,GACD,MAAM,GAA2B,OAAvBf,KAAKo/B,cAAwB,CAEtC,IAAI0B,EAAoB9gC,KAAKo/B,cAAc1jB,MACvCqlB,EAAa/gC,KAAKmF,KAAKoO,YACvBjR,EAAItC,KAAKo/B,cAAc1jB,MAAM3a,OACjC,IAAK,IAAIM,EAAI,EAAGA,EAAIiB,IAAKjB,EAAG,CAC1B,IAAIa,EAAQ49B,EAAM/+B,OAAS,EAAIM,EAC/B,GAAI0/B,EAAaL,EAAgB1gC,KAAKq/B,eAAen9B,GAAQ,CAC3D,IAAI4hB,EAAOgd,EAAkB,GAAG5a,QAChClmB,KAAKo/B,cAAcnjB,aAAa,GAChCjc,KAAKigC,WAAWl/B,EAAQ+iB,GAAM,GAC9BjH,EAAQ9b,GAAUgQ,EAASuM,WAAW,CACpC1X,MAAOke,EAAKle,MACZyX,QAAQ,EACRsjB,SAAU5/B,IAAW0/B,EACrBG,SAAyC,IAA/Bd,EAAM/+B,GAAQ2a,MAAM3a,OAC9B0kB,QAAS,KACPzlB,KAAKk/B,eAAiBn+B,EACtBf,KAAK+c,YAAchc,CAAM,IAG7BA,GACD,CACF,CACuC,IAApCf,KAAKo/B,cAAc1jB,MAAM3a,SAC3Bf,KAAKogC,WAAWpgC,KAAKo/B,eAAe,GACpCviB,EAAQ/N,MACR9O,KAAKo/B,cAAgB,KACrBp/B,KAAKs/B,gBAAkB,EAE1B,CAEH3iB,aAAWC,OAAOC,EAAS7c,KAAKyb,aAChCzb,KAAKghC,sB,CAMCA,uBACN,IAAKhhC,KAAKy/B,qBAAqBr5B,UAC7B,OAIF,MAAM66B,EAAYjhC,KAAKyb,YAAYwI,WACnC,IAAI8c,EAAa/gC,KAAKmF,KAAKoO,YACvBmtB,EAAgB,EAChBx+B,GAAS,EACTI,EAAI2+B,EAAUlgC,OAElB,GAAkC,GAA9Bf,KAAKq/B,eAAet+B,OAEtB,IAAK,IAAIM,EAAI,EAAGA,EAAIiB,EAAGjB,IAAK,CAC1B,IAAI8P,EAAO8vB,EAAU5/B,GAErBq/B,GAAiBvvB,EAAKoC,YACtBvT,KAAKq/B,eAAextB,KAAKV,EAAKoC,aAC1BmtB,EAAgBK,IAAyB,IAAX7+B,IAChCA,EAAQb,EAEX,MAGD,IAAK,IAAIA,EAAI,EAAGA,EAAIrB,KAAKq/B,eAAet+B,OAAQM,IAE9C,GADAq/B,GAAiB1gC,KAAKq/B,eAAeh+B,GACjCq/B,EAAgBK,EAAY,CAC9B7+B,EAAQb,EACR,KACD,CAGLrB,KAAKs/B,eAAiBp9B,C,CAShBkU,YAAYJ,GAElB,IAAI0P,EAAK1P,EAAMS,QAGf,GAAW,IAAPiP,EAEF,YADA1lB,KAAK+c,aAAe,GAStB,GAJA/G,EAAMK,iBACNL,EAAMM,kBAGK,KAAPoP,GAAoB,KAAPA,GAAoB,KAAPA,GAAoB,KAAPA,EAAW,CAIpD,GADA1lB,KAAK+c,YAAc/c,KAAKk/B,eACpBl/B,KAAK+c,cAAgB/c,KAAKk/B,eAI5B,OAGF,YADAl/B,KAAK+/B,gBAEN,CAGD,GAAW,KAAPra,EAGF,OAFA1lB,KAAKsmB,uBACLtmB,KAAKwgC,aAAaxgC,KAAK+c,aAKzB,GAAW,KAAP2I,GAAoB,KAAPA,EAAW,CAC1B,IAAIhM,EAAmB,KAAPgM,GAAa,EAAI,EAC7BxH,EAAQle,KAAKk/B,eAAiBxlB,EAC9BpX,EAAItC,KAAKm/B,OAAOp+B,OACpB,IAAK,IAAIM,EAAI,EAAGA,EAAIiB,EAAGjB,IAAK,CAC1B,IAAIa,GAASI,EAAI4b,EAAQxE,EAAYrY,GAAKiB,EAC1C,GAAItC,KAAKm/B,OAAOj9B,GAAOwZ,MAAM3a,OAE3B,YADAf,KAAKwgC,aAAat+B,EAGrB,CACD,MACD,CAGD,IAAIqX,EAAMoM,sBAAoBC,mBAAmB5P,GAGjD,IAAKuD,EACH,OAIF,IAAI2E,EAAQle,KAAKgb,aAAe,EAC5BiC,EAASxc,EAAQolB,aAAa7lB,KAAKm/B,OAAQ5lB,EAAK2E,IAM9B,IAAlBjB,EAAO/a,OAAiB+a,EAAO6I,UAGN,IAAlB7I,EAAO/a,OAChBlC,KAAK+c,YAAcE,EAAO/a,MAC1BlC,KAAKwgC,aAAaxgC,KAAK+c,eACG,IAAjBE,EAAO8I,OAChB/lB,KAAK+c,YAAcE,EAAO8I,KAC1B/lB,KAAKwgC,aAAaxgC,KAAK+c,eAPvB/c,KAAK+c,YAAcE,EAAO/a,MAC1BlC,KAAK+/B,iB,CAaD1a,cAAcrP,GAGpB,IAAK1H,aAAW0X,QAAQhmB,KAAKmF,KAAM6Q,EAAMe,QAASf,EAAMgB,SACtD,OAKFhB,EAAMM,kBACNN,EAAMkrB,2BAGN,IAAIh/B,EAAQoN,WAASqH,eAAe3W,KAAKyb,YAAYlU,UAAUpC,GACtDmJ,aAAW0X,QAAQ7gB,EAAM6Q,EAAMe,QAASf,EAAMgB,WAIvD,IAAe,IAAX9U,GAMJ,GAAqB,IAAjB8T,EAAMU,OAKV,GAAI1W,KAAKqjB,WACPrjB,KAAKsmB,kBACLtmB,KAAK+c,YAAc7a,MACd,CAGL8T,EAAMK,iBACN,MAAMpI,EAAWjO,KAAKmhC,iBAAiBj/B,GACvC+gB,EAAKsD,iBAELvmB,KAAK+c,YAAc7a,EACnBlC,KAAKukB,eAAetW,EACrB,OAtBCjO,KAAKsmB,iB,CA4BDpB,cAAclP,GAEpB,IAAI9T,EAAQoN,WAASqH,eAAe3W,KAAKyb,YAAYlU,UAAUpC,GACtDmJ,aAAW0X,QAAQ7gB,EAAM6Q,EAAMe,QAASf,EAAMgB,WAIvD,GAAI9U,IAAUlC,KAAKgb,aACjB,OAMF,IAAe,IAAX9Y,GAAgBlC,KAAKqjB,WACvB,OAIF,MAAMpV,EACJ/L,GAAS,GAAKlC,KAAKqjB,WAAarjB,KAAKmhC,iBAAiBj/B,GAAS,KAGjE+gB,EAAKsD,iBAKLvmB,KAAK+c,YAAc7a,EAGf+L,GACFjO,KAAKukB,eAAetW,E,CAWhBkzB,iBAAiBj/B,GACvB,IAAIskB,EAAWxmB,KAAKyb,YAAYlU,SAASrF,IACrCkM,KAAEA,EAAI+a,OAAEA,GAAY3C,EAAyB1P,wBACjD,MAAO,CACL3I,IAAKgb,EACL/a,O,CAOImyB,aAAavqB,GAEdhW,KAAKqjB,YAAerjB,KAAKmF,KAAK2B,SAASkP,EAAMorB,iBAChDphC,KAAK+c,aAAe,E,CAUhByjB,aAAat+B,GACnB,MAAMskB,EAAWxmB,KAAKyb,YAAYwI,WAAW/hB,GACzCskB,GACFA,EAAS5M,O,CAUL2K,eAAe1hB,EAA2C,IAEhE,IAAIw+B,EAAUrhC,KAAK6/B,WACnB,IAAKwB,EAEH,YADArhC,KAAKsmB,kBAKP,IAAIgb,EAAUthC,KAAKqjB,WACnB,GAAIie,IAAYD,EACd,OAIFrhC,KAAKqjB,WAAage,EAGdC,EACFA,EAAQ74B,QAERyD,SAASqK,iBAAiB,YAAavW,MAAM,GAI/CA,KAAKk/B,eAAiBl/B,KAAK+c,YAC3BlX,cAAYqB,YAAYlH,KAAM2E,EAAOwC,IAAIiB,eAGzC,IAAIgG,KAAEA,EAAID,IAAEA,GAAQtL,OACA,IAATuL,QAAuC,IAARD,KACrCC,OAAMD,OAAQnO,KAAKmhC,iBAAiBnhC,KAAKgb,eAIzCsmB,GAEHthC,KAAKqF,SAAS,iBAIZg8B,EAAQ3lB,MAAM3a,OAAS,GACzBsgC,EAAQ1c,KAAKvW,EAAMD,EAAKnO,KAAKu/B,oB,CASzBjZ,kBAEN,IAAKtmB,KAAKqjB,WACR,OAGFrjB,KAAK6H,YAAY,iBAGjBqE,SAASsK,oBAAoB,YAAaxW,MAAM,GAGhD,IAAI8jB,EAAO9jB,KAAKqjB,WAChBrjB,KAAKqjB,WAAa,KAGlBS,EAAKrb,QAGLzI,KAAK+c,aAAe,C,CAMdmjB,oBAAoB5nB,GAEtBA,IAAWtY,KAAKqjB,aAKpBrjB,KAAK6H,YAAY,iBAGjBqE,SAASsK,oBAAoB,YAAaxW,MAAM,GAGhDA,KAAKqjB,WAAa,KAGlBrjB,KAAK+c,aAAe,E,CAMdojB,qBAAqB7nB,EAAcoG,GAEzC,GAAIpG,IAAWtY,KAAKqjB,WAClB,OAIF,IAAIhiB,EAAIrB,KAAKgb,aACT1Y,EAAItC,KAAKm/B,OAAOp+B,OAGpB,OAAQ2d,GACN,IAAK,OACH1e,KAAK+c,YAAc1b,IAAMiB,EAAI,EAAI,EAAIjB,EAAI,EACzC,MACF,IAAK,WACHrB,KAAK+c,YAAoB,IAAN1b,EAAUiB,EAAI,EAAIjB,EAAI,EAK7CrB,KAAK+/B,gB,CAMC/nB,kBACNhY,KAAKkI,Q,GAsBT,SAAiB+2B,GAmFf,MAAaznB,EAQX8F,WAAWhI,GACT,IAAIrR,EAAYjE,KAAKgf,gBAAgB1J,GACjClR,EAAUpE,KAAKif,kBAAkB3J,GACjCwR,EAAO9mB,KAAK+mB,eAAezR,GAC/B,OAAOwJ,IAAEC,GACP,CACE9a,YACAG,aACIkR,EAAKsrB,SAAW,GAAK,CAAE5Z,SAAU1R,EAAKqrB,SAAW,IAAM,MAC3Dlb,QAASnQ,EAAKmQ,WACXqB,GAEL9mB,KAAKinB,WAAW3R,GAChBtV,KAAKknB,YAAY5R,G,CAWrB2R,WAAW3R,GACT,IAAIrR,EAAYjE,KAAKyf,gBAAgBnK,GAGrC,OAAOwJ,IAAEY,IAAI,CAAEzb,aAAaqR,EAAK1P,MAAM/B,KAAOyR,EAAK1P,MAAM7B,U,CAU3DmjB,YAAY5R,GACV,IAAIuH,EAAU7c,KAAKqnB,YAAY/R,GAC/B,OAAOwJ,IAAEY,IAAI,CAAEzb,UAAW,wBAA0B4Y,E,CAUtDmC,gBAAgB1J,GACd,IAAI5N,EAAO,kBAOX,OANI4N,EAAK1P,MAAM3B,YACbyD,GAAQ,IAAI4N,EAAK1P,MAAM3B,aAErBqR,EAAK+H,SAAW/H,EAAKsrB,WACvBl5B,GAAQ,kBAEHA,C,CAUTuX,kBAAkB3J,GAChB,OAAOA,EAAK1P,MAAMxB,O,CAUpB2iB,eAAezR,GACb,MAAO,CACL6J,KAAM,WACN,gBAAiB,OACjB,gBAAiB7J,EAAKsrB,SAAW,OAAS,Q,CAW9CnhB,gBAAgBnK,GACd,IAAI5N,EAAO,sBACPiM,EAAQ2B,EAAK1P,MAAM9B,UACvB,OAAO6P,EAAQ,GAAGjM,KAAQiM,IAAUjM,C,CAUtC2f,YAAY/R,GAEV,IAAI3R,MAAEA,EAAKC,SAAEA,GAAa0R,EAAK1P,MAG/B,GAAIhC,EAAW,GAAKA,GAAYD,EAAM5C,OACpC,OAAO4C,EAIT,IAAI4jB,EAAS5jB,EAAMiO,MAAM,EAAGhO,GACxB4jB,EAAS7jB,EAAMiO,MAAMhO,EAAW,GAChC6jB,EAAO9jB,EAAMC,GAMjB,MAAO,CAAC2jB,EAHGzI,IAAE4I,KAAK,CAAEzjB,UAAW,2BAA6BwjB,GAGtCD,E,EArIbyX,EAAAznB,SAAQA,EA4IRynB,EAAAxnB,gBAAkB,IAAID,CACpC,CAhOD,CAAiBynB,QAgOhB,KAuBD,SAAUx+B,GAIQA,EAAA2E,WAAhB,WACE,IAAID,EAAO+G,SAASC,cAAc,OAC9B0Q,EAAU3Q,SAASC,cAAc,MAIrC,OAHA0Q,EAAQ5Y,UAAY,qBACpBkB,EAAKoN,YAAYsK,GACjBA,EAAQpS,aAAa,OAAQ,WACtBtF,C,EA0CO1E,EAAAolB,aAAhB,SACEia,EACAvmB,EACA2E,GAGA,IAAIhc,GAAS,EACT6jB,GAAQ,EACRD,GAAW,EAGXwD,EAAW/P,EAAIgQ,cAGnB,IAAK,IAAIloB,EAAI,EAAGiB,EAAIw9B,EAAM/+B,OAAQM,EAAIiB,IAAKjB,EAAG,CAE5C,IAAImoB,GAAKnoB,EAAI6c,GAAS5b,EAGlBsD,EAAQk6B,EAAMtW,GAAG5jB,MAGrB,GAA2B,IAAvBA,EAAMjC,MAAM5C,OACd,SAIF,IAAI0oB,EAAK7jB,EAAMhC,SAGX6lB,GAAM,GAAKA,EAAK7jB,EAAMjC,MAAM5C,OAC1B6E,EAAMjC,MAAM8lB,GAAIF,gBAAkBD,KACrB,IAAXpnB,EACFA,EAAQsnB,EAER1D,GAAW,IAOH,IAAVC,GAAengB,EAAMjC,MAAM,GAAG4lB,gBAAkBD,IAClDvD,EAAOyD,EAEV,CAGD,MAAO,CAAEtnB,QAAO4jB,WAAUC,O,CAE7B,CAtGD,CAAUtlB,MAsGT,MCphBD,SAAUA,GA4CQA,EAAA2E,WAAhB,WACE,IAAID,EAAO+G,SAASC,cAAc,OAC9Bo1B,EAAYr1B,SAASC,cAAc,OACnCq1B,EAAYt1B,SAASC,cAAc,OACnCs1B,EAAQv1B,SAASC,cAAc,OAC/Bu1B,EAAQx1B,SAASC,cAAc,OAWnC,OAVAo1B,EAAUt9B,UAAY,sBACtBu9B,EAAUv9B,UAAY,sBACtBs9B,EAAUn9B,QAAgB,OAAI,YAC9Bo9B,EAAUp9B,QAAgB,OAAI,YAC9Bq9B,EAAMx9B,UAAY,qBAClBy9B,EAAMz9B,UAAY,qBAClBw9B,EAAMlvB,YAAYmvB,GAClBv8B,EAAKoN,YAAYgvB,GACjBp8B,EAAKoN,YAAYkvB,GACjBt8B,EAAKoN,YAAYivB,GACVr8B,C,EAMO1E,EAAAkhC,SAAhB,SACEC,EACAhrB,GAGA,OAAIgrB,EAAUC,UAAU/6B,SAAS8P,GACxB,QAILgrB,EAAUE,UAAUh7B,SAAS8P,GACxB,QAILgrB,EAAUG,cAAcj7B,SAAS8P,GAC5B,YAILgrB,EAAUI,cAAcl7B,SAAS8P,GAC5B,YAIF,I,CAEV,CA7FD,CAAUnW,MA6FT,KG5yBK,MAAOwhC,WAAwB51B,EAArCtM,c,oBAuKUC,KAAOkiC,QAAkB,I,CAnKjCz9B,UACE,GAAIzE,KAAKkiC,QAAS,CAChB,IAAI16B,EAASxH,KAAKkiC,QAClBliC,KAAKkiC,QAAU,KACf16B,EAAO/C,SACR,CACD4G,MAAM5G,S,CAMJ+C,aACF,OAAOxH,KAAKkiC,O,CAWV16B,WAAOA,GAGLA,IACFA,EAAO/B,OAASzF,KAAKyF,QAInBzF,KAAKkiC,UAAY16B,IAKjBxH,KAAKkiC,SACPliC,KAAKkiC,QAAQz9B,UAIfzE,KAAKkiC,QAAU16B,EAGXxH,KAAKyF,QAAU+B,GACjBxH,KAAKwP,aAAahI,G,CAStB,EAAEwH,OAAOC,YACHjP,KAAKkiC,gBACDliC,KAAKkiC,Q,CAiBfn1B,aAAavF,GAEPxH,KAAKkiC,UAAY16B,IAKrBxH,KAAKkiC,QAAU,KAGXliC,KAAKyF,QACPzF,KAAK6P,aAAarI,G,CAOZgF,OACRnB,MAAMmB,OACN,IAAK,MAAMhF,KAAUxH,KACnBA,KAAKwP,aAAahI,E,CAsBZgI,aAAahI,GAEjBxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,Y,CAoBrC6E,aAAarI,GAEjBxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,Y,EC9J3C,MAAOi3B,WAAsBvzB,EACjC7O,YAAY8C,EAAkC,IAC5CwI,MAAMxI,GAgVA7C,KAAMuQ,QAAG,EACTvQ,KAAM0Q,OAAiB,GACvB1Q,KAAI4Q,KAAiC,KAjV3C5Q,KAAKgF,iBACoB9B,IAAvBL,EAAQ4D,WACJ5D,EAAQ4D,WACR9B,EAAOM,WAAWC,O,CAUtBuB,iBACF,OAAOzG,KAAKgF,W,CAUVyB,eAAWyN,GACTlU,KAAKgF,cAAgBkP,IAGzBlU,KAAKgF,YAAckP,EACflU,KAAK+O,QAAQhO,OAAS,GACxBf,KAAK+O,QAAQiK,SAAQ4lB,IACnBA,EAAEn4B,WAAazG,KAAKgF,WAAW,I,CAQrCP,UAEE,IAAK,MAAM0M,KAAQnR,KAAK0Q,OACtBS,EAAK1M,UAIPzE,KAAK4Q,KAAO,KACZ5Q,KAAK0Q,OAAO3P,OAAS,EAGrBsK,MAAM5G,S,CAaE+K,aAAatN,EAAesF,GAIlCxH,KAAKgF,cAAgBL,EAAOM,WAAW0B,OACvC3G,KAAK0Q,OAAO3P,OAAS,GAEM,IAAvBf,KAAK0Q,OAAO3P,SACdf,KAAK+O,QAAQ,GAAGtI,WAAa9B,EAAOM,WAAW0B,OAEjDa,EAAOf,WAAa9B,EAAOM,WAAW0B,OAEtCa,EAAOf,WAAa9B,EAAOM,WAAWC,QAIxCoK,WAASC,OAAOvP,KAAK0Q,OAAQxO,EAAO,IAAIqL,EAAW/F,IAG/CxH,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI4D,cAI7C/K,KAAKyF,OAAQN,KAAKoN,YAAY/K,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI6D,aAI7ChL,KAAKyF,OAAQ4C,K,CAeLqH,WACRI,EACAC,EACAvI,GAGA8H,WAASG,KAAKzP,KAAK0Q,OAAQZ,EAAWC,GAGtC/P,KAAKyF,OAAQyC,Q,CAaL2H,aAAa3N,EAAesF,GAEpC,IAAI2J,EAAO7B,WAASM,SAAS5P,KAAK0Q,OAAQxO,GAGtClC,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI8D,cAI7CjL,KAAKyF,OAAQN,KAAK6G,YAAYxE,EAAOrC,MAGjCnF,KAAKyF,OAAQC,YACfG,cAAYqB,YAAYM,EAAQ7C,EAAOwC,IAAI+D,aAI7CiG,EAAM3J,OAAOrC,KAAKyB,MAAMgE,OAAS,GAG7B5K,KAAKgF,cAAgBL,EAAOM,WAAW0B,QACzCa,EAAOf,WAAa9B,EAAOM,WAAWC,QAGX,IAAvBlF,KAAK0Q,OAAO3P,SACdf,KAAK0Q,OAAO,GAAGlJ,OAAOf,WAAa9B,EAAOM,WAAWC,UAKzDiM,EAAM1M,UAGNzE,KAAKyF,OAAQ4C,K,CAMLsB,aAAa3C,GACrBqE,MAAM1B,aAAa3C,GACnBhH,KAAKyF,OAAQyC,Q,CAML6B,eAAe/C,GACvBqE,MAAMtB,eAAe/C,GACrBhH,KAAKyF,OAAQ4C,K,CAMLwE,aAAa7F,GACrBhH,KAAKyF,OAAQ4C,K,CAMLyE,cAAc9F,GACtBhH,KAAKyF,OAAQ4C,K,CAMLmB,SAASxC,GACbhH,KAAKyF,OAAQW,WACfpG,KAAKwS,QAAQxL,EAAIuE,MAAOvE,EAAIwE,O,CAOtB/B,gBAAgBzC,GACpBhH,KAAKyF,OAAQW,WACfpG,KAAKwS,SAAS,GAAI,E,CAOZ9I,aAAa1C,GACjBhH,KAAKyF,OAAQC,YACf1F,KAAKyS,M,CAODA,OAEN,IAAIO,EAAO,EACPC,EAAO,EAGX,IAAK,IAAI5R,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GAGnB8P,EAAKjL,WAKTiL,EAAK9I,MAGL2K,EAAOtR,KAAKF,IAAIwR,EAAM7B,EAAK1E,UAC3BwG,EAAOvR,KAAKF,IAAIyR,EAAM9B,EAAKzE,WAC5B,CAGD,IAAIyG,EAAOnT,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,MACzD6N,GAAQG,EAAIE,cACZJ,GAAQE,EAAIG,YAGZ,IAAI1M,EAAQ5G,KAAKyF,OAAQN,KAAKyB,MAC9BA,EAAM6F,SAAW,GAAGuG,MACpBpM,EAAM8F,UAAY,GAAGuG,MAGrBjT,KAAKuQ,QAAS,EAIVvQ,KAAKyF,OAAQA,QACfI,cAAYqB,YAAYlH,KAAKyF,OAAQA,OAASd,EAAOwC,IAAImB,YAKvDtI,KAAKuQ,QACP1K,cAAYqB,YAAYlH,KAAKyF,OAASd,EAAOwC,IAAIiB,c,CAS7CoK,QAAQe,EAAqBC,GAEnCxT,KAAKuQ,QAAS,EAGd,IAAIsC,EAAW,EACf,IAAK,IAAIxR,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAC/CwR,KAAc7S,KAAK0Q,OAAOrP,GAAG6E,SAI/B,GAAiB,IAAb2M,EACF,OAIEU,EAAc,IAChBA,EAAcvT,KAAKyF,OAAQN,KAAKoO,aAE9BC,EAAe,IACjBA,EAAexT,KAAKyF,OAAQN,KAAKqO,cAI9BxT,KAAK4Q,OACR5Q,KAAK4Q,KAAOtC,aAAW8E,UAAUpT,KAAKyF,OAAQN,OAIhD,IAAIgJ,EAAMnO,KAAK4Q,KAAK6C,WAChBrF,EAAOpO,KAAK4Q,KAAK8C,YACjBnI,EAAQgI,EAAcvT,KAAK4Q,KAAKyC,cAChC7H,EAASgI,EAAexT,KAAK4Q,KAAK0C,YAGtC,IAAK,IAAIjS,EAAI,EAAGiB,EAAItC,KAAK0Q,OAAO3P,OAAQM,EAAIiB,IAAKjB,EAAG,CAElD,IAAI8P,EAAOnR,KAAK0Q,OAAOrP,GAGnB8P,EAAKjL,WAKTiL,EAAK3J,OAAOrC,KAAKyB,MAAMgE,OAAS,GAAGvJ,IAGnC8P,EAAKjJ,OAAOkG,EAAMD,EAAK5C,EAAOC,GAC/B,C,EHnVC,MAAO42B,WAAqB5sB,EAMhCzV,YAAY8C,EAAiC,IAC3CwI,MAAM,CAAEhE,OAAQ5G,EAAQgV,aAAa5S,KAgD/B7C,KAAAqiC,eAAiB,IAAI7+B,SAAqBxD,MA/ChDA,KAAKqF,SAAS,kB,CAUZoB,iBACF,OAAQzG,KAAKqH,OAAyBZ,U,CAUpCA,eAAWyN,GACZlU,KAAKqH,OAAyBZ,WAAayN,C,CAM1CouB,oBACF,OAAOtiC,KAAKqiC,c,CAMJh4B,aAAarD,GACrBA,EAAIoE,MAAM/F,SAAS,wB,CAMXiF,eAAetD,GACvBA,EAAIoE,MAAMvD,YAAY,yBACtB7H,KAAKqiC,eAAe99B,KAAKyC,EAAIoE,M,GA0BjC,SAAU3K,GAIQA,EAAAgV,aAAhB,SAA6B5S,GAC3B,OAAOA,EAAQwE,QAAU,IAAI86B,E,CAEhC,CAPD,CAAU1hC,MAOT,MCsXD,SAAUA,GAIQA,EAAA8hC,yBAAhB,SACEC,GAEA,OAAOC,EAA0BD,E,EAMnB/hC,EAAAiiC,uBAAhB,SACEF,GAEA,OAAOG,EAAwBH,E,EAMjC,MAAMC,EAAmE,CACvEt0B,IAAK,aACLC,KAAM,WACN6a,MAAO,WACPE,OAAQ,cAMJwZ,EAAkE,CACtEx0B,IAAK,gBACLC,KAAM,gBACN6a,MAAO,gBACPE,OAAQ,gBAEX,CAtCD,CAAU1oB,MAsCT,K,sHRteCV,YAAY8C,GAkFJ7C,KAAc4iC,gBAAY,EAC1B5iC,KAAO6iC,QAAG,EACV7iC,KAAM0Q,OAAoB,GAC1B1Q,KAAe8iC,iBAAY,EApFjC,MAAM3Y,cAAEA,EAAaC,eAAEA,KAAmB2Y,GAAWlgC,EACrD7C,KAAK8jB,KAAO,IAAIb,EAAK8f,GACrB/iC,KAAK4iC,gBAAmC,IAAlBzY,EACtBnqB,KAAK8iC,iBAAqC,IAAnB1Y,C,CAezBzO,QAAQ9Y,GAEN,IAAIsO,EAAO1Q,EAAQmb,WAAW/Y,EAAS7C,KAAK6iC,WAM5C,OAHA7iC,KAAK0Q,OAAOmB,KAAKV,GAGV,IAAI6xB,sBAAmB,KAC5B1zB,WAASqmB,cAAc31B,KAAK0Q,OAAQS,EAAK,G,CAiB7CwT,KAAK3O,GAQH,GANAiN,EAAKsD,iBAGLvmB,KAAK8jB,KAAK5H,aAGiB,IAAvBlc,KAAK0Q,OAAO3P,OACd,OAAO,EAIT,IAAI2a,EAAQjb,EAAQ4hB,WAClBriB,KAAK0Q,OACLsF,EACAhW,KAAK4iC,eACL5iC,KAAK8iC,iBAIP,IAAKpnB,GAA0B,IAAjBA,EAAM3a,OAClB,OAAO,EAIT,IAAK,MAAMoQ,KAAQuK,EACjB1b,KAAK8jB,KAAKnI,QAAQxK,GAOpB,OAHAnR,KAAK8jB,KAAKa,KAAK3O,EAAMe,QAASf,EAAMgB,UAG7B,C,qDW1FXjX,cA0TUC,KAAQijC,SAAG,EACXjjC,KAAQ6O,SAAQ,GAChB7O,KAAakjC,cAAa,KAC1BljC,KAAcmjC,eAAa,KAC3BnjC,KAAAojC,SAAW,IAAI3Q,IACfzyB,KAAAqjC,OAAS,IAAI5Q,IACbzyB,KAAAsjC,eAAiB,IAAI9/B,SAA2CxD,MAChEA,KAAAkrB,gBAAkB,IAAI1nB,SAC5BxD,K,CA9TFyE,UAEE,KAAIzE,KAAKijC,SAAW,GAApB,CAKAjjC,KAAKijC,UAAY,EAGjBz/B,SAAOkB,UAAU1E,MAGjB,IAAK,MAAMwH,KAAUxH,KAAK6O,SACxBrH,EAAOrC,KAAKqR,oBAAoB,QAASxW,MAAM,GAC/CwH,EAAOrC,KAAKqR,oBAAoB,OAAQxW,MAAM,GAIhDA,KAAKkjC,cAAgB,KACrBljC,KAAKmjC,eAAiB,KACtBnjC,KAAKqjC,OAAOthB,QACZ/hB,KAAKojC,SAASrhB,QACd/hB,KAAK6O,SAAS9N,OAAS,CAnBtB,C,CAyBC+qB,qBACF,OAAO9rB,KAAKkrB,e,CAMVqY,oBACF,OAAOvjC,KAAKsjC,c,CAMV9+B,iBACF,OAAOxE,KAAKijC,SAAW,C,CAqBrBO,oBACF,OAAOxjC,KAAKmjC,c,CAUVM,mBACF,OAAOzjC,KAAKkjC,a,CAMVn0B,cACF,OAAO/O,KAAK6O,Q,CAsBd60B,YAAYl8B,GACV,IAAIlF,EAAItC,KAAKojC,SAAS78B,IAAIiB,GAC1B,YAAatE,IAANZ,GAAmB,EAAIA,C,CAUhC+xB,IAAI7sB,GACF,OAAOxH,KAAKojC,SAAS/O,IAAI7sB,E,CAc3BI,IAAIJ,GAEF,GAAIxH,KAAKojC,SAAS/O,IAAI7sB,GACpB,OAIF,IAAImX,EAAUnX,EAAOrC,KAAK2B,SAASoF,SAAS0S,eAGxCtc,EAAIqc,EAAU3e,KAAKijC,YAAc,EAGrCjjC,KAAK6O,SAASgD,KAAKrK,GACnBxH,KAAKojC,SAASj2B,IAAI3F,EAAQlF,GAC1BtC,KAAKqjC,OAAOl2B,IAAI3F,EAAOrC,KAAMqC,GAK7BA,EAAOrC,KAAKoR,iBAAiB,QAASvW,MAAM,GAC5CwH,EAAOrC,KAAKoR,iBAAiB,OAAQvW,MAAM,GAG3CwH,EAAOzB,SAASgS,QAAQ/X,KAAK2jC,kBAAmB3jC,MAG5C2e,GACF3e,KAAK4jC,YAAYp8B,EAAQA,E,CAgB7BM,OAAON,GAEL,IAAKxH,KAAKojC,SAAS/O,IAAI7sB,GACrB,OAgBF,GAZAA,EAAOzB,SAASsnB,WAAWrtB,KAAK2jC,kBAAmB3jC,MAGnDwH,EAAOrC,KAAKqR,oBAAoB,QAASxW,MAAM,GAC/CwH,EAAOrC,KAAKqR,oBAAoB,OAAQxW,MAAM,GAG9CsP,WAASqmB,cAAc31B,KAAK6O,SAAUrH,GACtCxH,KAAKqjC,OAAO7N,OAAOhuB,EAAOrC,MAC1BnF,KAAKojC,SAAS5N,OAAOhuB,GAGjBxH,KAAKmjC,iBAAmB37B,EAC1B,OAIF,IAAIq8B,EAAQ7jC,KAAK6O,SAASgvB,QAAOe,IAA+B,IAA1B5+B,KAAKojC,SAAS78B,IAAIq4B,KAGpDkF,EACFtiC,MAAIqiC,GAAO,CAACE,EAAOC,IACThkC,KAAKojC,SAAS78B,IAAIw9B,GAClB/jC,KAAKojC,SAAS78B,IAAIy9B,MAEtB,KAGRhkC,KAAK4jC,YAAYE,EAAU,K,CAa7B/tB,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,QACHtJ,KAAKikC,UAAUjuB,GACf,MACF,IAAK,OACHhW,KAAKkkC,SAASluB,G,CAQZ4tB,YAAY3V,EAAmB5Q,GAErC,IAAI8mB,EAAankC,KAAKmjC,eACtBnjC,KAAKmjC,eAAiBlV,EAGtB,IAAImW,EAAYpkC,KAAKkjC,cACrBljC,KAAKkjC,cAAgB7lB,EAGjB8mB,IAAelW,GACjBjuB,KAAKkrB,gBAAgB3mB,KAAK,CAAEiqB,SAAU2V,EAAYE,SAAUpW,IAI1DmW,IAAc/mB,GAChBrd,KAAKsjC,eAAe/+B,KAAK,CAAEiqB,SAAU4V,EAAWC,SAAUhnB,G,CAOtD4mB,UAAUjuB,GAEhB,IAAIxO,EAASxH,KAAKqjC,OAAO98B,IAAIyP,EAAMqU,eAG/B7iB,IAAWxH,KAAKmjC,gBAClBnjC,KAAKojC,SAASj2B,IAAI3F,EAAQxH,KAAKijC,YAIjCjjC,KAAK4jC,YAAYp8B,EAAQA,E,CAMnB08B,SAASluB,GAEf,IAAIxO,EAASxH,KAAKqjC,OAAO98B,IAAIyP,EAAMqU,eAG/Bia,EAActuB,EAAMorB,cAGnBkD,IAMD98B,EAAOrC,KAAK2B,SAASw9B,IAKpBrL,OAAKj5B,KAAK6O,UAAU+vB,GAAKA,EAAEz5B,KAAK2B,SAASw9B,OAV5CtkC,KAAK4jC,YAAY5jC,KAAKmjC,eAAgB,K,CAmBlCQ,kBAAkBrrB,GACxBtY,KAAK8H,OAAOwQ,E,yGLtTV,cAAyB3T,EAM7B5E,YAAY8C,EAA8B,IACxCwI,MAAM,CAAElG,KAAM1E,EAAQ2E,eAujBhBpF,KAASukC,UAAG,KAKlB,GAHAvkC,KAAKwkC,cAAgB,GAGhBxkC,KAAK4V,WACR,OAIF,IAAIyI,EAAOre,KAAK4V,WAAWyI,KAG3B,GAAa,UAATA,EACF,OAIFre,KAAKwkC,aAAevtB,OAAOyP,WAAW1mB,KAAKukC,UAAW,IAGtD,IAAIE,EAASzkC,KAAK4V,WAAW6uB,OACzBC,EAAS1kC,KAAK4V,WAAW8uB,OAG7B,GAAa,cAATrmB,EAcJ,GAAa,cAATA,GAcJ,GAAa,UAATA,EAAkB,CAEpB,IAAK/P,aAAW0X,QAAQhmB,KAAK8hC,UAAW2C,EAAQC,GAC9C,OAIF,IAAI7C,EAAY7hC,KAAK6hC,UAGrB,GAAIvzB,aAAW0X,QAAQ6b,EAAW4C,EAAQC,GACxC,OAIF,IAGI9pB,EAHA+pB,EAAY9C,EAAU/qB,wBAc1B,OATE8D,EADwB,eAAtB5a,KAAK8Q,aACD2zB,EAASE,EAAUv2B,KAAO,YAAc,YAExCs2B,EAASC,EAAUx2B,IAAM,YAAc,iBAI/CnO,KAAK4kC,eAAergC,KAAKqW,EAI1B,MA5CD,CAEE,IAAKtM,aAAW0X,QAAQhmB,KAAKgiC,cAAeyC,EAAQC,GAClD,OAIF1kC,KAAK6kC,eAAetgC,KAAK,YAI1B,KAzBD,CAEE,IAAK+J,aAAW0X,QAAQhmB,KAAK+hC,cAAe0C,EAAQC,GAClD,OAIF1kC,KAAK6kC,eAAetgC,KAAK,YAI1B,CA+CA,EAGKvE,KAAM8kC,OAAG,EACT9kC,KAAK+kC,MAAG,GACR/kC,KAAQglC,SAAG,IACXhlC,KAAYwkC,cAAI,EAEhBxkC,KAAU4V,WAA8B,KACxC5V,KAAAilC,YAAc,IAAIzhC,SAAqBxD,MACvCA,KAAA6kC,eAAiB,IAAIrhC,SAAwCxD,MAC7DA,KAAA4kC,eAAiB,IAAIphC,SAAwCxD,MAppBnEA,KAAKqF,SAAS,gBACdrF,KAAKsF,QAAQX,EAAOY,KAAK+B,gBAGzBtH,KAAK8Q,aAAejO,EAAQmO,aAAe,WAC3ChR,KAAKoE,QAAqB,YAAIpE,KAAK8Q,kBAGX5N,IAApBL,EAAQqiC,UACVllC,KAAKglC,SAAWtjC,KAAKF,IAAI,EAAGqB,EAAQqiC,eAEjBhiC,IAAjBL,EAAQsiC,OACVnlC,KAAK+kC,MAAQrjC,KAAKF,IAAI,EAAGqB,EAAQsiC,YAEbjiC,IAAlBL,EAAQyB,QACVtE,KAAK8kC,OAASpjC,KAAKF,IAAI,EAAGE,KAAKH,IAAIsB,EAAQyB,MAAOtE,KAAKglC,W,CAUvDI,iBACF,OAAOplC,KAAKilC,W,CASVI,oBACF,OAAOrlC,KAAK6kC,c,CASVS,oBACF,OAAOtlC,KAAK4kC,c,CAMV5zB,kBACF,OAAOhR,KAAK8Q,Y,CAMVE,gBAAY1M,GAEVtE,KAAK8Q,eAAiBxM,IAK1BtE,KAAK6V,gBAGL7V,KAAK8Q,aAAexM,EACpBtE,KAAKoE,QAAqB,YAAIE,EAG9BtE,KAAKkI,S,CAMH5D,YACF,OAAOtE,KAAK8kC,M,CASVxgC,UAAMA,GAERA,EAAQ5C,KAAKF,IAAI,EAAGE,KAAKH,IAAI+C,EAAOtE,KAAKglC,WAGrChlC,KAAK8kC,SAAWxgC,IAKpBtE,KAAK8kC,OAASxgC,EAGdtE,KAAKkI,S,CAWHi9B,WACF,OAAOnlC,KAAK+kC,K,CASVI,SAAK7gC,GAEPA,EAAQ5C,KAAKF,IAAI,EAAG8C,GAGhBtE,KAAK+kC,QAAUzgC,IAKnBtE,KAAK+kC,MAAQzgC,EAGbtE,KAAKkI,S,CAMHg9B,cACF,OAAOllC,KAAKglC,Q,CASVE,YAAQ5gC,GAEVA,EAAQ5C,KAAKF,IAAI,EAAG8C,GAGhBtE,KAAKglC,WAAa1gC,IAKtBtE,KAAKglC,SAAW1gC,EAGhBtE,KAAK8kC,OAASpjC,KAAKH,IAAIvB,KAAK8kC,OAAQxgC,GAGpCtE,KAAKkI,S,CASH65B,oBACF,OAAO/hC,KAAKmF,KAAKoW,uBACf,uBACA,E,CASAymB,oBACF,OAAOhiC,KAAKmF,KAAKoW,uBACf,uBACA,E,CASAumB,gBACF,OAAO9hC,KAAKmF,KAAKoW,uBACf,sBACA,E,CASAsmB,gBACF,OAAO7hC,KAAKmF,KAAKoW,uBACf,sBACA,E,CAcJxF,YAAYC,GACV,OAAQA,EAAM1M,MACZ,IAAK,YACHtJ,KAAKqlB,cAAcrP,GACnB,MACF,IAAK,YACHhW,KAAKklB,cAAclP,GACnB,MACF,IAAK,UACHhW,KAAKilB,YAAYjP,GACjB,MACF,IAAK,UACHhW,KAAKoW,YAAYJ,GACjB,MACF,IAAK,cACHA,EAAMK,iBACNL,EAAMM,kB,CAQFvM,eAAe/C,GACvBhH,KAAKmF,KAAKoR,iBAAiB,YAAavW,MACxCA,KAAKkI,Q,CAMGgC,cAAclD,GACtBhH,KAAKmF,KAAKqR,oBAAoB,YAAaxW,MAC3CA,KAAK6V,e,CAMGpM,gBAAgBzC,GAExB,IAAI1C,EAAuB,IAAdtE,KAAK8kC,OAAgB9kC,KAAKglC,SACnCG,EAAqB,IAAbnlC,KAAK+kC,OAAgB/kC,KAAK+kC,MAAQ/kC,KAAKglC,UAGnD1gC,EAAQ5C,KAAKF,IAAI,EAAGE,KAAKH,IAAI+C,EAAO,MACpC6gC,EAAOzjC,KAAKF,IAAI,EAAGE,KAAKH,IAAI4jC,EAAM,MAGlC,IAAII,EAAavlC,KAAK6hC,UAAUj7B,MAGN,eAAtB5G,KAAK8Q,cACPy0B,EAAWp3B,IAAM,GACjBo3B,EAAW/5B,OAAS,GACpB+5B,EAAWn3B,KAAO,GAAG9J,KACrBihC,EAAWh6B,MAAQ,GAAG45B,KACtBI,EAAW/6B,UAAY,cAAclG,YAErCihC,EAAWn3B,KAAO,GAClBm3B,EAAWh6B,MAAQ,GACnBg6B,EAAWp3B,IAAM,GAAG7J,KACpBihC,EAAW/5B,OAAS,GAAG25B,KACvBI,EAAW/6B,UAAY,kBAAkBlG,M,CAOrC8R,YAAYJ,GAMlB,GAJAA,EAAMK,iBACNL,EAAMM,kBAGgB,KAAlBN,EAAMS,QACR,OAIF,IAAInS,EAAQtE,KAAK4V,WAAa5V,KAAK4V,WAAWtR,OAAS,EAGvDtE,KAAK6V,iBAGU,IAAXvR,GACFtE,KAAKwlC,WAAWlhC,E,CAOZ+gB,cAAcrP,GAEpB,GAAqB,IAAjBA,EAAMU,OACR,OAQF,GAHA1W,KAAKuI,WAGDvI,KAAK4V,WACP,OAIF,IAAIyI,EAAO5d,EAAQkhC,SAAS3hC,KAAMgW,EAAMY,QAGxC,IAAKyH,EACH,OAIFrI,EAAMK,iBACNL,EAAMM,kBAGN,IAAIa,EAAWC,OAAKC,eAAe,WAmBnC,GAhBArX,KAAK4V,WAAa,CAChByI,OACAlH,WACAhV,OAAQ,EACRmC,OAAQ,EACRmgC,OAAQzuB,EAAMe,QACd2tB,OAAQ1uB,EAAMgB,SAIhB9K,SAASqK,iBAAiB,YAAavW,MAAM,GAC7CkM,SAASqK,iBAAiB,UAAWvW,MAAM,GAC3CkM,SAASqK,iBAAiB,UAAWvW,MAAM,GAC3CkM,SAASqK,iBAAiB,cAAevW,MAAM,GAGlC,UAATqe,EAAkB,CAEpB,IAAIwjB,EAAY7hC,KAAK6hC,UAGjB8C,EAAY9C,EAAU/qB,wBAgB1B,MAb0B,eAAtB9W,KAAK8Q,aACP9Q,KAAK4V,WAAWzT,MAAQ6T,EAAMe,QAAU4tB,EAAUv2B,KAElDpO,KAAK4V,WAAWzT,MAAQ6T,EAAMgB,QAAU2tB,EAAUx2B,IAIpD0zB,EAAUl6B,UAAUC,IAAI,sBAGxB5H,KAAK4V,WAAWtR,MAAQtE,KAAK8kC,OAI9B,CAGD,GAAa,UAATzmB,EAAkB,CAEpB,IAGIzD,EAHA+pB,EAAY3kC,KAAK6hC,UAAU/qB,wBAiB/B,OAZE8D,EADwB,eAAtB5a,KAAK8Q,aACDkF,EAAMe,QAAU4tB,EAAUv2B,KAAO,YAAc,YAE/C4H,EAAMgB,QAAU2tB,EAAUx2B,IAAM,YAAc,YAItDnO,KAAKwkC,aAAevtB,OAAOyP,WAAW1mB,KAAKukC,UAAW,UAGtDvkC,KAAK4kC,eAAergC,KAAKqW,EAI1B,CAGD,MAAa,cAATyD,GAEFre,KAAK+hC,cAAcp6B,UAAUC,IAAI,iBAGjC5H,KAAKwkC,aAAevtB,OAAOyP,WAAW1mB,KAAKukC,UAAW,UAGtDvkC,KAAK6kC,eAAetgC,KAAK,cAOd,cAAT8Z,GAEFre,KAAKgiC,cAAcr6B,UAAUC,IAAI,iBAGjC5H,KAAKwkC,aAAevtB,OAAOyP,WAAW1mB,KAAKukC,UAAW,UAGtDvkC,KAAK6kC,eAAetgC,KAAK,mBAR3B,C,CAkBM2gB,cAAclP,GAEpB,IAAKhW,KAAK4V,WACR,OAYF,GARAI,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK4V,WAAW6uB,OAASzuB,EAAMe,QAC/B/W,KAAK4V,WAAW8uB,OAAS1uB,EAAMgB,QAGF,UAAzBhX,KAAK4V,WAAWyI,KAClB,OAIF,IAIIonB,EACAC,EALAf,EAAY3kC,KAAK6hC,UAAU/qB,wBAC3B6uB,EAAY3lC,KAAK8hC,UAAUhrB,wBAKL,eAAtB9W,KAAK8Q,cACP20B,EAAWzvB,EAAMe,QAAU4uB,EAAUv3B,KAAOpO,KAAK4V,WAAWzT,MAC5DujC,EAAYC,EAAUp6B,MAAQo5B,EAAUp5B,QAExCk6B,EAAWzvB,EAAMgB,QAAU2uB,EAAUx3B,IAAMnO,KAAK4V,WAAWzT,MAC3DujC,EAAYC,EAAUn6B,OAASm5B,EAAUn5B,QAI3C,IAAIlH,EAAsB,IAAdohC,EAAkB,EAAKD,EAAWzlC,KAAKglC,SAAYU,EAG/D1lC,KAAKwlC,WAAWlhC,E,CAMV2gB,YAAYjP,GAEG,IAAjBA,EAAMU,SAKVV,EAAMK,iBACNL,EAAMM,kBAGNtW,KAAK6V,gB,CAMCA,gBAED7V,KAAK4V,aAKVgR,aAAa5mB,KAAKwkC,cAClBxkC,KAAKwkC,cAAgB,EAGrBxkC,KAAK4V,WAAWuB,SAAS1S,UACzBzE,KAAK4V,WAAa,KAGlB1J,SAASsK,oBAAoB,YAAaxW,MAAM,GAChDkM,SAASsK,oBAAoB,UAAWxW,MAAM,GAC9CkM,SAASsK,oBAAoB,UAAWxW,MAAM,GAC9CkM,SAASsK,oBAAoB,cAAexW,MAAM,GAGlDA,KAAK6hC,UAAUl6B,UAAUG,OAAO,iBAChC9H,KAAK+hC,cAAcp6B,UAAUG,OAAO,iBACpC9H,KAAKgiC,cAAcr6B,UAAUG,OAAO,iB,CAM9B09B,WAAWlhC,GAEjBA,EAAQ5C,KAAKF,IAAI,EAAGE,KAAKH,IAAI+C,EAAOtE,KAAKglC,WAGrChlC,KAAK8kC,SAAWxgC,IAKpBtE,KAAK8kC,OAASxgC,EAGdtE,KAAKkI,SAGLlI,KAAKilC,YAAY1gC,KAAKD,G,kHE9iBpB,cAAwBK,EAM5B5E,YAAY8C,EAA6B,IACvCwI,QAiVMrL,KAAAkrB,gBAAkB,IAAI1nB,SAC5BxD,MAGMA,KAAAmrB,cAAgB,IAAI3nB,SAA6BxD,MApVvDA,KAAKqF,SAAS,eAGdrF,KAAKs0B,OAAS,IAAI3J,EAAe9nB,GACjC7C,KAAKs0B,OAAOjvB,SAAS,sBACrBrF,KAAK4lC,aAAe,IAAIxD,GACxBpiC,KAAK4lC,aAAavgC,SAAS,4BAG3BrF,KAAKs0B,OAAOvI,SAAShU,QAAQ/X,KAAK46B,YAAa56B,MAC/CA,KAAKs0B,OAAOxI,eAAe/T,QAAQ/X,KAAK66B,kBAAmB76B,MAC3DA,KAAKs0B,OAAOpI,kBAAkBnU,QAAQ/X,KAAK86B,qBAAsB96B,MACjEA,KAAKs0B,OAAOtI,qBAAqBjU,QAC/B/X,KAAKg7B,wBACLh7B,MAEFA,KAAKs0B,OAAOrI,aAAalU,QAAQ/X,KAAKi7B,mBAAoBj7B,MAG1DA,KAAK4lC,aAAatD,cAAcvqB,QAAQ/X,KAAK6lC,iBAAkB7lC,MAG/DA,KAAK8lC,cAAgBjjC,EAAQkjC,cAAgB,MAC7C,IAAIrsB,EAAYjZ,EAAQiiC,uBAAuB1iC,KAAK8lC,eAChD90B,EAAcvQ,EAAQ8hC,yBAAyBviC,KAAK8lC,eAGxD9lC,KAAKs0B,OAAOtjB,YAAcA,EAC1BhR,KAAKs0B,OAAOlwB,QAAmB,UAAIpE,KAAK8lC,cAGxC,IAAIz+B,EAAS,IAAIiT,EAAU,CAAEZ,YAAWxI,QAAS,IAGjDoJ,EAAUvG,WAAW/T,KAAKs0B,OAAQ,GAClCha,EAAUvG,WAAW/T,KAAK4lC,aAAc,GAGxCv+B,EAAO6H,UAAUlP,KAAKs0B,QACtBjtB,EAAO6H,UAAUlP,KAAK4lC,cAGtB5lC,KAAKqH,OAASA,C,CAcZykB,qBACF,OAAO9rB,KAAKkrB,e,CASVmB,mBACF,OAAOrsB,KAAKs0B,OAAOjI,Y,CASjBA,iBAAa/nB,GACftE,KAAKs0B,OAAOjI,aAAe/nB,C,CASzBk/B,oBACF,IAAI59B,EAAQ5F,KAAKs0B,OAAOlI,aACxB,OAAOxmB,EAAQA,EAAMlC,MAAQ,I,CAS3B8/B,kBAAcl/B,GAChBtE,KAAKs0B,OAAOlI,aAAe9nB,EAAQA,EAAMsB,MAAQ,I,CAS/C4lB,kBACF,OAAOxrB,KAAKs0B,OAAO9I,W,CASjBA,gBAAYlnB,GACdtE,KAAKs0B,OAAO9I,YAAclnB,C,CAOxBqnB,uBACF,OAAO3rB,KAAKs0B,OAAO3I,gB,CAOjBA,qBAAiBrnB,GACnBtE,KAAKs0B,OAAO3I,iBAAmBrnB,C,CAS7ByhC,mBACF,OAAO/lC,KAAK8lC,a,CASVC,iBAAazhC,GAEf,GAAItE,KAAK8lC,gBAAkBxhC,EACzB,OAIFtE,KAAK8lC,cAAgBxhC,EAGrB,IAAIoV,EAAYjZ,EAAQiiC,uBAAuBp+B,GAC3C0M,EAAcvQ,EAAQ8hC,yBAAyBj+B,GAGnDtE,KAAKs0B,OAAOtjB,YAAcA,EAC1BhR,KAAKs0B,OAAOlwB,QAAmB,UAAIE,EAGlCtE,KAAKqH,OAAqBqS,UAAYA,C,CAOrCuS,mBACF,OAAOjsB,KAAKmrB,a,CAsBVpc,cACF,OAAO/O,KAAK4lC,aAAa72B,O,CAa3BG,UAAU1H,GACRxH,KAAKmP,aAAanP,KAAK+O,QAAQhO,OAAQyG,E,CAezC2H,aAAajN,EAAesF,GACtBA,IAAWxH,KAAKwjC,eAClBh8B,EAAOuB,OAET/I,KAAK4lC,aAAaz2B,aAAajN,EAAOsF,GACtCxH,KAAKs0B,OAAOvH,UAAU7qB,EAAOsF,EAAO5B,OAEpC4B,EAAOrC,KAAKsF,aAAa,OAAQ,YAEjC,IAAIsG,EAAW/Q,KAAKs0B,OAAOvjB,SAC3B,GAAIA,aAAoB4Z,EAAOnT,SAAU,CACvC,IAAIugB,EAAQhnB,EAAS6f,aAAa,CAChChrB,MAAO4B,EAAO5B,MACdqoB,SAAS,EACTrjB,OAAQ,IAEVpD,EAAOrC,KAAKsF,aAAa,kBAAmBstB,EAC7C,C,CAMK8C,kBACNviB,EACAoG,GAGA,IAAIgO,cAAEA,EAAaC,cAAEA,EAAaN,aAAEA,EAAYD,aAAEA,GAAiB1N,EAG/DsnB,EAAiBrZ,EAAgBA,EAAcjpB,MAAQ,KACvD8/B,EAAgBpX,EAAeA,EAAa1oB,MAAQ,KAGpDsiC,GACFA,EAAej9B,OAIby6B,GACFA,EAAc76B,OAIhB3I,KAAKkrB,gBAAgB3mB,KAAK,CACxBmoB,gBACAsZ,iBACA3Z,eACAmX,mBAIErK,WAASC,SAAWD,WAASE,QAC/BxzB,cAAYyzB,O,CAOR2B,mBAAmB3iB,EAAwBoG,GACjD1e,KAAKmrB,cAAc5mB,KAAK+T,E,CAMlB0iB,wBACN1iB,EACAoG,GAEAA,EAAK9Y,MAAMlC,MAAM6E,U,CAMXuyB,qBACNxiB,EACAoG,GAEAA,EAAK9Y,MAAMlC,MAAM+E,O,CAMXmyB,YACNtiB,EACAoG,GAEA1e,KAAK4lC,aAAaz2B,aAAauP,EAAK3O,QAAS2O,EAAK9Y,MAAMlC,M,CAMlDmiC,iBAAiBvtB,EAAsB9Q,GAC7CA,EAAOrC,KAAK0F,gBAAgB,QAC5BrD,EAAOrC,KAAK0F,gBAAgB,mBAC5B7K,KAAKs0B,OAAOnH,UAAU3lB,EAAO5B,M"}