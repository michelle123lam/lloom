{"version":3,"names":["LinkedList","constructor","this","_first","_last","_size","isEmpty","size","length","first","value","undefined","last","firstNode","lastNode","Symbol","iterator","node","next","retro","prev","nodes","retroNodes","assign","values","clear","addLast","push","pop","removeLast","shift","addFirst","unshift","removeFirst","Private","LinkedListNode","insertBefore","ref","list","Error","_ref","insertAfter","removeNode","_node","from"],"sources":["../src/linkedlist.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IRetroable } from '@lumino/algorithm';\n\n/**\n * A generic doubly-linked list.\n */\nexport class LinkedList<T> implements Iterable<T>, IRetroable<T> {\n  /**\n   * Whether the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  /**\n   * The size of the list.\n   *\n   * #### Complexity\n   * `O(1)`\n   *\n   * #### Notes\n   * This is equivalent to `length`.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * The length of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `size`.\n   *\n   * This property is deprecated.\n   */\n  get length(): number {\n    return this._size;\n  }\n\n  /**\n   * The first value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get first(): T | undefined {\n    return this._first ? this._first.value : undefined;\n  }\n\n  /**\n   * The last value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get last(): T | undefined {\n    return this._last ? this._last.value : undefined;\n  }\n\n  /**\n   * The first node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get firstNode(): LinkedList.INode<T> | null {\n    return this._first;\n  }\n\n  /**\n   * The last node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get lastNode(): LinkedList.INode<T> | null {\n    return this._last;\n  }\n\n  /**\n   * Create an iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the first value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  *[Symbol.iterator](): IterableIterator<T> {\n    let node = this._first;\n    while (node) {\n      yield node.value;\n      node = node.next;\n    }\n  }\n\n  /**\n   * Create a reverse iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the last value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  *retro(): IterableIterator<T> {\n    let node = this._last;\n    while (node) {\n      yield node.value;\n      node = node.prev;\n    }\n  }\n\n  /**\n   * Create an iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the first node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  *nodes(): IterableIterator<LinkedList.INode<T>> {\n    let node = this._first;\n    while (node) {\n      yield node;\n      node = node.next;\n    }\n  }\n\n  /**\n   * Create a reverse iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the last node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  *retroNodes(): IterableIterator<LinkedList.INode<T>> {\n    let node = this._last;\n    while (node) {\n      yield node;\n      node = node.prev;\n    }\n  }\n\n  /**\n   * Assign new values to the list, replacing all current values.\n   *\n   * @param values - The values to assign to the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  assign(values: Iterable<T>): void {\n    this.clear();\n    for (const value of values) {\n      this.addLast(value);\n    }\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addLast`.\n   */\n  push(value: T): void {\n    this.addLast(value);\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeLast`.\n   */\n  pop(): T | undefined {\n    return this.removeLast();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addFirst`.\n   */\n  shift(value: T): void {\n    this.addFirst(value);\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeFirst`.\n   */\n  unshift(): T | undefined {\n    return this.removeFirst();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addFirst(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._first) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.next = this._first;\n      this._first.prev = node;\n      this._first = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addLast(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._last) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.prev = this._last;\n      this._last.next = node;\n      this._last = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value before a specific node in the list.\n   *\n   * @param value - The value to insert before the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertBefore(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._first) {\n      return this.addFirst(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let prev = _ref.prev!;\n    node.next = _ref;\n    node.prev = prev;\n    _ref.prev = node;\n    prev.next = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value after a specific node in the list.\n   *\n   * @param value - The value to insert after the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertAfter(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._last) {\n      return this.addLast(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let next = _ref.next!;\n    node.next = next;\n    node.prev = _ref;\n    _ref.next = node;\n    next.prev = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeFirst(): T | undefined {\n    let node = this._first;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._first = node.next;\n      this._first!.prev = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeLast(): T | undefined {\n    let node = this._last;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._first) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._last = node.prev;\n      this._last!.next = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove a specific node from the list.\n   *\n   * @param node - The node to remove from the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * The node must be owned by the list.\n   */\n  removeNode(node: LinkedList.INode<T>): void {\n    if (!(node instanceof Private.LinkedListNode) || node.list !== this) {\n      throw new Error('Node is not owned by the list.');\n    }\n    let _node = node as Private.LinkedListNode<T>;\n    if (_node === this._first && _node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else if (_node === this._first) {\n      this._first = _node.next;\n      this._first!.prev = null;\n    } else if (_node === this._last) {\n      this._last = _node.prev;\n      this._last!.next = null;\n    } else {\n      _node.next!.prev = _node.prev;\n      _node.prev!.next = _node.next;\n    }\n    _node.list = null;\n    _node.next = null;\n    _node.prev = null;\n    this._size--;\n  }\n\n  /**\n   * Remove all values from the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  clear(): void {\n    let node = this._first;\n    while (node) {\n      let next = node.next;\n      node.list = null;\n      node.prev = null;\n      node.next = null;\n      node = next;\n    }\n    this._first = null;\n    this._last = null;\n    this._size = 0;\n  }\n\n  private _first: Private.LinkedListNode<T> | null = null;\n  private _last: Private.LinkedListNode<T> | null = null;\n  private _size = 0;\n}\n\n/**\n * The namespace for the `LinkedList` class statics.\n */\nexport namespace LinkedList {\n  /**\n   * An object which represents a node in a linked list.\n   *\n   * #### Notes\n   * User code will not create linked list nodes directly. Nodes\n   * are created automatically when values are added to a list.\n   */\n  export interface INode<T> {\n    /**\n     * The linked list which created and owns the node.\n     *\n     * This will be `null` when the node is removed from the list.\n     */\n    readonly list: LinkedList<T> | null;\n\n    /**\n     * The next node in the list.\n     *\n     * This will be `null` when the node is the last node in the list\n     * or when the node is removed from the list.\n     */\n    readonly next: INode<T> | null;\n\n    /**\n     * The previous node in the list.\n     *\n     * This will be `null` when the node is the first node in the list\n     * or when the node is removed from the list.\n     */\n    readonly prev: INode<T> | null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n  }\n\n  /**\n   * Create a linked list from an iterable of values.\n   *\n   * @param values - The iterable object of interest.\n   *\n   * @returns A new linked list initialized with the given values.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  export function from<T>(values: Iterable<T>): LinkedList<T> {\n    let list = new LinkedList<T>();\n    list.assign(values);\n    return list;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The internal linked list node implementation.\n   */\n  export class LinkedListNode<T> {\n    /**\n     * The linked list which created and owns the node.\n     */\n    list: LinkedList<T> | null = null;\n\n    /**\n     * The next node in the list.\n     */\n    next: LinkedListNode<T> | null = null;\n\n    /**\n     * The previous node in the list.\n     */\n    prev: LinkedListNode<T> | null = null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n\n    /**\n     * Construct a new linked list node.\n     *\n     * @param list - The list which owns the node.\n     *\n     * @param value - The value for the link.\n     */\n    constructor(list: LinkedList<T>, value: T) {\n      this.list = list;\n      this.value = value;\n    }\n  }\n}\n"],"mappings":"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"}