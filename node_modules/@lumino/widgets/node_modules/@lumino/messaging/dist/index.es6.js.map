{"version":3,"file":"index.es6.js","sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module messaging\n */\nimport { ArrayExt, every, retro, some } from '@lumino/algorithm';\n\nimport { LinkedList } from '@lumino/collections';\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nexport class Message {\n  /**\n   * Construct a new message.\n   *\n   * @param type - The type of the message.\n   */\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  /**\n   * The type of the message.\n   *\n   * #### Notes\n   * The `type` of a message should be related directly to its actual\n   * runtime type. This means that `type` can and will be used to cast\n   * the message to the relevant derived `Message` subtype.\n   */\n  readonly type: string;\n\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * If a conflatable message is posted to a handler while another\n   * conflatable message of the same `type` has already been posted\n   * to the handler, the `conflate()` method of the existing message\n   * will be invoked. If that method returns `true`, the new message\n   * will not be enqueued. This allows messages to be compressed, so\n   * that only a single instance of the message type is processed per\n   * cycle, no matter how many times messages of that type are posted.\n   *\n   * Custom message types may reimplement this property.\n   *\n   * The default implementation is always `false`.\n   */\n  get isConflatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * @param other - A conflatable message of the same `type`.\n   *\n   * @returns `true` if the message was successfully conflated, or\n   *   `false` otherwise.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * This method is called automatically by the message loop when the\n   * given message is posted to the handler paired with this message.\n   * This message will already be enqueued and conflatable, and the\n   * given message will have the same `type` and also be conflatable.\n   *\n   * This method should merge the state of the other message into this\n   * message as needed so that when this message is finally delivered\n   * to the handler, it receives the most up-to-date information.\n   *\n   * If this method returns `true`, it signals that the other message\n   * was successfully conflated and that message will not be enqueued.\n   *\n   * If this method returns `false`, the other message will be enqueued\n   * for normal delivery.\n   *\n   * Custom message types may reimplement this method.\n   *\n   * The default implementation always returns `false`.\n   */\n  conflate(other: Message): boolean {\n    return false;\n  }\n}\n\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nexport class ConflatableMessage extends Message {\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * This property is always `true`.\n   */\n  get isConflatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * #### Notes\n   * This method always returns `true`.\n   */\n  conflate(other: ConflatableMessage): boolean {\n    return true;\n  }\n}\n\n/**\n * An object which handles messages.\n *\n * #### Notes\n * A message handler is a simple way of defining a type which can act\n * upon on a large variety of external input without requiring a large\n * abstract API surface. This is particularly useful in the context of\n * widget frameworks where the number of distinct message types can be\n * unbounded.\n */\nexport interface IMessageHandler {\n  /**\n   * Process a message sent to the handler.\n   *\n   * @param msg - The message to be processed.\n   */\n  processMessage(msg: Message): void;\n}\n\n/**\n * An object which intercepts messages sent to a message handler.\n *\n * #### Notes\n * A message hook is useful for intercepting or spying on messages\n * sent to message handlers which were either not created by the\n * consumer, or when subclassing the handler is not feasible.\n *\n * If `messageHook` returns `false`, no other message hooks will be\n * invoked and the message will not be delivered to the handler.\n *\n * If all installed message hooks return `true`, the message will\n * be delivered to the handler for processing.\n *\n * **See also:** {@link MessageLoop.installMessageHook} and {@link MessageLoop.removeMessageHook}\n */\nexport interface IMessageHook {\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean;\n}\n\n/**\n * A type alias for message hook object or function.\n *\n * #### Notes\n * The signature and semantics of a message hook function are the same\n * as the `messageHook` method of {@link IMessageHook}.\n */\nexport type MessageHook =\n  | IMessageHook\n  | ((handler: IMessageHandler, msg: Message) => boolean);\n\n/**\n * The namespace for the global singleton message loop.\n */\nexport namespace MessageLoop {\n  /**\n   * A function that cancels the pending loop task; `null` if unavailable.\n   */\n  let pending: (() => void) | null = null;\n\n  /**\n   * Schedules a function for invocation as soon as possible asynchronously.\n   *\n   * @param fn The function to invoke when called back.\n   *\n   * @returns An anonymous function that will unschedule invocation if possible.\n   */\n  const schedule = (\n    resolved =>\n    (fn: () => unknown): (() => void) => {\n      let rejected = false;\n      resolved.then(() => !rejected && fn());\n      return () => {\n        rejected = true;\n      };\n    }\n  )(Promise.resolve());\n\n  /**\n   * Send a message to a message handler to process immediately.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to deliver to the handler.\n   *\n   * #### Notes\n   * The message will first be sent through any installed message hooks\n   * for the handler. If the message passes all hooks, it will then be\n   * delivered to the `processMessage` method of the handler.\n   *\n   * The message will not be conflated with pending posted messages.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function sendMessage(handler: IMessageHandler, msg: Message): void {\n    // Lookup the message hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Handle the common case of no installed hooks.\n    if (!hooks || hooks.length === 0) {\n      invokeHandler(handler, msg);\n      return;\n    }\n\n    // Invoke the message hooks starting with the newest first.\n    let passed = every(retro(hooks), hook => {\n      return hook ? invokeHook(hook, handler, msg) : true;\n    });\n\n    // Invoke the handler if the message passes all hooks.\n    if (passed) {\n      invokeHandler(handler, msg);\n    }\n  }\n\n  /**\n   * Post a message to a message handler to process in the future.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to post to the handler.\n   *\n   * #### Notes\n   * The message will be conflated with the pending posted messages for\n   * the handler, if possible. If the message is not conflated, it will\n   * be queued for normal delivery on the next cycle of the event loop.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function postMessage(handler: IMessageHandler, msg: Message): void {\n    // Handle the common case of a non-conflatable message.\n    if (!msg.isConflatable) {\n      enqueueMessage(handler, msg);\n      return;\n    }\n\n    // Conflate the message with an existing message if possible.\n    let conflated = some(messageQueue, posted => {\n      if (posted.handler !== handler) {\n        return false;\n      }\n      if (!posted.msg) {\n        return false;\n      }\n      if (posted.msg.type !== msg.type) {\n        return false;\n      }\n      if (!posted.msg.isConflatable) {\n        return false;\n      }\n      return posted.msg.conflate(msg);\n    });\n\n    // Enqueue the message if it was not conflated.\n    if (!conflated) {\n      enqueueMessage(handler, msg);\n    }\n  }\n\n  /**\n   * Install a message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to install.\n   *\n   * #### Notes\n   * A message hook is invoked before a message is delivered to the\n   * handler. If the hook returns `false`, no other hooks will be\n   * invoked and the message will not be delivered to the handler.\n   *\n   * The most recently installed message hook is executed first.\n   *\n   * If the hook is already installed, this is a no-op.\n   */\n  export function installMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Look up the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hook is already installed.\n    if (hooks && hooks.indexOf(hook) !== -1) {\n      return;\n    }\n\n    // Add the hook to the end, so it will be the first to execute.\n    if (!hooks) {\n      messageHooks.set(handler, [hook]);\n    } else {\n      hooks.push(hook);\n    }\n  }\n\n  /**\n   * Remove an installed message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to remove.\n   *\n   * #### Notes\n   * It is safe to call this function while the hook is executing.\n   *\n   * If the hook is not installed, this is a no-op.\n   */\n  export function removeMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hooks do not exist.\n    if (!hooks) {\n      return;\n    }\n\n    // Lookup the index of the hook and bail if not found.\n    let i = hooks.indexOf(hook);\n    if (i === -1) {\n      return;\n    }\n\n    // Clear the hook and schedule a cleanup of the array.\n    hooks[i] = null;\n    scheduleCleanup(hooks);\n  }\n\n  /**\n   * Clear all message data associated with a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * #### Notes\n   * This will clear all posted messages and hooks for the handler.\n   */\n  export function clearData(handler: IMessageHandler): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Clear all messsage hooks for the handler.\n    if (hooks && hooks.length > 0) {\n      ArrayExt.fill(hooks, null);\n      scheduleCleanup(hooks);\n    }\n\n    // Clear all posted messages for the handler.\n    for (const posted of messageQueue) {\n      if (posted.handler === handler) {\n        posted.handler = null;\n        posted.msg = null;\n      }\n    }\n  }\n\n  /**\n   * Process the pending posted messages in the queue immediately.\n   *\n   * #### Notes\n   * This function is useful when posted messages must be processed immediately.\n   *\n   * This function should normally not be needed, but it may be\n   * required to work around certain browser idiosyncrasies.\n   *\n   * Recursing into this function is a no-op.\n   */\n  export function flush(): void {\n    // Bail if recursion is detected or if there is no pending task.\n    if (flushGuard || pending === null) {\n      return;\n    }\n\n    // Unschedule the pending loop task.\n    pending();\n    pending = null;\n\n    // Run the message loop within the recursion guard.\n    flushGuard = true;\n    runMessageLoop();\n    flushGuard = false;\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the message loop exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return exceptionHandler;\n  }\n\n  /**\n   * Set the message loop exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a message handler or a\n   * message hook throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = exceptionHandler;\n    exceptionHandler = handler;\n    return old;\n  }\n\n  /**\n   * A type alias for a posted message pair.\n   */\n  type PostedMessage = { handler: IMessageHandler | null; msg: Message | null };\n\n  /**\n   * The queue of posted message pairs.\n   */\n  const messageQueue = new LinkedList<PostedMessage>();\n\n  /**\n   * A mapping of handler to array of installed message hooks.\n   */\n  const messageHooks = new WeakMap<\n    IMessageHandler,\n    Array<MessageHook | null>\n  >();\n\n  /**\n   * A set of message hook arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<Array<MessageHook | null>>();\n\n  /**\n   * The message loop exception handler.\n   */\n  let exceptionHandler: ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  /**\n   * A guard flag to prevent flush recursion.\n   */\n  let flushGuard = false;\n\n  /**\n   * Invoke a message hook with the specified handler and message.\n   *\n   * Returns the result of the hook, or `true` if the hook throws.\n   *\n   * Exceptions in the hook will be caught and logged.\n   */\n  function invokeHook(\n    hook: MessageHook,\n    handler: IMessageHandler,\n    msg: Message\n  ): boolean {\n    let result = true;\n    try {\n      if (typeof hook === 'function') {\n        result = hook(handler, msg);\n      } else {\n        result = hook.messageHook(handler, msg);\n      }\n    } catch (err) {\n      exceptionHandler(err);\n    }\n    return result;\n  }\n\n  /**\n   * Invoke a message handler with the specified message.\n   *\n   * Exceptions in the handler will be caught and logged.\n   */\n  function invokeHandler(handler: IMessageHandler, msg: Message): void {\n    try {\n      handler.processMessage(msg);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Add a message to the end of the message queue.\n   *\n   * This will automatically schedule a run of the message loop.\n   */\n  function enqueueMessage(handler: IMessageHandler, msg: Message): void {\n    // Add the posted message to the queue.\n    messageQueue.addLast({ handler, msg });\n\n    // Bail if a loop task is already pending.\n    if (pending !== null) {\n      return;\n    }\n\n    // Schedule a run of the message loop.\n    pending = schedule(runMessageLoop);\n  }\n\n  /**\n   * Run an iteration of the message loop.\n   *\n   * This will process all pending messages in the queue. If a message\n   * is added to the queue while the message loop is running, it will\n   * be processed on the next cycle of the loop.\n   */\n  function runMessageLoop(): void {\n    // Clear the task so the next loop can be scheduled.\n    pending = null;\n\n    // If the message queue is empty, there is nothing else to do.\n    if (messageQueue.isEmpty) {\n      return;\n    }\n\n    // Add a sentinel value to the end of the queue. The queue will\n    // only be processed up to the sentinel. Messages posted during\n    // this cycle will execute on the next cycle.\n    let sentinel: PostedMessage = { handler: null, msg: null };\n    messageQueue.addLast(sentinel);\n\n    // Enter the message loop.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Remove the first posted message in the queue.\n      let posted = messageQueue.removeFirst()!;\n\n      // If the value is the sentinel, exit the loop.\n      if (posted === sentinel) {\n        return;\n      }\n\n      // Dispatch the message if it has not been cleared.\n      if (posted.handler && posted.msg) {\n        sendMessage(posted.handler, posted.msg);\n      }\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a message hooks array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any `null` hook will\n   * be removed from the array.\n   */\n  function scheduleCleanup(hooks: Array<MessageHook | null>): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(hooks);\n  }\n\n  /**\n   * Cleanup the message hook arrays in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupHooks);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty hooks in a message hooks array.\n   *\n   * This will remove any `null` hook from the array.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupHooks(hooks: Array<MessageHook | null>): void {\n    ArrayExt.removeAllWhere(hooks, isNull);\n  }\n\n  /**\n   * Test whether a value is `null`.\n   */\n  function isNull<T>(value: T | null): boolean {\n    return value === null;\n  }\n}\n"],"names":[],"mappings":"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"}