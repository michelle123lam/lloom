{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module messaging\n */\nimport { ArrayExt, every, retro, some } from '@lumino/algorithm';\n\nimport { LinkedList } from '@lumino/collections';\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nexport class Message {\n  /**\n   * Construct a new message.\n   *\n   * @param type - The type of the message.\n   */\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  /**\n   * The type of the message.\n   *\n   * #### Notes\n   * The `type` of a message should be related directly to its actual\n   * runtime type. This means that `type` can and will be used to cast\n   * the message to the relevant derived `Message` subtype.\n   */\n  readonly type: string;\n\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * If a conflatable message is posted to a handler while another\n   * conflatable message of the same `type` has already been posted\n   * to the handler, the `conflate()` method of the existing message\n   * will be invoked. If that method returns `true`, the new message\n   * will not be enqueued. This allows messages to be compressed, so\n   * that only a single instance of the message type is processed per\n   * cycle, no matter how many times messages of that type are posted.\n   *\n   * Custom message types may reimplement this property.\n   *\n   * The default implementation is always `false`.\n   */\n  get isConflatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * @param other - A conflatable message of the same `type`.\n   *\n   * @returns `true` if the message was successfully conflated, or\n   *   `false` otherwise.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * This method is called automatically by the message loop when the\n   * given message is posted to the handler paired with this message.\n   * This message will already be enqueued and conflatable, and the\n   * given message will have the same `type` and also be conflatable.\n   *\n   * This method should merge the state of the other message into this\n   * message as needed so that when this message is finally delivered\n   * to the handler, it receives the most up-to-date information.\n   *\n   * If this method returns `true`, it signals that the other message\n   * was successfully conflated and that message will not be enqueued.\n   *\n   * If this method returns `false`, the other message will be enqueued\n   * for normal delivery.\n   *\n   * Custom message types may reimplement this method.\n   *\n   * The default implementation always returns `false`.\n   */\n  conflate(other: Message): boolean {\n    return false;\n  }\n}\n\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nexport class ConflatableMessage extends Message {\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * This property is always `true`.\n   */\n  get isConflatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * #### Notes\n   * This method always returns `true`.\n   */\n  conflate(other: ConflatableMessage): boolean {\n    return true;\n  }\n}\n\n/**\n * An object which handles messages.\n *\n * #### Notes\n * A message handler is a simple way of defining a type which can act\n * upon on a large variety of external input without requiring a large\n * abstract API surface. This is particularly useful in the context of\n * widget frameworks where the number of distinct message types can be\n * unbounded.\n */\nexport interface IMessageHandler {\n  /**\n   * Process a message sent to the handler.\n   *\n   * @param msg - The message to be processed.\n   */\n  processMessage(msg: Message): void;\n}\n\n/**\n * An object which intercepts messages sent to a message handler.\n *\n * #### Notes\n * A message hook is useful for intercepting or spying on messages\n * sent to message handlers which were either not created by the\n * consumer, or when subclassing the handler is not feasible.\n *\n * If `messageHook` returns `false`, no other message hooks will be\n * invoked and the message will not be delivered to the handler.\n *\n * If all installed message hooks return `true`, the message will\n * be delivered to the handler for processing.\n *\n * **See also:** {@link MessageLoop.installMessageHook} and {@link MessageLoop.removeMessageHook}\n */\nexport interface IMessageHook {\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean;\n}\n\n/**\n * A type alias for message hook object or function.\n *\n * #### Notes\n * The signature and semantics of a message hook function are the same\n * as the `messageHook` method of {@link IMessageHook}.\n */\nexport type MessageHook =\n  | IMessageHook\n  | ((handler: IMessageHandler, msg: Message) => boolean);\n\n/**\n * The namespace for the global singleton message loop.\n */\nexport namespace MessageLoop {\n  /**\n   * A function that cancels the pending loop task; `null` if unavailable.\n   */\n  let pending: (() => void) | null = null;\n\n  /**\n   * Schedules a function for invocation as soon as possible asynchronously.\n   *\n   * @param fn The function to invoke when called back.\n   *\n   * @returns An anonymous function that will unschedule invocation if possible.\n   */\n  const schedule = (\n    resolved =>\n    (fn: () => unknown): (() => void) => {\n      let rejected = false;\n      resolved.then(() => !rejected && fn());\n      return () => {\n        rejected = true;\n      };\n    }\n  )(Promise.resolve());\n\n  /**\n   * Send a message to a message handler to process immediately.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to deliver to the handler.\n   *\n   * #### Notes\n   * The message will first be sent through any installed message hooks\n   * for the handler. If the message passes all hooks, it will then be\n   * delivered to the `processMessage` method of the handler.\n   *\n   * The message will not be conflated with pending posted messages.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function sendMessage(handler: IMessageHandler, msg: Message): void {\n    // Lookup the message hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Handle the common case of no installed hooks.\n    if (!hooks || hooks.length === 0) {\n      invokeHandler(handler, msg);\n      return;\n    }\n\n    // Invoke the message hooks starting with the newest first.\n    let passed = every(retro(hooks), hook => {\n      return hook ? invokeHook(hook, handler, msg) : true;\n    });\n\n    // Invoke the handler if the message passes all hooks.\n    if (passed) {\n      invokeHandler(handler, msg);\n    }\n  }\n\n  /**\n   * Post a message to a message handler to process in the future.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to post to the handler.\n   *\n   * #### Notes\n   * The message will be conflated with the pending posted messages for\n   * the handler, if possible. If the message is not conflated, it will\n   * be queued for normal delivery on the next cycle of the event loop.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function postMessage(handler: IMessageHandler, msg: Message): void {\n    // Handle the common case of a non-conflatable message.\n    if (!msg.isConflatable) {\n      enqueueMessage(handler, msg);\n      return;\n    }\n\n    // Conflate the message with an existing message if possible.\n    let conflated = some(messageQueue, posted => {\n      if (posted.handler !== handler) {\n        return false;\n      }\n      if (!posted.msg) {\n        return false;\n      }\n      if (posted.msg.type !== msg.type) {\n        return false;\n      }\n      if (!posted.msg.isConflatable) {\n        return false;\n      }\n      return posted.msg.conflate(msg);\n    });\n\n    // Enqueue the message if it was not conflated.\n    if (!conflated) {\n      enqueueMessage(handler, msg);\n    }\n  }\n\n  /**\n   * Install a message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to install.\n   *\n   * #### Notes\n   * A message hook is invoked before a message is delivered to the\n   * handler. If the hook returns `false`, no other hooks will be\n   * invoked and the message will not be delivered to the handler.\n   *\n   * The most recently installed message hook is executed first.\n   *\n   * If the hook is already installed, this is a no-op.\n   */\n  export function installMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Look up the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hook is already installed.\n    if (hooks && hooks.indexOf(hook) !== -1) {\n      return;\n    }\n\n    // Add the hook to the end, so it will be the first to execute.\n    if (!hooks) {\n      messageHooks.set(handler, [hook]);\n    } else {\n      hooks.push(hook);\n    }\n  }\n\n  /**\n   * Remove an installed message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to remove.\n   *\n   * #### Notes\n   * It is safe to call this function while the hook is executing.\n   *\n   * If the hook is not installed, this is a no-op.\n   */\n  export function removeMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hooks do not exist.\n    if (!hooks) {\n      return;\n    }\n\n    // Lookup the index of the hook and bail if not found.\n    let i = hooks.indexOf(hook);\n    if (i === -1) {\n      return;\n    }\n\n    // Clear the hook and schedule a cleanup of the array.\n    hooks[i] = null;\n    scheduleCleanup(hooks);\n  }\n\n  /**\n   * Clear all message data associated with a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * #### Notes\n   * This will clear all posted messages and hooks for the handler.\n   */\n  export function clearData(handler: IMessageHandler): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Clear all messsage hooks for the handler.\n    if (hooks && hooks.length > 0) {\n      ArrayExt.fill(hooks, null);\n      scheduleCleanup(hooks);\n    }\n\n    // Clear all posted messages for the handler.\n    for (const posted of messageQueue) {\n      if (posted.handler === handler) {\n        posted.handler = null;\n        posted.msg = null;\n      }\n    }\n  }\n\n  /**\n   * Process the pending posted messages in the queue immediately.\n   *\n   * #### Notes\n   * This function is useful when posted messages must be processed immediately.\n   *\n   * This function should normally not be needed, but it may be\n   * required to work around certain browser idiosyncrasies.\n   *\n   * Recursing into this function is a no-op.\n   */\n  export function flush(): void {\n    // Bail if recursion is detected or if there is no pending task.\n    if (flushGuard || pending === null) {\n      return;\n    }\n\n    // Unschedule the pending loop task.\n    pending();\n    pending = null;\n\n    // Run the message loop within the recursion guard.\n    flushGuard = true;\n    runMessageLoop();\n    flushGuard = false;\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the message loop exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return exceptionHandler;\n  }\n\n  /**\n   * Set the message loop exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a message handler or a\n   * message hook throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = exceptionHandler;\n    exceptionHandler = handler;\n    return old;\n  }\n\n  /**\n   * A type alias for a posted message pair.\n   */\n  type PostedMessage = { handler: IMessageHandler | null; msg: Message | null };\n\n  /**\n   * The queue of posted message pairs.\n   */\n  const messageQueue = new LinkedList<PostedMessage>();\n\n  /**\n   * A mapping of handler to array of installed message hooks.\n   */\n  const messageHooks = new WeakMap<\n    IMessageHandler,\n    Array<MessageHook | null>\n  >();\n\n  /**\n   * A set of message hook arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<Array<MessageHook | null>>();\n\n  /**\n   * The message loop exception handler.\n   */\n  let exceptionHandler: ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  /**\n   * A guard flag to prevent flush recursion.\n   */\n  let flushGuard = false;\n\n  /**\n   * Invoke a message hook with the specified handler and message.\n   *\n   * Returns the result of the hook, or `true` if the hook throws.\n   *\n   * Exceptions in the hook will be caught and logged.\n   */\n  function invokeHook(\n    hook: MessageHook,\n    handler: IMessageHandler,\n    msg: Message\n  ): boolean {\n    let result = true;\n    try {\n      if (typeof hook === 'function') {\n        result = hook(handler, msg);\n      } else {\n        result = hook.messageHook(handler, msg);\n      }\n    } catch (err) {\n      exceptionHandler(err);\n    }\n    return result;\n  }\n\n  /**\n   * Invoke a message handler with the specified message.\n   *\n   * Exceptions in the handler will be caught and logged.\n   */\n  function invokeHandler(handler: IMessageHandler, msg: Message): void {\n    try {\n      handler.processMessage(msg);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Add a message to the end of the message queue.\n   *\n   * This will automatically schedule a run of the message loop.\n   */\n  function enqueueMessage(handler: IMessageHandler, msg: Message): void {\n    // Add the posted message to the queue.\n    messageQueue.addLast({ handler, msg });\n\n    // Bail if a loop task is already pending.\n    if (pending !== null) {\n      return;\n    }\n\n    // Schedule a run of the message loop.\n    pending = schedule(runMessageLoop);\n  }\n\n  /**\n   * Run an iteration of the message loop.\n   *\n   * This will process all pending messages in the queue. If a message\n   * is added to the queue while the message loop is running, it will\n   * be processed on the next cycle of the loop.\n   */\n  function runMessageLoop(): void {\n    // Clear the task so the next loop can be scheduled.\n    pending = null;\n\n    // If the message queue is empty, there is nothing else to do.\n    if (messageQueue.isEmpty) {\n      return;\n    }\n\n    // Add a sentinel value to the end of the queue. The queue will\n    // only be processed up to the sentinel. Messages posted during\n    // this cycle will execute on the next cycle.\n    let sentinel: PostedMessage = { handler: null, msg: null };\n    messageQueue.addLast(sentinel);\n\n    // Enter the message loop.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Remove the first posted message in the queue.\n      let posted = messageQueue.removeFirst()!;\n\n      // If the value is the sentinel, exit the loop.\n      if (posted === sentinel) {\n        return;\n      }\n\n      // Dispatch the message if it has not been cleared.\n      if (posted.handler && posted.msg) {\n        sendMessage(posted.handler, posted.msg);\n      }\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a message hooks array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any `null` hook will\n   * be removed from the array.\n   */\n  function scheduleCleanup(hooks: Array<MessageHook | null>): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(hooks);\n  }\n\n  /**\n   * Cleanup the message hook arrays in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupHooks);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty hooks in a message hooks array.\n   *\n   * This will remove any `null` hook from the array.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupHooks(hooks: Array<MessageHook | null>): void {\n    ArrayExt.removeAllWhere(hooks, isNull);\n  }\n\n  /**\n   * Test whether a value is `null`.\n   */\n  function isNull<T>(value: T | null): boolean {\n    return value === null;\n  }\n}\n"],"names":["MessageLoop","every","retro","some","ArrayExt","LinkedList"],"mappings":";;;;;;IAAA;IACA;IACA;;;;;;IAM+E;IAC/E;;;IAGG;IAKH;;;;;IAKG;UACU,OAAO,CAAA;IAClB;;;;IAIG;IACH,IAAA,WAAA,CAAY,IAAY,EAAA;IACtB,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SAClB;IAYD;;;;;;;;;;;;;;;;;;IAkBG;IACH,IAAA,IAAI,aAAa,GAAA;IACf,QAAA,OAAO,KAAK,CAAC;SACd;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8BG;IACH,IAAA,QAAQ,CAAC,KAAc,EAAA;IACrB,QAAA,OAAO,KAAK,CAAC;SACd;IACF,CAAA;IAED;;;;;;;;;;;;IAYG;IACG,MAAO,kBAAmB,SAAQ,OAAO,CAAA;IAC7C;;;;;IAKG;IACH,IAAA,IAAI,aAAa,GAAA;IACf,QAAA,OAAO,IAAI,CAAC;SACb;IAED;;;;;IAKG;IACH,IAAA,QAAQ,CAAC,KAAyB,EAAA;IAChC,QAAA,OAAO,IAAI,CAAC;SACb;IACF,CAAA;IA8DD;;IAEG;AACcA,iCAwbhB;IAxbD,CAAA,UAAiB,WAAW,EAAA;IAC1B;;IAEG;QACH,IAAI,OAAO,GAAwB,IAAI,CAAC;IAExC;;;;;;IAMG;QACH,MAAM,QAAQ,GAAG,CACf,QAAQ,IACR,CAAC,EAAiB,KAAkB;YAClC,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB,QAAA,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,EAAE,EAAE,CAAC,CAAC;IACvC,QAAA,OAAO,MAAK;gBACV,QAAQ,GAAG,IAAI,CAAC;IAClB,SAAC,CAAC;IACJ,KAAC,EACD,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IAErB;;;;;;;;;;;;;;;IAeG;IACH,IAAA,SAAgB,WAAW,CAAC,OAAwB,EAAE,GAAY,EAAA;;YAEhE,IAAI,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;YAGtC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;IAChC,YAAA,aAAa,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;gBAC5B,OAAO;IACR,SAAA;;YAGD,IAAI,MAAM,GAAGC,eAAK,CAACC,eAAK,CAAC,KAAK,CAAC,EAAE,IAAI,IAAG;IACtC,YAAA,OAAO,IAAI,GAAG,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC;IACtD,SAAC,CAAC,CAAC;;IAGH,QAAA,IAAI,MAAM,EAAE;IACV,YAAA,aAAa,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAC7B,SAAA;SACF;IAnBe,IAAA,WAAA,CAAA,WAAW,cAmB1B,CAAA;IAED;;;;;;;;;;;;;IAaG;IACH,IAAA,SAAgB,WAAW,CAAC,OAAwB,EAAE,GAAY,EAAA;;IAEhE,QAAA,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;IACtB,YAAA,cAAc,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;gBAC7B,OAAO;IACR,SAAA;;YAGD,IAAI,SAAS,GAAGC,cAAI,CAAC,YAAY,EAAE,MAAM,IAAG;IAC1C,YAAA,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,EAAE;IAC9B,gBAAA,OAAO,KAAK,CAAC;IACd,aAAA;IACD,YAAA,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE;IACf,gBAAA,OAAO,KAAK,CAAC;IACd,aAAA;gBACD,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE;IAChC,gBAAA,OAAO,KAAK,CAAC;IACd,aAAA;IACD,YAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,EAAE;IAC7B,gBAAA,OAAO,KAAK,CAAC;IACd,aAAA;gBACD,OAAO,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;IAClC,SAAC,CAAC,CAAC;;YAGH,IAAI,CAAC,SAAS,EAAE;IACd,YAAA,cAAc,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAC9B,SAAA;SACF;IA5Be,IAAA,WAAA,CAAA,WAAW,cA4B1B,CAAA;IAED;;;;;;;;;;;;;;;IAeG;IACH,IAAA,SAAgB,kBAAkB,CAChC,OAAwB,EACxB,IAAiB,EAAA;;YAGjB,IAAI,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;YAGtC,IAAI,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBACvC,OAAO;IACR,SAAA;;YAGD,IAAI,CAAC,KAAK,EAAE;gBACV,YAAY,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;IACnC,SAAA;IAAM,aAAA;IACL,YAAA,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB,SAAA;SACF;IAlBe,IAAA,WAAA,CAAA,kBAAkB,qBAkBjC,CAAA;IAED;;;;;;;;;;;IAWG;IACH,IAAA,SAAgB,iBAAiB,CAC/B,OAAwB,EACxB,IAAiB,EAAA;;YAGjB,IAAI,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;YAGtC,IAAI,CAAC,KAAK,EAAE;gBACV,OAAO;IACR,SAAA;;YAGD,IAAI,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAC5B,QAAA,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBACZ,OAAO;IACR,SAAA;;IAGD,QAAA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YAChB,eAAe,CAAC,KAAK,CAAC,CAAC;SACxB;IArBe,IAAA,WAAA,CAAA,iBAAiB,oBAqBhC,CAAA;IAED;;;;;;;IAOG;QACH,SAAgB,SAAS,CAAC,OAAwB,EAAA;;YAEhD,IAAI,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;IAGtC,QAAA,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;IAC7B,YAAAC,kBAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBAC3B,eAAe,CAAC,KAAK,CAAC,CAAC;IACxB,SAAA;;IAGD,QAAA,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;IACjC,YAAA,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,EAAE;IAC9B,gBAAA,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;IACtB,gBAAA,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC;IACnB,aAAA;IACF,SAAA;SACF;IAjBe,IAAA,WAAA,CAAA,SAAS,YAiBxB,CAAA;IAED;;;;;;;;;;IAUG;IACH,IAAA,SAAgB,KAAK,GAAA;;IAEnB,QAAA,IAAI,UAAU,IAAI,OAAO,KAAK,IAAI,EAAE;gBAClC,OAAO;IACR,SAAA;;IAGD,QAAA,OAAO,EAAE,CAAC;YACV,OAAO,GAAG,IAAI,CAAC;;YAGf,UAAU,GAAG,IAAI,CAAC;IAClB,QAAA,cAAc,EAAE,CAAC;YACjB,UAAU,GAAG,KAAK,CAAC;SACpB;IAde,IAAA,WAAA,CAAA,KAAK,QAcpB,CAAA;IAOD;;;;;;;IAOG;IACH,IAAA,SAAgB,mBAAmB,GAAA;IACjC,QAAA,OAAO,gBAAgB,CAAC;SACzB;IAFe,IAAA,WAAA,CAAA,mBAAmB,sBAElC,CAAA;IAED;;;;;;;;;;IAUG;QACH,SAAgB,mBAAmB,CACjC,OAAyB,EAAA;YAEzB,IAAI,GAAG,GAAG,gBAAgB,CAAC;YAC3B,gBAAgB,GAAG,OAAO,CAAC;IAC3B,QAAA,OAAO,GAAG,CAAC;SACZ;IANe,IAAA,WAAA,CAAA,mBAAmB,sBAMlC,CAAA;IAOD;;IAEG;IACH,IAAA,MAAM,YAAY,GAAG,IAAIC,sBAAU,EAAiB,CAAC;IAErD;;IAEG;IACH,IAAA,MAAM,YAAY,GAAG,IAAI,OAAO,EAG7B,CAAC;IAEJ;;IAEG;IACH,IAAA,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA6B,CAAC;IAEtD;;IAEG;IACH,IAAA,IAAI,gBAAgB,GAAqB,CAAC,GAAU,KAAI;IACtD,QAAA,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACrB,KAAC,CAAC;IAEF;;IAEG;QACH,IAAI,UAAU,GAAG,KAAK,CAAC;IAEvB;;;;;;IAMG;IACH,IAAA,SAAS,UAAU,CACjB,IAAiB,EACjB,OAAwB,EACxB,GAAY,EAAA;YAEZ,IAAI,MAAM,GAAG,IAAI,CAAC;YAClB,IAAI;IACF,YAAA,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;IAC9B,gBAAA,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAC7B,aAAA;IAAM,iBAAA;oBACL,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACzC,aAAA;IACF,SAAA;IAAC,QAAA,OAAO,GAAG,EAAE;gBACZ,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACvB,SAAA;IACD,QAAA,OAAO,MAAM,CAAC;SACf;IAED;;;;IAIG;IACH,IAAA,SAAS,aAAa,CAAC,OAAwB,EAAE,GAAY,EAAA;YAC3D,IAAI;IACF,YAAA,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;IAC7B,SAAA;IAAC,QAAA,OAAO,GAAG,EAAE;gBACZ,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACvB,SAAA;SACF;IAED;;;;IAIG;IACH,IAAA,SAAS,cAAc,CAAC,OAAwB,EAAE,GAAY,EAAA;;YAE5D,YAAY,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC;;YAGvC,IAAI,OAAO,KAAK,IAAI,EAAE;gBACpB,OAAO;IACR,SAAA;;IAGD,QAAA,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,CAAC;SACpC;IAED;;;;;;IAMG;IACH,IAAA,SAAS,cAAc,GAAA;;YAErB,OAAO,GAAG,IAAI,CAAC;;YAGf,IAAI,YAAY,CAAC,OAAO,EAAE;gBACxB,OAAO;IACR,SAAA;;;;YAKD,IAAI,QAAQ,GAAkB,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;IAC3D,QAAA,YAAY,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;;;IAI/B,QAAA,OAAO,IAAI,EAAE;;IAEX,YAAA,IAAI,MAAM,GAAG,YAAY,CAAC,WAAW,EAAG,CAAC;;gBAGzC,IAAI,MAAM,KAAK,QAAQ,EAAE;oBACvB,OAAO;IACR,aAAA;;IAGD,YAAA,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,GAAG,EAAE;oBAChC,WAAW,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;IACzC,aAAA;IACF,SAAA;SACF;IAED;;;;;;IAMG;QACH,SAAS,eAAe,CAAC,KAAgC,EAAA;IACvD,QAAA,IAAI,QAAQ,CAAC,IAAI,KAAK,CAAC,EAAE;gBACvB,QAAQ,CAAC,eAAe,CAAC,CAAC;IAC3B,SAAA;IACD,QAAA,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SACrB;IAED;;;;;IAKG;IACH,IAAA,SAAS,eAAe,GAAA;IACtB,QAAA,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YAC/B,QAAQ,CAAC,KAAK,EAAE,CAAC;SAClB;IAED;;;;;;;IAOG;QACH,SAAS,YAAY,CAAC,KAAgC,EAAA;IACpD,QAAAD,kBAAQ,CAAC,cAAc,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;SACxC;IAED;;IAEG;QACH,SAAS,MAAM,CAAI,KAAe,EAAA;YAChC,OAAO,KAAK,KAAK,IAAI,CAAC;SACvB;IACH,CAAC,EAxbgBJ,mBAAW,KAAXA,mBAAW,GAwb3B,EAAA,CAAA,CAAA;;;;;;;;;"}