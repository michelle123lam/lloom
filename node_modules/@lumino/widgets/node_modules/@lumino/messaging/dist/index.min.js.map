{"version":3,"names":["Message","constructor","type","this","isConflatable","conflate","other","MessageLoop","pending","schedule","resolved","Promise","resolve","fn","rejected","then","sendMessage","handler","msg","hooks","messageHooks","get","length","invokeHandler","passed","every","retro","hook","result","messageHook","err","exceptionHandler","invokeHook","postMessage","enqueueMessage","some","messageQueue","posted","installMessageHook","indexOf","push","set","removeMessageHook","i","scheduleCleanup","clearData","ArrayExt","fill","flush","flushGuard","runMessageLoop","getExceptionHandler","setExceptionHandler","old","LinkedList","WeakMap","dirtySet","Set","console","error","processMessage","addLast","isEmpty","sentinel","removeFirst","size","cleanupDirtySet","add","forEach","cleanupHooks","clear","removeAllWhere","isNull","value"],"sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module messaging\n */\nimport { ArrayExt, every, retro, some } from '@lumino/algorithm';\n\nimport { LinkedList } from '@lumino/collections';\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nexport class Message {\n  /**\n   * Construct a new message.\n   *\n   * @param type - The type of the message.\n   */\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  /**\n   * The type of the message.\n   *\n   * #### Notes\n   * The `type` of a message should be related directly to its actual\n   * runtime type. This means that `type` can and will be used to cast\n   * the message to the relevant derived `Message` subtype.\n   */\n  readonly type: string;\n\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * If a conflatable message is posted to a handler while another\n   * conflatable message of the same `type` has already been posted\n   * to the handler, the `conflate()` method of the existing message\n   * will be invoked. If that method returns `true`, the new message\n   * will not be enqueued. This allows messages to be compressed, so\n   * that only a single instance of the message type is processed per\n   * cycle, no matter how many times messages of that type are posted.\n   *\n   * Custom message types may reimplement this property.\n   *\n   * The default implementation is always `false`.\n   */\n  get isConflatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * @param other - A conflatable message of the same `type`.\n   *\n   * @returns `true` if the message was successfully conflated, or\n   *   `false` otherwise.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * This method is called automatically by the message loop when the\n   * given message is posted to the handler paired with this message.\n   * This message will already be enqueued and conflatable, and the\n   * given message will have the same `type` and also be conflatable.\n   *\n   * This method should merge the state of the other message into this\n   * message as needed so that when this message is finally delivered\n   * to the handler, it receives the most up-to-date information.\n   *\n   * If this method returns `true`, it signals that the other message\n   * was successfully conflated and that message will not be enqueued.\n   *\n   * If this method returns `false`, the other message will be enqueued\n   * for normal delivery.\n   *\n   * Custom message types may reimplement this method.\n   *\n   * The default implementation always returns `false`.\n   */\n  conflate(other: Message): boolean {\n    return false;\n  }\n}\n\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nexport class ConflatableMessage extends Message {\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * This property is always `true`.\n   */\n  get isConflatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * #### Notes\n   * This method always returns `true`.\n   */\n  conflate(other: ConflatableMessage): boolean {\n    return true;\n  }\n}\n\n/**\n * An object which handles messages.\n *\n * #### Notes\n * A message handler is a simple way of defining a type which can act\n * upon on a large variety of external input without requiring a large\n * abstract API surface. This is particularly useful in the context of\n * widget frameworks where the number of distinct message types can be\n * unbounded.\n */\nexport interface IMessageHandler {\n  /**\n   * Process a message sent to the handler.\n   *\n   * @param msg - The message to be processed.\n   */\n  processMessage(msg: Message): void;\n}\n\n/**\n * An object which intercepts messages sent to a message handler.\n *\n * #### Notes\n * A message hook is useful for intercepting or spying on messages\n * sent to message handlers which were either not created by the\n * consumer, or when subclassing the handler is not feasible.\n *\n * If `messageHook` returns `false`, no other message hooks will be\n * invoked and the message will not be delivered to the handler.\n *\n * If all installed message hooks return `true`, the message will\n * be delivered to the handler for processing.\n *\n * **See also:** {@link MessageLoop.installMessageHook} and {@link MessageLoop.removeMessageHook}\n */\nexport interface IMessageHook {\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean;\n}\n\n/**\n * A type alias for message hook object or function.\n *\n * #### Notes\n * The signature and semantics of a message hook function are the same\n * as the `messageHook` method of {@link IMessageHook}.\n */\nexport type MessageHook =\n  | IMessageHook\n  | ((handler: IMessageHandler, msg: Message) => boolean);\n\n/**\n * The namespace for the global singleton message loop.\n */\nexport namespace MessageLoop {\n  /**\n   * A function that cancels the pending loop task; `null` if unavailable.\n   */\n  let pending: (() => void) | null = null;\n\n  /**\n   * Schedules a function for invocation as soon as possible asynchronously.\n   *\n   * @param fn The function to invoke when called back.\n   *\n   * @returns An anonymous function that will unschedule invocation if possible.\n   */\n  const schedule = (\n    resolved =>\n    (fn: () => unknown): (() => void) => {\n      let rejected = false;\n      resolved.then(() => !rejected && fn());\n      return () => {\n        rejected = true;\n      };\n    }\n  )(Promise.resolve());\n\n  /**\n   * Send a message to a message handler to process immediately.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to deliver to the handler.\n   *\n   * #### Notes\n   * The message will first be sent through any installed message hooks\n   * for the handler. If the message passes all hooks, it will then be\n   * delivered to the `processMessage` method of the handler.\n   *\n   * The message will not be conflated with pending posted messages.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function sendMessage(handler: IMessageHandler, msg: Message): void {\n    // Lookup the message hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Handle the common case of no installed hooks.\n    if (!hooks || hooks.length === 0) {\n      invokeHandler(handler, msg);\n      return;\n    }\n\n    // Invoke the message hooks starting with the newest first.\n    let passed = every(retro(hooks), hook => {\n      return hook ? invokeHook(hook, handler, msg) : true;\n    });\n\n    // Invoke the handler if the message passes all hooks.\n    if (passed) {\n      invokeHandler(handler, msg);\n    }\n  }\n\n  /**\n   * Post a message to a message handler to process in the future.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to post to the handler.\n   *\n   * #### Notes\n   * The message will be conflated with the pending posted messages for\n   * the handler, if possible. If the message is not conflated, it will\n   * be queued for normal delivery on the next cycle of the event loop.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function postMessage(handler: IMessageHandler, msg: Message): void {\n    // Handle the common case of a non-conflatable message.\n    if (!msg.isConflatable) {\n      enqueueMessage(handler, msg);\n      return;\n    }\n\n    // Conflate the message with an existing message if possible.\n    let conflated = some(messageQueue, posted => {\n      if (posted.handler !== handler) {\n        return false;\n      }\n      if (!posted.msg) {\n        return false;\n      }\n      if (posted.msg.type !== msg.type) {\n        return false;\n      }\n      if (!posted.msg.isConflatable) {\n        return false;\n      }\n      return posted.msg.conflate(msg);\n    });\n\n    // Enqueue the message if it was not conflated.\n    if (!conflated) {\n      enqueueMessage(handler, msg);\n    }\n  }\n\n  /**\n   * Install a message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to install.\n   *\n   * #### Notes\n   * A message hook is invoked before a message is delivered to the\n   * handler. If the hook returns `false`, no other hooks will be\n   * invoked and the message will not be delivered to the handler.\n   *\n   * The most recently installed message hook is executed first.\n   *\n   * If the hook is already installed, this is a no-op.\n   */\n  export function installMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Look up the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hook is already installed.\n    if (hooks && hooks.indexOf(hook) !== -1) {\n      return;\n    }\n\n    // Add the hook to the end, so it will be the first to execute.\n    if (!hooks) {\n      messageHooks.set(handler, [hook]);\n    } else {\n      hooks.push(hook);\n    }\n  }\n\n  /**\n   * Remove an installed message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to remove.\n   *\n   * #### Notes\n   * It is safe to call this function while the hook is executing.\n   *\n   * If the hook is not installed, this is a no-op.\n   */\n  export function removeMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hooks do not exist.\n    if (!hooks) {\n      return;\n    }\n\n    // Lookup the index of the hook and bail if not found.\n    let i = hooks.indexOf(hook);\n    if (i === -1) {\n      return;\n    }\n\n    // Clear the hook and schedule a cleanup of the array.\n    hooks[i] = null;\n    scheduleCleanup(hooks);\n  }\n\n  /**\n   * Clear all message data associated with a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * #### Notes\n   * This will clear all posted messages and hooks for the handler.\n   */\n  export function clearData(handler: IMessageHandler): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Clear all messsage hooks for the handler.\n    if (hooks && hooks.length > 0) {\n      ArrayExt.fill(hooks, null);\n      scheduleCleanup(hooks);\n    }\n\n    // Clear all posted messages for the handler.\n    for (const posted of messageQueue) {\n      if (posted.handler === handler) {\n        posted.handler = null;\n        posted.msg = null;\n      }\n    }\n  }\n\n  /**\n   * Process the pending posted messages in the queue immediately.\n   *\n   * #### Notes\n   * This function is useful when posted messages must be processed immediately.\n   *\n   * This function should normally not be needed, but it may be\n   * required to work around certain browser idiosyncrasies.\n   *\n   * Recursing into this function is a no-op.\n   */\n  export function flush(): void {\n    // Bail if recursion is detected or if there is no pending task.\n    if (flushGuard || pending === null) {\n      return;\n    }\n\n    // Unschedule the pending loop task.\n    pending();\n    pending = null;\n\n    // Run the message loop within the recursion guard.\n    flushGuard = true;\n    runMessageLoop();\n    flushGuard = false;\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the message loop exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return exceptionHandler;\n  }\n\n  /**\n   * Set the message loop exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a message handler or a\n   * message hook throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = exceptionHandler;\n    exceptionHandler = handler;\n    return old;\n  }\n\n  /**\n   * A type alias for a posted message pair.\n   */\n  type PostedMessage = { handler: IMessageHandler | null; msg: Message | null };\n\n  /**\n   * The queue of posted message pairs.\n   */\n  const messageQueue = new LinkedList<PostedMessage>();\n\n  /**\n   * A mapping of handler to array of installed message hooks.\n   */\n  const messageHooks = new WeakMap<\n    IMessageHandler,\n    Array<MessageHook | null>\n  >();\n\n  /**\n   * A set of message hook arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<Array<MessageHook | null>>();\n\n  /**\n   * The message loop exception handler.\n   */\n  let exceptionHandler: ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  /**\n   * A guard flag to prevent flush recursion.\n   */\n  let flushGuard = false;\n\n  /**\n   * Invoke a message hook with the specified handler and message.\n   *\n   * Returns the result of the hook, or `true` if the hook throws.\n   *\n   * Exceptions in the hook will be caught and logged.\n   */\n  function invokeHook(\n    hook: MessageHook,\n    handler: IMessageHandler,\n    msg: Message\n  ): boolean {\n    let result = true;\n    try {\n      if (typeof hook === 'function') {\n        result = hook(handler, msg);\n      } else {\n        result = hook.messageHook(handler, msg);\n      }\n    } catch (err) {\n      exceptionHandler(err);\n    }\n    return result;\n  }\n\n  /**\n   * Invoke a message handler with the specified message.\n   *\n   * Exceptions in the handler will be caught and logged.\n   */\n  function invokeHandler(handler: IMessageHandler, msg: Message): void {\n    try {\n      handler.processMessage(msg);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Add a message to the end of the message queue.\n   *\n   * This will automatically schedule a run of the message loop.\n   */\n  function enqueueMessage(handler: IMessageHandler, msg: Message): void {\n    // Add the posted message to the queue.\n    messageQueue.addLast({ handler, msg });\n\n    // Bail if a loop task is already pending.\n    if (pending !== null) {\n      return;\n    }\n\n    // Schedule a run of the message loop.\n    pending = schedule(runMessageLoop);\n  }\n\n  /**\n   * Run an iteration of the message loop.\n   *\n   * This will process all pending messages in the queue. If a message\n   * is added to the queue while the message loop is running, it will\n   * be processed on the next cycle of the loop.\n   */\n  function runMessageLoop(): void {\n    // Clear the task so the next loop can be scheduled.\n    pending = null;\n\n    // If the message queue is empty, there is nothing else to do.\n    if (messageQueue.isEmpty) {\n      return;\n    }\n\n    // Add a sentinel value to the end of the queue. The queue will\n    // only be processed up to the sentinel. Messages posted during\n    // this cycle will execute on the next cycle.\n    let sentinel: PostedMessage = { handler: null, msg: null };\n    messageQueue.addLast(sentinel);\n\n    // Enter the message loop.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Remove the first posted message in the queue.\n      let posted = messageQueue.removeFirst()!;\n\n      // If the value is the sentinel, exit the loop.\n      if (posted === sentinel) {\n        return;\n      }\n\n      // Dispatch the message if it has not been cleared.\n      if (posted.handler && posted.msg) {\n        sendMessage(posted.handler, posted.msg);\n      }\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a message hooks array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any `null` hook will\n   * be removed from the array.\n   */\n  function scheduleCleanup(hooks: Array<MessageHook | null>): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(hooks);\n  }\n\n  /**\n   * Cleanup the message hook arrays in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupHooks);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty hooks in a message hooks array.\n   *\n   * This will remove any `null` hook from the array.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupHooks(hooks: Array<MessageHook | null>): void {\n    ArrayExt.removeAllWhere(hooks, isNull);\n  }\n\n  /**\n   * Test whether a value is `null`.\n   */\n  function isNull<T>(value: T | null): boolean {\n    return value === null;\n  }\n}\n"],"mappings":"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"}