{"version":3,"file":"index.es6.js","sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module signaling\n */\nimport { ArrayExt, find } from '@lumino/algorithm';\nimport { PromiseDelegate } from '@lumino/coreutils';\n\n/**\n * A type alias for a slot function.\n *\n * @param sender - The object emitting the signal.\n *\n * @param args - The args object emitted with the signal.\n *\n * #### Notes\n * A slot is invoked when a signal to which it is connected is emitted.\n */\nexport type Slot<T, U> = (sender: T, args: U) => void;\n\n/**\n * An object used for type-safe inter-object communication.\n *\n * #### Notes\n * Signals provide a type-safe implementation of the publish-subscribe\n * pattern. An object (publisher) declares which signals it will emit,\n * and consumers connect callbacks (subscribers) to those signals. The\n * subscribers are invoked whenever the publisher emits the signal.\n */\nexport interface ISignal<T, U> {\n  /**\n   * Connect a slot to the signal.\n   *\n   * @param slot - The slot to invoke when the signal is emitted.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection succeeds, `false` otherwise.\n   *\n   * #### Notes\n   * Slots are invoked in the order in which they are connected.\n   *\n   * Signal connections are unique. If a connection already exists for\n   * the given `slot` and `thisArg`, this method returns `false`.\n   *\n   * A newly connected slot will not be invoked until the next time the\n   * signal is emitted, even if the slot is connected while the signal\n   * is dispatching.\n   */\n  connect(slot: Slot<T, U>, thisArg?: any): boolean;\n\n  /**\n   * Disconnect a slot from the signal.\n   *\n   * @param slot - The slot to disconnect from the signal.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection is removed, `false` otherwise.\n   *\n   * #### Notes\n   * If no connection exists for the given `slot` and `thisArg`, this\n   * method returns `false`.\n   *\n   * A disconnected slot will no longer be invoked, even if the slot\n   * is disconnected while the signal is dispatching.\n   */\n  disconnect(slot: Slot<T, U>, thisArg?: any): boolean;\n}\n\n/**\n * An object that is both a signal and an async iterable.\n */\nexport interface IStream<T, U> extends ISignal<T, U>, AsyncIterable<U> {}\n\n/**\n * A concrete implementation of `ISignal`.\n *\n * #### Example\n * ```typescript\n * import { ISignal, Signal } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get valueChanged: ISignal<this, number> {\n *     return this._valueChanged;\n *   }\n *\n *   get value(): number {\n *     return this._value;\n *   }\n *\n *   set value(value: number) {\n *     if (value === this._value) {\n *       return;\n *     }\n *     this._value = value;\n *     this._valueChanged.emit(value);\n *   }\n *\n *   private _value = 0;\n *   private _valueChanged = new Signal<this, number>(this);\n * }\n *\n * function logger(sender: SomeClass, value: number): void {\n *   console.log(sender.name, value);\n * }\n *\n * let m1 = new SomeClass('foo');\n * let m2 = new SomeClass('bar');\n *\n * m1.valueChanged.connect(logger);\n * m2.valueChanged.connect(logger);\n *\n * m1.value = 42;  // logs: foo 42\n * m2.value = 17;  // logs: bar 17\n * ```\n */\nexport class Signal<T, U> implements ISignal<T, U> {\n  /**\n   * Construct a new signal.\n   *\n   * @param sender - The sender which owns the signal.\n   */\n  constructor(sender: T) {\n    this.sender = sender;\n  }\n\n  /**\n   * The sender which owns the signal.\n   */\n  readonly sender: T;\n\n  /**\n   * Connect a slot to the signal.\n   *\n   * @param slot - The slot to invoke when the signal is emitted.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection succeeds, `false` otherwise.\n   */\n  connect(slot: Slot<T, U>, thisArg?: unknown): boolean {\n    return Private.connect(this, slot, thisArg);\n  }\n\n  /**\n   * Disconnect a slot from the signal.\n   *\n   * @param slot - The slot to disconnect from the signal.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection is removed, `false` otherwise.\n   */\n  disconnect(slot: Slot<T, U>, thisArg?: unknown): boolean {\n    return Private.disconnect(this, slot, thisArg);\n  }\n\n  /**\n   * Emit the signal and invoke the connected slots.\n   *\n   * @param args - The args to pass to the connected slots.\n   *\n   * #### Notes\n   * Slots are invoked synchronously in connection order.\n   *\n   * Exceptions thrown by connected slots will be caught and logged.\n   */\n  emit(args: U): void {\n    Private.emit(this, args);\n  }\n}\n\n/**\n * The namespace for the `Signal` class statics.\n */\nexport namespace Signal {\n  /**\n   * Remove all connections between a sender and receiver.\n   *\n   * @param sender - The sender object of interest.\n   *\n   * @param receiver - The receiver object of interest.\n   *\n   * #### Notes\n   * If a `thisArg` is provided when connecting a signal, that object\n   * is considered the receiver. Otherwise, the `slot` is considered\n   * the receiver.\n   */\n  export function disconnectBetween(sender: unknown, receiver: unknown): void {\n    Private.disconnectBetween(sender, receiver);\n  }\n\n  /**\n   * Remove all connections where the given object is the sender.\n   *\n   * @param sender - The sender object of interest.\n   */\n  export function disconnectSender(sender: unknown): void {\n    Private.disconnectSender(sender);\n  }\n\n  /**\n   * Remove all connections where the given object is the receiver.\n   *\n   * @param receiver - The receiver object of interest.\n   *\n   * #### Notes\n   * If a `thisArg` is provided when connecting a signal, that object\n   * is considered the receiver. Otherwise, the `slot` is considered\n   * the receiver.\n   */\n  export function disconnectReceiver(receiver: unknown): void {\n    Private.disconnectReceiver(receiver);\n  }\n\n  /**\n   * Remove all connections where an object is the sender or receiver.\n   *\n   * @param object - The object of interest.\n   *\n   * #### Notes\n   * If a `thisArg` is provided when connecting a signal, that object\n   * is considered the receiver. Otherwise, the `slot` is considered\n   * the receiver.\n   */\n  export function disconnectAll(object: unknown): void {\n    Private.disconnectAll(object);\n  }\n\n  /**\n   * Clear all signal data associated with the given object.\n   *\n   * @param object - The object for which the data should be cleared.\n   *\n   * #### Notes\n   * This removes all signal connections and any other signal data\n   * associated with the object.\n   */\n  export function clearData(object: unknown): void {\n    Private.disconnectAll(object);\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the signal exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return Private.exceptionHandler;\n  }\n\n  /**\n   * Set the signal exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a slot throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = Private.exceptionHandler;\n    Private.exceptionHandler = handler;\n    return old;\n  }\n}\n\n/**\n * A concrete implementation of `IStream`.\n *\n * #### Example\n * ```typescript\n * import { IStream, Stream } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get pings(): IStream<this, string> {\n *     return this._pings;\n *   }\n *\n *   ping(value: string) {\n *     this._pings.emit(value);\n *   }\n *\n *   private _pings = new Stream<this, string>(this);\n * }\n *\n * let m1 = new SomeClass('foo');\n *\n * m1.pings.connect((_, value: string) => {\n *   console.log('connect', value);\n * });\n *\n * void (async () => {\n *   for await (const ping of m1.pings) {\n *     console.log('iterator', ping);\n *   }\n * })();\n *\n * m1.ping('alpha');  // logs: connect alpha\n *                    // logs: iterator alpha\n * m1.ping('beta');   // logs: connect beta\n *                    // logs: iterator beta\n * ```\n */\nexport class Stream<T, U> extends Signal<T, U> implements IStream<T, U> {\n  /**\n   * Return an async iterator that yields every emission.\n   */\n  async *[Symbol.asyncIterator](): AsyncIterableIterator<U> {\n    let pending = this._pending;\n    while (true) {\n      try {\n        const { args, next } = await pending.promise;\n        pending = next;\n        yield args;\n      } catch (_) {\n        return; // Any promise rejection stops the iterator.\n      }\n    }\n  }\n\n  /**\n   * Emit the signal, invoke the connected slots, and yield the emission.\n   *\n   * @param args - The args to pass to the connected slots.\n   */\n  emit(args: U): void {\n    const pending = this._pending;\n    const next = (this._pending = new PromiseDelegate());\n    pending.resolve({ args, next });\n    super.emit(args);\n  }\n\n  /**\n   * Stop the stream's async iteration.\n   */\n  stop(): void {\n    this._pending.promise.catch(() => undefined);\n    this._pending.reject('stop');\n    this._pending = new PromiseDelegate();\n  }\n\n  private _pending: Private.Pending<U> = new PromiseDelegate();\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A pending promise in a promise chain underlying a stream.\n   */\n  export type Pending<U> = PromiseDelegate<{ args: U; next: Pending<U> }>;\n\n  /**\n   * The signal exception handler function.\n   */\n  export let exceptionHandler: Signal.ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  /**\n   * Connect a slot to a signal.\n   *\n   * @param signal - The signal of interest.\n   *\n   * @param slot - The slot to invoke when the signal is emitted.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection succeeds, `false` otherwise.\n   */\n  export function connect<T, U>(\n    signal: Signal<T, U>,\n    slot: Slot<T, U>,\n    thisArg?: unknown\n  ): boolean {\n    // Coerce a `null` `thisArg` to `undefined`.\n    thisArg = thisArg || undefined;\n\n    // Ensure the sender's array of receivers is created.\n    let receivers = receiversForSender.get(signal.sender);\n    if (!receivers) {\n      receivers = [];\n      receiversForSender.set(signal.sender, receivers);\n    }\n\n    // Bail if a matching connection already exists.\n    if (findConnection(receivers, signal, slot, thisArg)) {\n      return false;\n    }\n\n    // Choose the best object for the receiver.\n    let receiver = thisArg || slot;\n\n    // Ensure the receiver's array of senders is created.\n    let senders = sendersForReceiver.get(receiver);\n    if (!senders) {\n      senders = [];\n      sendersForReceiver.set(receiver, senders);\n    }\n\n    // Create a new connection and add it to the end of each array.\n    let connection = { signal, slot, thisArg };\n    receivers.push(connection);\n    senders.push(connection);\n\n    // Indicate a successful connection.\n    return true;\n  }\n\n  /**\n   * Disconnect a slot from a signal.\n   *\n   * @param signal - The signal of interest.\n   *\n   * @param slot - The slot to disconnect from the signal.\n   *\n   * @param thisArg - The `this` context for the slot. If provided,\n   *   this must be a non-primitive object.\n   *\n   * @returns `true` if the connection is removed, `false` otherwise.\n   */\n  export function disconnect<T, U>(\n    signal: Signal<T, U>,\n    slot: Slot<T, U>,\n    thisArg?: unknown\n  ): boolean {\n    // Coerce a `null` `thisArg` to `undefined`.\n    thisArg = thisArg || undefined;\n\n    // Lookup the list of receivers, and bail if none exist.\n    let receivers = receiversForSender.get(signal.sender);\n    if (!receivers || receivers.length === 0) {\n      return false;\n    }\n\n    // Bail if no matching connection exits.\n    let connection = findConnection(receivers, signal, slot, thisArg);\n    if (!connection) {\n      return false;\n    }\n\n    // Choose the best object for the receiver.\n    let receiver = thisArg || slot;\n\n    // Lookup the array of senders, which is now known to exist.\n    let senders = sendersForReceiver.get(receiver)!;\n\n    // Clear the connection and schedule cleanup of the arrays.\n    connection.signal = null;\n    scheduleCleanup(receivers);\n    scheduleCleanup(senders);\n\n    // Indicate a successful disconnection.\n    return true;\n  }\n\n  /**\n   * Remove all connections between a sender and receiver.\n   *\n   * @param sender - The sender object of interest.\n   *\n   * @param receiver - The receiver object of interest.\n   */\n  export function disconnectBetween(sender: unknown, receiver: unknown): void {\n    // If there are no receivers, there is nothing to do.\n    let receivers = receiversForSender.get(sender);\n    if (!receivers || receivers.length === 0) {\n      return;\n    }\n\n    // If there are no senders, there is nothing to do.\n    let senders = sendersForReceiver.get(receiver);\n    if (!senders || senders.length === 0) {\n      return;\n    }\n\n    // Clear each connection between the sender and receiver.\n    for (const connection of senders) {\n      // Skip connections which have already been cleared.\n      if (!connection.signal) {\n        continue;\n      }\n\n      // Clear the connection if it matches the sender.\n      if (connection.signal.sender === sender) {\n        connection.signal = null;\n      }\n    }\n\n    // Schedule a cleanup of the senders and receivers.\n    scheduleCleanup(receivers);\n    scheduleCleanup(senders);\n  }\n\n  /**\n   * Remove all connections where the given object is the sender.\n   *\n   * @param sender - The sender object of interest.\n   */\n  export function disconnectSender(sender: unknown): void {\n    // If there are no receivers, there is nothing to do.\n    let receivers = receiversForSender.get(sender);\n    if (!receivers || receivers.length === 0) {\n      return;\n    }\n\n    // Clear each receiver connection.\n    for (const connection of receivers) {\n      // Skip connections which have already been cleared.\n      if (!connection.signal) {\n        continue;\n      }\n\n      // Choose the best object for the receiver.\n      let receiver = connection.thisArg || connection.slot;\n\n      // Clear the connection.\n      connection.signal = null;\n\n      // Cleanup the array of senders, which is now known to exist.\n      scheduleCleanup(sendersForReceiver.get(receiver)!);\n    }\n\n    // Schedule a cleanup of the receivers.\n    scheduleCleanup(receivers);\n  }\n\n  /**\n   * Remove all connections where the given object is the receiver.\n   *\n   * @param receiver - The receiver object of interest.\n   */\n  export function disconnectReceiver(receiver: unknown): void {\n    // If there are no senders, there is nothing to do.\n    let senders = sendersForReceiver.get(receiver);\n    if (!senders || senders.length === 0) {\n      return;\n    }\n\n    // Clear each sender connection.\n    for (const connection of senders) {\n      // Skip connections which have already been cleared.\n      if (!connection.signal) {\n        continue;\n      }\n\n      // Lookup the sender for the connection.\n      let sender = connection.signal.sender;\n\n      // Clear the connection.\n      connection.signal = null;\n\n      // Cleanup the array of receivers, which is now known to exist.\n      scheduleCleanup(receiversForSender.get(sender)!);\n    }\n\n    // Schedule a cleanup of the list of senders.\n    scheduleCleanup(senders);\n  }\n\n  /**\n   * Remove all connections where an object is the sender or receiver.\n   *\n   * @param object - The object of interest.\n   */\n  export function disconnectAll(object: unknown): void {\n    // Remove all connections where the given object is the sender.\n    disconnectSender(object);\n    // Remove all connections where the given object is the receiver.\n    disconnectReceiver(object);\n  }\n\n  /**\n   * Emit a signal and invoke its connected slots.\n   *\n   * @param signal - The signal of interest.\n   *\n   * @param args - The args to pass to the connected slots.\n   *\n   * #### Notes\n   * Slots are invoked synchronously in connection order.\n   *\n   * Exceptions thrown by connected slots will be caught and logged.\n   */\n  export function emit<T, U>(signal: Signal<T, U>, args: U): void {\n    // If there are no receivers, there is nothing to do.\n    let receivers = receiversForSender.get(signal.sender);\n    if (!receivers || receivers.length === 0) {\n      return;\n    }\n\n    // Invoke the slots for connections with a matching signal.\n    // Any connections added during emission are not invoked.\n    for (let i = 0, n = receivers.length; i < n; ++i) {\n      let connection = receivers[i];\n      if (connection.signal === signal) {\n        invokeSlot(connection, args);\n      }\n    }\n  }\n\n  /**\n   * An object which holds connection data.\n   */\n  interface IConnection {\n    /**\n     * The signal for the connection.\n     *\n     * A `null` signal indicates a cleared connection.\n     */\n    signal: Signal<any, any> | null;\n\n    /**\n     * The slot connected to the signal.\n     */\n    readonly slot: Slot<any, any>;\n\n    /**\n     * The `this` context for the slot.\n     */\n    readonly thisArg: any;\n  }\n\n  /**\n   * A weak mapping of sender to array of receiver connections.\n   */\n  const receiversForSender = new WeakMap<any, IConnection[]>();\n\n  /**\n   * A weak mapping of receiver to array of sender connections.\n   */\n  const sendersForReceiver = new WeakMap<any, IConnection[]>();\n\n  /**\n   * A set of connection arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<IConnection[]>();\n\n  /**\n   * A function to schedule an event loop callback.\n   */\n  const schedule = (() => {\n    let ok = typeof requestAnimationFrame === 'function';\n    return ok ? requestAnimationFrame : setImmediate;\n  })();\n\n  /**\n   * Find a connection which matches the given parameters.\n   */\n  function findConnection(\n    connections: IConnection[],\n    signal: Signal<any, any>,\n    slot: Slot<any, any>,\n    thisArg: any\n  ): IConnection | undefined {\n    return find(\n      connections,\n      connection =>\n        connection.signal === signal &&\n        connection.slot === slot &&\n        connection.thisArg === thisArg\n    );\n  }\n\n  /**\n   * Invoke a slot with the given parameters.\n   *\n   * The connection is assumed to be valid.\n   *\n   * Exceptions in the slot will be caught and logged.\n   */\n  function invokeSlot(connection: IConnection, args: any): void {\n    let { signal, slot, thisArg } = connection;\n    try {\n      slot.call(thisArg, signal!.sender, args);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a connection array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any connection with a\n   * `null` signal will be removed from the array.\n   */\n  function scheduleCleanup(array: IConnection[]): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(array);\n  }\n\n  /**\n   * Cleanup the connection lists in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupConnections);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty connections in a connections array.\n   *\n   * This will remove any connection with a `null` signal.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupConnections(connections: IConnection[]): void {\n    ArrayExt.removeAllWhere(connections, isDeadConnection);\n  }\n\n  /**\n   * Test whether a connection is dead.\n   *\n   * A dead connection has a `null` signal.\n   */\n  function isDeadConnection(connection: IConnection): boolean {\n    return connection.signal === null;\n  }\n}\n"],"names":[],"mappings":"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"}