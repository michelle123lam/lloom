{"version":3,"names":["DisposableDelegate","constructor","fn","this","_fn","isDisposed","dispose","DisposableSet","_isDisposed","_items","Set","forEach","item","clear","contains","has","add","remove","delete","from","items","set","ObservableDisposableSet","_disposed","Signal","disposed","super","emit","undefined","clearData"],"sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module disposable\n */\nimport { ISignal, Signal } from '@lumino/signaling';\n\n/**\n * An object which implements the disposable pattern.\n */\nexport interface IDisposable {\n  /**\n   * Test whether the object has been disposed.\n   *\n   * #### Notes\n   * This property is always safe to access.\n   */\n  readonly isDisposed: boolean;\n\n  /**\n   * Dispose of the resources held by the object.\n   *\n   * #### Notes\n   * If the object's `dispose` method is called more than once, all\n   * calls made after the first will be a no-op.\n   *\n   * #### Undefined Behavior\n   * It is undefined behavior to use any functionality of the object\n   * after it has been disposed unless otherwise explicitly noted.\n   */\n  dispose(): void;\n}\n\n/**\n * A disposable object with an observable `disposed` signal.\n */\nexport interface IObservableDisposable extends IDisposable {\n  /**\n   * A signal emitted when the object is disposed.\n   */\n  readonly disposed: ISignal<this, void>;\n}\n\n/**\n * A disposable object which delegates to a callback function.\n */\nexport class DisposableDelegate implements IDisposable {\n  /**\n   * Construct a new disposable delegate.\n   *\n   * @param fn - The callback function to invoke on dispose.\n   */\n  constructor(fn: () => void) {\n    this._fn = fn;\n  }\n\n  /**\n   * Test whether the delegate has been disposed.\n   */\n  get isDisposed(): boolean {\n    return !this._fn;\n  }\n\n  /**\n   * Dispose of the delegate and invoke the callback function.\n   */\n  dispose(): void {\n    if (!this._fn) {\n      return;\n    }\n    let fn = this._fn;\n    this._fn = null;\n    fn();\n  }\n\n  private _fn: (() => void) | null;\n}\n\n/**\n * An observable disposable object which delegates to a callback function.\n */\nexport class ObservableDisposableDelegate\n  extends DisposableDelegate\n  implements IObservableDisposable\n{\n  /**\n   * A signal emitted when the delegate is disposed.\n   */\n  get disposed(): ISignal<this, void> {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the delegate and invoke the callback function.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    super.dispose();\n    this._disposed.emit(undefined);\n    Signal.clearData(this);\n  }\n\n  private _disposed = new Signal<this, void>(this);\n}\n\n/**\n * An object which manages a collection of disposable items.\n */\nexport class DisposableSet implements IDisposable {\n  /**\n   * Test whether the set has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the set and the items it contains.\n   *\n   * #### Notes\n   * Items are disposed in the order they are added to the set.\n   */\n  dispose(): void {\n    if (this._isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    this._items.forEach(item => {\n      item.dispose();\n    });\n    this._items.clear();\n  }\n\n  /**\n   * Test whether the set contains a specific item.\n   *\n   * @param item - The item of interest.\n   *\n   * @returns `true` if the set contains the item, `false` otherwise.\n   */\n  contains(item: IDisposable): boolean {\n    return this._items.has(item);\n  }\n\n  /**\n   * Add a disposable item to the set.\n   *\n   * @param item - The item to add to the set.\n   *\n   * #### Notes\n   * If the item is already contained in the set, this is a no-op.\n   */\n  add(item: IDisposable): void {\n    this._items.add(item);\n  }\n\n  /**\n   * Remove a disposable item from the set.\n   *\n   * @param item - The item to remove from the set.\n   *\n   * #### Notes\n   * If the item is not contained in the set, this is a no-op.\n   */\n  remove(item: IDisposable): void {\n    this._items.delete(item);\n  }\n\n  /**\n   * Remove all items from the set.\n   */\n  clear(): void {\n    this._items.clear();\n  }\n\n  private _isDisposed = false;\n  private _items = new Set<IDisposable>();\n}\n\n/**\n * The namespace for the `DisposableSet` class statics.\n */\nexport namespace DisposableSet {\n  /**\n   * Create a disposable set from an iterable of items.\n   *\n   * @param items - The iterable object of interest.\n   *\n   * @returns A new disposable initialized with the given items.\n   */\n  export function from(items: Iterable<IDisposable>): DisposableSet {\n    let set = new DisposableSet();\n    for (const item of items) {\n      set.add(item);\n    }\n    return set;\n  }\n}\n\n/**\n * An observable object which manages a collection of disposable items.\n */\nexport class ObservableDisposableSet\n  extends DisposableSet\n  implements IObservableDisposable\n{\n  /**\n   * A signal emitted when the set is disposed.\n   */\n  get disposed(): ISignal<this, void> {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the set and the items it contains.\n   *\n   * #### Notes\n   * Items are disposed in the order they are added to the set.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    super.dispose();\n    this._disposed.emit(undefined);\n    Signal.clearData(this);\n  }\n\n  private _disposed = new Signal<this, void>(this);\n}\n\n/**\n * The namespace for the `ObservableDisposableSet` class statics.\n */\nexport namespace ObservableDisposableSet {\n  /**\n   * Create an observable disposable set from an iterable of items.\n   *\n   * @param items - The iterable object of interest.\n   *\n   * @returns A new disposable initialized with the given items.\n   */\n  export function from(items: Iterable<IDisposable>): ObservableDisposableSet {\n    let set = new ObservableDisposableSet();\n    for (const item of items) {\n      set.add(item);\n    }\n    return set;\n  }\n}\n"],"mappings":"qUAsDaA,EAMXC,YAAYC,GACVC,KAAKC,IAAMF,C,CAMTG,iBACF,OAAQF,KAAKC,G,CAMfE,UACE,IAAKH,KAAKC,IACR,OAEF,IAAIF,EAAKC,KAAKC,IACdD,KAAKC,IAAM,KACXF,G,QAsCSK,EAAbN,cAmEUE,KAAWK,aAAG,EACdL,KAAAM,OAAS,IAAIC,G,CAhEjBL,iBACF,OAAOF,KAAKK,W,CASdF,UACMH,KAAKK,cAGTL,KAAKK,aAAc,EACnBL,KAAKM,OAAOE,SAAQC,IAClBA,EAAKN,SAAS,IAEhBH,KAAKM,OAAOI,Q,CAUdC,SAASF,GACP,OAAOT,KAAKM,OAAOM,IAAIH,E,CAWzBI,IAAIJ,GACFT,KAAKM,OAAOO,IAAIJ,E,CAWlBK,OAAOL,GACLT,KAAKM,OAAOS,OAAON,E,CAMrBC,QACEV,KAAKM,OAAOI,O,GAUhB,SAAiBN,GAQCA,EAAAY,KAAhB,SAAqBC,GACnB,IAAIC,EAAM,IAAId,EACd,IAAK,MAAMK,KAAQQ,EACjBC,EAAIL,IAAIJ,GAEV,OAAOS,C,CAEV,CAfD,CAAiBd,MAehB,KAKK,MAAOe,UACHf,EADVN,c,oBA0BUE,KAAAoB,UAAY,IAAIC,SAAmBrB,K,CAnBvCsB,eACF,OAAOtB,KAAKoB,S,CASdjB,UACMH,KAAKE,aAGTqB,MAAMpB,UACNH,KAAKoB,UAAUI,UAAKC,GACpBJ,SAAOK,UAAU1B,M,GASrB,SAAiBmB,GAQCA,EAAAH,KAAhB,SAAqBC,GACnB,IAAIC,EAAM,IAAIC,EACd,IAAK,MAAMV,KAAQQ,EACjBC,EAAIL,IAAIJ,GAEV,OAAOS,C,CAEV,CAfD,CAAiBC,MAehB,K,wEA1KK,cACItB,EADVC,c,oBAuBUE,KAAAoB,UAAY,IAAIC,SAAmBrB,K,CAhBvCsB,eACF,OAAOtB,KAAKoB,S,CAMdjB,UACMH,KAAKE,aAGTqB,MAAMpB,UACNH,KAAKoB,UAAUI,UAAKC,GACpBJ,SAAOK,UAAU1B,M"}