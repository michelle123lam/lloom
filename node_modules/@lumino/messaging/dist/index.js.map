{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt, each, every, retro, some } from '@lumino/algorithm';\n\nimport { LinkedList } from '@lumino/collections';\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nexport class Message {\n  /**\n   * Construct a new message.\n   *\n   * @param type - The type of the message.\n   */\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  /**\n   * The type of the message.\n   *\n   * #### Notes\n   * The `type` of a message should be related directly to its actual\n   * runtime type. This means that `type` can and will be used to cast\n   * the message to the relevant derived `Message` subtype.\n   */\n  readonly type: string;\n\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * If a conflatable message is posted to a handler while another\n   * conflatable message of the same `type` has already been posted\n   * to the handler, the `conflate()` method of the existing message\n   * will be invoked. If that method returns `true`, the new message\n   * will not be enqueued. This allows messages to be compressed, so\n   * that only a single instance of the message type is processed per\n   * cycle, no matter how many times messages of that type are posted.\n   *\n   * Custom message types may reimplement this property.\n   *\n   * The default implementation is always `false`.\n   */\n  get isConflatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * @param other - A conflatable message of the same `type`.\n   *\n   * @returns `true` if the message was successfully conflated, or\n   *   `false` otherwise.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * This method is called automatically by the message loop when the\n   * given message is posted to the handler paired with this message.\n   * This message will already be enqueued and conflatable, and the\n   * given message will have the same `type` and also be conflatable.\n   *\n   * This method should merge the state of the other message into this\n   * message as needed so that when this message is finally delivered\n   * to the handler, it receives the most up-to-date information.\n   *\n   * If this method returns `true`, it signals that the other message\n   * was successfully conflated and that message will not be enqueued.\n   *\n   * If this method returns `false`, the other message will be enqueued\n   * for normal delivery.\n   *\n   * Custom message types may reimplement this method.\n   *\n   * The default implementation always returns `false`.\n   */\n  conflate(other: Message): boolean {\n    return false;\n  }\n}\n\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nexport class ConflatableMessage extends Message {\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * This property is always `true`.\n   */\n  get isConflatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * #### Notes\n   * This method always returns `true`.\n   */\n  conflate(other: ConflatableMessage): boolean {\n    return true;\n  }\n}\n\n/**\n * An object which handles messages.\n *\n * #### Notes\n * A message handler is a simple way of defining a type which can act\n * upon on a large variety of external input without requiring a large\n * abstract API surface. This is particularly useful in the context of\n * widget frameworks where the number of distinct message types can be\n * unbounded.\n */\nexport interface IMessageHandler {\n  /**\n   * Process a message sent to the handler.\n   *\n   * @param msg - The message to be processed.\n   */\n  processMessage(msg: Message): void;\n}\n\n/**\n * An object which intercepts messages sent to a message handler.\n *\n * #### Notes\n * A message hook is useful for intercepting or spying on messages\n * sent to message handlers which were either not created by the\n * consumer, or when subclassing the handler is not feasible.\n *\n * If `messageHook` returns `false`, no other message hooks will be\n * invoked and the message will not be delivered to the handler.\n *\n * If all installed message hooks return `true`, the message will\n * be delivered to the handler for processing.\n *\n * **See also:** [[installMessageHook]] and [[removeMessageHook]]\n */\nexport interface IMessageHook {\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean;\n}\n\n/**\n * A type alias for message hook object or function.\n *\n * #### Notes\n * The signature and semantics of a message hook function are the same\n * as the `messageHook` method of [[IMessageHook]].\n */\nexport type MessageHook =\n  | IMessageHook\n  | ((handler: IMessageHandler, msg: Message) => boolean);\n\n/**\n * The namespace for the global singleton message loop.\n */\nexport namespace MessageLoop {\n  /**\n   * Send a message to a message handler to process immediately.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to deliver to the handler.\n   *\n   * #### Notes\n   * The message will first be sent through any installed message hooks\n   * for the handler. If the message passes all hooks, it will then be\n   * delivered to the `processMessage` method of the handler.\n   *\n   * The message will not be conflated with pending posted messages.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function sendMessage(handler: IMessageHandler, msg: Message): void {\n    // Lookup the message hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Handle the common case of no installed hooks.\n    if (!hooks || hooks.length === 0) {\n      invokeHandler(handler, msg);\n      return;\n    }\n\n    // Invoke the message hooks starting with the newest first.\n    let passed = every(retro(hooks), hook => {\n      return hook ? invokeHook(hook, handler, msg) : true;\n    });\n\n    // Invoke the handler if the message passes all hooks.\n    if (passed) {\n      invokeHandler(handler, msg);\n    }\n  }\n\n  /**\n   * Post a message to a message handler to process in the future.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to post to the handler.\n   *\n   * #### Notes\n   * The message will be conflated with the pending posted messages for\n   * the handler, if possible. If the message is not conflated, it will\n   * be queued for normal delivery on the next cycle of the event loop.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function postMessage(handler: IMessageHandler, msg: Message): void {\n    // Handle the common case of a non-conflatable message.\n    if (!msg.isConflatable) {\n      enqueueMessage(handler, msg);\n      return;\n    }\n\n    // Conflate the message with an existing message if possible.\n    let conflated = some(messageQueue, posted => {\n      if (posted.handler !== handler) {\n        return false;\n      }\n      if (!posted.msg) {\n        return false;\n      }\n      if (posted.msg.type !== msg.type) {\n        return false;\n      }\n      if (!posted.msg.isConflatable) {\n        return false;\n      }\n      return posted.msg.conflate(msg);\n    });\n\n    // Enqueue the message if it was not conflated.\n    if (!conflated) {\n      enqueueMessage(handler, msg);\n    }\n  }\n\n  /**\n   * Install a message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to install.\n   *\n   * #### Notes\n   * A message hook is invoked before a message is delivered to the\n   * handler. If the hook returns `false`, no other hooks will be\n   * invoked and the message will not be delivered to the handler.\n   *\n   * The most recently installed message hook is executed first.\n   *\n   * If the hook is already installed, this is a no-op.\n   */\n  export function installMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hook is already installed.\n    if (hooks && hooks.indexOf(hook) !== -1) {\n      return;\n    }\n\n    // Add the hook to the end, so it will be the first to execute.\n    if (!hooks) {\n      messageHooks.set(handler, [hook]);\n    } else {\n      hooks.push(hook);\n    }\n  }\n\n  /**\n   * Remove an installed message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to remove.\n   *\n   * #### Notes\n   * It is safe to call this function while the hook is executing.\n   *\n   * If the hook is not installed, this is a no-op.\n   */\n  export function removeMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hooks do not exist.\n    if (!hooks) {\n      return;\n    }\n\n    // Lookup the index of the hook and bail if not found.\n    let i = hooks.indexOf(hook);\n    if (i === -1) {\n      return;\n    }\n\n    // Clear the hook and schedule a cleanup of the array.\n    hooks[i] = null;\n    scheduleCleanup(hooks);\n  }\n\n  /**\n   * Clear all message data associated with a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * #### Notes\n   * This will clear all posted messages and hooks for the handler.\n   */\n  export function clearData(handler: IMessageHandler): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Clear all messsage hooks for the handler.\n    if (hooks && hooks.length > 0) {\n      ArrayExt.fill(hooks, null);\n      scheduleCleanup(hooks);\n    }\n\n    // Clear all posted messages for the handler.\n    each(messageQueue, posted => {\n      if (posted.handler === handler) {\n        posted.handler = null;\n        posted.msg = null;\n      }\n    });\n  }\n\n  /**\n   * Process the pending posted messages in the queue immediately.\n   *\n   * #### Notes\n   * This function is useful when posted messages must be processed\n   * immediately, instead of on the next animation frame.\n   *\n   * This function should normally not be needed, but it may be\n   * required to work around certain browser idiosyncrasies.\n   *\n   * Recursing into this function is a no-op.\n   */\n  export function flush(): void {\n    // Bail if recursion is detected or if there is no pending task.\n    if (flushGuard || loopTaskID === 0) {\n      return;\n    }\n\n    // Unschedule the pending loop task.\n    unschedule(loopTaskID);\n\n    // Run the message loop within the recursion guard.\n    flushGuard = true;\n    runMessageLoop();\n    flushGuard = false;\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the message loop exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return exceptionHandler;\n  }\n\n  /**\n   * Set the message loop exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a message handler or a\n   * message hook throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = exceptionHandler;\n    exceptionHandler = handler;\n    return old;\n  }\n\n  /**\n   * A type alias for a posted message pair.\n   */\n  type PostedMessage = { handler: IMessageHandler | null; msg: Message | null };\n\n  /**\n   * The queue of posted message pairs.\n   */\n  const messageQueue = new LinkedList<PostedMessage>();\n\n  /**\n   * A mapping of handler to array of installed message hooks.\n   */\n  const messageHooks = new WeakMap<\n    IMessageHandler,\n    Array<MessageHook | null>\n  >();\n\n  /**\n   * A set of message hook arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<Array<MessageHook | null>>();\n\n  /**\n   * The message loop exception handler.\n   */\n  let exceptionHandler: ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  type ScheduleHandle = number | any; //  requestAnimationFrame (number) and setImmediate (any)\n\n  /**\n   * The id of the pending loop task animation frame.\n   */\n  let loopTaskID: ScheduleHandle = 0;\n\n  /**\n   * A guard flag to prevent flush recursion.\n   */\n  let flushGuard = false;\n\n  /**\n   * A function to schedule an event loop callback.\n   */\n  const schedule = ((): ScheduleHandle => {\n    let ok = typeof requestAnimationFrame === 'function';\n    return ok ? requestAnimationFrame : setImmediate;\n  })();\n\n  /**\n   * A function to unschedule an event loop callback.\n   */\n  const unschedule = (() => {\n    let ok = typeof cancelAnimationFrame === 'function';\n    return ok ? cancelAnimationFrame : clearImmediate;\n  })();\n\n  /**\n   * Invoke a message hook with the specified handler and message.\n   *\n   * Returns the result of the hook, or `true` if the hook throws.\n   *\n   * Exceptions in the hook will be caught and logged.\n   */\n  function invokeHook(\n    hook: MessageHook,\n    handler: IMessageHandler,\n    msg: Message\n  ): boolean {\n    let result = true;\n    try {\n      if (typeof hook === 'function') {\n        result = hook(handler, msg);\n      } else {\n        result = hook.messageHook(handler, msg);\n      }\n    } catch (err) {\n      exceptionHandler(err);\n    }\n    return result;\n  }\n\n  /**\n   * Invoke a message handler with the specified message.\n   *\n   * Exceptions in the handler will be caught and logged.\n   */\n  function invokeHandler(handler: IMessageHandler, msg: Message): void {\n    try {\n      handler.processMessage(msg);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Add a message to the end of the message queue.\n   *\n   * This will automatically schedule a run of the message loop.\n   */\n  function enqueueMessage(handler: IMessageHandler, msg: Message): void {\n    // Add the posted message to the queue.\n    messageQueue.addLast({ handler, msg });\n\n    // Bail if a loop task is already pending.\n    if (loopTaskID !== 0) {\n      return;\n    }\n\n    // Schedule a run of the message loop.\n    loopTaskID = schedule(runMessageLoop);\n  }\n\n  /**\n   * Run an iteration of the message loop.\n   *\n   * This will process all pending messages in the queue. If a message\n   * is added to the queue while the message loop is running, it will\n   * be processed on the next cycle of the loop.\n   */\n  function runMessageLoop(): void {\n    // Clear the task ID so the next loop can be scheduled.\n    loopTaskID = 0;\n\n    // If the message queue is empty, there is nothing else to do.\n    if (messageQueue.isEmpty) {\n      return;\n    }\n\n    // Add a sentinel value to the end of the queue. The queue will\n    // only be processed up to the sentinel. Messages posted during\n    // this cycle will execute on the next cycle.\n    let sentinel: PostedMessage = { handler: null, msg: null };\n    messageQueue.addLast(sentinel);\n\n    // Enter the message loop.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Remove the first posted message in the queue.\n      let posted = messageQueue.removeFirst()!;\n\n      // If the value is the sentinel, exit the loop.\n      if (posted === sentinel) {\n        return;\n      }\n\n      // Dispatch the message if it has not been cleared.\n      if (posted.handler && posted.msg) {\n        sendMessage(posted.handler, posted.msg);\n      }\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a message hooks array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any `null` hook will\n   * be removed from the array.\n   */\n  function scheduleCleanup(hooks: Array<MessageHook | null>): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(hooks);\n  }\n\n  /**\n   * Cleanup the message hook arrays in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupHooks);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty hooks in a message hooks array.\n   *\n   * This will remove any `null` hook from the array.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupHooks(hooks: Array<MessageHook | null>): void {\n    ArrayExt.removeAllWhere(hooks, isNull);\n  }\n\n  /**\n   * Test whether a value is `null`.\n   */\n  function isNull<T>(value: T | null): boolean {\n    return value === null;\n  }\n}\n"],"names":["MessageLoop","every","retro","some","ArrayExt","each","LinkedList"],"mappings":"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"}