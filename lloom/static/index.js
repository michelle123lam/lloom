var kP = Object.defineProperty;
var AP = (e, t, n) => t in e ? kP(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var zs = (e, t, n) => (AP(e, typeof t != "symbol" ? t + "" : t, n), n);
import * as An from "https://esm.sh/d3@7";
function Jn() {
}
function $3(e, t) {
  for (const n in t)
    e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function M3(e) {
  return e();
}
function mS() {
  return /* @__PURE__ */ Object.create(null);
}
function As(e) {
  e.forEach(M3);
}
function F3(e) {
  return typeof e == "function";
}
function Cs(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function CP(e) {
  return Object.keys(e).length === 0;
}
function Rv(e, t, n, i) {
  if (e) {
    const r = T3(e, t, n, i);
    return e[0](r);
  }
}
function T3(e, t, n, i) {
  return e[1] && i ? $3(n.ctx.slice(), e[1](i(t))) : n.ctx;
}
function Lv(e, t, n, i) {
  if (e[2] && i) {
    const r = e[2](i(n));
    if (t.dirty === void 0)
      return r;
    if (typeof r == "object") {
      const s = [], o = Math.max(t.dirty.length, r.length);
      for (let a = 0; a < o; a += 1)
        s[a] = t.dirty[a] | r[a];
      return s;
    }
    return t.dirty | r;
  }
  return t.dirty;
}
function Pv(e, t, n, i, r, s) {
  if (r) {
    const o = T3(t, n, i, s);
    e.p(o, r);
  }
}
function Iv(e) {
  if (e.ctx.length > 32) {
    const t = [], n = e.ctx.length / 32;
    for (let i = 0; i < n; i++)
      t[i] = -1;
    return t;
  }
  return -1;
}
function st(e) {
  return e ?? "";
}
function xe(e, t) {
  e.appendChild(t);
}
function Se(e, t, n) {
  e.insertBefore(t, n || null);
}
function _e(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function Ja(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function ge(e) {
  return document.createElement(e);
}
function $P(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function Qn(e) {
  return document.createTextNode(e);
}
function vt() {
  return Qn(" ");
}
function Pp() {
  return Qn("");
}
function Cr(e, t, n, i) {
  return e.addEventListener(t, n, i), () => e.removeEventListener(t, n, i);
}
function de(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function MP(e) {
  return Array.from(e.childNodes);
}
function xs(e, t) {
  t = "" + t, e.data !== t && (e.data = /** @type {string} */
  t);
}
function yf(e, t) {
  e.value = t ?? "";
}
function yS(e, t, n) {
  for (let i = 0; i < e.options.length; i += 1) {
    const r = e.options[i];
    if (r.__value === t) {
      r.selected = !0;
      return;
    }
  }
  (!n || t !== void 0) && (e.selectedIndex = -1);
}
function FP(e) {
  const t = e.querySelector(":checked");
  return t && t.__value;
}
function TP(e, t, { bubbles: n = !1, cancelable: i = !1 } = {}) {
  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: i });
}
class Ip {
  constructor(t = !1) {
    /**
     * @private
     * @default false
     */
    zs(this, "is_svg", !1);
    /** parent for creating node */
    zs(this, "e");
    /** html tag nodes */
    zs(this, "n");
    /** target */
    zs(this, "t");
    /** anchor */
    zs(this, "a");
    this.is_svg = t, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(t) {
    this.h(t);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(t, n, i = null) {
    this.e || (this.is_svg ? this.e = $P(
      /** @type {keyof SVGElementTagNameMap} */
      n.nodeName
    ) : this.e = ge(
      /** @type {keyof HTMLElementTagNameMap} */
      n.nodeType === 11 ? "TEMPLATE" : n.nodeName
    ), this.t = n.tagName !== "TEMPLATE" ? n : (
      /** @type {HTMLTemplateElement} */
      n.content
    ), this.c(t)), this.i(i);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(t) {
    this.e.innerHTML = t, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(t) {
    for (let n = 0; n < this.n.length; n += 1)
      Se(this.t, this.n[n], t);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(t) {
    this.d(), this.h(t), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(_e);
  }
}
function bS(e, t) {
  return new e(t);
}
let bf;
function ef(e) {
  bf = e;
}
function zv() {
  if (!bf)
    throw new Error("Function called outside component initialization");
  return bf;
}
function zp(e) {
  zv().$$.on_mount.push(e);
}
function OP(e) {
  zv().$$.on_destroy.push(e);
}
function Bv() {
  const e = zv();
  return (t, n, { cancelable: i = !1 } = {}) => {
    const r = e.$$.callbacks[t];
    if (r) {
      const s = TP(
        /** @type {string} */
        t,
        n,
        { cancelable: i }
      );
      return r.slice().forEach((o) => {
        o.call(e, s);
      }), !s.defaultPrevented;
    }
    return !0;
  };
}
function vS(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((i) => i.call(this, t));
}
const Fl = [], Ql = [];
let Bl = [];
const wy = [], NP = /* @__PURE__ */ Promise.resolve();
let _y = !1;
function DP() {
  _y || (_y = !0, NP.then(O3));
}
function tg(e) {
  Bl.push(e);
}
function jv(e) {
  wy.push(e);
}
const V0 = /* @__PURE__ */ new Set();
let pl = 0;
function O3() {
  if (pl !== 0)
    return;
  const e = bf;
  do {
    try {
      for (; pl < Fl.length; ) {
        const t = Fl[pl];
        pl++, ef(t), RP(t.$$);
      }
    } catch (t) {
      throw Fl.length = 0, pl = 0, t;
    }
    for (ef(null), Fl.length = 0, pl = 0; Ql.length; )
      Ql.pop()();
    for (let t = 0; t < Bl.length; t += 1) {
      const n = Bl[t];
      V0.has(n) || (V0.add(n), n());
    }
    Bl.length = 0;
  } while (Fl.length);
  for (; wy.length; )
    wy.pop()();
  _y = !1, V0.clear(), ef(e);
}
function RP(e) {
  if (e.fragment !== null) {
    e.update(), As(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(tg);
  }
}
function LP(e) {
  const t = [], n = [];
  Bl.forEach((i) => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach((i) => i()), Bl = t;
}
const Fh = /* @__PURE__ */ new Set();
let da;
function vi() {
  da = {
    r: 0,
    c: [],
    p: da
    // parent group
  };
}
function xi() {
  da.r || As(da.c), da = da.p;
}
function pe(e, t) {
  e && e.i && (Fh.delete(e), e.i(t));
}
function $e(e, t, n, i) {
  if (e && e.o) {
    if (Fh.has(e))
      return;
    Fh.add(e), da.c.push(() => {
      Fh.delete(e), i && (n && e.d(1), i());
    }), e.o(t);
  } else
    i && i();
}
function Rn(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function xS(e, t) {
  const n = {}, i = {}, r = { $$scope: 1 };
  let s = e.length;
  for (; s--; ) {
    const o = e[s], a = t[s];
    if (a) {
      for (const l in o)
        l in a || (i[l] = 1);
      for (const l in a)
        r[l] || (n[l] = a[l], r[l] = 1);
      e[s] = a;
    } else
      for (const l in o)
        r[l] = 1;
  }
  for (const o in i)
    o in n || (n[o] = void 0);
  return n;
}
function wS(e) {
  return typeof e == "object" && e !== null ? e : {};
}
function Uv(e, t, n) {
  const i = e.$$.props[t];
  i !== void 0 && (e.$$.bound[i] = n, n(e.$$.ctx[i]));
}
function wi(e) {
  e && e.c();
}
function ti(e, t, n) {
  const { fragment: i, after_update: r } = e.$$;
  i && i.m(t, n), tg(() => {
    const s = e.$$.on_mount.map(M3).filter(F3);
    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : As(s), e.$$.on_mount = [];
  }), r.forEach(tg);
}
function ni(e, t) {
  const n = e.$$;
  n.fragment !== null && (LP(n.after_update), As(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function PP(e, t) {
  e.$$.dirty[0] === -1 && (Fl.push(e), DP(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function $s(e, t, n, i, r, s, o = null, a = [-1]) {
  const l = bf;
  ef(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: Jn,
    not_equal: r,
    bound: mS(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: mS(),
    dirty: a,
    skip_bound: !1,
    root: t.target || l.$$.root
  };
  o && o(u.root);
  let c = !1;
  if (u.ctx = n ? n(e, t.props || {}, (f, d, ...h) => {
    const g = h.length ? h[0] : d;
    return u.ctx && r(u.ctx[f], u.ctx[f] = g) && (!u.skip_bound && u.bound[f] && u.bound[f](g), c && PP(e, f)), d;
  }) : [], u.update(), c = !0, As(u.before_update), u.fragment = i ? i(u.ctx) : !1, t.target) {
    if (t.hydrate) {
      const f = MP(t.target);
      u.fragment && u.fragment.l(f), f.forEach(_e);
    } else
      u.fragment && u.fragment.c();
    t.intro && pe(e.$$.fragment), ti(e, t.target, t.anchor), O3();
  }
  ef(l);
}
class Ms {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    zs(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    zs(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    ni(this, 1), this.$destroy = Jn;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!F3(n))
      return Jn;
    const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return i.push(n), () => {
      const r = i.indexOf(n);
      r !== -1 && i.splice(r, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !CP(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
const IP = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(IP);
function zP(e) {
  let t;
  return {
    c() {
      t = ge("div"), t.innerHTML = "";
    },
    m(n, i) {
      Se(n, t, i);
    },
    p: Jn,
    i: Jn,
    o: Jn,
    d(n) {
      n && _e(t);
    }
  };
}
function BP(e, t, n) {
  let { data: i } = t, { div: r } = t, { numConcepts: s } = t, o;
  const a = Bv();
  zp(() => {
    l(i);
  });
  function l(F) {
    if (F != null && s > 0) {
      let x = JSON.parse(F);
      const k = 675, A = 300 + 60 * s, M = "#82C1FB";
      o = new u(r).size([k, A]).options({
        highlightScope: "matrix",
        showSlider: !1,
        preserveRowOrder: !0,
        preserveColumnOrder: !0,
        sortOnAxisClick: !1
      }).font({ family: "system-ui", size: 12 }).columns({
        row: "concept",
        column: "id",
        value: "value",
        detail: "example"
      }).colors({
        above: M,
        below: M,
        row: "#eee"
      }).data(x), o.render();
    }
  }
  class u {
    constructor(x = document.createElement("DIV")) {
      this._container = x, this._options = new c(), this.partitions = new S(this), this._dataset = null, this._fieldNames = new p(), this.chartData = null, this.measures = new w(this._getMeasureSvg()), this.scales = new L(), this.renderer = new E(this);
    }
    get fieldNames() {
      return this._fieldNames;
    }
    size(x) {
      return arguments.length ? (this.measures.width = x[0], this.measures.height = x[1], this) : [this.measures.width, this.measures.height];
    }
    colors(x) {
      return arguments.length ? (this.renderer.colors.row = x.row, this.renderer.colors.above = x.above, this.renderer.colors.below = x.below, this.renderer.colors.label = x.label, this) : this.renderer.colors;
    }
    margin(x) {
      return arguments.length ? (this.measures.margin.left = x.left, this.measures.margin.right = x.right, this.measures.margin.top = x.top, this.measures.margin.bottom = x.bottom, this) : this.measures.margin;
    }
    options(x) {
      return arguments.length ? (this._options = Object.assign(this._options, x), this) : this._options;
    }
    columns(x) {
      return arguments.length ? (this._fieldNames.column = x.column, this._fieldNames.row = x.row, this._fieldNames.value = x.value, this._fieldNames.detail = x.detail, this) : this._fieldNames;
    }
    font(x) {
      return arguments.length ? (this.measures.font.family(x.family), this.measures.font.size(x.size), this) : this.measures.font;
    }
    data(x) {
      return arguments.length ? (this._dataset = x, this) : this._dataset;
    }
    events(x) {
      return arguments.length ? (this.renderer.rows.onclick = x.onclick, this.renderer.rows.onhover = x.onhover, this.renderer.rows.oncancel = x.oncancel, this) : {
        onclick: this.renderer.onclick,
        onhover: this.renderer.onhover,
        oncancel: this.renderer.oncancel
      };
    }
    render() {
      const x = this._options, k = !this._container.isConnected;
      return k && document.body.append(this._container), this.chartData = new f(this._dataset, this._fieldNames), this.chartData.numberIsPercentage = x.numberIsPercentage, this.chartData.preserveColumnOrder = x.preserveColumnOrder, this.chartData.preserveRowOrder = x.preserveRowOrder, this.chartData.numOfTopBottom = x.numberOfTopBottom, this.chartData.process(), this.measures.initialize(this.chartData, x.showSlider), this.scales.initialize(this), this.partitions.initialize(), this._container.appendChild(this.partitions.chartArea), this.renderer.rows.highlight = T[x.highlightScope], this.renderer.rows.showTooltip = x.showTooltip, this.renderer.rows.showAnnotation = x.showAnnotation, this.renderer.rows.sortOnAxisClick = x.sortOnAxisClick, this.renderer.columns.sortOnAxisClick = x.sortOnAxisClick, this.renderer.render(), x.showSlider && new O(this, x.sliderCaption).render(), this.partitions.adjustScrollableBlocks(), k ? (this._container.remove(), this._container) : this;
    }
    _getMeasureSvg() {
      const x = An.select(this._container).append("svg").attr("width", 0).attr("height", 0).style("position", "absolute").style("visibility", "hidden");
      return x.append("text"), x;
    }
  }
  class c {
    constructor() {
      this.numberIsPercentage = !1, this.preserveRowOrder = !1, this.preserveColumnOrder = !1, this.showSlider = !0, this.sliderCaption = "Value", this.highlightScope = "matrix", this.numberOfTopBottom = 5, this.showTooltip = !0, this.showAnnotation = !0, this.sortOnAxisClick = !0;
    }
  }
  class f {
    constructor(x, k) {
      this._dataset = x, this._fieldNames = k, this.numberIsPercentage = !1, this.preserveColumnOrder = !1, this.preserveRowOrder = !1, this.columns = null, this.rows = null, this.level = 0, this.defaultLevel = 0, this.average = 0, this.min = 0, this.max = 0, this.numOfTopBottom = 5;
    }
    resetColumns(x) {
      this.columns.forEach((k) => {
        k !== x && (k.order = m.none);
      });
    }
    resetRows(x) {
      this.rows.forEach((k) => {
        k !== x && (k.order = m.none);
      });
    }
    process() {
      const x = this._fieldNames, k = An.group(this._dataset, (R) => R[x.row]);
      this.columns = [...new Set(this._dataset.map((R) => R[x.column]))].map((R, U) => new d(R, U)), this.preserveColumnOrder || (this.columns.sort((R, U) => R.name.localeCompare(U.name)), this.columns.forEach((R, U) => R.position = U));
      const A = [...k.keys()];
      this.preserveRowOrder || A.sort((R, U) => R.localeCompare(U)), this.rows = A.map((R, U) => {
        const W = k.get(R), ne = this.columns.map((re) => {
          const Ce = W.find((Et) => Et[x.column] === re.name);
          return new g(R, re.name, Ce ? +Ce[x.value] : null, Ce[x.detail]);
        }), Z = new h(R, U, ne);
        return Z.markBounds(), Z;
      });
      const M = this.rows.flatMap((R) => R.cells).filter((R) => R.value).sort((R, U) => R.value - U.value);
      M[0].flag |= y.min, M[M.length - 1].flag |= y.max, M.slice(0, this.numOfTopBottom).forEach((R) => R.flag |= y.bottomGroup), M.slice(-this.numOfTopBottom).forEach((R) => R.flag |= y.topGroup);
      const D = M.reduce((R, U) => R + U.value, 0);
      this.level = this.defaultLevel = this.average = D / M.length, this.min = M[0].value, this.max = M[M.length - 1].value;
    }
  }
  class d {
    constructor(x, k) {
      this.name = x, this.position = k, this.order = m.none;
    }
  }
  class h {
    constructor(x, k, A) {
      this.name = x, this.position = k, this.order = m.none, this.cells = A;
    }
    markBounds() {
      const x = [...this.cells].filter((k) => k.value).sort((k, A) => k.value - A.value);
      x[0].flag |= y.rowMin, x[x.length - 1].flag |= y.rowMax;
    }
  }
  class g {
    constructor(x, k, A, M) {
      this.row = x, this.column = k, this.value = A, this.detail = M, this.flag = y.unspecified;
    }
  }
  class p {
    constructor(x, k, A, M) {
      this.column = x, this.row = k, this.value = A, this.detail = M;
    }
  }
  class m {
    static get none() {
      return 0;
    }
    static get ascending() {
      return 1;
    }
    static get descending() {
      return 2;
    }
  }
  class y {
    static get unspecified() {
      return 0;
    }
    static get min() {
      return 1;
    }
    static get max() {
      return 2;
    }
    static get rowMin() {
      return 4;
    }
    static get rowMax() {
      return 8;
    }
    static get bottomGroup() {
      return 16;
    }
    static get topGroup() {
      return 32;
    }
  }
  class b {
    constructor(x, k, A, M, D) {
      this._svg = x, this._font = k, this._charBox = null, this._box = this._initBox(A, M, D), this.left = 0, this.top = 0, this.getBBox = null, this.calcTextWidth = null, this.calcPosition = null;
    }
    get box() {
      return this._box;
    }
    get offset() {
      return 10;
    }
    show(x, k, A, M) {
      this._charBox || (this._charBox = this.getBBox("M"));
      const D = this, R = 1.4, U = this._calcWidth(k);
      this._box.style("visibility", "visible").select("rect").attr("width", U + 10).attr("height", `${k.length * R + 0.5}em`), W("backtext", "white", 3), W("foretext"), this.move(x, A, M);
      function W(ne, Z, re) {
        D._box.selectAll("." + ne).data(k).join(
          (Ce) => {
            Ce.append("text").attr("class", ne).attr("dy", (Et, ln) => `${R * ln + 1}em`).attr("stroke", Z).attr("stroke-width", re).text((Et) => Et);
          },
          (Ce) => Ce.text((Et) => Et),
          (Ce) => Ce.remove()
        );
      }
    }
    // wrap(text, wrapWidth, yAxisAdjustment = 0) {
    //   text.each(function() {
    //     var text = d3.select(this),
    //         words = text.text().split(/\s+/).reverse(),
    //         word,
    //         line = [],
    //         lineNumber = 0,
    //         lineHeight = 1.1, // ems
    //         y = text.attr("y"),
    //         dy = parseFloat(text.attr("dy")) - yAxisAdjustment,
    //         tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", `${dy}em`);
    //     while (word = words.pop()) {
    //       line.push(word);
    //       tspan.text(line.join(" "));
    //       if (tspan.node().getComputedTextLength() > wrapWidth) {
    //         line.pop();
    //         tspan.text(line.join(" "));
    //         line = [word];
    //         tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
    //       }
    //     }
    //   });
    //   return 0;
    // }
    move(x, k, A) {
      if (this._box) {
        const M = k && A ? new DOMPoint(k, A) : this._convertCoordinate(x, this._svg), D = this._box.node().getBBox(), { left: R, top: U } = this.calcPosition(M, D);
        this.left = R + this.offset, this.top = U + this.offset, this._box.attr("transform", `translate(${this.left},${this.top})`);
      }
    }
    hide() {
      this._box && this._box.style("visibility", "hidden");
    }
    _initBox(x, k, A) {
      const M = this._svg.append("g").attr("fill", "black").call((D) => {
        D.append("rect").attr("opacity", k).attr("stroke", A).attr("stroke-width", 0.5).attr("rx", 4).attr("ry", 4).attr("x", -5).attr("y", -5).attr("fill", x);
      });
      return this._font.applyTo(M), M;
    }
    _calcWidth(x) {
      let k = 0;
      return x.forEach((A) => {
        const M = this.calcTextWidth(A);
        M > k && (k = M);
      }), k;
    }
    _convertCoordinate(x, k) {
      const A = this._svg.node().createSVGPoint();
      return A.x = x.clientX, A.y = x.clientY, A.matrixTransform(k.node().getScreenCTM().inverse());
    }
  }
  class v extends b {
    constructor(x, k, A, M, D) {
      super(x, k, A, M, D), this._pointer = null;
    }
    show(x, k, A, M, D, R) {
      super.show(x, k, A, M);
      const U = this.box.node().getBBox();
      this.move(x, A + D - this.offset, M + D - this.offset);
      const W = this.offset / 2;
      let ne = this.left, Z = this.top, re = ne - W, Ce = Z - W, Et = re + 30, ln = Ce + U.height;
      ne < A && (re = A - D - W, Et = re - 30, ne = A - D - U.width), Z < M && (Ce = M - D - W, ln = Ce - U.height, Z = M - D - U.height), this.box.attr("transform", `translate(${ne},${Z})`), this._removePointer(), this._pointer = this._svg.append("path").attr("fill", "none").attr("stroke", R).attr("stroke-width", 2).attr("d", `M ${A} ${M} L ${re} ${Ce} L ${re} ${ln} L ${Et} ${ln}`);
    }
    hide() {
      super.hide(), this._removePointer();
    }
    _removePointer() {
      this._pointer && (this._pointer.remove(), this._pointer = null);
    }
  }
  class w {
    constructor(x) {
      this._svg = x, this.font = new _(), this.padding = 10, this.margin = { left: 0, right: 0, top: 0, bottom: 0 }, this.width = 0, this.height = 0, this.sliderHeight = 20, this.columnHeight = 0, this.rowWidth = 0, this._minRadius = 25, this.bubbleRadius = 0, this.bubbleDiameter = 0;
    }
    initialize(x, k) {
      this._calculateLabels(x), this._calculateBubbleRadius(x, k);
    }
    _calculateLabels(x) {
      let k = "";
      const A = (M, D) => {
        let R = 0;
        return M.forEach((U) => {
          U = k.concat(U);
          const W = this.calculateStringWidth(U, void 0, D);
          W > R && (R = W);
        }), R;
      };
      this.columnHeight = A(x.columns.map((M) => this.trim(M.name) + "M")), this.rowWidth = this.margin.left + A(x.rows.map((M) => M.name + "MM"), this.font.clone().weight("bold"));
    }
    _calculateBubbleRadius(x, k) {
      const A = this.width - this.rowWidth, M = this.height - this.columnHeight - this.padding * 2 - (k ? this.sliderHeight : 0), D = x.rows.length, R = x.columns.length, U = (M / D - this.padding) / 2, W = A / R / 2;
      if (U < W)
        this.bubbleRadius = U;
      else {
        const ne = D * W;
        this.bubbleRadius = W > M ? W - (ne - M) / D / 2 : W;
      }
      this.bubbleRadius < this._minRadius && (this.bubbleRadius = this._minRadius), this.bubbleDiameter = this.bubbleRadius * 2;
    }
    getBBox(x, k, A) {
      const M = A ?? this.font, D = this._svg.select("text");
      return D ? (M.applyTo(D), D.text(x), k && D.attr("transform", `rotate(${k})`), D.node().getBBox()) : null;
    }
    calculateStringWidth(x, k, A) {
      const M = this.getBBox(x, k, A);
      return M ? Math.sqrt(M.width * M.width + M.height * M.height) : x.length * this.font.size;
    }
    trim(x) {
      return x.length > 100 ? `${x.substr(0, 10)}...` : x;
    }
  }
  class _ {
    constructor(x = "", k = "10pt", A = "normal", M = "normal") {
      this._family = x, this._size = k, this._style = A, this._weight = M;
    }
    family(x) {
      return arguments.length ? (this._family = x, this) : this._family;
    }
    size(x) {
      return arguments.length ? (this._size = x, this) : this._size;
    }
    style(x) {
      return arguments.length ? (this._style = x, this) : this._style;
    }
    weight(x) {
      return arguments.length ? (this._weight = x, this) : this._weight;
    }
    applyTo(x) {
      x = x instanceof HTMLElement ? An.select(x) : x, x.style("font-family", this._family).style("font-size", isNaN(+this._size) ? this._size : `${this._size}pt`).style("font-style", this._style).style("font-weight", this._weight);
    }
    clone() {
      return new _(this._family, this._size, this._style, this._weight);
    }
  }
  class S {
    constructor(x) {
      this._chart = x, this.chartArea = this._createDiv(), this.mainBlock = this._createDiv(), this.slider = this._createDiv(), this.columnBlock = this._createDiv(), this.placeHolder = this._createDiv(), this.columns = this._createDiv(), this.matrixBlock = this._createDiv(), this.rows = this._createDiv(), this.matrix = this._createDiv();
    }
    initialize() {
      this._initStyles(), this._initLayout(), this._adjustSize();
    }
    adjustScrollableBlocks() {
      const x = this.matrix.offsetHeight - this.matrix.clientHeight, k = this.matrix.offsetWidth - this.matrix.clientWidth;
      x && (this.rows.style.height = `${this.rows.clientHeight - x}px`), k && (this.columns.style.width = `${this.columns.clientWidth - k}px`);
    }
    changeFont(x) {
      this.chartArea.style.font = x.shorthand;
    }
    _adjustSize() {
      const x = this._chart.measures;
      this.chartArea.style.height = `${x.height}px`, this._chart.options().showSlider && (this.slider.style.height = `${x.sliderHeight}px`), this.columns.style.height = `${x.columnHeight}px`, this.columns.style.width = `${x.width - x.rowWidth - x.margin.left}px`, this.placeHolder.style.width = `${x.rowWidth + x.margin.left}px`, this.placeHolder.style.height = `${x.columnHeight}px`, this.rows.style.width = `${x.rowWidth + x.margin.left}px`, this.matrix.style.width = `${x.width + x.margin.right + x.rowWidth}px`;
    }
    _createDiv() {
      return document.createElement("div");
    }
    _initStyles() {
      const x = this._chart.measures, k = x.width + x.margin.left + x.margin.right;
      let A = this.chartArea.style;
      A.display = "flex", A.flexDirection = "column", A.cursor = "default", A.userSelect = "none", x.font.applyTo(this.chartArea), A = this.mainBlock.style, A.display = "flex", A.flexDirection = "column", A.flexGrow = 1, A.height = "1px", A = this.columnBlock.style, A.textAlign = "left", A.display = "flex", A.flexDirection = "row", A.flexShrink = 0, A.width = "1px", A = this.placeHolder.style, A.flexShrink = 0, A.backgroundColor = "white", A = this.columns.style, A.paddingTop = "5px", A.paddingBottom = "5px", A.overflow = "hidden", A.flexShrink = 0, A.width = `${k}px`, A = this.matrixBlock.style, A.display = "flex", A.flexDirection = "row", A.flexGrow = 0, A.width = "1px", A.overflowY = "auto", A.textAlign = "left", A.width = `${k}px`, A = this.rows.style, A.overflow = "hidden", A.flexShrink = 0, A = this.matrix.style, A.overflowX = "auto", this.matrix.onscroll = (M) => {
        this.columns.scrollLeft = this.matrix.scrollLeft, this.rows.scrollTop = this.matrix.scrollTop;
      };
    }
    _initLayout() {
      this.chartArea.appendChild(this.mainBlock), this.mainBlock.appendChild(this.slider), this.mainBlock.appendChild(this.columnBlock), this.mainBlock.appendChild(this.matrixBlock), this.columnBlock.appendChild(this.placeHolder), this.columnBlock.appendChild(this.columns), this.matrixBlock.appendChild(this.rows), this.matrixBlock.appendChild(this.matrix);
    }
  }
  class E {
    constructor(x) {
      this.chart = x, this.colors = {
        row: "#caf0f8",
        above: "#ffd166",
        below: "#118ab2",
        label: "black"
      }, this.matrix = { svg: null, g: null, og: null, ig: null }, this.columns = new $(this), this.rows = new N(this), this._uuid = `uu${Date.now()}${Math.floor(Math.random() * 1e4)}`;
    }
    render() {
      this._initMatrix(), this._renderGradients(), this.columns.render(), this.rows.render();
    }
    _createSvg(x, k, A) {
      return An.select(x).append("svg").attr("width", k + 100).attr("height", A);
    }
    _transform(x, k) {
      return `translate(${x},${k})`;
    }
    _initMatrix() {
      const x = this.chart, k = this.matrix;
      k.svg = this._createSvg(x.partitions.matrix, x.scales.maxX, x.scales.maxY), k.g = k.svg.append("g"), k.og = k.g.append("g"), k.ig = k.svg.append("g").attr("transform", this._transform(0, x.measures.padding / 2));
    }
    uid(x) {
      return `${this._uuid}_${x}`;
    }
    _renderGradients() {
      const x = this.chart, k = (A) => {
        this.matrix.g.append("linearGradient").attr("id", this.uid(A ? "descending" : "ascending")).attr("x1", 0).attr("x2", x.measures.rowWidth + x.chartData.columns.length * x.measures.bubbleDiameter).attr("y1", "100%").attr("y2", "100%").attr("gradientUnits", "userSpaceOnUse").call((M) => {
          M.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", A ? 1 : 0).attr("offset", 0), M.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", A ? 0 : 1).attr("offset", 1);
        });
      };
      k(!1), k(!0);
    }
  }
  class C {
    constructor(x) {
      this._mainRenderer = x, this.duration = 500;
    }
    get chart() {
      return this._mainRenderer.chart;
    }
    get matrix() {
      return this._mainRenderer.matrix;
    }
    get colors() {
      return this._mainRenderer.colors;
    }
    get rows() {
      return this._mainRenderer.rows;
    }
    get columns() {
      return this._mainRenderer.columns;
    }
    uid(x) {
      return this._mainRenderer.uid(x);
    }
    url(x) {
      return `url(#${x})`;
    }
  }
  class $ extends C {
    constructor(x) {
      super(x), this.text = null, this._arrow = null, this.labels = null, this.axis = null, this._focused = null, this.sortOnAxisClick = !0;
    }
    render() {
      const x = this.chart, M = An.select(x.partitions.columns).append("svg").attr("width", x.scales.maxX + x.measures.rowWidth + 0).attr("height", x.measures.columnHeight + 0).append("g");
      this.labels = this._renderGroups(M, `translate(0,${x.measures.columnHeight})`, "start", (D) => {
        this.text = D.append("text").attr("y", 0).attr("dy", "-0.25em").attr("transform", "rotate(-45)").attr("fill", this.colors.label).text(this._trim.bind(this)).on("click", this._click.bind(this)).on("pointerenter", this._handlePointerEnter.bind(this)).on("pointerleave", this._handlePointerLeave.bind(this));
      }), this.axis = this._renderGroups(this.matrix.og, void 0, "middle", (D) => {
        D.append("line").attr("y1", 0).attr("y2", x.scales.maxY).attr("stroke-width", 1).attr("stroke", "#8d99ae");
      });
    }
    _renderGroups(x, k, A, M) {
      const D = this.chart, R = x.append("g");
      return k && R.attr("transform", k), R.selectAll("g").data(D.chartData.columns).join("g").attr("text-anchor", A).attr("transform", (U, W) => `translate(${D.scales.x(W) + D.measures.bubbleRadius},0)`).call(M);
    }
    _trim(x) {
      return this.chart.measures.trim("" + x.name);
    }
    _click(x, k) {
      this._sort(k), this._arrow && this._arrow.attr("d", (A) => {
        if (k.order !== m.none && k.name === A.name) {
          const M = this.chart.measures.getBBox(this._trim(A)), D = M.height / 2 + 1, R = M.width, U = 5;
          return k.order === m.descending ? `M 0 ${D} L ${R} ${D} L ${R} ${D + U} L 0 ${D}` : `M 0 ${D} L 0 ${D + U} L ${R} ${D} L 0 ${D}`;
        }
      }), this._focused !== k ? (this.columns.axis.select("line").attr("stroke-width", (A) => A.name === k.name ? 2 : 1), this.columns.text.attr("font-weight", (A) => A.name === k.name ? "bold" : ""), this._focused = k, a("message", {
        selection_type: "col",
        col: "" + k.name,
        row: null,
        sortOrder: k.order
      }), this.rows._rowFocused != null && (this.rows._bubbleRects.attr("stroke-width", 0), this.rows._labelRects.attr("stroke-width", 0), this.rows._rowFocused = null)) : (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this._focused = null, a("message", {
        selection_type: "col",
        col: null,
        row: null,
        sortOrder: k.order
      }));
    }
    _sort(x) {
      if (this.sortOnAxisClick) {
        let W = function(ne) {
          ne.transition().duration((Z, re) => re * U).attr("transform", (Z) => {
            let re = 0;
            for (let Ce = 0; Ce < R.length; Ce++)
              if (R[Ce].row === Z) {
                Z.position = re = Ce;
                break;
              }
            return `translate(0,${k.chart.scales.y(re)})`;
          });
        };
        const k = this, A = this.chart.chartData, M = A.columns, D = M.indexOf(x), R = A.rows.map((ne) => ({ row: ne, column: ne.cells[D] }));
        A.resetColumns(x), x.order === m.none ? x.order = m.descending : x.order === m.descending ? x.order = m.ascending : x.order = m.none, x.order === m.ascending ? R.sort((ne, Z) => ne.column.value - Z.column.value) : x.order === m.descending && R.sort((ne, Z) => Z.column.value - ne.column.value);
        const U = this.duration / A.rows.length;
        W(this.rows.axis), W(this.rows.labels), this.rows.relocateAnnotation();
      }
    }
    _handlePointerEnter(x, k) {
      this.onhover && this.onhover(x, k), this.axis.select("line").attr("stroke-width", (A) => A.name === k.name || this._focused != null && A.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (A) => A.name === k.name || this._focused != null && A.name === this._focused.name ? "bold" : "");
    }
    _handlePointerLeave(x, k) {
      this._focused == null ? (this.oncancel && this.oncancel(x, k), this.axis.select("line").attr("stroke-width", 1), this.text.attr("font-weight", "")) : (this.axis.select("line").attr("stroke-width", (A) => A.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (A) => A.name === this._focused.name ? "bold" : ""));
    }
  }
  class N extends C {
    constructor(x) {
      super(x), this._tooltip = null, this._annotation = null, this.labels = null, this.axis = null, this.highlight = T.matrix, this.showTooltip = !0, this.showAnnotation = !0, this.sortOnAxisClick = !0, this._labelRects = null, this._bubbleRects = null, this._bubbles = null, this._focused = null, this._rowFocused = null, this.onhover = null, this.oncancel = null, this.onclick = null;
    }
    get bubbles() {
      return this._bubbles;
    }
    render() {
      this._initInfoLayer();
      const x = this.chart, k = An.select(x.partitions.rows).append("svg").attr("width", x.measures.rowWidth).attr("height", x.scales.maxY).append("g").attr("transform", `translate(0,${x.measures.padding / 2})`);
      this.labels = this._renderGroups(k, (M) => {
        this._labelRects = this._renderRect(M, 1, x.measures.rowWidth + 10).on("click", this._click.bind(this)), M.append("text").attr("font-weight", "bold").attr("y", x.measures.bubbleRadius).attr("dx", "1em").attr("dy", "0.25em").attr("fill", this.colors.label).text((D) => D.name).on("click", this._click.bind(this));
      });
      const A = x.chartData.columns.length * x.measures.bubbleDiameter;
      this.axis = this._renderGroups(this.matrix.ig.append("g"), (M) => {
        this._bubbleRects = this._renderRect(M, -11, A + 10), this._bubbles = M.append("g").selectAll("g").data((D) => D.cells).join("g").attr("transform", (D, R) => `translate(${x.scales.x(R) + x.measures.bubbleRadius},0)`).call((D) => {
          D.append("circle").attr("class", "bubble").attr("fill", (R) => R.value >= x.chartData.average ? this.colors.above : this.colors.below).attr("opacity", 0.5).attr("stroke-width", 2).attr("cy", x.measures.bubbleRadius).attr("r", 0);
        }).on("click", this._handleClick.bind(this)), this._bubbles.selectAll("circle").transition().ease(An.easeBounce).duration(500).attr("r", (D) => D.value ? x.scales.r(D.value) : 0);
      });
    }
    // this.highlightBubbles(); // TEMP: remove highlighting
    relocateAnnotation(x = !0) {
      if (this._focused) {
        const k = () => this._showAnnotation(null, this._focused);
        this._annotation.hide(), x ? setTimeout(k, this.duration) : k();
      }
    }
    _handleClick(x, k) {
      this.chart, this.onclick && this.onclick(x, k);
    }
    _showAnnotation(x, k) {
    }
    // const
    //     a = this._annotation,
    //     getPosition = (axis, name) => {
    //         const obj = axis.find(d => d.name === name);
    //         return obj ? obj.position : 0;
    //     }
    // if (this.showAnnotation) {
    //     const
    //         cx = c.scales.x(getPosition(c.chartData.columns, d.column)),
    //         cy = c.scales.y(getPosition(c.chartData.rows, d.row)),
    //         r = c.scales.r(d.value),
    //         color = d.value >= c.chartData.level ? this.colors.above : this.colors.below;
    //     this._focused = d;
    //     a.hide();
    //     a.show(
    //         null, this._getTooltipContent(d),
    //         cx + c.measures.bubbleRadius,
    //         cy + c.measures.bubbleRadius + c.measures.padding / 2,
    //         r, d3.color(color).darker(1));
    // }
    _handlePointerEnter(x, k) {
      this.chart, this.onhover && this.onhover(x, k), this.columns.axis.select("line").attr("stroke-width", (A) => A.name === k.column ? 2 : 1), this.columns.text.attr("font-weight", (A) => A.name === k.column ? "bold" : "");
    }
    // if (this._focused == null) {
    //     // if (this.showTooltip) this._tooltip.show(e, this._getTooltipContent(d));
    //     if (this.onhover) this.onhover(e, d);
    //     this.columns.axis.select("line").attr("stroke-width", col => col.name === d.column ? 2 : 1);
    //     this.columns.text.attr("font-weight", col => col.name === d.column ? "bold" : "");
    //     dispatch("message", {selection_type: "cell", row: ("" + d.row) , col: ("" + d.column)})
    //     // Add shadow
    //     this._bubbles.filter(b => b === d)
    //     .call(g => {
    //         // g.select(".bubble").attr("transform", "translate(1,-1.5)");
    //         g.insert("circle", "circle")
    //         .attr("class", "shadow")
    //         .attr("cy", c.measures.bubbleRadius)
    //         .attr("r", d => d.value ? c.scales.r(d.value) : 0)
    //         .attr("fill", d => {
    //             const color = d.value >= c.chartData.level ? this.colors.above : this.colors.below;
    //             return d3.color(color).darker(1);
    //         })
    //     });  // TEMP: remove threshold-based circle coloring
    // }
    _handlePointerMove(x) {
      this.showTooltip && this._tooltip.move(x);
    }
    _handlePointerLeave(x, k) {
      this._focused == null && (this.oncancel && this.oncancel(x, k), this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""));
    }
    //         g.select(".bubble").attr("transform", "");
    //     });
    highlightBubbles(x) {
      const k = this.chart.measures.bubbleRadius, A = (W) => this.highlight === T.byRow && ((W.flag & y.rowMin) === y.rowMin || (W.flag & y.rowMax) === y.rowMax), M = (W) => this.highlight === T.matrix && ((W.flag & y.min) === y.min || (W.flag & y.max) === y.max), D = (W) => this.highlight === T.top && (W.flag & y.topGroup) === y.topGroup, R = (W) => this.highlight === T.bottom && (W.flag & y.bottomGroup) === y.bottomGroup, U = this._bubbles.filter((W) => W.value && (A(W) || M(W) || D(W) || R(W)));
      U.select("circle").attr("stroke", (W) => {
        const ne = W.value >= this.chart.chartData.level ? this.colors.above : this.colors.below;
        return An.color(ne).darker(0.75);
      }), x || U.append("text").attr("text-anchor", "middle").attr("y", (W) => {
        const ne = this.chart.scales.r(W.value);
        return this.chart.measures.calculateStringWidth(this._formatValue(W.value)) + 5 > ne * 2 ? k + ne + 12 : k;
      }).attr("dy", "0.3em").attr("fill", this.colors.label).attr("font-weight", "bold").text((W) => this._formatValue(W.value));
    }
    _formatValue(x, k = !0) {
      const A = this.chart.chartData.numberIsPercentage ? ".1%" : k ? ".2s" : ",.2f";
      return An.format(A)(x);
    }
    _initInfoLayer() {
      const x = this, k = this.chart.measures.font;
      if (this.showAnnotation) {
        const M = k.clone().family("system-ui").size("11px").weight("bold");
        this._annotation = new v(this.matrix.svg, M, "none"), A(this._annotation, M);
      }
      this.showTooltip && (this._tooltip = new b(this.matrix.svg, k, "white", 0.7, "#aaa"), A(this._tooltip, k));
      function A(M, D) {
        M.getBBox = (R) => x.chart.measures.getBBox(R, void 0, D), M.calcTextWidth = (R) => x.chart.measures.calculateStringWidth(R, void 0, D), M.calcPosition = (R, U) => x._calcTooltipPosition(R, U);
      }
    }
    _getTooltipContent(x) {
      const k = this.chart.fieldNames;
      return [
        `${k.row}: ${x.row}`,
        `${k.column}: ${x.column}`,
        `${k.value}: ${this._formatValue(x.value, !1)}`,
        `${k.detail}: ${x.detail.slice(0, 50)}...`
      ];
    }
    _calcTooltipPosition(x, k) {
      const A = this.matrix.svg.node().getBoundingClientRect(), M = x.x + A.left, D = x.y + A.top, R = 5, U = M + k.width + R > A.right ? x.x - k.width - R : x.x + R, W = D + k.height + R > A.bottom ? x.y - k.height - R : x.y + R;
      return { left: U, top: W };
    }
    _renderGroups(x, k) {
      const A = this.chart;
      return x.selectAll("g").data(A.chartData.rows).join("g").attr("transform", (M, D) => `translate(0,${A.scales.y(D)})`).call(k).on("click", this._rowClick.bind(this)).on("pointerenter", (M, D) => {
        this._bubbleRects.attr("opacity", (R) => R.name === D.name ? 0.8 : 0.5), this._labelRects.attr("opacity", (R) => R.name === D.name ? 0.8 : 0.5);
      }).on("pointerleave", (M, D) => {
        this._bubbleRects.attr("opacity", 0.5), this._labelRects.attr("opacity", 0.5);
      });
    }
    _rowClick(x, k) {
      this._rowFocused !== k ? (this._bubbleRects.attr("stroke-width", (A) => A.name === k.name ? 2 : 0), this._labelRects.attr("stroke-width", (A) => A.name === k.name ? 2 : 0), this._rowFocused = k, a("message", {
        selection_type: "row",
        row: "" + k.name,
        col: null,
        sortOrder: k.order
      }), this.columns._focused != null && (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this.columns._focused = null)) : (this._bubbleRects.attr("stroke-width", 0), this._labelRects.attr("stroke-width", 0), this._rowFocused = null, a("message", {
        selection_type: "row",
        row: null,
        col: null,
        sortOrder: k.order
      }));
    }
    _renderRect(x, k, A) {
      const M = this.chart;
      return x.append("rect").attr("width", A).attr("height", M.measures.bubbleDiameter).attr("x", k).attr("rx", 10).attr("opacity", 0.5).attr("fill", this.colors.row).attr("stroke", An.color(this.colors.row).darker(1)).attr("stroke-width", 0);
    }
    _click(x, k) {
      this._sort(k), this._labelRects.attr("fill", (A) => A.order === m.ascending ? "white" : this.colors.row), this._bubbleRects.attr("fill", (A) => {
        if (A.order === m.none)
          return this.colors.row;
        {
          const M = this.uid(A.order === m.ascending ? "ascending" : "descending");
          return A === k ? this.url(M) : this.colors.row;
        }
      });
    }
    _sort(x) {
      if (this.sortOnAxisClick) {
        let W = function(ne) {
          ne.transition().duration((Z, re) => re * D).attr("transform", (Z) => {
            let re = 0;
            for (let Ce = 0; Ce < M.length; Ce++)
              if (M[Ce].column === Z.name) {
                Z.position = re = Ce, k.push(Ce);
                break;
              }
            return `translate(${R(re) + U},0)`;
          });
        };
        const k = [], A = this.chart.chartData, M = x.cells.map((ne) => ne);
        A.resetRows(x), x.order === m.none ? x.order = m.descending : x.order === m.descending ? x.order = m.ascending : x.order = m.none, x.order === m.ascending ? M.sort((ne, Z) => ne.value - Z.value) : x.order === m.descending && M.sort((ne, Z) => Z.value - ne.value);
        const D = this.duration / A.columns.length, R = this.chart.scales.x, U = this.chart.measures.bubbleRadius;
        W(this.columns.axis), W(this.columns.labels), this.relocateAnnotation(), this._bubbles.transition().duration((ne, Z) => Z * D).attr("transform", (ne, Z) => `translate(${R(k[Z]) + U},0)`);
      }
    }
  }
  class T {
    static get matrix() {
      return 0;
    }
    static get byRow() {
      return 1;
    }
    static get top() {
      return 2;
    }
    static get bottom() {
      return 3;
    }
  }
  class L {
    constructor() {
      this.x = null, this.y = null, this.r = null, this._maxX = 0, this._maxY = 0;
    }
    get maxX() {
      return this._maxX;
    }
    get maxY() {
      return this._maxY;
    }
    initialize(x) {
      const k = x.measures, A = x.chartData;
      this.x = (M) => M * k.bubbleDiameter, this.y = (M) => M * (k.bubbleDiameter + k.padding), this.r = An.scaleLinear().domain([A.min, A.max]).range([k.bubbleRadius * 0.2, k.bubbleRadius - 1.5]), this._maxX = this.x(A.columns.length), this._maxY = this.y(A.rows.length);
    }
  }
  class O {
    constructor(x, k) {
      this._chart = x, this._caption = k, this._g = null, this._label = null, this._below = null, this._above = null, this._width = 0, this._min = 0, this._max = 0, this._defaultValue = 0;
    }
    get level() {
      return this._chart.chartData.level;
    }
    set level(x) {
      this._chart.chartData.level = x;
    }
    get defaultLevel() {
      return this._chart.chartData.defaultLevel;
    }
    get isPercent() {
      return this._chart.chartData.numberIsPercentage;
    }
    get height() {
      return this._chart.measures.sliderHeight;
    }
    get rowRenderer() {
      return this._chart.renderer.rows;
    }
    render() {
      const x = this._chart.measures;
      this._initialize(), this._g = An.select(this._chart.partitions.slider).append("svg").attr("width", x.width).attr("height", this.height).append("g"), this._renderLabel(), this._renderColorRects(), this._renderSlider();
    }
    _initialize() {
      const x = this._chart.measures, k = this._chart.chartData;
      this._defaultValue = this.isPercent ? this.defaultLevel * 100 : this._roundUp(this.defaultLevel, 1), this._width = (x.width - x.rowWidth) / 2;
      let A = k.min, M = k.max;
      this.isPercent && (A = A * 100, M = M * 100 + 1, A = A > 0 ? A - 1 : A), this._min = A, this._max = M;
    }
    _renderLabel() {
      this._label = this._g.append("text").attr("x", this._width + 12).attr("y", 10).attr("dy", "0.5em").attr("fill", "black"), this._updateLabel(this._defaultValue);
    }
    _renderColorRects() {
      const { a: x, b: k } = this._getSafeBound(), A = (this._defaultValue - x) / (k - x) * this._width;
      this._below = this._g.append("rect").attr("y", 2).attr("rx", 5).attr("width", A).attr("height", this.height - 2).attr("opacity", 0.5).attr("fill", this._chart.renderer.colors.below), this._above = this._g.append("rect").attr("x", A).attr("y", 2).attr("rx", 5).attr("width", this._width - A).attr("height", this.height - 2).attr("opacity", 0.5).attr("fill", this._chart.renderer.colors.above);
    }
    _renderSlider() {
      const { a: x, b: k } = this._getSafeBound(), A = this._g.append("foreignObject").attr("width", this._width + 2).attr("height", this.height);
      this._slider = A.append("xhtml:input").attr("type", "range").attr("min", x).attr("max", k).style("width", `${this._width - 5}px`).style("height", `${this._height}px`).on("click", (M) => M.stopPropagation()).on("dblclick", (M) => {
        this._slider.node().value = this._defaultValue, this._change(), M.stopPropagation();
      }).on("input", () => this._change()), this._slider.node().value = this._defaultValue;
    }
    _change() {
      const { a: x, b: k } = this._getSafeBound(), A = +this._slider.node().value, M = A < x ? x : A > k ? k : A, D = (M - x) / (k - x) * this._width;
      this._below.attr("width", D), this._above.attr("x", D).attr("width", this._width - D), this._updateLabel(A), this.level = this.isPercent ? A / 100 : A;
      const R = this._chart.renderer.colors;
      this.rowRenderer.bubbles.selectAll("circle").transition().duration(1e3).ease(An.easeBounce).attr("fill", (U) => U.value >= this.level ? R.above : R.below).attr("opacity", 0.5), this.rowRenderer.relocateAnnotation(!1);
    }
    _getSafeBound() {
      const x = this.isPercent ? this._min : this._roundDown(this._min, 2), k = this.isPercent ? this._max : this._roundUp(this._max, 2);
      return { a: x, b: k };
    }
    _roundUp(x, k) {
      const A = x < 0 ? -1 : 1, M = Math.ceil(Math.abs(x)).toString(), D = Math.pow(10, M.length - k);
      return Math.ceil(+M / D) * D * A;
    }
    _roundDown(x, k) {
      const A = x < 0 ? -1 : 1, M = x < 0 ? 1 : 0, D = Math.floor(Math.abs(x)).toString(), R = Math.pow(10, D.length - k);
      return (Math.floor(+D / R) + M) * R * A;
    }
    _updateLabel(x) {
      const k = x.toFixed(0), A = this.isPercent ? `${k}%` : An.format(",.2r")(k);
      this._label.text(`${this._caption} = ${A}`);
    }
  }
  return e.$$set = (F) => {
    "data" in F && n(0, i = F.data), "div" in F && n(1, r = F.div), "numConcepts" in F && n(2, s = F.numConcepts);
  }, [i, r, s];
}
class jP extends Ms {
  constructor(t) {
    super(), $s(this, t, BP, zP, Cs, { data: 0, div: 1, numConcepts: 2 });
  }
}
function _S(e, t, n) {
  const i = e.slice();
  return i[56] = t[n], i[58] = n, i;
}
const UP = (e) => ({ row: e[0] & /*c_rows*/
8 }), ES = (e) => ({ row: (
  /*row*/
  e[56]
), n: (
  /*n*/
  e[58]
) });
function SS(e, t, n) {
  const i = e.slice();
  return i[59] = t[n], i[61] = n, i;
}
const qP = (e) => ({ row: e[0] & /*c_rows*/
8 }), kS = (e) => ({ row: (
  /*row*/
  e[56]
), n: (
  /*n*/
  e[58]
) });
function AS(e, t, n) {
  const i = e.slice();
  return i[59] = t[n], i;
}
const WP = (e) => ({
  sortOrder: e[0] & /*sortOrder*/
  2,
  sortBy: e[0] & /*sortBy*/
  1
}), CS = (e) => ({
  sortOrder: (
    /*sortOrder*/
    e[1]
  ),
  sortBy: (
    /*sortBy*/
    e[0]
  )
});
function $S(e, t, n) {
  const i = e.slice();
  return i[59] = t[n], i[64] = t, i[65] = n, i;
}
function MS(e, t, n) {
  const i = e.slice();
  return i[66] = t[n], i;
}
function HP(e) {
  let t, n, i = Rn(
    /*columns*/
    e[4]
  ), r = [];
  for (let o = 0; o < i.length; o += 1)
    r[o] = TS($S(e, i, o));
  let s = (
    /*showExpandIcon*/
    e[11] && OS()
  );
  return {
    c() {
      t = ge("tr");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      n = vt(), s && s.c(), de(t, "class", "svelte-dsaf7t");
    },
    m(o, a) {
      Se(o, t, a);
      for (let l = 0; l < r.length; l += 1)
        r[l] && r[l].m(t, null);
      xe(t, n), s && s.m(t, null);
    },
    p(o, a) {
      if (a[0] & /*asStringArray, columns, classNameInput, filterSelections, classNameSelect, filterValues*/
      75595796) {
        i = Rn(
          /*columns*/
          o[4]
        );
        let l;
        for (l = 0; l < i.length; l += 1) {
          const u = $S(o, i, l);
          r[l] ? r[l].p(u, a) : (r[l] = TS(u), r[l].c(), r[l].m(t, n));
        }
        for (; l < r.length; l += 1)
          r[l].d(1);
        r.length = i.length;
      }
      /*showExpandIcon*/
      o[11] ? s || (s = OS(), s.c(), s.m(t, null)) : s && (s.d(1), s = null);
    },
    d(o) {
      o && _e(t), Ja(r, o), s && s.d();
    }
  };
}
function GP(e) {
  let t, n, i = (
    /*col*/
    (e[59].filterPlaceholder || "") + ""
  ), r, s, o, a, l = Rn(
    /*filterValues*/
    e[23][
      /*col*/
      e[59].key
    ]
  ), u = [];
  for (let f = 0; f < l.length; f += 1)
    u[f] = FS(MS(e, l, f));
  function c() {
    e[44].call(
      t,
      /*col*/
      e[59]
    );
  }
  return {
    c() {
      t = ge("select"), n = ge("option"), r = Qn(i);
      for (let f = 0; f < u.length; f += 1)
        u[f].c();
      n.__value = void 0, yf(n, n.__value), de(t, "class", s = st(
        /*asStringArray*/
        e[26](
          /*classNameSelect*/
          e[15]
        )
      ) + " svelte-dsaf7t"), /*filterSelections*/
      e[2][
        /*col*/
        e[59].key
      ] === void 0 && tg(c);
    },
    m(f, d) {
      Se(f, t, d), xe(t, n), xe(n, r);
      for (let h = 0; h < u.length; h += 1)
        u[h] && u[h].m(t, null);
      yS(
        t,
        /*filterSelections*/
        e[2][
          /*col*/
          e[59].key
        ],
        !0
      ), o || (a = Cr(t, "change", c), o = !0);
    },
    p(f, d) {
      if (e = f, d[0] & /*columns*/
      16 && i !== (i = /*col*/
      (e[59].filterPlaceholder || "") + "") && xs(r, i), d[0] & /*filterValues, columns*/
      8388624) {
        l = Rn(
          /*filterValues*/
          e[23][
            /*col*/
            e[59].key
          ]
        );
        let h;
        for (h = 0; h < l.length; h += 1) {
          const g = MS(e, l, h);
          u[h] ? u[h].p(g, d) : (u[h] = FS(g), u[h].c(), u[h].m(t, null));
        }
        for (; h < u.length; h += 1)
          u[h].d(1);
        u.length = l.length;
      }
      d[0] & /*classNameSelect*/
      32768 && s !== (s = st(
        /*asStringArray*/
        e[26](
          /*classNameSelect*/
          e[15]
        )
      ) + " svelte-dsaf7t") && de(t, "class", s), d[0] & /*filterSelections, columns, filterValues*/
      8388628 && yS(
        t,
        /*filterSelections*/
        e[2][
          /*col*/
          e[59].key
        ]
      );
    },
    d(f) {
      f && _e(t), Ja(u, f), o = !1, a();
    }
  };
}
function VP(e) {
  let t, n, i, r, s;
  function o() {
    e[43].call(
      t,
      /*col*/
      e[59]
    );
  }
  return {
    c() {
      t = ge("input"), de(t, "class", n = st(
        /*asStringArray*/
        e[26](
          /*classNameInput*/
          e[16]
        )
      ) + " svelte-dsaf7t"), de(t, "placeholder", i = /*col*/
      e[59].filterPlaceholder);
    },
    m(a, l) {
      Se(a, t, l), yf(
        t,
        /*filterSelections*/
        e[2][
          /*col*/
          e[59].key
        ]
      ), r || (s = Cr(t, "input", o), r = !0);
    },
    p(a, l) {
      e = a, l[0] & /*classNameInput*/
      65536 && n !== (n = st(
        /*asStringArray*/
        e[26](
          /*classNameInput*/
          e[16]
        )
      ) + " svelte-dsaf7t") && de(t, "class", n), l[0] & /*columns, filterValues*/
      8388624 && i !== (i = /*col*/
      e[59].filterPlaceholder) && de(t, "placeholder", i), l[0] & /*filterSelections, columns, filterValues*/
      8388628 && t.value !== /*filterSelections*/
      e[2][
        /*col*/
        e[59].key
      ] && yf(
        t,
        /*filterSelections*/
        e[2][
          /*col*/
          e[59].key
        ]
      );
    },
    d(a) {
      a && _e(t), r = !1, s();
    }
  };
}
function FS(e) {
  let t, n = (
    /*option*/
    e[66].name + ""
  ), i, r;
  return {
    c() {
      t = ge("option"), i = Qn(n), t.__value = r = /*option*/
      e[66].value, yf(t, t.__value);
    },
    m(s, o) {
      Se(s, t, o), xe(t, i);
    },
    p(s, o) {
      o[0] & /*filterValues, columns*/
      8388624 && n !== (n = /*option*/
      s[66].name + "") && xs(i, n), o[0] & /*filterValues, columns*/
      8388624 && r !== (r = /*option*/
      s[66].value) && (t.__value = r, yf(t, t.__value));
    },
    d(s) {
      s && _e(t);
    }
  };
}
function TS(e) {
  let t, n;
  function i(o, a) {
    if (!/*col*/
    o[59].hideFilterHeader && /*col*/
    o[59].searchValue !== void 0)
      return VP;
    if (!/*col*/
    o[59].hideFilterHeader && /*filterValues*/
    o[23][
      /*col*/
      o[59].key
    ] !== void 0)
      return GP;
  }
  let r = i(e), s = r && r(e);
  return {
    c() {
      t = ge("th"), s && s.c(), de(t, "class", n = st(
        /*asStringArray*/
        e[26]([
          /*col*/
          e[59].headerFilterClass
        ])
      ) + " svelte-dsaf7t");
    },
    m(o, a) {
      Se(o, t, a), s && s.m(t, null);
    },
    p(o, a) {
      r === (r = i(o)) && s ? s.p(o, a) : (s && s.d(1), s = r && r(o), s && (s.c(), s.m(t, null))), a[0] & /*columns, filterValues*/
      8388624 && n !== (n = st(
        /*asStringArray*/
        o[26]([
          /*col*/
          o[59].headerFilterClass
        ])
      ) + " svelte-dsaf7t") && de(t, "class", n);
    },
    d(o) {
      o && _e(t), s && s.d();
    }
  };
}
function OS(e) {
  let t;
  return {
    c() {
      t = ge("th");
    },
    m(n, i) {
      Se(n, t, i);
    },
    d(n) {
      n && _e(t);
    }
  };
}
function YP(e) {
  let t, n;
  return {
    c() {
      t = new Ip(!1), n = Pp(), t.a = n;
    },
    m(i, r) {
      t.m(
        /*iconSortable*/
        e[8],
        i,
        r
      ), Se(i, n, r);
    },
    p(i, r) {
      r[0] & /*iconSortable*/
      256 && t.p(
        /*iconSortable*/
        i[8]
      );
    },
    d(i) {
      i && (_e(n), t.d());
    }
  };
}
function XP(e) {
  let t, n = (
    /*sortOrder*/
    (e[1] === 1 ? (
      /*iconAsc*/
      e[6]
    ) : (
      /*iconDesc*/
      e[7]
    )) + ""
  ), i;
  return {
    c() {
      t = new Ip(!1), i = Pp(), t.a = i;
    },
    m(r, s) {
      t.m(n, r, s), Se(r, i, s);
    },
    p(r, s) {
      s[0] & /*sortOrder, iconAsc, iconDesc*/
      194 && n !== (n = /*sortOrder*/
      (r[1] === 1 ? (
        /*iconAsc*/
        r[6]
      ) : (
        /*iconDesc*/
        r[7]
      )) + "") && t.p(n);
    },
    d(r) {
      r && (_e(i), t.d());
    }
  };
}
function NS(e) {
  let t, n = (
    /*col*/
    e[59].title + ""
  ), i, r, s, o, a;
  function l(h, g) {
    if (
      /*sortBy*/
      h[0] === /*col*/
      h[59].key
    )
      return XP;
    if (
      /*col*/
      h[59].sortable
    )
      return YP;
  }
  let u = l(e), c = u && u(e);
  function f(...h) {
    return (
      /*click_handler*/
      e[45](
        /*col*/
        e[59],
        ...h
      )
    );
  }
  function d(...h) {
    return (
      /*keypress_handler*/
      e[46](
        /*col*/
        e[59],
        ...h
      )
    );
  }
  return {
    c() {
      t = ge("th"), i = Qn(n), r = vt(), c && c.c(), de(t, "class", s = st(
        /*asStringArray*/
        e[26]([
          /*col*/
          e[59].sortable ? "isSortable" : "",
          /*col*/
          e[59].headerClass
        ])
      ) + " svelte-dsaf7t"), de(t, "tabindex", "0");
    },
    m(h, g) {
      Se(h, t, g), xe(t, i), xe(t, r), c && c.m(t, null), o || (a = [
        Cr(t, "click", f),
        Cr(t, "keypress", d)
      ], o = !0);
    },
    p(h, g) {
      e = h, g[0] & /*columns*/
      16 && n !== (n = /*col*/
      e[59].title + "") && xs(i, n), u === (u = l(e)) && c ? c.p(e, g) : (c && c.d(1), c = u && u(e), c && (c.c(), c.m(t, null))), g[0] & /*columns, filterValues*/
      8388624 && s !== (s = st(
        /*asStringArray*/
        e[26]([
          /*col*/
          e[59].sortable ? "isSortable" : "",
          /*col*/
          e[59].headerClass
        ])
      ) + " svelte-dsaf7t") && de(t, "class", s);
    },
    d(h) {
      h && _e(t), c && c.d(), o = !1, As(a);
    }
  };
}
function DS(e) {
  let t;
  return {
    c() {
      t = ge("th");
    },
    m(n, i) {
      Se(n, t, i);
    },
    d(n) {
      n && _e(t);
    }
  };
}
function KP(e) {
  let t, n, i = Rn(
    /*columns*/
    e[4]
  ), r = [];
  for (let o = 0; o < i.length; o += 1)
    r[o] = NS(AS(e, i, o));
  let s = (
    /*showExpandIcon*/
    e[11] && DS()
  );
  return {
    c() {
      t = ge("tr");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      n = vt(), s && s.c();
    },
    m(o, a) {
      Se(o, t, a);
      for (let l = 0; l < r.length; l += 1)
        r[l] && r[l].m(t, null);
      xe(t, n), s && s.m(t, null);
    },
    p(o, a) {
      if (a[0] & /*asStringArray, columns, handleClickCol, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
      201327059) {
        i = Rn(
          /*columns*/
          o[4]
        );
        let l;
        for (l = 0; l < i.length; l += 1) {
          const u = AS(o, i, l);
          r[l] ? r[l].p(u, a) : (r[l] = NS(u), r[l].c(), r[l].m(t, n));
        }
        for (; l < r.length; l += 1)
          r[l].d(1);
        r.length = i.length;
      }
      /*showExpandIcon*/
      o[11] ? s || (s = DS(), s.c(), s.m(t, null)) : s && (s.d(1), s = null);
    },
    d(o) {
      o && _e(t), Ja(r, o), s && s.d();
    }
  };
}
function JP(e) {
  let t = (
    /*col*/
    (e[59].renderValue ? (
      /*col*/
      e[59].renderValue(
        /*row*/
        e[56],
        /*n*/
        e[58],
        /*colIndex*/
        e[61]
      )
    ) : (
      /*col*/
      e[59].value(
        /*row*/
        e[56],
        /*n*/
        e[58],
        /*colIndex*/
        e[61]
      )
    )) + ""
  ), n;
  return {
    c() {
      n = Qn(t);
    },
    m(i, r) {
      Se(i, n, r);
    },
    p(i, r) {
      r[0] & /*columns, c_rows*/
      24 && t !== (t = /*col*/
      (i[59].renderValue ? (
        /*col*/
        i[59].renderValue(
          /*row*/
          i[56],
          /*n*/
          i[58],
          /*colIndex*/
          i[61]
        )
      ) : (
        /*col*/
        i[59].value(
          /*row*/
          i[56],
          /*n*/
          i[58],
          /*colIndex*/
          i[61]
        )
      )) + "") && xs(n, t);
    },
    i: Jn,
    o: Jn,
    d(i) {
      i && _e(n);
    }
  };
}
function QP(e) {
  let t, n = (
    /*col*/
    (e[59].renderValue ? (
      /*col*/
      e[59].renderValue(
        /*row*/
        e[56],
        /*n*/
        e[58],
        /*colIndex*/
        e[61]
      )
    ) : (
      /*col*/
      e[59].value(
        /*row*/
        e[56],
        /*n*/
        e[58],
        /*colIndex*/
        e[61]
      )
    )) + ""
  ), i;
  return {
    c() {
      t = new Ip(!1), i = Pp(), t.a = i;
    },
    m(r, s) {
      t.m(n, r, s), Se(r, i, s);
    },
    p(r, s) {
      s[0] & /*columns, c_rows*/
      24 && n !== (n = /*col*/
      (r[59].renderValue ? (
        /*col*/
        r[59].renderValue(
          /*row*/
          r[56],
          /*n*/
          r[58],
          /*colIndex*/
          r[61]
        )
      ) : (
        /*col*/
        r[59].value(
          /*row*/
          r[56],
          /*n*/
          r[58],
          /*colIndex*/
          r[61]
        )
      )) + "") && t.p(n);
    },
    i: Jn,
    o: Jn,
    d(r) {
      r && (_e(i), t.d());
    }
  };
}
function ZP(e) {
  let t, n, i;
  const r = [
    /*col*/
    e[59].renderComponent.props || {},
    { row: (
      /*row*/
      e[56]
    ) },
    { col: (
      /*col*/
      e[59]
    ) }
  ];
  var s = (
    /*col*/
    e[59].renderComponent.component || /*col*/
    e[59].renderComponent
  );
  function o(a, l) {
    let u = {};
    if (l !== void 0 && l[0] & /*columns, c_rows*/
    24)
      u = xS(r, [
        l[0] & /*columns*/
        16 && wS(
          /*col*/
          a[59].renderComponent.props || {}
        ),
        l[0] & /*c_rows*/
        8 && { row: (
          /*row*/
          a[56]
        ) },
        l[0] & /*columns*/
        16 && { col: (
          /*col*/
          a[59]
        ) }
      ]);
    else
      for (let c = 0; c < r.length; c += 1)
        u = $3(u, r[c]);
    return { props: u };
  }
  return s && (t = bS(s, o(e))), {
    c() {
      t && wi(t.$$.fragment), n = Pp();
    },
    m(a, l) {
      t && ti(t, a, l), Se(a, n, l), i = !0;
    },
    p(a, l) {
      if (l[0] & /*columns*/
      16 && s !== (s = /*col*/
      a[59].renderComponent.component || /*col*/
      a[59].renderComponent)) {
        if (t) {
          vi();
          const u = t;
          $e(u.$$.fragment, 1, 0, () => {
            ni(u, 1);
          }), xi();
        }
        s ? (t = bS(s, o(a, l)), wi(t.$$.fragment), pe(t.$$.fragment, 1), ti(t, n.parentNode, n)) : t = null;
      } else if (s) {
        const u = l[0] & /*columns, c_rows*/
        24 ? xS(r, [
          l[0] & /*columns*/
          16 && wS(
            /*col*/
            a[59].renderComponent.props || {}
          ),
          l[0] & /*c_rows*/
          8 && { row: (
            /*row*/
            a[56]
          ) },
          l[0] & /*columns*/
          16 && { col: (
            /*col*/
            a[59]
          ) }
        ]) : {};
        t.$set(u);
      }
    },
    i(a) {
      i || (t && pe(t.$$.fragment, a), i = !0);
    },
    o(a) {
      t && $e(t.$$.fragment, a), i = !1;
    },
    d(a) {
      a && _e(n), t && ni(t, a);
    }
  };
}
function RS(e) {
  let t, n, i, r, s, o, a;
  const l = [ZP, QP, JP], u = [];
  function c(h, g) {
    return (
      /*col*/
      h[59].renderComponent ? 0 : (
        /*col*/
        h[59].parseHTML ? 1 : 2
      )
    );
  }
  n = c(e), i = u[n] = l[n](e);
  function f(...h) {
    return (
      /*click_handler_1*/
      e[47](
        /*row*/
        e[56],
        /*col*/
        e[59],
        ...h
      )
    );
  }
  function d(...h) {
    return (
      /*keypress_handler_1*/
      e[48](
        /*row*/
        e[56],
        /*col*/
        e[59],
        ...h
      )
    );
  }
  return {
    c() {
      t = ge("td"), i.c(), de(t, "class", r = st(
        /*asStringArray*/
        e[26]([
          typeof /*col*/
          e[59].class == "string" ? (
            /*col*/
            e[59].class
          ) : null,
          typeof /*col*/
          e[59].class == "function" ? (
            /*col*/
            e[59].class(
              /*row*/
              e[56],
              /*n*/
              e[58],
              /*colIndex*/
              e[61]
            )
          ) : null,
          /*classNameCell*/
          e[18]
        ])
      ) + " svelte-dsaf7t");
    },
    m(h, g) {
      Se(h, t, g), u[n].m(t, null), s = !0, o || (a = [
        Cr(t, "click", f),
        Cr(t, "keypress", d)
      ], o = !0);
    },
    p(h, g) {
      e = h;
      let p = n;
      n = c(e), n === p ? u[n].p(e, g) : (vi(), $e(u[p], 1, 1, () => {
        u[p] = null;
      }), xi(), i = u[n], i ? i.p(e, g) : (i = u[n] = l[n](e), i.c()), pe(i, 1), i.m(t, null)), (!s || g[0] & /*columns, c_rows, classNameCell, filterValues*/
      8650776 && r !== (r = st(
        /*asStringArray*/
        e[26]([
          typeof /*col*/
          e[59].class == "string" ? (
            /*col*/
            e[59].class
          ) : null,
          typeof /*col*/
          e[59].class == "function" ? (
            /*col*/
            e[59].class(
              /*row*/
              e[56],
              /*n*/
              e[58],
              /*colIndex*/
              e[61]
            )
          ) : null,
          /*classNameCell*/
          e[18]
        ])
      ) + " svelte-dsaf7t")) && de(t, "class", r);
    },
    i(h) {
      s || (pe(i), s = !0);
    },
    o(h) {
      $e(i), s = !1;
    },
    d(h) {
      h && _e(t), u[n].d(), o = !1, As(a);
    }
  };
}
function LS(e) {
  let t, n, i = (
    /*row*/
    (e[56].$expanded ? (
      /*iconExpand*/
      e[9]
    ) : (
      /*iconExpanded*/
      e[10]
    )) + ""
  ), r, s, o;
  function a(...u) {
    return (
      /*click_handler_2*/
      e[49](
        /*row*/
        e[56],
        ...u
      )
    );
  }
  function l(...u) {
    return (
      /*keypress_handler_2*/
      e[50](
        /*row*/
        e[56],
        ...u
      )
    );
  }
  return {
    c() {
      t = ge("td"), n = ge("span"), de(n, "class", "isClickable svelte-dsaf7t"), de(n, "tabindex", "0"), de(n, "role", "button"), de(t, "class", r = st(
        /*asStringArray*/
        e[26](
          /*classNameCellExpand*/
          e[22]
        )
      ) + " svelte-dsaf7t");
    },
    m(u, c) {
      Se(u, t, c), xe(t, n), n.innerHTML = i, s || (o = [
        Cr(n, "click", a),
        Cr(n, "keypress", l)
      ], s = !0);
    },
    p(u, c) {
      e = u, c[0] & /*c_rows, iconExpand, iconExpanded*/
      1544 && i !== (i = /*row*/
      (e[56].$expanded ? (
        /*iconExpand*/
        e[9]
      ) : (
        /*iconExpanded*/
        e[10]
      )) + "") && (n.innerHTML = i), c[0] & /*classNameCellExpand*/
      4194304 && r !== (r = st(
        /*asStringArray*/
        e[26](
          /*classNameCellExpand*/
          e[22]
        )
      ) + " svelte-dsaf7t") && de(t, "class", r);
    },
    d(u) {
      u && _e(t), s = !1, As(o);
    }
  };
}
function PS(e) {
  let t, n, i, r;
  const s = (
    /*#slots*/
    e[42].expanded
  ), o = Rv(
    s,
    e,
    /*$$scope*/
    e[41],
    ES
  );
  return {
    c() {
      t = ge("tr"), n = ge("td"), o && o.c(), de(
        n,
        "colspan",
        /*colspan*/
        e[24]
      ), de(t, "class", i = st(
        /*asStringArray*/
        e[26](
          /*classNameExpandedContent*/
          e[21]
        )
      ) + " svelte-dsaf7t");
    },
    m(a, l) {
      Se(a, t, l), xe(t, n), o && o.m(n, null), r = !0;
    },
    p(a, l) {
      o && o.p && (!r || l[0] & /*c_rows*/
      8 | l[1] & /*$$scope*/
      1024) && Pv(
        o,
        s,
        a,
        /*$$scope*/
        a[41],
        r ? Lv(
          s,
          /*$$scope*/
          a[41],
          l,
          UP
        ) : Iv(
          /*$$scope*/
          a[41]
        ),
        ES
      ), (!r || l[0] & /*colspan*/
      16777216) && de(
        n,
        "colspan",
        /*colspan*/
        a[24]
      ), (!r || l[0] & /*classNameExpandedContent*/
      2097152 && i !== (i = st(
        /*asStringArray*/
        a[26](
          /*classNameExpandedContent*/
          a[21]
        )
      ) + " svelte-dsaf7t")) && de(t, "class", i);
    },
    i(a) {
      r || (pe(o, a), r = !0);
    },
    o(a) {
      $e(o, a), r = !1;
    },
    d(a) {
      a && _e(t), o && o.d(a);
    }
  };
}
function eI(e) {
  let t, n, i, r, s, o, a, l, u, c = Rn(
    /*columns*/
    e[4]
  ), f = [];
  for (let y = 0; y < c.length; y += 1)
    f[y] = RS(SS(e, c, y));
  const d = (y) => $e(f[y], 1, 1, () => {
    f[y] = null;
  });
  let h = (
    /*showExpandIcon*/
    e[11] && LS(e)
  );
  function g(...y) {
    return (
      /*click_handler_3*/
      e[51](
        /*row*/
        e[56],
        ...y
      )
    );
  }
  function p(...y) {
    return (
      /*keypress_handler_3*/
      e[52](
        /*row*/
        e[56],
        ...y
      )
    );
  }
  let m = (
    /*row*/
    e[56].$expanded && PS(e)
  );
  return {
    c() {
      t = ge("tr");
      for (let y = 0; y < f.length; y += 1)
        f[y].c();
      n = vt(), h && h.c(), s = vt(), m && m.c(), o = vt(), de(t, "class", i = st(
        /*asStringArray*/
        e[26]([
          typeof /*classNameRow*/
          e[17] == "string" ? (
            /*classNameRow*/
            e[17]
          ) : null,
          typeof /*classNameRow*/
          e[17] == "function" ? (
            /*classNameRow*/
            e[17](
              /*row*/
              e[56],
              /*n*/
              e[58]
            )
          ) : null,
          /*row*/
          e[56].$expanded && /*classNameRowExpanded*/
          e[20],
          /*row*/
          e[56].$selected && /*classNameRowSelected*/
          e[19]
        ])
      ) + " svelte-dsaf7t"), de(t, "tabindex", r = /*selectOnClick*/
      e[5] ? "0" : null);
    },
    m(y, b) {
      Se(y, t, b);
      for (let v = 0; v < f.length; v += 1)
        f[v] && f[v].m(t, null);
      xe(t, n), h && h.m(t, null), Se(y, s, b), m && m.m(y, b), Se(y, o, b), a = !0, l || (u = [
        Cr(t, "click", g),
        Cr(t, "keypress", p)
      ], l = !0);
    },
    p(y, b) {
      if (e = y, b[0] & /*asStringArray, columns, c_rows, classNameCell, handleClickCell*/
      1141112856) {
        c = Rn(
          /*columns*/
          e[4]
        );
        let v;
        for (v = 0; v < c.length; v += 1) {
          const w = SS(e, c, v);
          f[v] ? (f[v].p(w, b), pe(f[v], 1)) : (f[v] = RS(w), f[v].c(), pe(f[v], 1), f[v].m(t, n));
        }
        for (vi(), v = c.length; v < f.length; v += 1)
          d(v);
        xi();
      }
      /*showExpandIcon*/
      e[11] ? h ? h.p(e, b) : (h = LS(e), h.c(), h.m(t, null)) : h && (h.d(1), h = null), (!a || b[0] & /*classNameRow, c_rows, classNameRowExpanded, classNameRowSelected*/
      1703944 && i !== (i = st(
        /*asStringArray*/
        e[26]([
          typeof /*classNameRow*/
          e[17] == "string" ? (
            /*classNameRow*/
            e[17]
          ) : null,
          typeof /*classNameRow*/
          e[17] == "function" ? (
            /*classNameRow*/
            e[17](
              /*row*/
              e[56],
              /*n*/
              e[58]
            )
          ) : null,
          /*row*/
          e[56].$expanded && /*classNameRowExpanded*/
          e[20],
          /*row*/
          e[56].$selected && /*classNameRowSelected*/
          e[19]
        ])
      ) + " svelte-dsaf7t")) && de(t, "class", i), (!a || b[0] & /*selectOnClick*/
      32 && r !== (r = /*selectOnClick*/
      e[5] ? "0" : null)) && de(t, "tabindex", r), /*row*/
      e[56].$expanded ? m ? (m.p(e, b), b[0] & /*c_rows*/
      8 && pe(m, 1)) : (m = PS(e), m.c(), pe(m, 1), m.m(o.parentNode, o)) : m && (vi(), $e(m, 1, 1, () => {
        m = null;
      }), xi());
    },
    i(y) {
      if (!a) {
        for (let b = 0; b < c.length; b += 1)
          pe(f[b]);
        pe(m), a = !0;
      }
    },
    o(y) {
      f = f.filter(Boolean);
      for (let b = 0; b < f.length; b += 1)
        $e(f[b]);
      $e(m), a = !1;
    },
    d(y) {
      y && (_e(t), _e(s), _e(o)), Ja(f, y), h && h.d(), m && m.d(y), l = !1, As(u);
    }
  };
}
function IS(e) {
  let t;
  const n = (
    /*#slots*/
    e[42].row
  ), i = Rv(
    n,
    e,
    /*$$scope*/
    e[41],
    kS
  ), r = i || eI(e);
  return {
    c() {
      r && r.c();
    },
    m(s, o) {
      r && r.m(s, o), t = !0;
    },
    p(s, o) {
      i ? i.p && (!t || o[0] & /*c_rows*/
      8 | o[1] & /*$$scope*/
      1024) && Pv(
        i,
        n,
        s,
        /*$$scope*/
        s[41],
        t ? Lv(
          n,
          /*$$scope*/
          s[41],
          o,
          qP
        ) : Iv(
          /*$$scope*/
          s[41]
        ),
        kS
      ) : r && r.p && (!t || o[0] & /*classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, classNameCellExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell*/
      25038392 | o[1] & /*$$scope*/
      1024) && r.p(s, t ? o : [-1, -1, -1]);
    },
    i(s) {
      t || (pe(r, s), t = !0);
    },
    o(s) {
      $e(r, s), t = !1;
    },
    d(s) {
      r && r.d(s);
    }
  };
}
function tI(e) {
  let t, n, i, r, s, o, a, l, u, c = (
    /*showFilterHeader*/
    e[25] && HP(e)
  );
  const f = (
    /*#slots*/
    e[42].header
  ), d = Rv(
    f,
    e,
    /*$$scope*/
    e[41],
    CS
  ), h = d || KP(e);
  let g = Rn(
    /*c_rows*/
    e[3]
  ), p = [];
  for (let y = 0; y < g.length; y += 1)
    p[y] = IS(_S(e, g, y));
  const m = (y) => $e(p[y], 1, 1, () => {
    p[y] = null;
  });
  return {
    c() {
      t = ge("table"), n = ge("thead"), c && c.c(), i = vt(), h && h.c(), s = vt(), o = ge("tbody");
      for (let y = 0; y < p.length; y += 1)
        p[y].c();
      de(n, "class", r = st(
        /*asStringArray*/
        e[26](
          /*classNameThead*/
          e[13]
        )
      ) + " svelte-dsaf7t"), de(o, "class", a = st(
        /*asStringArray*/
        e[26](
          /*classNameTbody*/
          e[14]
        )
      ) + " svelte-dsaf7t"), de(t, "class", l = st(
        /*asStringArray*/
        e[26](
          /*classNameTable*/
          e[12]
        )
      ) + " svelte-dsaf7t");
    },
    m(y, b) {
      Se(y, t, b), xe(t, n), c && c.m(n, null), xe(n, i), h && h.m(n, null), xe(t, s), xe(t, o);
      for (let v = 0; v < p.length; v += 1)
        p[v] && p[v].m(o, null);
      u = !0;
    },
    p(y, b) {
      if (
        /*showFilterHeader*/
        y[25] && c.p(y, b), d ? d.p && (!u || b[0] & /*sortOrder, sortBy*/
        3 | b[1] & /*$$scope*/
        1024) && Pv(
          d,
          f,
          y,
          /*$$scope*/
          y[41],
          u ? Lv(
            f,
            /*$$scope*/
            y[41],
            b,
            WP
          ) : Iv(
            /*$$scope*/
            y[41]
          ),
          CS
        ) : h && h.p && (!u || b[0] & /*showExpandIcon, columns, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
        2515) && h.p(y, u ? b : [-1, -1, -1]), (!u || b[0] & /*classNameThead*/
        8192 && r !== (r = st(
          /*asStringArray*/
          y[26](
            /*classNameThead*/
            y[13]
          )
        ) + " svelte-dsaf7t")) && de(n, "class", r), b[0] & /*asStringArray, classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, handleClickRow, classNameCellExpand, handleClickExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell, handleClickCell*/
        1971195448 | b[1] & /*$$scope*/
        1024
      ) {
        g = Rn(
          /*c_rows*/
          y[3]
        );
        let v;
        for (v = 0; v < g.length; v += 1) {
          const w = _S(y, g, v);
          p[v] ? (p[v].p(w, b), pe(p[v], 1)) : (p[v] = IS(w), p[v].c(), pe(p[v], 1), p[v].m(o, null));
        }
        for (vi(), v = g.length; v < p.length; v += 1)
          m(v);
        xi();
      }
      (!u || b[0] & /*classNameTbody*/
      16384 && a !== (a = st(
        /*asStringArray*/
        y[26](
          /*classNameTbody*/
          y[14]
        )
      ) + " svelte-dsaf7t")) && de(o, "class", a), (!u || b[0] & /*classNameTable*/
      4096 && l !== (l = st(
        /*asStringArray*/
        y[26](
          /*classNameTable*/
          y[12]
        )
      ) + " svelte-dsaf7t")) && de(t, "class", l);
    },
    i(y) {
      if (!u) {
        pe(h, y);
        for (let b = 0; b < g.length; b += 1)
          pe(p[b]);
        u = !0;
      }
    },
    o(y) {
      $e(h, y), p = p.filter(Boolean);
      for (let b = 0; b < p.length; b += 1)
        $e(p[b]);
      u = !1;
    },
    d(y) {
      y && _e(t), c && c.d(), h && h.d(y), Ja(p, y);
    }
  };
}
function nI(e, t, n) {
  let i, { $$slots: r = {}, $$scope: s } = t, { columns: o } = t, { rows: a } = t, { c_rows: l = void 0 } = t, { sortOrders: u = [1, -1] } = t, { sortBy: c = "" } = t, { sortOrder: f = (u == null ? void 0 : u[0]) || 1 } = t, { filterSelections: d = {} } = t, { expanded: h = [] } = t, { selected: g = [] } = t, { expandRowKey: p = null } = t, { rowKey: m = p } = t, { expandSingle: y = !1 } = t, { selectSingle: b = !1 } = t, { selectOnClick: v = !1 } = t, { iconAsc: w = "" } = t, { iconDesc: _ = "" } = t, { iconSortable: S = "" } = t, { iconExpand: E = "" } = t, { iconExpanded: C = "" } = t, { showExpandIcon: $ = !1 } = t, { classNameTable: N = "" } = t, { classNameThead: T = "" } = t, { classNameTbody: L = "" } = t, { classNameSelect: O = "" } = t, { classNameInput: F = "" } = t, { classNameRow: x = null } = t, { classNameCell: k = "" } = t, { classNameRowSelected: A = null } = t, { classNameRowExpanded: M = null } = t, { classNameExpandedContent: D = "" } = t, { classNameCellExpand: R = "" } = t;
  const U = Bv();
  let W = () => "";
  if (!Array.isArray(h))
    throw "'expanded' needs to be an array";
  if (!Array.isArray(g))
    throw "'selection' needs to be an array";
  p !== null && console.warn("'expandRowKey' is deprecated in favour of 'rowKey'"), A && !m && console.error("'rowKey' is needed to use 'classNameRowSelected'");
  let ne = o.some((I) => !I.hideFilterHeader && (I.filterOptions !== void 0 || I.searchValue !== void 0)), Z = {}, re;
  const Ce = (I) => [].concat(I).filter((ie) => ie !== null && typeof ie == "string" && ie !== "").join(" "), Et = () => {
    n(23, Z = {}), o.forEach((I) => {
      typeof I.filterOptions == "function" ? n(23, Z[I.key] = I.filterOptions(a), Z) : Array.isArray(I.filterOptions) && n(23, Z[I.key] = I.filterOptions.map((ie) => ({ name: ie, value: ie })), Z);
    });
  }, ln = (I) => I === c ? u[(u.findIndex((ie) => ie === f) + 1) % u.length] : u[0], te = (I, ie) => {
    ie.sortable && (n(1, f = ln(ie.key)), n(0, c = f ? ie.key : void 0)), U("clickCol", { event: I, col: ie, key: ie.key });
  }, ye = (I, ie) => {
    v && (b ? g.includes(ie[m]) ? n(32, g = []) : n(32, g = [ie[m]]) : g.includes(ie[m]) ? n(32, g = g.filter((It) => It != ie[m])) : n(32, g = [...g, ie[m]].sort())), U("clickRow", { event: I, row: ie });
  }, ve = (I, ie) => {
    ie.$expanded = !ie.$expanded;
    const It = ie[m];
    y && ie.$expanded ? n(31, h = [It]) : y ? n(31, h = []) : ie.$expanded ? n(31, h = [...h, It]) : n(31, h = h.filter((gS) => gS != It)), U("clickExpand", { event: I, row: ie });
  }, H = (I, ie, It) => {
    U("clickCell", { event: I, row: ie, key: It });
  };
  function gt(I) {
    d[I.key] = this.value, n(2, d), n(23, Z), n(4, o);
  }
  function De(I) {
    d[I.key] = FP(this), n(2, d), n(23, Z), n(4, o);
  }
  const St = (I, ie) => te(ie, I), Pt = (I, ie) => ie.key === "Enter" && te(ie, I), Xr = (I, ie, It) => H(It, I, ie.key), Ud = (I, ie, It) => It.key === "Enter" && H(It, I, ie.key), wP = (I, ie) => ve(ie, I), _P = (I, ie) => ie.key === "Enter" && ve(ie, I), EP = (I, ie) => ye(ie, I), SP = (I, ie) => ie.key === "Enter" && ye(ie, I);
  return e.$$set = (I) => {
    "columns" in I && n(4, o = I.columns), "rows" in I && n(33, a = I.rows), "c_rows" in I && n(3, l = I.c_rows), "sortOrders" in I && n(34, u = I.sortOrders), "sortBy" in I && n(0, c = I.sortBy), "sortOrder" in I && n(1, f = I.sortOrder), "filterSelections" in I && n(2, d = I.filterSelections), "expanded" in I && n(31, h = I.expanded), "selected" in I && n(32, g = I.selected), "expandRowKey" in I && n(35, p = I.expandRowKey), "rowKey" in I && n(36, m = I.rowKey), "expandSingle" in I && n(37, y = I.expandSingle), "selectSingle" in I && n(38, b = I.selectSingle), "selectOnClick" in I && n(5, v = I.selectOnClick), "iconAsc" in I && n(6, w = I.iconAsc), "iconDesc" in I && n(7, _ = I.iconDesc), "iconSortable" in I && n(8, S = I.iconSortable), "iconExpand" in I && n(9, E = I.iconExpand), "iconExpanded" in I && n(10, C = I.iconExpanded), "showExpandIcon" in I && n(11, $ = I.showExpandIcon), "classNameTable" in I && n(12, N = I.classNameTable), "classNameThead" in I && n(13, T = I.classNameThead), "classNameTbody" in I && n(14, L = I.classNameTbody), "classNameSelect" in I && n(15, O = I.classNameSelect), "classNameInput" in I && n(16, F = I.classNameInput), "classNameRow" in I && n(17, x = I.classNameRow), "classNameCell" in I && n(18, k = I.classNameCell), "classNameRowSelected" in I && n(19, A = I.classNameRowSelected), "classNameRowExpanded" in I && n(20, M = I.classNameRowExpanded), "classNameExpandedContent" in I && n(21, D = I.classNameExpandedContent), "classNameCellExpand" in I && n(22, R = I.classNameCellExpand), "$$scope" in I && n(41, s = I.$$scope);
  }, e.$$.update = () => {
    if (e.$$.dirty[0] & /*columns*/
    16 && (n(40, re = {}), o.forEach((I) => {
      n(40, re[I.key] = I, re);
    })), e.$$.dirty[0] & /*showExpandIcon, columns*/
    2064 && n(24, i = ($ ? 1 : 0) + o.length), e.$$.dirty[0] & /*sortBy*/
    1 | e.$$.dirty[1] & /*columnByKey*/
    512) {
      let I = re[c];
      I !== void 0 && I.sortable === !0 && typeof I.value == "function" && n(39, W = (ie) => I.value(ie));
    }
    e.$$.dirty[0] & /*filterSelections, sortBy, sortOrder*/
    7 | e.$$.dirty[1] & /*rows, columnByKey, sortFunction, rowKey, expanded, selected*/
    807 && n(3, l = a.filter((I) => Object.keys(d).every((ie) => {
      var pS;
      let It = null;
      if (re[ie] === void 0)
        return !0;
      if (!((pS = re[ie]) != null && pS.searchValue))
        It = !1;
      else {
        if (d[ie] === "")
          return !0;
        re[ie].searchValue.length === 1 ? It = (re[ie].searchValue(I) + "").toLocaleLowerCase().indexOf((d[ie] + "").toLocaleLowerCase()) >= 0 : re[ie].searchValue.length === 2 && (It = !!re[ie].searchValue(I, d[ie] + ""));
      }
      return It || d[ie] === void 0 || // default to value() if filterValue() not provided in col
      d[ie] === (typeof re[ie].filterValue == "function" ? re[ie].filterValue(I) : re[ie].value(I));
    })).map((I) => Object.assign({}, I, {
      // internal row property for sort order
      $sortOn: W(I),
      // internal row property for expanded rows
      $expanded: m !== null && h.indexOf(I[m]) >= 0,
      $selected: m !== null && g.indexOf(I[m]) >= 0
    })).sort((I, ie) => {
      if (c) {
        if (I.$sortOn > ie.$sortOn)
          return f;
        if (I.$sortOn < ie.$sortOn)
          return -f;
      } else
        return 0;
      return 0;
    })), e.$$.dirty[0] & /*columns*/
    16 | e.$$.dirty[1] & /*rows*/
    4 && ne && o && a && Et();
  }, [
    c,
    f,
    d,
    l,
    o,
    v,
    w,
    _,
    S,
    E,
    C,
    $,
    N,
    T,
    L,
    O,
    F,
    x,
    k,
    A,
    M,
    D,
    R,
    Z,
    i,
    ne,
    Ce,
    te,
    ye,
    ve,
    H,
    h,
    g,
    a,
    u,
    p,
    m,
    y,
    b,
    W,
    re,
    s,
    r,
    gt,
    De,
    St,
    Pt,
    Xr,
    Ud,
    wP,
    _P,
    EP,
    SP
  ];
}
class N3 extends Ms {
  constructor(t) {
    super(), $s(
      this,
      t,
      nI,
      tI,
      Cs,
      {
        columns: 4,
        rows: 33,
        c_rows: 3,
        sortOrders: 34,
        sortBy: 0,
        sortOrder: 1,
        filterSelections: 2,
        expanded: 31,
        selected: 32,
        expandRowKey: 35,
        rowKey: 36,
        expandSingle: 37,
        selectSingle: 38,
        selectOnClick: 5,
        iconAsc: 6,
        iconDesc: 7,
        iconSortable: 8,
        iconExpand: 9,
        iconExpanded: 10,
        showExpandIcon: 11,
        classNameTable: 12,
        classNameThead: 13,
        classNameTbody: 14,
        classNameSelect: 15,
        classNameInput: 16,
        classNameRow: 17,
        classNameCell: 18,
        classNameRowSelected: 19,
        classNameRowExpanded: 20,
        classNameExpandedContent: 21,
        classNameCellExpand: 22
      },
      null,
      [-1, -1, -1]
    );
  }
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var iI = /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r)
        r.hasOwnProperty(s) && (i[s] = r[s]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function i() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
  };
}(), rI = Object.prototype.hasOwnProperty;
function Ey(e, t) {
  return rI.call(e, t);
}
function Sy(e) {
  if (Array.isArray(e)) {
    for (var t = new Array(e.length), n = 0; n < t.length; n++)
      t[n] = "" + n;
    return t;
  }
  if (Object.keys)
    return Object.keys(e);
  var i = [];
  for (var r in e)
    Ey(e, r) && i.push(r);
  return i;
}
function Yn(e) {
  switch (typeof e) {
    case "object":
      return JSON.parse(JSON.stringify(e));
    case "undefined":
      return null;
    default:
      return e;
  }
}
function ky(e) {
  for (var t = 0, n = e.length, i; t < n; ) {
    if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
      t++;
      continue;
    }
    return !1;
  }
  return !0;
}
function ia(e) {
  return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function D3(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Ay(e) {
  if (e === void 0)
    return !0;
  if (e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = e.length; t < n; t++)
        if (Ay(e[t]))
          return !0;
    } else if (typeof e == "object") {
      for (var i = Sy(e), r = i.length, s = 0; s < r; s++)
        if (Ay(e[i[s]]))
          return !0;
    }
  }
  return !1;
}
function zS(e, t) {
  var n = [e];
  for (var i in t) {
    var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
    typeof r < "u" && n.push(i + ": " + r);
  }
  return n.join(`
`);
}
var R3 = (
  /** @class */
  function(e) {
    iI(t, e);
    function t(n, i, r, s, o) {
      var a = this.constructor, l = e.call(this, zS(n, { name: i, index: r, operation: s, tree: o })) || this;
      return l.name = i, l.index = r, l.operation = s, l.tree = o, Object.setPrototypeOf(l, a.prototype), l.message = zS(n, { name: i, index: r, operation: s, tree: o }), l;
    }
    return t;
  }(Error)
), rt = R3, sI = Yn, Nl = {
  add: function(e, t, n) {
    return e[t] = this.value, { newDocument: n };
  },
  remove: function(e, t, n) {
    var i = e[t];
    return delete e[t], { newDocument: n, removed: i };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: function(e, t, n) {
    var i = ng(n, this.path);
    i && (i = Yn(i));
    var r = ba(n, { op: "remove", path: this.from }).removed;
    return ba(n, { op: "add", path: this.path, value: r }), { newDocument: n, removed: i };
  },
  copy: function(e, t, n) {
    var i = ng(n, this.from);
    return ba(n, { op: "add", path: this.path, value: Yn(i) }), { newDocument: n };
  },
  test: function(e, t, n) {
    return { newDocument: n, test: vf(e[t], this.value) };
  },
  _get: function(e, t, n) {
    return this.value = e[t], { newDocument: n };
  }
}, oI = {
  add: function(e, t, n) {
    return ky(t) ? e.splice(t, 0, this.value) : e[t] = this.value, { newDocument: n, index: t };
  },
  remove: function(e, t, n) {
    var i = e.splice(t, 1);
    return { newDocument: n, removed: i[0] };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: Nl.move,
  copy: Nl.copy,
  test: Nl.test,
  _get: Nl._get
};
function ng(e, t) {
  if (t == "")
    return e;
  var n = { op: "_get", path: t };
  return ba(e, n), n.value;
}
function ba(e, t, n, i, r, s) {
  if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : ig(t, 0)), t.path === "") {
    var o = { newDocument: e };
    if (t.op === "add")
      return o.newDocument = t.value, o;
    if (t.op === "replace")
      return o.newDocument = t.value, o.removed = e, o;
    if (t.op === "move" || t.op === "copy")
      return o.newDocument = ng(e, t.from), t.op === "move" && (o.removed = e), o;
    if (t.op === "test") {
      if (o.test = vf(e, t.value), o.test === !1)
        throw new rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
      return o.newDocument = e, o;
    } else {
      if (t.op === "remove")
        return o.removed = e, o.newDocument = null, o;
      if (t.op === "_get")
        return t.value = e, o;
      if (n)
        throw new rt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
      return o;
    }
  } else {
    i || (e = Yn(e));
    var a = t.path || "", l = a.split("/"), u = e, c = 1, f = l.length, d = void 0, h = void 0, g = void 0;
    for (typeof n == "function" ? g = n : g = ig; ; ) {
      if (h = l[c], h && h.indexOf("~") != -1 && (h = D3(h)), r && (h == "__proto__" || h == "prototype" && c > 0 && l[c - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && d === void 0 && (u[h] === void 0 ? d = l.slice(0, c).join("/") : c == f - 1 && (d = t.path), d !== void 0 && g(t, 0, e, d)), c++, Array.isArray(u)) {
        if (h === "-")
          h = u.length;
        else {
          if (n && !ky(h))
            throw new rt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
          ky(h) && (h = ~~h);
        }
        if (c >= f) {
          if (n && t.op === "add" && h > u.length)
            throw new rt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
          var o = oI[t.op].call(t, u, h, e);
          if (o.test === !1)
            throw new rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
          return o;
        }
      } else if (c >= f) {
        var o = Nl[t.op].call(t, u, h, e);
        if (o.test === !1)
          throw new rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
        return o;
      }
      if (u = u[h], n && c < f && (!u || typeof u != "object"))
        throw new rt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e);
    }
  }
}
function Bp(e, t, n, i, r) {
  if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t))
    throw new rt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  i || (e = Yn(e));
  for (var s = new Array(t.length), o = 0, a = t.length; o < a; o++)
    s[o] = ba(e, t[o], n, !0, r, o), e = s[o].newDocument;
  return s.newDocument = e, s;
}
function aI(e, t, n) {
  var i = ba(e, t);
  if (i.test === !1)
    throw new rt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
  return i.newDocument;
}
function ig(e, t, n, i) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new rt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
  if (Nl[e.op]) {
    if (typeof e.path != "string")
      throw new rt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
    if (e.path.indexOf("/") !== 0 && e.path.length > 0)
      throw new rt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
    if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
      throw new rt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
      throw new rt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && Ay(e.value))
      throw new rt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
    if (n) {
      if (e.op == "add") {
        var r = e.path.split("/").length, s = i.split("/").length;
        if (r !== s + 1 && r !== s)
          throw new rt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
      } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
        if (e.path !== i)
          throw new rt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
      } else if (e.op === "move" || e.op === "copy") {
        var o = { op: "_get", path: e.from, value: void 0 }, a = L3([o], n);
        if (a && a.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new rt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
      }
    }
  } else
    throw new rt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
}
function L3(e, t, n) {
  try {
    if (!Array.isArray(e))
      throw new rt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (t)
      Bp(Yn(t), Yn(e), n || !0);
    else {
      n = n || ig;
      for (var i = 0; i < e.length; i++)
        n(e[i], i, t, void 0);
    }
  } catch (r) {
    if (r instanceof rt)
      return r;
    throw r;
  }
}
function vf(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    var n = Array.isArray(e), i = Array.isArray(t), r, s, o;
    if (n && i) {
      if (s = e.length, s != t.length)
        return !1;
      for (r = s; r-- !== 0; )
        if (!vf(e[r], t[r]))
          return !1;
      return !0;
    }
    if (n != i)
      return !1;
    var a = Object.keys(e);
    if (s = a.length, s !== Object.keys(t).length)
      return !1;
    for (r = s; r-- !== 0; )
      if (!t.hasOwnProperty(a[r]))
        return !1;
    for (r = s; r-- !== 0; )
      if (o = a[r], !vf(e[o], t[o]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
const lI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonPatchError: rt,
  _areEquals: vf,
  applyOperation: ba,
  applyPatch: Bp,
  applyReducer: aI,
  deepClone: sI,
  getValueByPointer: ng,
  validate: L3,
  validator: ig
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var qv = /* @__PURE__ */ new WeakMap(), uI = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.observers = /* @__PURE__ */ new Map(), this.obj = t;
    }
    return e;
  }()
), cI = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      this.callback = t, this.observer = n;
    }
    return e;
  }()
);
function fI(e) {
  return qv.get(e);
}
function dI(e, t) {
  return e.observers.get(t);
}
function hI(e, t) {
  e.observers.delete(t.callback);
}
function gI(e, t) {
  t.unobserve();
}
function pI(e, t) {
  var n = [], i, r = fI(e);
  if (!r)
    r = new uI(e), qv.set(e, r);
  else {
    var s = dI(r, t);
    i = s && s.observer;
  }
  if (i)
    return i;
  if (i = {}, r.value = Yn(e), t) {
    i.callback = t, i.next = null;
    var o = function() {
      Cy(i);
    }, a = function() {
      clearTimeout(i.next), i.next = setTimeout(o);
    };
    typeof window < "u" && (window.addEventListener("mouseup", a), window.addEventListener("keyup", a), window.addEventListener("mousedown", a), window.addEventListener("keydown", a), window.addEventListener("change", a));
  }
  return i.patches = n, i.object = e, i.unobserve = function() {
    Cy(i), clearTimeout(i.next), hI(r, i), typeof window < "u" && (window.removeEventListener("mouseup", a), window.removeEventListener("keyup", a), window.removeEventListener("mousedown", a), window.removeEventListener("keydown", a), window.removeEventListener("change", a));
  }, r.observers.set(t, new cI(t, i)), i;
}
function Cy(e, t) {
  t === void 0 && (t = !1);
  var n = qv.get(e.object);
  Wv(n.value, e.object, e.patches, "", t), e.patches.length && Bp(n.value, e.patches);
  var i = e.patches;
  return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i;
}
function Wv(e, t, n, i, r) {
  if (t !== e) {
    typeof t.toJSON == "function" && (t = t.toJSON());
    for (var s = Sy(t), o = Sy(e), a = !1, l = o.length - 1; l >= 0; l--) {
      var u = o[l], c = e[u];
      if (Ey(t, u) && !(t[u] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
        var f = t[u];
        typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? Wv(c, f, n, i + "/" + ia(u), r) : c !== f && (r && n.push({ op: "test", path: i + "/" + ia(u), value: Yn(c) }), n.push({ op: "replace", path: i + "/" + ia(u), value: Yn(f) }));
      } else
        Array.isArray(e) === Array.isArray(t) ? (r && n.push({ op: "test", path: i + "/" + ia(u), value: Yn(c) }), n.push({ op: "remove", path: i + "/" + ia(u) }), a = !0) : (r && n.push({ op: "test", path: i, value: e }), n.push({ op: "replace", path: i, value: t }));
    }
    if (!(!a && s.length == o.length))
      for (var l = 0; l < s.length; l++) {
        var u = s[l];
        !Ey(e, u) && t[u] !== void 0 && n.push({ op: "add", path: i + "/" + ia(u), value: Yn(t[u]) });
      }
  }
}
function mI(e, t, n) {
  n === void 0 && (n = !1);
  var i = [];
  return Wv(e, t, i, "", n), i;
}
const yI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: mI,
  generate: Cy,
  observe: pI,
  unobserve: gI
}, Symbol.toStringTag, { value: "Module" }));
Object.assign({}, lI, yI, {
  JsonPatchError: R3,
  deepClone: Yn,
  escapePathComponent: ia,
  unescapePathComponent: D3
});
function P3(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var bI = /("(?:[^\\"]|\\.)*")|[:,]/g, vI = function(t, n) {
  var i, r, s;
  return n = n || {}, i = JSON.stringify(
    [1],
    void 0,
    n.indent === void 0 ? 2 : n.indent
  ).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, s = n.replacer, function o(a, l, u) {
    var c, f, d, h, g, p, m, y, b, v, w, _;
    if (a && typeof a.toJSON == "function" && (a = a.toJSON()), w = JSON.stringify(a, s), w === void 0)
      return w;
    if (m = r - l.length - u, w.length <= m && (b = w.replace(
      bI,
      function(S, E) {
        return E || S + " ";
      }
    ), b.length <= m))
      return b;
    if (s != null && (a = JSON.parse(w), s = void 0), typeof a == "object" && a !== null) {
      if (y = l + i, d = [], f = 0, Array.isArray(a))
        for (v = "[", c = "]", m = a.length; f < m; f++)
          d.push(
            o(a[f], y, f === m - 1 ? 0 : 1) || "null"
          );
      else
        for (v = "{", c = "}", p = Object.keys(a), m = p.length; f < m; f++)
          h = p[f], g = JSON.stringify(h) + ": ", _ = o(
            a[h],
            y,
            g.length + (f === m - 1 ? 0 : 1)
          ), _ !== void 0 && d.push(g + _);
      if (d.length > 0)
        return [v, i + d.join(`,
` + y), c].join(
          `
` + l
        );
    }
    return w;
  }(t, "", 0);
};
const Y0 = /* @__PURE__ */ P3(vI);
function Un(e, t, n) {
  return e.fields = t || [], e.fname = n, e;
}
function lt(e) {
  return e == null ? null : e.fname;
}
function tn(e) {
  return e == null ? null : e.fields;
}
function I3(e) {
  return e.length === 1 ? xI(e[0]) : wI(e);
}
const xI = (e) => function(t) {
  return t[e];
}, wI = (e) => {
  const t = e.length;
  return function(n) {
    for (let i = 0; i < t; ++i)
      n = n[e[i]];
    return n;
  };
};
function B(e) {
  throw Error(e);
}
function Pr(e) {
  const t = [], n = e.length;
  let i = null, r = 0, s = "", o, a, l;
  e = e + "";
  function u() {
    t.push(s + e.substring(o, a)), s = "", o = a + 1;
  }
  for (o = a = 0; a < n; ++a)
    if (l = e[a], l === "\\")
      s += e.substring(o, a++), o = a;
    else if (l === i)
      u(), i = null, r = -1;
    else {
      if (i)
        continue;
      o === r && l === '"' || o === r && l === "'" ? (o = a + 1, i = l) : l === "." && !r ? a > o ? u() : o = a + 1 : l === "[" ? (a > o && u(), r = o = a + 1) : l === "]" && (r || B("Access path missing open bracket: " + e), r > 0 && u(), r = 0, o = a + 1);
    }
  return r && B("Access path missing closing bracket: " + e), i && B("Access path missing closing quote: " + e), a > o && (a++, u()), t;
}
function _i(e, t, n) {
  const i = Pr(e);
  return e = i.length === 1 ? i[0] : e, Un((n && n.get || I3)(i), [e], t || e);
}
const Zf = _i("id"), on = Un((e) => e, [], "identity"), Xs = Un(() => 0, [], "zero"), Nu = Un(() => 1, [], "one"), Ei = Un(() => !0, [], "true"), js = Un(() => !1, [], "false");
function _I(e, t, n) {
  const i = [t].concat([].slice.call(n));
  console[e].apply(console, i);
}
const z3 = 0, Hv = 1, Gv = 2, B3 = 3, j3 = 4;
function Vv(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _I, i = e || z3;
  return {
    level(r) {
      return arguments.length ? (i = +r, this) : i;
    },
    error() {
      return i >= Hv && n(t || "error", "ERROR", arguments), this;
    },
    warn() {
      return i >= Gv && n(t || "warn", "WARN", arguments), this;
    },
    info() {
      return i >= B3 && n(t || "log", "INFO", arguments), this;
    },
    debug() {
      return i >= j3 && n(t || "log", "DEBUG", arguments), this;
    }
  };
}
var j = Array.isArray;
function ee(e) {
  return e === Object(e);
}
const BS = (e) => e !== "__proto__";
function Du() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t.reduce((i, r) => {
    for (const s in r)
      if (s === "signals")
        i.signals = EI(i.signals, r.signals);
      else {
        const o = s === "legend" ? {
          layout: 1
        } : s === "style" ? !0 : null;
        Ru(i, s, r[s], o);
      }
    return i;
  }, {});
}
function Ru(e, t, n, i) {
  if (!BS(t))
    return;
  let r, s;
  if (ee(n) && !j(n)) {
    s = ee(e[t]) ? e[t] : e[t] = {};
    for (r in n)
      i && (i === !0 || i[r]) ? Ru(s, r, n[r]) : BS(r) && (s[r] = n[r]);
  } else
    e[t] = n;
}
function EI(e, t) {
  if (e == null)
    return t;
  const n = {}, i = [];
  function r(s) {
    n[s.name] || (n[s.name] = 1, i.push(s));
  }
  return t.forEach(r), e.forEach(r), i;
}
function Oe(e) {
  return e[e.length - 1];
}
function Qt(e) {
  return e == null || e === "" ? null : +e;
}
const U3 = (e) => (t) => e * Math.exp(t), q3 = (e) => (t) => Math.log(e * t), W3 = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)), H3 = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e, rg = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
function jp(e, t, n, i) {
  const r = n(e[0]), s = n(Oe(e)), o = (s - r) * t;
  return [i(r - o), i(s - o)];
}
function G3(e, t) {
  return jp(e, t, Qt, on);
}
function V3(e, t) {
  var n = Math.sign(e[0]);
  return jp(e, t, q3(n), U3(n));
}
function Y3(e, t, n) {
  return jp(e, t, rg(n), rg(1 / n));
}
function X3(e, t, n) {
  return jp(e, t, W3(n), H3(n));
}
function Up(e, t, n, i, r) {
  const s = i(e[0]), o = i(Oe(e)), a = t != null ? i(t) : (s + o) / 2;
  return [r(a + (s - a) * n), r(a + (o - a) * n)];
}
function Yv(e, t, n) {
  return Up(e, t, n, Qt, on);
}
function Xv(e, t, n) {
  const i = Math.sign(e[0]);
  return Up(e, t, n, q3(i), U3(i));
}
function sg(e, t, n, i) {
  return Up(e, t, n, rg(i), rg(1 / i));
}
function Kv(e, t, n, i) {
  return Up(e, t, n, W3(i), H3(i));
}
function K3(e) {
  return 1 + ~~(new Date(e).getMonth() / 3);
}
function J3(e) {
  return 1 + ~~(new Date(e).getUTCMonth() / 3);
}
function J(e) {
  return e != null ? j(e) ? e : [e] : [];
}
function Q3(e, t, n) {
  let i = e[0], r = e[1], s;
  return r < i && (s = r, r = i, i = s), s = r - i, s >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - s), i + s];
}
function Ee(e) {
  return typeof e == "function";
}
const SI = "descending";
function Jv(e, t, n) {
  n = n || {}, t = J(t) || [];
  const i = [], r = [], s = {}, o = n.comparator || kI;
  return J(e).forEach((a, l) => {
    a != null && (i.push(t[l] === SI ? -1 : 1), r.push(a = Ee(a) ? a : _i(a, null, n)), (tn(a) || []).forEach((u) => s[u] = 1));
  }), r.length === 0 ? null : Un(o(r, i), Object.keys(s));
}
const qp = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0), kI = (e, t) => e.length === 1 ? AI(e[0], t[0]) : CI(e, t, e.length), AI = (e, t) => function(n, i) {
  return qp(e(n), e(i)) * t;
}, CI = (e, t, n) => (t.push(0), function(i, r) {
  let s, o = 0, a = -1;
  for (; o === 0 && ++a < n; )
    s = e[a], o = qp(s(i), s(r));
  return o * t[a];
});
function an(e) {
  return Ee(e) ? e : () => e;
}
function Qv(e, t) {
  let n;
  return (i) => {
    n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e);
  };
}
function we(e) {
  for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
    t = arguments[i];
    for (n in t)
      e[n] = t[n];
  }
  return e;
}
function $r(e, t) {
  let n = 0, i, r, s, o;
  if (e && (i = e.length))
    if (t == null) {
      for (r = e[n]; n < i && (r == null || r !== r); r = e[++n])
        ;
      for (s = o = r; n < i; ++n)
        r = e[n], r != null && (r < s && (s = r), r > o && (o = r));
    } else {
      for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]))
        ;
      for (s = o = r; n < i; ++n)
        r = t(e[n]), r != null && (r < s && (s = r), r > o && (o = r));
    }
  return [s, o];
}
function Z3(e, t) {
  const n = e.length;
  let i = -1, r, s, o, a, l;
  if (t == null) {
    for (; ++i < n; )
      if (s = e[i], s != null && s >= s) {
        r = o = s;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (a = l = i; ++i < n; )
      s = e[i], s != null && (r > s && (r = s, a = i), o < s && (o = s, l = i));
  } else {
    for (; ++i < n; )
      if (s = t(e[i], i, e), s != null && s >= s) {
        r = o = s;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (a = l = i; ++i < n; )
      s = t(e[i], i, e), s != null && (r > s && (r = s, a = i), o < s && (o = s, l = i));
  }
  return [a, l];
}
const $I = Object.prototype.hasOwnProperty;
function ce(e, t) {
  return $I.call(e, t);
}
const qd = {};
function Lu(e) {
  let t = {}, n;
  function i(s) {
    return ce(t, s) && t[s] !== qd;
  }
  const r = {
    size: 0,
    empty: 0,
    object: t,
    has: i,
    get(s) {
      return i(s) ? t[s] : void 0;
    },
    set(s, o) {
      return i(s) || (++r.size, t[s] === qd && --r.empty), t[s] = o, this;
    },
    delete(s) {
      return i(s) && (--r.size, ++r.empty, t[s] = qd), this;
    },
    clear() {
      r.size = r.empty = 0, r.object = t = {};
    },
    test(s) {
      return arguments.length ? (n = s, r) : n;
    },
    clean() {
      const s = {};
      let o = 0;
      for (const a in t) {
        const l = t[a];
        l !== qd && (!n || !n(l)) && (s[a] = l, ++o);
      }
      r.size = o, r.empty = 0, r.object = t = s;
    }
  };
  return e && Object.keys(e).forEach((s) => {
    r.set(s, e[s]);
  }), r;
}
function eF(e, t, n, i, r, s) {
  if (!n && n !== 0)
    return s;
  const o = +n;
  let a = e[0], l = Oe(e), u;
  l < a && (u = a, a = l, l = u), u = Math.abs(t - a);
  const c = Math.abs(l - t);
  return u < c && u <= o ? i : c <= o ? r : s;
}
function Y(e, t, n) {
  const i = e.prototype = Object.create(t.prototype);
  return Object.defineProperty(i, "constructor", {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  }), we(i, n);
}
function Dl(e, t, n, i) {
  let r = t[0], s = t[t.length - 1], o;
  return r > s && (o = r, r = s, s = o), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= s : e < s);
}
function To(e) {
  return typeof e == "boolean";
}
function so(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function tF(e) {
  return e && Ee(e[Symbol.iterator]);
}
function Re(e) {
  return typeof e == "number";
}
function nF(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function Q(e) {
  return typeof e == "string";
}
function Zv(e, t, n) {
  e && (e = t ? J(e).map((a) => a.replace(/\\(.)/g, "$1")) : J(e));
  const i = e && e.length, r = n && n.get || I3, s = (a) => r(t ? [a] : Pr(a));
  let o;
  if (!i)
    o = function() {
      return "";
    };
  else if (i === 1) {
    const a = s(e[0]);
    o = function(l) {
      return "" + a(l);
    };
  } else {
    const a = e.map(s);
    o = function(l) {
      let u = "" + a[0](l), c = 0;
      for (; ++c < i; )
        u += "|" + a[c](l);
      return u;
    };
  }
  return Un(o, e, "key");
}
function iF(e, t) {
  const n = e[0], i = Oe(e), r = +t;
  return r ? r === 1 ? i : n + r * (i - n) : n;
}
const MI = 1e4;
function rF(e) {
  e = +e || MI;
  let t, n, i;
  const r = () => {
    t = {}, n = {}, i = 0;
  }, s = (o, a) => (++i > e && (n = t, t = {}, i = 1), t[o] = a);
  return r(), {
    clear: r,
    has: (o) => ce(t, o) || ce(n, o),
    get: (o) => ce(t, o) ? t[o] : ce(n, o) ? s(o, n[o]) : void 0,
    set: (o, a) => ce(t, o) ? t[o] = a : s(o, a)
  };
}
function sF(e, t, n, i) {
  const r = t.length, s = n.length;
  if (!s)
    return t;
  if (!r)
    return n;
  const o = i || new t.constructor(r + s);
  let a = 0, l = 0, u = 0;
  for (; a < r && l < s; ++u)
    o[u] = e(t[a], n[l]) > 0 ? n[l++] : t[a++];
  for (; a < r; ++a, ++u)
    o[u] = t[a];
  for (; l < s; ++l, ++u)
    o[u] = n[l];
  return o;
}
function Fc(e, t) {
  let n = "";
  for (; --t >= 0; )
    n += e;
  return n;
}
function oF(e, t, n, i) {
  const r = n || " ", s = e + "", o = t - s.length;
  return o <= 0 ? s : i === "left" ? Fc(r, o) + s : i === "center" ? Fc(r, ~~(o / 2)) + s + Fc(r, Math.ceil(o / 2)) : s + Fc(r, o);
}
function ed(e) {
  return e && Oe(e) - e[0] || 0;
}
function X(e) {
  return j(e) ? "[" + e.map(X) + "]" : ee(e) || Q(e) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : e;
}
function ex(e) {
  return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
}
const FI = (e) => Re(e) || so(e) ? e : Date.parse(e);
function tx(e, t) {
  return t = t || FI, e == null || e === "" ? null : t(e);
}
function nx(e) {
  return e == null || e === "" ? null : e + "";
}
function Ji(e) {
  const t = {}, n = e.length;
  for (let i = 0; i < n; ++i)
    t[e[i]] = !0;
  return t;
}
function aF(e, t, n, i) {
  const r = i ?? "", s = e + "", o = s.length, a = Math.max(0, t - r.length);
  return o <= t ? s : n === "left" ? r + s.slice(o - a) : n === "center" ? s.slice(0, Math.ceil(a / 2)) + r + s.slice(o - ~~(a / 2)) : s.slice(0, a) + r;
}
function Ws(e, t, n) {
  if (e)
    if (t) {
      const i = e.length;
      for (let r = 0; r < i; ++r) {
        const s = t(e[r]);
        s && n(s, r, e);
      }
    } else
      e.forEach(n);
}
var jS = {}, X0 = {}, K0 = 34, rc = 10, J0 = 13;
function lF(e) {
  return new Function("d", "return {" + e.map(function(t, n) {
    return JSON.stringify(t) + ": d[" + n + '] || ""';
  }).join(",") + "}");
}
function TI(e, t) {
  var n = lF(e);
  return function(i, r) {
    return t(n(i), r, e);
  };
}
function US(e) {
  var t = /* @__PURE__ */ Object.create(null), n = [];
  return e.forEach(function(i) {
    for (var r in i)
      r in t || n.push(t[r] = r);
  }), n;
}
function Cn(e, t) {
  var n = e + "", i = n.length;
  return i < t ? new Array(t - i + 1).join(0) + n : n;
}
function OI(e) {
  return e < 0 ? "-" + Cn(-e, 6) : e > 9999 ? "+" + Cn(e, 6) : Cn(e, 4);
}
function NI(e) {
  var t = e.getUTCHours(), n = e.getUTCMinutes(), i = e.getUTCSeconds(), r = e.getUTCMilliseconds();
  return isNaN(e) ? "Invalid Date" : OI(e.getUTCFullYear()) + "-" + Cn(e.getUTCMonth() + 1, 2) + "-" + Cn(e.getUTCDate(), 2) + (r ? "T" + Cn(t, 2) + ":" + Cn(n, 2) + ":" + Cn(i, 2) + "." + Cn(r, 3) + "Z" : i ? "T" + Cn(t, 2) + ":" + Cn(n, 2) + ":" + Cn(i, 2) + "Z" : n || t ? "T" + Cn(t, 2) + ":" + Cn(n, 2) + "Z" : "");
}
function DI(e) {
  var t = new RegExp('["' + e + `
\r]`), n = e.charCodeAt(0);
  function i(f, d) {
    var h, g, p = r(f, function(m, y) {
      if (h)
        return h(m, y - 1);
      g = m, h = d ? TI(m, d) : lF(m);
    });
    return p.columns = g || [], p;
  }
  function r(f, d) {
    var h = [], g = f.length, p = 0, m = 0, y, b = g <= 0, v = !1;
    f.charCodeAt(g - 1) === rc && --g, f.charCodeAt(g - 1) === J0 && --g;
    function w() {
      if (b)
        return X0;
      if (v)
        return v = !1, jS;
      var S, E = p, C;
      if (f.charCodeAt(E) === K0) {
        for (; p++ < g && f.charCodeAt(p) !== K0 || f.charCodeAt(++p) === K0; )
          ;
        return (S = p) >= g ? b = !0 : (C = f.charCodeAt(p++)) === rc ? v = !0 : C === J0 && (v = !0, f.charCodeAt(p) === rc && ++p), f.slice(E + 1, S - 1).replace(/""/g, '"');
      }
      for (; p < g; ) {
        if ((C = f.charCodeAt(S = p++)) === rc)
          v = !0;
        else if (C === J0)
          v = !0, f.charCodeAt(p) === rc && ++p;
        else if (C !== n)
          continue;
        return f.slice(E, S);
      }
      return b = !0, f.slice(E, g);
    }
    for (; (y = w()) !== X0; ) {
      for (var _ = []; y !== jS && y !== X0; )
        _.push(y), y = w();
      d && (_ = d(_, m++)) == null || h.push(_);
    }
    return h;
  }
  function s(f, d) {
    return f.map(function(h) {
      return d.map(function(g) {
        return c(h[g]);
      }).join(e);
    });
  }
  function o(f, d) {
    return d == null && (d = US(f)), [d.map(c).join(e)].concat(s(f, d)).join(`
`);
  }
  function a(f, d) {
    return d == null && (d = US(f)), s(f, d).join(`
`);
  }
  function l(f) {
    return f.map(u).join(`
`);
  }
  function u(f) {
    return f.map(c).join(e);
  }
  function c(f) {
    return f == null ? "" : f instanceof Date ? NI(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f;
  }
  return {
    parse: i,
    parseRows: r,
    format: o,
    formatBody: a,
    formatRows: l,
    formatRow: u,
    formatValue: c
  };
}
function RI(e) {
  return e;
}
function LI(e) {
  if (e == null)
    return RI;
  var t, n, i = e.scale[0], r = e.scale[1], s = e.translate[0], o = e.translate[1];
  return function(a, l) {
    l || (t = n = 0);
    var u = 2, c = a.length, f = new Array(c);
    for (f[0] = (t += a[0]) * i + s, f[1] = (n += a[1]) * r + o; u < c; )
      f[u] = a[u], ++u;
    return f;
  };
}
function PI(e, t) {
  for (var n, i = e.length, r = i - t; r < --i; )
    n = e[r], e[r++] = e[i], e[i] = n;
}
function II(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return qS(e, n);
  }) } : qS(e, t);
}
function qS(e, t) {
  var n = t.id, i = t.bbox, r = t.properties == null ? {} : t.properties, s = uF(e, t);
  return n == null && i == null ? { type: "Feature", properties: r, geometry: s } : i == null ? { type: "Feature", id: n, properties: r, geometry: s } : { type: "Feature", id: n, bbox: i, properties: r, geometry: s };
}
function uF(e, t) {
  var n = LI(e.transform), i = e.arcs;
  function r(c, f) {
    f.length && f.pop();
    for (var d = i[c < 0 ? ~c : c], h = 0, g = d.length; h < g; ++h)
      f.push(n(d[h], h));
    c < 0 && PI(f, g);
  }
  function s(c) {
    return n(c);
  }
  function o(c) {
    for (var f = [], d = 0, h = c.length; d < h; ++d)
      r(c[d], f);
    return f.length < 2 && f.push(f[0]), f;
  }
  function a(c) {
    for (var f = o(c); f.length < 4; )
      f.push(f[0]);
    return f;
  }
  function l(c) {
    return c.map(a);
  }
  function u(c) {
    var f = c.type, d;
    switch (f) {
      case "GeometryCollection":
        return { type: f, geometries: c.geometries.map(u) };
      case "Point":
        d = s(c.coordinates);
        break;
      case "MultiPoint":
        d = c.coordinates.map(s);
        break;
      case "LineString":
        d = o(c.arcs);
        break;
      case "MultiLineString":
        d = c.arcs.map(o);
        break;
      case "Polygon":
        d = l(c.arcs);
        break;
      case "MultiPolygon":
        d = c.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: f, coordinates: d };
  }
  return u(t);
}
function zI(e, t) {
  var n = {}, i = {}, r = {}, s = [], o = -1;
  t.forEach(function(u, c) {
    var f = e.arcs[u < 0 ? ~u : u], d;
    f.length < 3 && !f[1][0] && !f[1][1] && (d = t[++o], t[o] = u, t[c] = d);
  }), t.forEach(function(u) {
    var c = a(u), f = c[0], d = c[1], h, g;
    if (h = r[f])
      if (delete r[h.end], h.push(u), h.end = d, g = i[d]) {
        delete i[g.start];
        var p = g === h ? h : h.concat(g);
        i[p.start = h.start] = r[p.end = g.end] = p;
      } else
        i[h.start] = r[h.end] = h;
    else if (h = i[d])
      if (delete i[h.start], h.unshift(u), h.start = f, g = r[f]) {
        delete r[g.end];
        var m = g === h ? h : g.concat(h);
        i[m.start = g.start] = r[m.end = h.end] = m;
      } else
        i[h.start] = r[h.end] = h;
    else
      h = [u], i[h.start = f] = r[h.end = d] = h;
  });
  function a(u) {
    var c = e.arcs[u < 0 ? ~u : u], f = c[0], d;
    return e.transform ? (d = [0, 0], c.forEach(function(h) {
      d[0] += h[0], d[1] += h[1];
    })) : d = c[c.length - 1], u < 0 ? [d, f] : [f, d];
  }
  function l(u, c) {
    for (var f in u) {
      var d = u[f];
      delete c[d.start], delete d.start, delete d.end, d.forEach(function(h) {
        n[h < 0 ? ~h : h] = 1;
      }), s.push(d);
    }
  }
  return l(r, i), l(i, r), t.forEach(function(u) {
    n[u < 0 ? ~u : u] || s.push([u]);
  }), s;
}
function BI(e) {
  return uF(e, jI.apply(this, arguments));
}
function jI(e, t, n) {
  var i, r, s;
  if (arguments.length > 1)
    i = UI(e, t, n);
  else
    for (r = 0, i = new Array(s = e.arcs.length); r < s; ++r)
      i[r] = r;
  return { type: "MultiLineString", arcs: zI(e, i) };
}
function UI(e, t, n) {
  var i = [], r = [], s;
  function o(f) {
    var d = f < 0 ? ~f : f;
    (r[d] || (r[d] = [])).push({ i: f, g: s });
  }
  function a(f) {
    f.forEach(o);
  }
  function l(f) {
    f.forEach(a);
  }
  function u(f) {
    f.forEach(l);
  }
  function c(f) {
    switch (s = f, f.type) {
      case "GeometryCollection":
        f.geometries.forEach(c);
        break;
      case "LineString":
        a(f.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        l(f.arcs);
        break;
      case "MultiPolygon":
        u(f.arcs);
        break;
    }
  }
  return c(t), r.forEach(n == null ? function(f) {
    i.push(f[0].i);
  } : function(f) {
    n(f[0].g, f[f.length - 1].g) && i.push(f[0].i);
  }), i;
}
function hs(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function qI(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Pu(e) {
  let t, n, i;
  e.length !== 2 ? (t = hs, n = (a, l) => hs(e(a), l), i = (a, l) => e(a) - l) : (t = e === hs || e === qI ? e : WI, n = e, i = e);
  function r(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (t(l, l) !== 0)
        return c;
      do {
        const f = u + c >>> 1;
        n(a[f], l) < 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function s(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (t(l, l) !== 0)
        return c;
      do {
        const f = u + c >>> 1;
        n(a[f], l) <= 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function o(a, l, u = 0, c = a.length) {
    const f = r(a, l, u, c - 1);
    return f > u && i(a[f - 1], l) > -i(a[f], l) ? f - 1 : f;
  }
  return { left: r, center: o, right: s };
}
function WI() {
  return 0;
}
function cF(e) {
  return e === null ? NaN : +e;
}
function* HI(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
  }
}
const fF = Pu(hs), fo = fF.right, GI = fF.left;
Pu(cF).center;
function VI(e, t) {
  let n = 0, i, r = 0, s = 0;
  if (t === void 0)
    for (let o of e)
      o != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r));
  else {
    let o = -1;
    for (let a of e)
      (a = t(a, ++o, e)) != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
  }
  if (n > 1)
    return s / (n - 1);
}
function YI(e, t) {
  const n = VI(e, t);
  return n && Math.sqrt(n);
}
class bn {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let i = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const s = n[r], o = t + s, a = Math.abs(t) < Math.abs(s) ? t - (o - s) : s - (o - t);
      a && (n[i++] = a), t = o;
    }
    return n[i] = t, this._n = i + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, i, r, s, o = 0;
    if (n > 0) {
      for (o = t[--n]; n > 0 && (i = o, r = t[--n], o = i + r, s = r - (o - i), !s); )
        ;
      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = o + r, r == i - o && (o = i));
    }
    return o;
  }
}
class WS extends Map {
  constructor(t, n = gF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [i, r] of t)
        this.set(i, r);
  }
  get(t) {
    return super.get($y(this, t));
  }
  has(t) {
    return super.has($y(this, t));
  }
  set(t, n) {
    return super.set(dF(this, t), n);
  }
  delete(t) {
    return super.delete(hF(this, t));
  }
}
class og extends Set {
  constructor(t, n = gF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const i of t)
        this.add(i);
  }
  has(t) {
    return super.has($y(this, t));
  }
  add(t) {
    return super.add(dF(this, t));
  }
  delete(t) {
    return super.delete(hF(this, t));
  }
}
function $y({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : n;
}
function dF({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : (e.set(i, n), n);
}
function hF({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) && (n = e.get(i), e.delete(i)), n;
}
function gF(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function XI(e, t) {
  return Array.from(t, (n) => e[n]);
}
function KI(e = hs) {
  if (e === hs)
    return pF;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const i = e(t, n);
    return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function pF(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const JI = Math.sqrt(50), QI = Math.sqrt(10), ZI = Math.sqrt(2);
function ag(e, t, n) {
  const i = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= JI ? 10 : s >= QI ? 5 : s >= ZI ? 2 : 1;
  let a, l, u;
  return r < 0 ? (u = Math.pow(10, -r) / o, a = Math.round(e * u), l = Math.round(t * u), a / u < e && ++a, l / u > t && --l, u = -u) : (u = Math.pow(10, r) * o, a = Math.round(e / u), l = Math.round(t / u), a * u < e && ++a, l * u > t && --l), l < a && 0.5 <= n && n < 2 ? ag(e, t, n * 2) : [a, l, u];
}
function My(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const i = t < e, [r, s, o] = i ? ag(t, e, n) : ag(e, t, n);
  if (!(s >= r))
    return [];
  const a = s - r + 1, l = new Array(a);
  if (i)
    if (o < 0)
      for (let u = 0; u < a; ++u)
        l[u] = (s - u) / -o;
    else
      for (let u = 0; u < a; ++u)
        l[u] = (s - u) * o;
  else if (o < 0)
    for (let u = 0; u < a; ++u)
      l[u] = (r + u) / -o;
  else
    for (let u = 0; u < a; ++u)
      l[u] = (r + u) * o;
  return l;
}
function Fy(e, t, n) {
  return t = +t, e = +e, n = +n, ag(e, t, n)[2];
}
function ho(e, t, n) {
  t = +t, e = +e, n = +n;
  const i = t < e, r = i ? Fy(t, e, n) : Fy(e, t, n);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function va(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n < i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Ty(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n > i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function mF(e, t, n = 0, i = 1 / 0, r) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i))
    return e;
  for (r = r === void 0 ? pF : KI(r); i > n; ) {
    if (i - n > 600) {
      const l = i - n + 1, u = t - n + 1, c = Math.log(l), f = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * f * (l - f) / l) * (u - l / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - u * f / l + d)), g = Math.min(i, Math.floor(t + (l - u) * f / l + d));
      mF(e, t, h, g, r);
    }
    const s = e[t];
    let o = n, a = i;
    for (sc(e, n, t), r(e[i], s) > 0 && sc(e, n, i); o < a; ) {
      for (sc(e, o, a), ++o, --a; r(e[o], s) < 0; )
        ++o;
      for (; r(e[a], s) > 0; )
        --a;
    }
    r(e[n], s) === 0 ? sc(e, n, a) : (++a, sc(e, a, i)), a <= t && (n = a + 1), t <= a && (i = a - 1);
  }
  return e;
}
function sc(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function Oy(e, t, n) {
  if (e = Float64Array.from(HI(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return Ty(e);
    if (t >= 1)
      return va(e);
    var i, r = (i - 1) * t, s = Math.floor(r), o = va(mF(e, s).subarray(0, s + 1)), a = Ty(e.subarray(s + 1));
    return o + (a - o) * (r - s);
  }
}
function yF(e, t, n = cF) {
  if (!(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return +n(e[0], 0, e);
    if (t >= 1)
      return +n(e[i - 1], i - 1, e);
    var i, r = (i - 1) * t, s = Math.floor(r), o = +n(e[s], s, e), a = +n(e[s + 1], s + 1, e);
    return o + (a - o) * (r - s);
  }
}
function e9(e, t) {
  let n = 0, i = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, i += r);
  else {
    let r = -1;
    for (let s of e)
      (s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s);
  }
  if (n)
    return i / n;
}
function bF(e, t) {
  return Oy(e, 0.5, t);
}
function* t9(e) {
  for (const t of e)
    yield* t;
}
function vF(e) {
  return Array.from(t9(e));
}
function Xn(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r; )
    s[i] = e + i * n;
  return s;
}
function xF(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      (i = +i) && (n += i);
  else {
    let i = -1;
    for (let r of e)
      (r = +t(r, ++i, e)) && (n += r);
  }
  return n;
}
function n9(e, ...t) {
  e = new og(e), t = t.map(i9);
  e:
    for (const n of e)
      for (const i of t)
        if (!i.has(n)) {
          e.delete(n);
          continue e;
        }
  return e;
}
function i9(e) {
  return e instanceof og ? e : new og(e);
}
function r9(...e) {
  const t = new og();
  for (const n of e)
    for (const i of n)
      t.add(i);
  return t;
}
function s9(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function lg(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, i = e.slice(0, n);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +e.slice(n + 1)
  ];
}
function Zl(e) {
  return e = lg(Math.abs(e)), e ? e[1] : NaN;
}
function o9(e, t) {
  return function(n, i) {
    for (var r = n.length, s = [], o = 0, a = e[0], l = 0; r > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), s.push(n.substring(r -= a, r + a)), !((l += a + 1) > i)); )
      a = e[o = (o + 1) % e.length];
    return s.reverse().join(t);
  };
}
function a9(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var l9 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function $a(e) {
  if (!(t = l9.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new ix({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
$a.prototype = ix.prototype;
function ix(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
ix.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function u9(e) {
  e:
    for (var t = e.length, n = 1, i = -1, r; n < t; ++n)
      switch (e[n]) {
        case ".":
          i = r = n;
          break;
        case "0":
          i === 0 && (i = n), r = n;
          break;
        default:
          if (!+e[n])
            break e;
          i > 0 && (i = 0);
          break;
      }
  return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e;
}
var wF;
function c9(e, t) {
  var n = lg(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1], s = r - (wF = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + lg(e, Math.max(0, t + s - 1))[0];
}
function HS(e, t) {
  var n = lg(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const GS = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: s9,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => HS(e * 100, t),
  r: HS,
  s: c9,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function VS(e) {
  return e;
}
var YS = Array.prototype.map, XS = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function _F(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? VS : o9(YS.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? VS : a9(YS.call(e.numerals, String)), o = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function u(f) {
    f = $a(f);
    var d = f.fill, h = f.align, g = f.sign, p = f.symbol, m = f.zero, y = f.width, b = f.comma, v = f.precision, w = f.trim, _ = f.type;
    _ === "n" ? (b = !0, _ = "g") : GS[_] || (v === void 0 && (v = 12), w = !0, _ = "g"), (m || d === "0" && h === "=") && (m = !0, d = "0", h = "=");
    var S = p === "$" ? n : p === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", E = p === "$" ? i : /[%p]/.test(_) ? o : "", C = GS[_], $ = /[defgprs%]/.test(_);
    v = v === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v));
    function N(T) {
      var L = S, O = E, F, x, k;
      if (_ === "c")
        O = C(T) + O, T = "";
      else {
        T = +T;
        var A = T < 0 || 1 / T < 0;
        if (T = isNaN(T) ? l : C(Math.abs(T), v), w && (T = u9(T)), A && +T == 0 && g !== "+" && (A = !1), L = (A ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + L, O = (_ === "s" ? XS[8 + wF / 3] : "") + O + (A && g === "(" ? ")" : ""), $) {
          for (F = -1, x = T.length; ++F < x; )
            if (k = T.charCodeAt(F), 48 > k || k > 57) {
              O = (k === 46 ? r + T.slice(F + 1) : T.slice(F)) + O, T = T.slice(0, F);
              break;
            }
        }
      }
      b && !m && (T = t(T, 1 / 0));
      var M = L.length + T.length + O.length, D = M < y ? new Array(y - M + 1).join(d) : "";
      switch (b && m && (T = t(D + T, D.length ? y - O.length : 1 / 0), D = ""), h) {
        case "<":
          T = L + T + O + D;
          break;
        case "=":
          T = L + D + T + O;
          break;
        case "^":
          T = D.slice(0, M = D.length >> 1) + L + T + O + D.slice(M);
          break;
        default:
          T = D + L + T + O;
          break;
      }
      return s(T);
    }
    return N.toString = function() {
      return f + "";
    }, N;
  }
  function c(f, d) {
    var h = u((f = $a(f), f.type = "f", f)), g = Math.max(-8, Math.min(8, Math.floor(Zl(d) / 3))) * 3, p = Math.pow(10, -g), m = XS[8 + g / 3];
    return function(y) {
      return h(p * y) + m;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var Wd, Wp, rx;
f9({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function f9(e) {
  return Wd = _F(e), Wp = Wd.format, rx = Wd.formatPrefix, Wd;
}
function EF(e) {
  return Math.max(0, -Zl(Math.abs(e)));
}
function SF(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Zl(t) / 3))) * 3 - Zl(Math.abs(e)));
}
function kF(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Zl(t) - Zl(e)) + 1;
}
const Q0 = /* @__PURE__ */ new Date(), Z0 = /* @__PURE__ */ new Date();
function wt(e, t, n, i) {
  function r(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return r.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), r.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = (s) => {
    const o = r(s), a = r.ceil(s);
    return s - o < a - s ? o : a;
  }, r.offset = (s, o) => (t(s = /* @__PURE__ */ new Date(+s), o == null ? 1 : Math.floor(o)), s), r.range = (s, o, a) => {
    const l = [];
    if (s = r.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
      return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+s)), t(s, a), e(s);
    while (u < s && s < o);
    return l;
  }, r.filter = (s) => wt((o) => {
    if (o >= o)
      for (; e(o), !s(o); )
        o.setTime(o - 1);
  }, (o, a) => {
    if (o >= o)
      if (a < 0)
        for (; ++a <= 0; )
          for (; t(o, -1), !s(o); )
            ;
      else
        for (; --a >= 0; )
          for (; t(o, 1), !s(o); )
            ;
  }), n && (r.count = (s, o) => (Q0.setTime(+s), Z0.setTime(+o), e(Q0), e(Z0), Math.floor(n(Q0, Z0))), r.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? (o) => i(o) % s === 0 : (o) => r.count(0, o) % s === 0) : r)), r;
}
const eu = wt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
eu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? wt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : eu);
eu.range;
const as = 1e3, hi = as * 60, ls = hi * 60, ws = ls * 24, sx = ws * 7, KS = ws * 30, e1 = ws * 365, us = wt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * as);
}, (e, t) => (t - e) / as, (e) => e.getUTCSeconds());
us.range;
const Hp = wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * as);
}, (e, t) => {
  e.setTime(+e + t * hi);
}, (e, t) => (t - e) / hi, (e) => e.getMinutes());
Hp.range;
const Gp = wt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * hi);
}, (e, t) => (t - e) / hi, (e) => e.getUTCMinutes());
Gp.range;
const Vp = wt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * as - e.getMinutes() * hi);
}, (e, t) => {
  e.setTime(+e + t * ls);
}, (e, t) => (t - e) / ls, (e) => e.getHours());
Vp.range;
const Yp = wt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * ls);
}, (e, t) => (t - e) / ls, (e) => e.getUTCHours());
Yp.range;
const gs = wt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * hi) / ws,
  (e) => e.getDate() - 1
);
gs.range;
const oo = wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ws, (e) => e.getUTCDate() - 1);
oo.range;
const AF = wt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ws, (e) => Math.floor(e / ws));
AF.range;
function Qa(e) {
  return wt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * hi) / sx);
}
const Iu = Qa(0), ug = Qa(1), d9 = Qa(2), h9 = Qa(3), tu = Qa(4), g9 = Qa(5), p9 = Qa(6);
Iu.range;
ug.range;
d9.range;
h9.range;
tu.range;
g9.range;
p9.range;
function Za(e) {
  return wt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / sx);
}
const zu = Za(0), cg = Za(1), m9 = Za(2), y9 = Za(3), nu = Za(4), b9 = Za(5), v9 = Za(6);
zu.range;
cg.range;
m9.range;
y9.range;
nu.range;
b9.range;
v9.range;
const xf = wt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
xf.range;
const wf = wt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
wf.range;
const Mr = wt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Mr.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : wt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
Mr.range;
const Fr = wt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Fr.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : wt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
Fr.range;
function CF(e, t, n, i, r, s) {
  const o = [
    [us, 1, as],
    [us, 5, 5 * as],
    [us, 15, 15 * as],
    [us, 30, 30 * as],
    [s, 1, hi],
    [s, 5, 5 * hi],
    [s, 15, 15 * hi],
    [s, 30, 30 * hi],
    [r, 1, ls],
    [r, 3, 3 * ls],
    [r, 6, 6 * ls],
    [r, 12, 12 * ls],
    [i, 1, ws],
    [i, 2, 2 * ws],
    [n, 1, sx],
    [t, 1, KS],
    [t, 3, 3 * KS],
    [e, 1, e1]
  ];
  function a(u, c, f) {
    const d = c < u;
    d && ([u, c] = [c, u]);
    const h = f && typeof f.range == "function" ? f : l(u, c, f), g = h ? h.range(u, +c + 1) : [];
    return d ? g.reverse() : g;
  }
  function l(u, c, f) {
    const d = Math.abs(c - u) / f, h = Pu(([, , m]) => m).right(o, d);
    if (h === o.length)
      return e.every(ho(u / e1, c / e1, f));
    if (h === 0)
      return eu.every(Math.max(ho(u, c, f), 1));
    const [g, p] = o[d / o[h - 1][2] < o[h][2] / d ? h - 1 : h];
    return g.every(p);
  }
  return [a, l];
}
const [x9, w9] = CF(Fr, wf, zu, AF, Yp, Gp), [_9, E9] = CF(Mr, xf, Iu, gs, Vp, Hp), Ut = "year", Ln = "quarter", nn = "month", yt = "week", Pn = "date", Jt = "day", Tr = "dayofyear", ii = "hours", ri = "minutes", Si = "seconds", Qi = "milliseconds", ox = [Ut, Ln, nn, yt, Pn, Jt, Tr, ii, ri, Si, Qi], t1 = ox.reduce((e, t, n) => (e[t] = 1 + n, e), {});
function ax(e) {
  const t = J(e).slice(), n = {};
  return t.length || B("Missing time unit."), t.forEach((r) => {
    ce(t1, r) ? n[r] = 1 : B(`Invalid time unit: ${r}.`);
  }), (n[yt] || n[Jt] ? 1 : 0) + (n[Ln] || n[nn] || n[Pn] ? 1 : 0) + (n[Tr] ? 1 : 0) > 1 && B(`Incompatible time units: ${e}`), t.sort((r, s) => t1[r] - t1[s]), t;
}
const S9 = {
  [Ut]: "%Y ",
  [Ln]: "Q%q ",
  [nn]: "%b ",
  [Pn]: "%d ",
  [yt]: "W%U ",
  [Jt]: "%a ",
  [Tr]: "%j ",
  [ii]: "%H:00",
  [ri]: "00:%M",
  [Si]: ":%S",
  [Qi]: ".%L",
  [`${Ut}-${nn}`]: "%Y-%m ",
  [`${Ut}-${nn}-${Pn}`]: "%Y-%m-%d ",
  [`${ii}-${ri}`]: "%H:%M"
};
function $F(e, t) {
  const n = we({}, S9, t), i = ax(e), r = i.length;
  let s = "", o = 0, a, l;
  for (o = 0; o < r; )
    for (a = i.length; a > o; --a)
      if (l = i.slice(o, a).join("-"), n[l] != null) {
        s += n[l], o = a;
        break;
      }
  return s.trim();
}
const oa = /* @__PURE__ */ new Date();
function lx(e) {
  return oa.setFullYear(e), oa.setMonth(0), oa.setDate(1), oa.setHours(0, 0, 0, 0), oa;
}
function MF(e) {
  return TF(new Date(e));
}
function FF(e) {
  return Ny(new Date(e));
}
function TF(e) {
  return gs.count(lx(e.getFullYear()) - 1, e);
}
function Ny(e) {
  return Iu.count(lx(e.getFullYear()) - 1, e);
}
function Dy(e) {
  return lx(e).getDay();
}
function k9(e, t, n, i, r, s, o) {
  if (0 <= e && e < 100) {
    const a = new Date(-1, t, n, i, r, s, o);
    return a.setFullYear(e), a;
  }
  return new Date(e, t, n, i, r, s, o);
}
function OF(e) {
  return DF(new Date(e));
}
function NF(e) {
  return Ry(new Date(e));
}
function DF(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return oo.count(t - 1, e);
}
function Ry(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return zu.count(t - 1, e);
}
function Ly(e) {
  return oa.setTime(Date.UTC(e, 0, 1)), oa.getUTCDay();
}
function A9(e, t, n, i, r, s, o) {
  if (0 <= e && e < 100) {
    const a = new Date(Date.UTC(-1, t, n, i, r, s, o));
    return a.setUTCFullYear(n.y), a;
  }
  return new Date(Date.UTC(e, t, n, i, r, s, o));
}
function RF(e, t, n, i, r) {
  const s = t || 1, o = Oe(e), a = (y, b, v) => (v = v || y, C9(n[v], i[v], y === o && s, b)), l = /* @__PURE__ */ new Date(), u = Ji(e), c = u[Ut] ? a(Ut) : an(2012), f = u[nn] ? a(nn) : u[Ln] ? a(Ln) : Xs, d = u[yt] && u[Jt] ? a(Jt, 1, yt + Jt) : u[yt] ? a(yt, 1) : u[Jt] ? a(Jt, 1) : u[Pn] ? a(Pn, 1) : u[Tr] ? a(Tr, 1) : Nu, h = u[ii] ? a(ii) : Xs, g = u[ri] ? a(ri) : Xs, p = u[Si] ? a(Si) : Xs, m = u[Qi] ? a(Qi) : Xs;
  return function(y) {
    l.setTime(+y);
    const b = c(l);
    return r(b, f(l), d(l, b), h(l), g(l), p(l), m(l));
  };
}
function C9(e, t, n, i) {
  const r = n <= 1 ? e : i ? (s, o) => i + n * Math.floor((e(s, o) - i) / n) : (s, o) => n * Math.floor(e(s, o) / n);
  return t ? (s, o) => t(r(s, o), o) : r;
}
function iu(e, t, n) {
  return t + e * 7 - (n + 6) % 7;
}
const $9 = {
  [Ut]: (e) => e.getFullYear(),
  [Ln]: (e) => Math.floor(e.getMonth() / 3),
  [nn]: (e) => e.getMonth(),
  [Pn]: (e) => e.getDate(),
  [ii]: (e) => e.getHours(),
  [ri]: (e) => e.getMinutes(),
  [Si]: (e) => e.getSeconds(),
  [Qi]: (e) => e.getMilliseconds(),
  [Tr]: (e) => TF(e),
  [yt]: (e) => Ny(e),
  [yt + Jt]: (e, t) => iu(Ny(e), e.getDay(), Dy(t)),
  [Jt]: (e, t) => iu(1, e.getDay(), Dy(t))
}, M9 = {
  [Ln]: (e) => 3 * e,
  [yt]: (e, t) => iu(e, 0, Dy(t))
};
function LF(e, t) {
  return RF(e, t || 1, $9, M9, k9);
}
const F9 = {
  [Ut]: (e) => e.getUTCFullYear(),
  [Ln]: (e) => Math.floor(e.getUTCMonth() / 3),
  [nn]: (e) => e.getUTCMonth(),
  [Pn]: (e) => e.getUTCDate(),
  [ii]: (e) => e.getUTCHours(),
  [ri]: (e) => e.getUTCMinutes(),
  [Si]: (e) => e.getUTCSeconds(),
  [Qi]: (e) => e.getUTCMilliseconds(),
  [Tr]: (e) => DF(e),
  [yt]: (e) => Ry(e),
  [Jt]: (e, t) => iu(1, e.getUTCDay(), Ly(t)),
  [yt + Jt]: (e, t) => iu(Ry(e), e.getUTCDay(), Ly(t))
}, T9 = {
  [Ln]: (e) => 3 * e,
  [yt]: (e, t) => iu(e, 0, Ly(t))
};
function PF(e, t) {
  return RF(e, t || 1, F9, T9, A9);
}
const O9 = {
  [Ut]: Mr,
  [Ln]: xf.every(3),
  [nn]: xf,
  [yt]: Iu,
  [Pn]: gs,
  [Jt]: gs,
  [Tr]: gs,
  [ii]: Vp,
  [ri]: Hp,
  [Si]: us,
  [Qi]: eu
}, N9 = {
  [Ut]: Fr,
  [Ln]: wf.every(3),
  [nn]: wf,
  [yt]: zu,
  [Pn]: oo,
  [Jt]: oo,
  [Tr]: oo,
  [ii]: Yp,
  [ri]: Gp,
  [Si]: us,
  [Qi]: eu
};
function Bu(e) {
  return O9[e];
}
function ju(e) {
  return N9[e];
}
function IF(e, t, n) {
  return e ? e.offset(t, n) : void 0;
}
function zF(e, t, n) {
  return IF(Bu(e), t, n);
}
function BF(e, t, n) {
  return IF(ju(e), t, n);
}
function jF(e, t, n, i) {
  return e ? e.range(t, n, i) : void 0;
}
function UF(e, t, n, i) {
  return jF(Bu(e), t, n, i);
}
function qF(e, t, n, i) {
  return jF(ju(e), t, n, i);
}
const Tc = 1e3, Oc = Tc * 60, Nc = Oc * 60, Xp = Nc * 24, D9 = Xp * 7, JS = Xp * 30, Py = Xp * 365, WF = [Ut, nn, Pn, ii, ri, Si, Qi], Dc = WF.slice(0, -1), Rc = Dc.slice(0, -1), Lc = Rc.slice(0, -1), R9 = Lc.slice(0, -1), L9 = [Ut, yt], QS = [Ut, nn], HF = [Ut], oc = [[Dc, 1, Tc], [Dc, 5, 5 * Tc], [Dc, 15, 15 * Tc], [Dc, 30, 30 * Tc], [Rc, 1, Oc], [Rc, 5, 5 * Oc], [Rc, 15, 15 * Oc], [Rc, 30, 30 * Oc], [Lc, 1, Nc], [Lc, 3, 3 * Nc], [Lc, 6, 6 * Nc], [Lc, 12, 12 * Nc], [R9, 1, Xp], [L9, 1, D9], [QS, 1, JS], [QS, 3, 3 * JS], [HF, 1, Py]];
function GF(e) {
  const t = e.extent, n = e.maxbins || 40, i = Math.abs(ed(t)) / n;
  let r = Pu((a) => a[2]).right(oc, i), s, o;
  return r === oc.length ? (s = HF, o = ho(t[0] / Py, t[1] / Py, n)) : r ? (r = oc[i / oc[r - 1][2] < oc[r][2] / i ? r - 1 : r], s = r[0], o = r[1]) : (s = WF, o = Math.max(ho(t[0], t[1], n), 1)), {
    units: s,
    step: o
  };
}
function n1(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function i1(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ac(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function VF(e) {
  var t = e.dateTime, n = e.date, i = e.time, r = e.periods, s = e.days, o = e.shortDays, a = e.months, l = e.shortMonths, u = lc(r), c = uc(r), f = lc(s), d = uc(s), h = lc(o), g = uc(o), p = lc(a), m = uc(a), y = lc(l), b = uc(l), v = {
    a: A,
    A: M,
    b: D,
    B: R,
    c: null,
    d: rk,
    e: rk,
    f: sz,
    g: pz,
    G: yz,
    H: nz,
    I: iz,
    j: rz,
    L: YF,
    m: oz,
    M: az,
    p: U,
    q: W,
    Q: ak,
    s: lk,
    S: lz,
    u: uz,
    U: cz,
    V: fz,
    w: dz,
    W: hz,
    x: null,
    X: null,
    y: gz,
    Y: mz,
    Z: bz,
    "%": ok
  }, w = {
    a: ne,
    A: Z,
    b: re,
    B: Ce,
    c: null,
    d: sk,
    e: sk,
    f: _z,
    g: Oz,
    G: Dz,
    H: vz,
    I: xz,
    j: wz,
    L: KF,
    m: Ez,
    M: Sz,
    p: Et,
    q: ln,
    Q: ak,
    s: lk,
    S: kz,
    u: Az,
    U: Cz,
    V: $z,
    w: Mz,
    W: Fz,
    x: null,
    X: null,
    y: Tz,
    Y: Nz,
    Z: Rz,
    "%": ok
  }, _ = {
    a: N,
    A: T,
    b: L,
    B: O,
    c: F,
    d: nk,
    e: nk,
    f: Q9,
    g: tk,
    G: ek,
    H: ik,
    I: ik,
    j: Y9,
    L: J9,
    m: V9,
    M: X9,
    p: $,
    q: G9,
    Q: ez,
    s: tz,
    S: K9,
    u: j9,
    U: U9,
    V: q9,
    w: B9,
    W: W9,
    x,
    X: k,
    y: tk,
    Y: ek,
    Z: H9,
    "%": Z9
  };
  v.x = S(n, v), v.X = S(i, v), v.c = S(t, v), w.x = S(n, w), w.X = S(i, w), w.c = S(t, w);
  function S(te, ye) {
    return function(ve) {
      var H = [], gt = -1, De = 0, St = te.length, Pt, Xr, Ud;
      for (ve instanceof Date || (ve = /* @__PURE__ */ new Date(+ve)); ++gt < St; )
        te.charCodeAt(gt) === 37 && (H.push(te.slice(De, gt)), (Xr = ZS[Pt = te.charAt(++gt)]) != null ? Pt = te.charAt(++gt) : Xr = Pt === "e" ? " " : "0", (Ud = ye[Pt]) && (Pt = Ud(ve, Xr)), H.push(Pt), De = gt + 1);
      return H.push(te.slice(De, gt)), H.join("");
    };
  }
  function E(te, ye) {
    return function(ve) {
      var H = ac(1900, void 0, 1), gt = C(H, te, ve += "", 0), De, St;
      if (gt != ve.length)
        return null;
      if ("Q" in H)
        return new Date(H.Q);
      if ("s" in H)
        return new Date(H.s * 1e3 + ("L" in H ? H.L : 0));
      if (ye && !("Z" in H) && (H.Z = 0), "p" in H && (H.H = H.H % 12 + H.p * 12), H.m === void 0 && (H.m = "q" in H ? H.q : 0), "V" in H) {
        if (H.V < 1 || H.V > 53)
          return null;
        "w" in H || (H.w = 1), "Z" in H ? (De = i1(ac(H.y, 0, 1)), St = De.getUTCDay(), De = St > 4 || St === 0 ? cg.ceil(De) : cg(De), De = oo.offset(De, (H.V - 1) * 7), H.y = De.getUTCFullYear(), H.m = De.getUTCMonth(), H.d = De.getUTCDate() + (H.w + 6) % 7) : (De = n1(ac(H.y, 0, 1)), St = De.getDay(), De = St > 4 || St === 0 ? ug.ceil(De) : ug(De), De = gs.offset(De, (H.V - 1) * 7), H.y = De.getFullYear(), H.m = De.getMonth(), H.d = De.getDate() + (H.w + 6) % 7);
      } else
        ("W" in H || "U" in H) && ("w" in H || (H.w = "u" in H ? H.u % 7 : "W" in H ? 1 : 0), St = "Z" in H ? i1(ac(H.y, 0, 1)).getUTCDay() : n1(ac(H.y, 0, 1)).getDay(), H.m = 0, H.d = "W" in H ? (H.w + 6) % 7 + H.W * 7 - (St + 5) % 7 : H.w + H.U * 7 - (St + 6) % 7);
      return "Z" in H ? (H.H += H.Z / 100 | 0, H.M += H.Z % 100, i1(H)) : n1(H);
    };
  }
  function C(te, ye, ve, H) {
    for (var gt = 0, De = ye.length, St = ve.length, Pt, Xr; gt < De; ) {
      if (H >= St)
        return -1;
      if (Pt = ye.charCodeAt(gt++), Pt === 37) {
        if (Pt = ye.charAt(gt++), Xr = _[Pt in ZS ? ye.charAt(gt++) : Pt], !Xr || (H = Xr(te, ve, H)) < 0)
          return -1;
      } else if (Pt != ve.charCodeAt(H++))
        return -1;
    }
    return H;
  }
  function $(te, ye, ve) {
    var H = u.exec(ye.slice(ve));
    return H ? (te.p = c.get(H[0].toLowerCase()), ve + H[0].length) : -1;
  }
  function N(te, ye, ve) {
    var H = h.exec(ye.slice(ve));
    return H ? (te.w = g.get(H[0].toLowerCase()), ve + H[0].length) : -1;
  }
  function T(te, ye, ve) {
    var H = f.exec(ye.slice(ve));
    return H ? (te.w = d.get(H[0].toLowerCase()), ve + H[0].length) : -1;
  }
  function L(te, ye, ve) {
    var H = y.exec(ye.slice(ve));
    return H ? (te.m = b.get(H[0].toLowerCase()), ve + H[0].length) : -1;
  }
  function O(te, ye, ve) {
    var H = p.exec(ye.slice(ve));
    return H ? (te.m = m.get(H[0].toLowerCase()), ve + H[0].length) : -1;
  }
  function F(te, ye, ve) {
    return C(te, t, ye, ve);
  }
  function x(te, ye, ve) {
    return C(te, n, ye, ve);
  }
  function k(te, ye, ve) {
    return C(te, i, ye, ve);
  }
  function A(te) {
    return o[te.getDay()];
  }
  function M(te) {
    return s[te.getDay()];
  }
  function D(te) {
    return l[te.getMonth()];
  }
  function R(te) {
    return a[te.getMonth()];
  }
  function U(te) {
    return r[+(te.getHours() >= 12)];
  }
  function W(te) {
    return 1 + ~~(te.getMonth() / 3);
  }
  function ne(te) {
    return o[te.getUTCDay()];
  }
  function Z(te) {
    return s[te.getUTCDay()];
  }
  function re(te) {
    return l[te.getUTCMonth()];
  }
  function Ce(te) {
    return a[te.getUTCMonth()];
  }
  function Et(te) {
    return r[+(te.getUTCHours() >= 12)];
  }
  function ln(te) {
    return 1 + ~~(te.getUTCMonth() / 3);
  }
  return {
    format: function(te) {
      var ye = S(te += "", v);
      return ye.toString = function() {
        return te;
      }, ye;
    },
    parse: function(te) {
      var ye = E(te += "", !1);
      return ye.toString = function() {
        return te;
      }, ye;
    },
    utcFormat: function(te) {
      var ye = S(te += "", w);
      return ye.toString = function() {
        return te;
      }, ye;
    },
    utcParse: function(te) {
      var ye = E(te += "", !0);
      return ye.toString = function() {
        return te;
      }, ye;
    }
  };
}
var ZS = { "-": "", _: " ", 0: "0" }, Rt = /^\s*\d+/, P9 = /^%/, I9 = /[\\^$*+?|[\]().{}]/g;
function Pe(e, t, n) {
  var i = e < 0 ? "-" : "", r = (i ? -e : e) + "", s = r.length;
  return i + (s < n ? new Array(n - s + 1).join(t) + r : r);
}
function z9(e) {
  return e.replace(I9, "\\$&");
}
function lc(e) {
  return new RegExp("^(?:" + e.map(z9).join("|") + ")", "i");
}
function uc(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function B9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 1));
  return i ? (e.w = +i[0], n + i[0].length) : -1;
}
function j9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 1));
  return i ? (e.u = +i[0], n + i[0].length) : -1;
}
function U9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.U = +i[0], n + i[0].length) : -1;
}
function q9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.V = +i[0], n + i[0].length) : -1;
}
function W9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.W = +i[0], n + i[0].length) : -1;
}
function ek(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 4));
  return i ? (e.y = +i[0], n + i[0].length) : -1;
}
function tk(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
}
function H9(e, t, n) {
  var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
}
function G9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 1));
  return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
}
function V9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
}
function nk(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.d = +i[0], n + i[0].length) : -1;
}
function Y9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 3));
  return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
}
function ik(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.H = +i[0], n + i[0].length) : -1;
}
function X9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.M = +i[0], n + i[0].length) : -1;
}
function K9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 2));
  return i ? (e.S = +i[0], n + i[0].length) : -1;
}
function J9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 3));
  return i ? (e.L = +i[0], n + i[0].length) : -1;
}
function Q9(e, t, n) {
  var i = Rt.exec(t.slice(n, n + 6));
  return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
}
function Z9(e, t, n) {
  var i = P9.exec(t.slice(n, n + 1));
  return i ? n + i[0].length : -1;
}
function ez(e, t, n) {
  var i = Rt.exec(t.slice(n));
  return i ? (e.Q = +i[0], n + i[0].length) : -1;
}
function tz(e, t, n) {
  var i = Rt.exec(t.slice(n));
  return i ? (e.s = +i[0], n + i[0].length) : -1;
}
function rk(e, t) {
  return Pe(e.getDate(), t, 2);
}
function nz(e, t) {
  return Pe(e.getHours(), t, 2);
}
function iz(e, t) {
  return Pe(e.getHours() % 12 || 12, t, 2);
}
function rz(e, t) {
  return Pe(1 + gs.count(Mr(e), e), t, 3);
}
function YF(e, t) {
  return Pe(e.getMilliseconds(), t, 3);
}
function sz(e, t) {
  return YF(e, t) + "000";
}
function oz(e, t) {
  return Pe(e.getMonth() + 1, t, 2);
}
function az(e, t) {
  return Pe(e.getMinutes(), t, 2);
}
function lz(e, t) {
  return Pe(e.getSeconds(), t, 2);
}
function uz(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function cz(e, t) {
  return Pe(Iu.count(Mr(e) - 1, e), t, 2);
}
function XF(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? tu(e) : tu.ceil(e);
}
function fz(e, t) {
  return e = XF(e), Pe(tu.count(Mr(e), e) + (Mr(e).getDay() === 4), t, 2);
}
function dz(e) {
  return e.getDay();
}
function hz(e, t) {
  return Pe(ug.count(Mr(e) - 1, e), t, 2);
}
function gz(e, t) {
  return Pe(e.getFullYear() % 100, t, 2);
}
function pz(e, t) {
  return e = XF(e), Pe(e.getFullYear() % 100, t, 2);
}
function mz(e, t) {
  return Pe(e.getFullYear() % 1e4, t, 4);
}
function yz(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? tu(e) : tu.ceil(e), Pe(e.getFullYear() % 1e4, t, 4);
}
function bz(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Pe(t / 60 | 0, "0", 2) + Pe(t % 60, "0", 2);
}
function sk(e, t) {
  return Pe(e.getUTCDate(), t, 2);
}
function vz(e, t) {
  return Pe(e.getUTCHours(), t, 2);
}
function xz(e, t) {
  return Pe(e.getUTCHours() % 12 || 12, t, 2);
}
function wz(e, t) {
  return Pe(1 + oo.count(Fr(e), e), t, 3);
}
function KF(e, t) {
  return Pe(e.getUTCMilliseconds(), t, 3);
}
function _z(e, t) {
  return KF(e, t) + "000";
}
function Ez(e, t) {
  return Pe(e.getUTCMonth() + 1, t, 2);
}
function Sz(e, t) {
  return Pe(e.getUTCMinutes(), t, 2);
}
function kz(e, t) {
  return Pe(e.getUTCSeconds(), t, 2);
}
function Az(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function Cz(e, t) {
  return Pe(zu.count(Fr(e) - 1, e), t, 2);
}
function JF(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? nu(e) : nu.ceil(e);
}
function $z(e, t) {
  return e = JF(e), Pe(nu.count(Fr(e), e) + (Fr(e).getUTCDay() === 4), t, 2);
}
function Mz(e) {
  return e.getUTCDay();
}
function Fz(e, t) {
  return Pe(cg.count(Fr(e) - 1, e), t, 2);
}
function Tz(e, t) {
  return Pe(e.getUTCFullYear() % 100, t, 2);
}
function Oz(e, t) {
  return e = JF(e), Pe(e.getUTCFullYear() % 100, t, 2);
}
function Nz(e, t) {
  return Pe(e.getUTCFullYear() % 1e4, t, 4);
}
function Dz(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? nu(e) : nu.ceil(e), Pe(e.getUTCFullYear() % 1e4, t, 4);
}
function Rz() {
  return "+0000";
}
function ok() {
  return "%";
}
function ak(e) {
  return +e;
}
function lk(e) {
  return Math.floor(+e / 1e3);
}
var ml, ux, QF, cx, ZF;
Lz({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Lz(e) {
  return ml = VF(e), ux = ml.format, QF = ml.parse, cx = ml.utcFormat, ZF = ml.utcParse, ml;
}
function Pc(e) {
  const t = {};
  return (n) => t[n] || (t[n] = e(n));
}
function Pz(e, t) {
  return (n) => {
    const i = e(n), r = i.indexOf(t);
    if (r < 0)
      return i;
    let s = Iz(i, r);
    const o = s < i.length ? i.slice(s) : "";
    for (; --s > r; )
      if (i[s] !== "0") {
        ++s;
        break;
      }
    return i.slice(0, s) + o;
  };
}
function Iz(e, t) {
  let n = e.lastIndexOf("e"), i;
  if (n > 0)
    return n;
  for (n = e.length; --n > t; )
    if (i = e.charCodeAt(n), i >= 48 && i <= 57)
      return n + 1;
}
function eT(e) {
  const t = Pc(e.format), n = e.formatPrefix;
  return {
    format: t,
    formatPrefix: n,
    formatFloat(i) {
      const r = $a(i || ",");
      if (r.precision == null) {
        switch (r.precision = 12, r.type) {
          case "%":
            r.precision -= 2;
            break;
          case "e":
            r.precision -= 1;
            break;
        }
        return Pz(
          t(r),
          // number format
          t(".1f")(1)[1]
          // decimal point character
        );
      } else
        return t(r);
    },
    formatSpan(i, r, s, o) {
      o = $a(o ?? ",f");
      const a = ho(i, r, s), l = Math.max(Math.abs(i), Math.abs(r));
      let u;
      if (o.precision == null)
        switch (o.type) {
          case "s":
            return isNaN(u = SF(a, l)) || (o.precision = u), n(o, l);
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            isNaN(u = kF(a, l)) || (o.precision = u - (o.type === "e"));
            break;
          }
          case "f":
          case "%": {
            isNaN(u = EF(a)) || (o.precision = u - (o.type === "%") * 2);
            break;
          }
        }
      return t(o);
    }
  };
}
let Iy;
tT();
function tT() {
  return Iy = eT({
    format: Wp,
    formatPrefix: rx
  });
}
function nT(e) {
  return eT(_F(e));
}
function fg(e) {
  return arguments.length ? Iy = nT(e) : Iy;
}
function uk(e, t, n) {
  n = n || {}, ee(n) || B(`Invalid time multi-format specifier: ${n}`);
  const i = t(Si), r = t(ri), s = t(ii), o = t(Pn), a = t(yt), l = t(nn), u = t(Ln), c = t(Ut), f = e(n[Qi] || ".%L"), d = e(n[Si] || ":%S"), h = e(n[ri] || "%I:%M"), g = e(n[ii] || "%I %p"), p = e(n[Pn] || n[Jt] || "%a %d"), m = e(n[yt] || "%b %d"), y = e(n[nn] || "%B"), b = e(n[Ln] || "%B"), v = e(n[Ut] || "%Y");
  return (w) => (i(w) < w ? f : r(w) < w ? d : s(w) < w ? h : o(w) < w ? g : l(w) < w ? a(w) < w ? p : m : c(w) < w ? u(w) < w ? y : b : v)(w);
}
function iT(e) {
  const t = Pc(e.format), n = Pc(e.utcFormat);
  return {
    timeFormat: (i) => Q(i) ? t(i) : uk(t, Bu, i),
    utcFormat: (i) => Q(i) ? n(i) : uk(n, ju, i),
    timeParse: Pc(e.parse),
    utcParse: Pc(e.utcParse)
  };
}
let zy;
rT();
function rT() {
  return zy = iT({
    format: ux,
    parse: QF,
    utcFormat: cx,
    utcParse: ZF
  });
}
function sT(e) {
  return iT(VF(e));
}
function _f(e) {
  return arguments.length ? zy = sT(e) : zy;
}
const By = (e, t) => we({}, e, t);
function oT(e, t) {
  const n = e ? nT(e) : fg(), i = t ? sT(t) : _f();
  return By(n, i);
}
function fx(e, t) {
  const n = arguments.length;
  return n && n !== 2 && B("defaultLocale expects either zero or two arguments."), n ? By(fg(e), _f(t)) : By(fg(), _f());
}
function zz() {
  return tT(), rT(), fx();
}
const Bz = /^(data:|([A-Za-z]+:)?\/\/)/, jz = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, Uz = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, ck = "file://";
function qz(e, t) {
  return (n) => ({
    options: n || {},
    sanitize: Hz,
    load: Wz,
    fileAccess: !!t,
    file: Gz(t),
    http: Yz(e)
  });
}
async function Wz(e, t) {
  const n = await this.sanitize(e, t), i = n.href;
  return n.localFile ? this.file(i) : this.http(i, t);
}
async function Hz(e, t) {
  t = we({}, this.options, t);
  const n = this.fileAccess, i = {
    href: null
  };
  let r, s, o;
  const a = jz.test(e.replace(Uz, ""));
  (e == null || typeof e != "string" || !a) && B("Sanitize failure, invalid URI: " + X(e));
  const l = Bz.test(e);
  return (o = t.baseURL) && !l && (!e.startsWith("/") && !o.endsWith("/") && (e = "/" + e), e = o + e), s = (r = e.startsWith(ck)) || t.mode === "file" || t.mode !== "http" && !l && n, r ? e = e.slice(ck.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), s = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
    value: !!s
  }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i;
}
function Gz(e) {
  return e ? (t) => new Promise((n, i) => {
    e.readFile(t, (r, s) => {
      r ? i(r) : n(s);
    });
  }) : Vz;
}
async function Vz() {
  B("No file system access.");
}
function Yz(e) {
  return e ? async function(t, n) {
    const i = we({}, this.options.http, n), r = n && n.response, s = await e(t, i);
    return s.ok ? Ee(s[r]) ? s[r]() : s.text() : B(s.status + "" + s.statusText);
  } : Xz;
}
async function Xz() {
  B("No HTTP fetch method available.");
}
const Kz = (e) => e != null && e === e, Jz = (e) => e === "true" || e === "false" || e === !0 || e === !1, Qz = (e) => !Number.isNaN(Date.parse(e)), aT = (e) => !Number.isNaN(+e) && !(e instanceof Date), Zz = (e) => aT(e) && Number.isInteger(+e), jy = {
  boolean: ex,
  integer: Qt,
  number: Qt,
  date: tx,
  string: nx,
  unknown: on
}, Hd = [Jz, Zz, aT, Qz], e7 = ["boolean", "integer", "number", "date"];
function lT(e, t) {
  if (!e || !e.length)
    return "unknown";
  const n = e.length, i = Hd.length, r = Hd.map((s, o) => o + 1);
  for (let s = 0, o = 0, a, l; s < n; ++s)
    for (l = t ? e[s][t] : e[s], a = 0; a < i; ++a)
      if (r[a] && Kz(l) && !Hd[a](l) && (r[a] = 0, ++o, o === Hd.length))
        return "string";
  return e7[r.reduce((s, o) => s === 0 ? o : s, 0) - 1];
}
function uT(e, t) {
  return t.reduce((n, i) => (n[i] = lT(e, i), n), {});
}
function fk(e) {
  const t = function(n, i) {
    const r = {
      delimiter: e
    };
    return dx(n, i ? we(i, r) : r);
  };
  return t.responseType = "text", t;
}
function dx(e, t) {
  return t.header && (e = t.header.map(X).join(t.delimiter) + `
` + e), DI(t.delimiter).parse(e + "");
}
dx.responseType = "text";
function t7(e) {
  return typeof Buffer == "function" && Ee(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
}
function hx(e, t) {
  const n = t && t.property ? _i(t.property) : on;
  return ee(e) && !t7(e) ? n7(n(e), t) : n(JSON.parse(e));
}
hx.responseType = "json";
function n7(e, t) {
  return !j(e) && tF(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
}
const i7 = {
  interior: (e, t) => e !== t,
  exterior: (e, t) => e === t
};
function cT(e, t) {
  let n, i, r, s;
  return e = hx(e, t), t && t.feature ? (n = II, r = t.feature) : t && t.mesh ? (n = BI, r = t.mesh, s = i7[t.filter]) : B("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : B("Invalid TopoJSON object: " + r), i && i.features || [i];
}
cT.responseType = "json";
const Th = {
  dsv: dx,
  csv: fk(","),
  tsv: fk("	"),
  json: hx,
  topojson: cT
};
function gx(e, t) {
  return arguments.length > 1 ? (Th[e] = t, this) : ce(Th, e) ? Th[e] : null;
}
function fT(e) {
  const t = gx(e);
  return t && t.responseType || "text";
}
function dT(e, t, n, i) {
  t = t || {};
  const r = gx(t.type || "json");
  return r || B("Unknown data format type: " + t.type), e = r(e, t), t.parse && r7(e, t.parse, n, i), ce(e, "columns") && delete e.columns, e;
}
function r7(e, t, n, i) {
  if (!e.length)
    return;
  const r = _f();
  n = n || r.timeParse, i = i || r.utcParse;
  let s = e.columns || Object.keys(e[0]), o, a, l, u, c, f;
  t === "auto" && (t = uT(e, s)), s = Object.keys(t);
  const d = s.map((h) => {
    const g = t[h];
    let p, m;
    if (g && (g.startsWith("date:") || g.startsWith("utc:")))
      return p = g.split(/:(.+)?/, 2), m = p[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (p[0] === "utc" ? i : n)(m);
    if (!jy[g])
      throw Error("Illegal format pattern: " + h + ":" + g);
    return jy[g];
  });
  for (l = 0, c = e.length, f = s.length; l < c; ++l)
    for (o = e[l], u = 0; u < f; ++u)
      a = s[u], o[a] = d[u](o[a]);
}
const Kp = qz(
  typeof fetch < "u" && fetch,
  // use built-in fetch API
  null
  // no file system access
);
function Jp(e) {
  const t = e || on, n = [], i = {};
  return n.add = (r) => {
    const s = t(r);
    return i[s] || (i[s] = 1, n.push(r)), n;
  }, n.remove = (r) => {
    const s = t(r);
    if (i[s]) {
      i[s] = 0;
      const o = n.indexOf(r);
      o >= 0 && n.splice(o, 1);
    }
    return n;
  }, n;
}
async function Oh(e, t) {
  try {
    await t(e);
  } catch (n) {
    e.error(n);
  }
}
const hT = Symbol("vega_id");
let s7 = 1;
function Qp(e) {
  return !!(e && le(e));
}
function le(e) {
  return e[hT];
}
function gT(e, t) {
  return e[hT] = t, e;
}
function Be(e) {
  const t = e === Object(e) ? e : {
    data: e
  };
  return le(t) ? t : gT(t, s7++);
}
function px(e) {
  return Zp(e, Be({}));
}
function Zp(e, t) {
  for (const n in e)
    t[n] = e[n];
  return t;
}
function pT(e, t) {
  return gT(t, le(e));
}
function el(e, t) {
  return e ? t ? (n, i) => e(n, i) || le(t(n)) - le(t(i)) : (n, i) => e(n, i) || le(n) - le(i) : null;
}
function mT(e) {
  return e && e.constructor === tl;
}
function tl() {
  const e = [], t = [], n = [], i = [], r = [];
  let s = null, o = !1;
  return {
    constructor: tl,
    insert(a) {
      const l = J(a), u = l.length;
      for (let c = 0; c < u; ++c)
        e.push(l[c]);
      return this;
    },
    remove(a) {
      const l = Ee(a) ? i : t, u = J(a), c = u.length;
      for (let f = 0; f < c; ++f)
        l.push(u[f]);
      return this;
    },
    modify(a, l, u) {
      const c = {
        field: l,
        value: an(u)
      };
      return Ee(a) ? (c.filter = a, r.push(c)) : (c.tuple = a, n.push(c)), this;
    },
    encode(a, l) {
      return Ee(a) ? r.push({
        filter: a,
        field: l
      }) : n.push({
        tuple: a,
        field: l
      }), this;
    },
    clean(a) {
      return s = a, this;
    },
    reflow() {
      return o = !0, this;
    },
    pulse(a, l) {
      const u = {}, c = {};
      let f, d, h, g, p, m;
      for (f = 0, d = l.length; f < d; ++f)
        u[le(l[f])] = 1;
      for (f = 0, d = t.length; f < d; ++f)
        p = t[f], u[le(p)] = -1;
      for (f = 0, d = i.length; f < d; ++f)
        g = i[f], l.forEach((b) => {
          g(b) && (u[le(b)] = -1);
        });
      for (f = 0, d = e.length; f < d; ++f)
        p = e[f], m = le(p), u[m] ? u[m] = 1 : a.add.push(Be(e[f]));
      for (f = 0, d = l.length; f < d; ++f)
        p = l[f], u[le(p)] < 0 && a.rem.push(p);
      function y(b, v, w) {
        w ? b[v] = w(b) : a.encode = v, o || (c[le(b)] = b);
      }
      for (f = 0, d = n.length; f < d; ++f)
        h = n[f], p = h.tuple, g = h.field, m = u[le(p)], m > 0 && (y(p, g, h.value), a.modifies(g));
      for (f = 0, d = r.length; f < d; ++f)
        h = r[f], g = h.filter, l.forEach((b) => {
          g(b) && u[le(b)] > 0 && y(b, h.field, h.value);
        }), a.modifies(h.field);
      if (o)
        a.mod = t.length || i.length ? l.filter((b) => u[le(b)] > 0) : l.slice();
      else
        for (m in c)
          a.mod.push(c[m]);
      return (s || s == null && (t.length || i.length)) && a.clean(!0), a;
    }
  };
}
const Nh = "_:mod:_";
function em() {
  Object.defineProperty(this, Nh, {
    writable: !0,
    value: {}
  });
}
em.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(e, t, n, i) {
    const r = this, s = r[e], o = r[Nh];
    return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, o[t + ":" + e] = -1, o[e] = -1) : (s !== n || i) && (r[e] = n, o[e] = j(n) ? 1 + n.length : -1), r;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(e, t) {
    const n = this[Nh];
    if (arguments.length) {
      if (j(e)) {
        for (let i = 0; i < e.length; ++i)
          if (n[e[i]])
            return !0;
        return !1;
      }
    } else {
      for (const i in n)
        if (n[i])
          return !0;
      return !1;
    }
    return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    return this[Nh] = {}, this;
  }
};
let o7 = 0;
const a7 = "pulse", l7 = new em(), u7 = 1, c7 = 2;
function Ye(e, t, n, i) {
  this.id = ++o7, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i);
}
function dk(e) {
  return function(t) {
    const n = this.flags;
    return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this);
  };
}
Ye.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = Jp(Zf));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(e) {
    return this.value !== e ? (this.value = e, 1) : 0;
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: dk(u7),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: dk(c7),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(e, t, n) {
    t = t !== !1;
    const i = this._argval = this._argval || new em(), r = this._argops = this._argops || [], s = [];
    let o, a, l, u;
    const c = (f, d, h) => {
      h instanceof Ye ? (h !== this && (t && h.targets().add(this), s.push(h)), r.push({
        op: h,
        name: f,
        index: d
      })) : i.set(f, d, h);
    };
    for (o in e)
      if (a = e[o], o === a7)
        J(a).forEach((f) => {
          f instanceof Ye ? f !== this && (f.targets().add(this), s.push(f)) : B("Pulse parameters must be operator instances.");
        }), this.source = a;
      else if (j(a))
        for (i.set(o, -1, Array(l = a.length)), u = 0; u < l; ++u)
          c(o, u, a[u]);
      else
        c(o, -1, a);
    return this.marshall().clear(), n && (r.initonly = !0), s;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(e) {
    const t = this._argval || l7, n = this._argops;
    let i, r, s, o;
    if (n) {
      const a = n.length;
      for (r = 0; r < a; ++r)
        i = n[r], s = i.op, o = s.modified() && s.stamp === e, t.set(i.name, i.index, s.value, o);
      if (n.initonly) {
        for (r = 0; r < a; ++r)
          i = n[r], i.op.targets().remove(this);
        this._argops = null, this._update = null;
      }
    }
    return t;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const e = this._argops;
    let t, n, i, r;
    if (e)
      for (t = 0, n = e.length; t < n; ++t)
        i = e[t], r = i.op, r._targets && r._targets.remove(this);
    this.pulse = null, this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(e) {
    const t = this._update;
    if (t) {
      const n = this.marshall(e.stamp), i = t.call(this, n, e);
      if (n.clear(), i !== this.value)
        this.value = i;
      else if (!this.modified())
        return e.StopPropagation;
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e;
  }
};
function f7(e, t, n, i) {
  let r = 1, s;
  return e instanceof Ye ? s = e : e && e.prototype instanceof Ye ? s = new e() : Ee(e) ? s = new Ye(null, e) : (r = 0, s = new Ye(e, t)), this.rank(s), r && (i = n, n = t), n && this.connect(s, s.parameters(n, i)), this.touch(s), s;
}
function d7(e, t) {
  const n = e.rank, i = t.length;
  for (let r = 0; r < i; ++r)
    if (n < t[r].rank) {
      this.rerank(e);
      return;
    }
}
let h7 = 0;
function tm(e, t, n) {
  this.id = ++h7, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t);
}
function Us(e, t, n) {
  return new tm(e, t, n);
}
tm.prototype = {
  _filter: Ei,
  _apply: on,
  targets() {
    return this._targets || (this._targets = Jp(Zf));
  },
  consume(e) {
    return arguments.length ? (this._consume = !!e, this) : !!this._consume;
  },
  receive(e) {
    if (this._filter(e)) {
      const t = this.value = this._apply(e), n = this._targets, i = n ? n.length : 0;
      for (let r = 0; r < i; ++r)
        n[r].receive(t);
      this._consume && (e.preventDefault(), e.stopPropagation());
    }
  },
  filter(e) {
    const t = Us(e);
    return this.targets().add(t), t;
  },
  apply(e) {
    const t = Us(null, e);
    return this.targets().add(t), t;
  },
  merge() {
    const e = Us();
    this.targets().add(e);
    for (let t = 0, n = arguments.length; t < n; ++t)
      arguments[t].targets().add(e);
    return e;
  },
  throttle(e) {
    let t = -1;
    return this.filter(() => {
      const n = Date.now();
      return n - t > e ? (t = n, 1) : 0;
    });
  },
  debounce(e) {
    const t = Us();
    return this.targets().add(Us(null, null, Qv(e, (n) => {
      const i = n.dataflow;
      t.receive(n), i && i.run && i.run();
    }))), t;
  },
  between(e, t) {
    let n = !1;
    return e.targets().add(Us(null, null, () => n = !0)), t.targets().add(Us(null, null, () => n = !1)), this.filter(() => n);
  },
  detach() {
    this._filter = Ei, this._targets = null;
  }
};
function g7(e, t, n, i) {
  const r = this, s = Us(n, i), o = function(u) {
    u.dataflow = r;
    try {
      s.receive(u);
    } catch (c) {
      r.error(c);
    } finally {
      r.run();
    }
  };
  let a;
  typeof e == "string" && typeof document < "u" ? a = document.querySelectorAll(e) : a = J(e);
  const l = a.length;
  for (let u = 0; u < l; ++u)
    a[u].addEventListener(t, o);
  return s;
}
function p7(e, t) {
  const n = this.locale();
  return dT(e, t, n.timeParse, n.utcParse);
}
function m7(e, t, n) {
  return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
}
async function y7(e, t) {
  const n = this;
  let i = 0, r;
  try {
    r = await n.loader().load(e, {
      context: "dataflow",
      response: fT(t && t.type)
    });
    try {
      r = n.parse(r, t);
    } catch (s) {
      i = -2, n.warn("Data ingestion failed", e, s);
    }
  } catch (s) {
    i = -1, n.warn("Loading failed", e, s);
  }
  return {
    data: r,
    status: i
  };
}
async function b7(e, t, n) {
  const i = this, r = i._pending || v7(i);
  r.requests += 1;
  const s = await i.request(t, n);
  return i.pulse(e, i.changeset().remove(Ei).insert(s.data || [])), r.done(), s;
}
function v7(e) {
  let t;
  const n = new Promise((i) => t = i);
  return n.requests = 0, n.done = () => {
    --n.requests === 0 && (e._pending = null, t(e));
  }, e._pending = n;
}
const x7 = {
  skip: !0
};
function w7(e, t, n, i, r) {
  return (e instanceof Ye ? E7 : _7)(this, e, t, n, i, r), this;
}
function _7(e, t, n, i, r, s) {
  const o = we({}, s, x7);
  let a, l;
  Ee(n) || (n = an(n)), i === void 0 ? a = (u) => e.touch(n(u)) : Ee(i) ? (l = new Ye(null, i, r, !1), a = (u) => {
    l.evaluate(u);
    const c = n(u), f = l.value;
    mT(f) ? e.pulse(c, f, s) : e.update(c, f, o);
  }) : a = (u) => e.update(n(u), i, o), t.apply(a);
}
function E7(e, t, n, i, r, s) {
  if (i === void 0)
    t.targets().add(n);
  else {
    const o = s || {}, a = new Ye(null, S7(n, i), r, !1);
    a.modified(o.force), a.rank = t.rank, t.targets().add(a), n && (a.skip(!0), a.value = n.value, a.targets().add(n), e.connect(n, [a]));
  }
}
function S7(e, t) {
  return t = Ee(t) ? t : an(t), e ? function(n, i) {
    const r = t(n, i);
    return e.skip() || (e.skip(r !== this.value).value = r), r;
  } : t;
}
function k7(e) {
  e.rank = ++this._rank;
}
function A7(e) {
  const t = [e];
  let n, i, r;
  for (; t.length; )
    if (this.rank(n = t.pop()), i = n._targets)
      for (r = i.length; --r >= 0; )
        t.push(n = i[r]), n === e && B("Cycle detected in dataflow graph.");
}
const dg = {}, gr = 1, Hs = 2, es = 4, C7 = gr | Hs, hk = gr | es, yl = gr | Hs | es, gk = 8, cc = 16, pk = 32, mk = 64;
function ao(e, t, n) {
  this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null;
}
function r1(e, t) {
  const n = [];
  return Ws(e, t, (i) => n.push(i)), n;
}
function yk(e, t) {
  const n = {};
  return e.visit(t, (i) => {
    n[le(i)] = 1;
  }), (i) => n[le(i)] ? null : i;
}
function Gd(e, t) {
  return e ? (n, i) => e(n, i) && t(n, i) : t;
}
ao.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation: dg,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD: gr,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM: Hs,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD: es,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM: C7,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD: hk,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL: yl,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW: gk,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE: cc,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE: pk,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS: mk,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(e) {
    return new ao(this.dataflow).init(this, e);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const e = this.fork(yl);
    return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(yl | cc);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let e = this;
    return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new ao(this.dataflow).init(this), e.add = e.source, e.rem = []), e;
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(e, t) {
    const n = this;
    return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & mk) && (n.fields = e.fields), t & gr ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & Hs ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & es ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & pk ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(e) {
    this.dataflow.runAfter(e);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(e) {
    const t = e || yl;
    return t & gr && this.add.length || t & Hs && this.rem.length || t & es && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(e) {
    if (e)
      return this.fork(yl).reflow();
    const t = this.add.length, n = this.source && this.source.length;
    return n && n !== t && (this.mod = this.source, t && this.filter(es, yk(this, gr))), this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(e) {
    return arguments.length ? (this.cleans = !!e, this) : this.cleans;
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(e) {
    const t = this.fields || (this.fields = {});
    return j(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(e, t) {
    const n = this.fields;
    return (t || this.mod.length) && n ? arguments.length ? j(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(e, t) {
    const n = this;
    return e & gr && (n.addF = Gd(n.addF, t)), e & Hs && (n.remF = Gd(n.remF, t)), e & es && (n.modF = Gd(n.modF, t)), e & cc && (n.srcF = Gd(n.srcF, t)), n;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(e) {
    e = e || yl;
    const t = this;
    return e & gr && t.addF && (t.add = r1(t.add, t.addF), t.addF = null), e & Hs && t.remF && (t.rem = r1(t.rem, t.remF), t.remF = null), e & es && t.modF && (t.mod = r1(t.mod, t.modF), t.modF = null), e & cc && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(e, t) {
    const n = this, i = t;
    if (e & cc)
      return Ws(n.source, n.srcF, i), n;
    e & gr && Ws(n.add, n.addF, i), e & Hs && Ws(n.rem, n.remF, i), e & es && Ws(n.mod, n.modF, i);
    const r = n.source;
    if (e & gk && r) {
      const s = n.add.length + n.mod.length;
      s === r.length || (s ? Ws(r, yk(n, hk), i) : Ws(r, n.srcF, i));
    }
    return n;
  }
};
function mx(e, t, n, i) {
  const r = this;
  let s = 0;
  this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
  for (const o of n)
    if (o.stamp === t) {
      if (o.fields) {
        const a = r.fields || (r.fields = {});
        for (const l in o.fields)
          a[l] = 1;
      }
      o.changed(r.ADD) && (s |= r.ADD), o.changed(r.REM) && (s |= r.REM), o.changed(r.MOD) && (s |= r.MOD);
    }
  this.changes = s;
}
Y(mx, ao, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(e) {
    const t = new ao(this.dataflow).init(this, e & this.NO_FIELDS);
    return e !== void 0 && (e & t.ADD && this.visit(t.ADD, (n) => t.add.push(n)), e & t.REM && this.visit(t.REM, (n) => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, (n) => t.mod.push(n))), t;
  },
  changed(e) {
    return this.changes & e;
  },
  modified(e) {
    const t = this, n = t.fields;
    return n && t.changes & t.MOD ? j(e) ? e.some((i) => n[i]) : n[e] : 0;
  },
  filter() {
    B("MultiPulse does not support filtering.");
  },
  materialize() {
    B("MultiPulse does not support materialization.");
  },
  visit(e, t) {
    const n = this, i = n.pulses, r = i.length;
    let s = 0;
    if (e & n.SOURCE)
      for (; s < r; ++s)
        i[s].visit(e, t);
    else
      for (; s < r; ++s)
        i[s].stamp === n.stamp && i[s].visit(e, t);
    return n;
  }
});
async function $7(e, t, n) {
  const i = this, r = [];
  if (i._pulse)
    return yT(i);
  if (i._pending && await i._pending, t && await Oh(i, t), !i._touched.length)
    return i.debug("Dataflow invoked, but nothing to do."), i;
  const s = ++i._clock;
  i._pulse = new ao(i, s, e), i._touched.forEach((c) => i._enqueue(c, !0)), i._touched = Jp(Zf);
  let o = 0, a, l, u;
  try {
    for (; i._heap.size() > 0; ) {
      if (a = i._heap.pop(), a.rank !== a.qrank) {
        i._enqueue(a, !0);
        continue;
      }
      l = a.run(i._getPulse(a, e)), l.then ? l = await l : l.async && (r.push(l.async), l = dg), l !== dg && a._targets && a._targets.forEach((c) => i._enqueue(c)), ++o;
    }
  } catch (c) {
    i._heap.clear(), u = c;
  }
  if (i._input = {}, i._pulse = null, i.debug(`Pulse ${s}: ${o} operators`), u && (i._postrun = [], i.error(u)), i._postrun.length) {
    const c = i._postrun.sort((f, d) => d.priority - f.priority);
    i._postrun = [];
    for (let f = 0; f < c.length; ++f)
      await Oh(i, c[f].callback);
  }
  return n && await Oh(i, n), r.length && Promise.all(r).then((c) => i.runAsync(null, () => {
    c.forEach((f) => {
      try {
        f(i);
      } catch (d) {
        i.error(d);
      }
    });
  })), i;
}
async function M7(e, t, n) {
  for (; this._running; )
    await this._running;
  const i = () => this._running = null;
  return (this._running = this.evaluate(e, t, n)).then(i, i), this._running;
}
function F7(e, t, n) {
  return this._pulse ? yT(this) : (this.evaluate(e, t, n), this);
}
function T7(e, t, n) {
  if (this._pulse || t)
    this._postrun.push({
      priority: n || 0,
      callback: e
    });
  else
    try {
      e(this);
    } catch (i) {
      this.error(i);
    }
}
function yT(e) {
  return e.error("Dataflow already running. Use runAsync() to chain invocations."), e;
}
function O7(e, t) {
  const n = e.stamp < this._clock;
  n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
}
function N7(e, t) {
  const n = e.source, i = this._clock;
  return n && j(n) ? new mx(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || D7(this._pulse, n && n.pulse);
}
function D7(e, t) {
  return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== dg && (e.source = t.source), e);
}
const yx = {
  skip: !1,
  force: !1
};
function R7(e, t) {
  const n = t || yx;
  return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this;
}
function L7(e, t, n) {
  const i = n || yx;
  return (e.set(t) || i.force) && this.touch(e, i), this;
}
function P7(e, t, n) {
  this.touch(e, n || yx);
  const i = new ao(this, this._clock + (this._pulse ? 0 : 1)), r = e.pulse && e.pulse.source || [];
  return i.target = e, this._input[e.id] = t.pulse(i, r), this;
}
function I7(e) {
  let t = [];
  return {
    clear: () => t = [],
    size: () => t.length,
    peek: () => t[0],
    push: (n) => (t.push(n), bT(t, 0, t.length - 1, e)),
    pop: () => {
      const n = t.pop();
      let i;
      return t.length ? (i = t[0], t[0] = n, z7(t, 0, e)) : i = n, i;
    }
  };
}
function bT(e, t, n, i) {
  let r, s;
  const o = e[n];
  for (; n > t; ) {
    if (s = n - 1 >> 1, r = e[s], i(o, r) < 0) {
      e[n] = r, n = s;
      continue;
    }
    break;
  }
  return e[n] = o;
}
function z7(e, t, n) {
  const i = t, r = e.length, s = e[t];
  let o = (t << 1) + 1, a;
  for (; o < r; )
    a = o + 1, a < r && n(e[o], e[a]) >= 0 && (o = a), e[t] = e[o], t = o, o = (t << 1) + 1;
  return e[t] = s, bT(e, i, t, n);
}
function jl() {
  this.logger(Vv()), this.logLevel(Hv), this._clock = 0, this._rank = 0, this._locale = fx();
  try {
    this._loader = Kp();
  } catch {
  }
  this._touched = Jp(Zf), this._input = {}, this._pulse = null, this._heap = I7((e, t) => e.qrank - t.qrank), this._postrun = [];
}
function fc(e) {
  return function() {
    return this._log[e].apply(this, arguments);
  };
}
jl.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(e) {
    return arguments.length ? (this._loader = e, this) : this._loader;
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(e) {
    return arguments.length ? (this._locale = e, this) : this._locale;
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(e) {
    return arguments.length ? (this._log = e, this) : this._log;
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: fc("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: fc("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: fc("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: fc("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: fc("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add: f7,
  connect: d7,
  rank: k7,
  rerank: A7,
  // OPERATOR UPDATES
  pulse: P7,
  touch: R7,
  update: L7,
  changeset: tl,
  // DATA LOADING
  ingest: m7,
  parse: p7,
  preload: b7,
  request: y7,
  // EVENT HANDLING
  events: g7,
  on: w7,
  // PULSE PROPAGATION
  evaluate: $7,
  run: F7,
  runAsync: M7,
  runAfter: T7,
  _enqueue: O7,
  _getPulse: N7
};
function P(e, t) {
  Ye.call(this, e, null, t);
}
Y(P, Ye, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then((n) => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(e) {
    const t = this.marshall(e.stamp), n = this.transform(t, e);
    return t.clear(), n;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
const ru = {};
function vT(e) {
  const t = xT(e);
  return t && t.Definition || null;
}
function xT(e) {
  return e = e && e.toLowerCase(), ce(ru, e) ? ru[e] : null;
}
function* wT(e, t) {
  if (t == null)
    for (let n of e)
      n != null && n !== "" && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i);
  }
}
function bx(e, t, n) {
  const i = Float64Array.from(wT(e, n));
  return i.sort(hs), t.map((r) => yF(i, r));
}
function vx(e, t) {
  return bx(e, [0.25, 0.5, 0.75], t);
}
function xx(e, t) {
  const n = e.length, i = YI(e, t), r = vx(e, t), s = (r[2] - r[0]) / 1.34;
  return 1.06 * (Math.min(i, s) || i || Math.abs(r[0]) || 1) * Math.pow(n, -0.2);
}
function _T(e) {
  const t = e.maxbins || 20, n = e.base || 10, i = Math.log(n), r = e.divide || [5, 2];
  let s = e.extent[0], o = e.extent[1], a, l, u, c, f, d;
  const h = e.span || o - s || Math.abs(s) || 1;
  if (e.step)
    a = e.step;
  else if (e.steps) {
    for (c = h / t, f = 0, d = e.steps.length; f < d && e.steps[f] < c; ++f)
      ;
    a = e.steps[Math.max(0, f - 1)];
  } else {
    for (l = Math.ceil(Math.log(t) / i), u = e.minstep || 0, a = Math.max(u, Math.pow(n, Math.round(Math.log(h) / i) - l)); Math.ceil(h / a) > t; )
      a *= n;
    for (f = 0, d = r.length; f < d; ++f)
      c = a / r[f], c >= u && h / c <= t && (a = c);
  }
  c = Math.log(a);
  const g = c >= 0 ? 0 : ~~(-c / i) + 1, p = Math.pow(n, -g - 1);
  return (e.nice || e.nice === void 0) && (c = Math.floor(s / a + p) * a, s = s < c ? c - a : c, o = Math.ceil(o / a) * a), {
    start: s,
    stop: o === s ? s + a : o,
    step: a
  };
}
var ki = Math.random;
function B7(e) {
  ki = e;
}
function ET(e, t, n, i) {
  if (!e.length)
    return [void 0, void 0];
  const r = Float64Array.from(wT(e, i)), s = r.length, o = t;
  let a, l, u, c;
  for (u = 0, c = Array(o); u < o; ++u) {
    for (a = 0, l = 0; l < s; ++l)
      a += r[~~(ki() * s)];
    c[u] = a / s;
  }
  return c.sort(hs), [Oy(c, n / 2), Oy(c, 1 - n / 2)];
}
function ST(e, t, n, i) {
  i = i || ((d) => d);
  const r = e.length, s = new Float64Array(r);
  let o = 0, a = 1, l = i(e[0]), u = l, c = l + t, f;
  for (; a < r; ++a) {
    if (f = i(e[a]), f >= c) {
      for (u = (l + u) / 2; o < a; ++o)
        s[o] = u;
      c = f + t, l = f;
    }
    u = f;
  }
  for (u = (l + u) / 2; o < a; ++o)
    s[o] = u;
  return n ? j7(s, t + t / 4) : s;
}
function j7(e, t) {
  const n = e.length;
  let i = 0, r = 1, s, o;
  for (; e[i] === e[r]; )
    ++r;
  for (; r < n; ) {
    for (s = r + 1; e[r] === e[s]; )
      ++s;
    if (e[r] - e[r - 1] < t) {
      for (o = r + (i + s - r - r >> 1); o < r; )
        e[o++] = e[r];
      for (; o > r; )
        e[o--] = e[i];
    }
    i = r, r = s;
  }
  return e;
}
function U7(e) {
  return function() {
    return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647;
  };
}
function q7(e, t) {
  t == null && (t = e, e = 0);
  let n, i, r;
  const s = {
    min(o) {
      return arguments.length ? (n = o || 0, r = i - n, s) : n;
    },
    max(o) {
      return arguments.length ? (i = o || 0, r = i - n, s) : i;
    },
    sample() {
      return n + Math.floor(r * ki());
    },
    pdf(o) {
      return o === Math.floor(o) && o >= n && o < i ? 1 / r : 0;
    },
    cdf(o) {
      const a = Math.floor(o);
      return a < n ? 0 : a >= i ? 1 : (a - n + 1) / r;
    },
    icdf(o) {
      return o >= 0 && o <= 1 ? n - 1 + Math.floor(o * r) : NaN;
    }
  };
  return s.min(e).max(t);
}
const kT = Math.sqrt(2 * Math.PI), W7 = Math.SQRT2;
let dc = NaN;
function nm(e, t) {
  e = e || 0, t = t ?? 1;
  let n = 0, i = 0, r, s;
  if (dc === dc)
    n = dc, dc = NaN;
  else {
    do
      n = ki() * 2 - 1, i = ki() * 2 - 1, r = n * n + i * i;
    while (r === 0 || r > 1);
    s = Math.sqrt(-2 * Math.log(r) / r), n *= s, dc = i * s;
  }
  return e + n * t;
}
function wx(e, t, n) {
  n = n ?? 1;
  const i = (e - (t || 0)) / n;
  return Math.exp(-0.5 * i * i) / (n * kT);
}
function im(e, t, n) {
  t = t || 0, n = n ?? 1;
  const i = (e - t) / n, r = Math.abs(i);
  let s;
  if (r > 37)
    s = 0;
  else {
    const o = Math.exp(-r * r / 2);
    let a;
    r < 7.07106781186547 ? (a = 0.0352624965998911 * r + 0.700383064443688, a = a * r + 6.37396220353165, a = a * r + 33.912866078383, a = a * r + 112.079291497871, a = a * r + 221.213596169931, a = a * r + 220.206867912376, s = o * a, a = 0.0883883476483184 * r + 1.75566716318264, a = a * r + 16.064177579207, a = a * r + 86.7807322029461, a = a * r + 296.564248779674, a = a * r + 637.333633378831, a = a * r + 793.826512519948, a = a * r + 440.413735824752, s = s / a) : (a = r + 0.65, a = r + 4 / a, a = r + 3 / a, a = r + 2 / a, a = r + 1 / a, s = o / a / 2.506628274631);
  }
  return i > 0 ? 1 - s : s;
}
function rm(e, t, n) {
  return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * W7 * H7(2 * e - 1);
}
function H7(e) {
  let t = -Math.log((1 - e) * (1 + e)), n;
  return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
}
function _x(e, t) {
  let n, i;
  const r = {
    mean(s) {
      return arguments.length ? (n = s || 0, r) : n;
    },
    stdev(s) {
      return arguments.length ? (i = s ?? 1, r) : i;
    },
    sample: () => nm(n, i),
    pdf: (s) => wx(s, n, i),
    cdf: (s) => im(s, n, i),
    icdf: (s) => rm(s, n, i)
  };
  return r.mean(e).stdev(t);
}
function Ex(e, t) {
  const n = _x();
  let i = 0;
  const r = {
    data(s) {
      return arguments.length ? (e = s, i = s ? s.length : 0, r.bandwidth(t)) : e;
    },
    bandwidth(s) {
      return arguments.length ? (t = s, !t && e && (t = xx(e)), r) : t;
    },
    sample() {
      return e[~~(ki() * i)] + t * n.sample();
    },
    pdf(s) {
      let o = 0, a = 0;
      for (; a < i; ++a)
        o += n.pdf((s - e[a]) / t);
      return o / t / i;
    },
    cdf(s) {
      let o = 0, a = 0;
      for (; a < i; ++a)
        o += n.cdf((s - e[a]) / t);
      return o / i;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return r.data(e);
}
function Sx(e, t) {
  return e = e || 0, t = t ?? 1, Math.exp(e + nm() * t);
}
function kx(e, t, n) {
  if (e <= 0)
    return 0;
  t = t || 0, n = n ?? 1;
  const i = (Math.log(e) - t) / n;
  return Math.exp(-0.5 * i * i) / (n * kT * e);
}
function Ax(e, t, n) {
  return im(Math.log(e), t, n);
}
function Cx(e, t, n) {
  return Math.exp(rm(e, t, n));
}
function AT(e, t) {
  let n, i;
  const r = {
    mean(s) {
      return arguments.length ? (n = s || 0, r) : n;
    },
    stdev(s) {
      return arguments.length ? (i = s ?? 1, r) : i;
    },
    sample: () => Sx(n, i),
    pdf: (s) => kx(s, n, i),
    cdf: (s) => Ax(s, n, i),
    icdf: (s) => Cx(s, n, i)
  };
  return r.mean(e).stdev(t);
}
function CT(e, t) {
  let n = 0, i;
  function r(o) {
    const a = [];
    let l = 0, u;
    for (u = 0; u < n; ++u)
      l += a[u] = o[u] == null ? 1 : +o[u];
    for (u = 0; u < n; ++u)
      a[u] /= l;
    return a;
  }
  const s = {
    weights(o) {
      return arguments.length ? (i = r(t = o || []), s) : t;
    },
    distributions(o) {
      return arguments.length ? (o ? (n = o.length, e = o) : (n = 0, e = []), s.weights(t)) : e;
    },
    sample() {
      const o = ki();
      let a = e[n - 1], l = i[0], u = 0;
      for (; u < n - 1; l += i[++u])
        if (o < l) {
          a = e[u];
          break;
        }
      return a.sample();
    },
    pdf(o) {
      let a = 0, l = 0;
      for (; l < n; ++l)
        a += i[l] * e[l].pdf(o);
      return a;
    },
    cdf(o) {
      let a = 0, l = 0;
      for (; l < n; ++l)
        a += i[l] * e[l].cdf(o);
      return a;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return s.distributions(e).weights(t);
}
function $x(e, t) {
  return t == null && (t = e ?? 1, e = 0), e + (t - e) * ki();
}
function Mx(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0;
}
function Fx(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
}
function Tx(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN;
}
function $T(e, t) {
  let n, i;
  const r = {
    min(s) {
      return arguments.length ? (n = s || 0, r) : n;
    },
    max(s) {
      return arguments.length ? (i = s ?? 1, r) : i;
    },
    sample: () => $x(n, i),
    pdf: (s) => Mx(s, n, i),
    cdf: (s) => Fx(s, n, i),
    icdf: (s) => Tx(s, n, i)
  };
  return t == null && (t = e ?? 1, e = 0), r.min(e).max(t);
}
function Ox(e, t, n) {
  let i = 0, r = 0;
  for (const s of e) {
    const o = n(s);
    t(s) == null || o == null || isNaN(o) || (i += (o - i) / ++r);
  }
  return {
    coef: [i],
    predict: () => i,
    rSquared: 0
  };
}
function td(e, t, n, i) {
  const r = i - e * e, s = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
  return [t - s * e, s];
}
function sm(e, t, n, i) {
  e = e.filter((h) => {
    let g = t(h), p = n(h);
    return g != null && (g = +g) >= g && p != null && (p = +p) >= p;
  }), i && e.sort((h, g) => t(h) - t(g));
  const r = e.length, s = new Float64Array(r), o = new Float64Array(r);
  let a = 0, l = 0, u = 0, c, f, d;
  for (d of e)
    s[a] = c = +t(d), o[a] = f = +n(d), ++a, l += (c - l) / a, u += (f - u) / a;
  for (a = 0; a < r; ++a)
    s[a] -= l, o[a] -= u;
  return [s, o, l, u];
}
function nd(e, t, n, i) {
  let r = -1, s, o;
  for (const a of e)
    s = t(a), o = n(a), s != null && (s = +s) >= s && o != null && (o = +o) >= o && i(s, o, ++r);
}
function Uu(e, t, n, i, r) {
  let s = 0, o = 0;
  return nd(e, t, n, (a, l) => {
    const u = l - r(a), c = l - i;
    s += u * u, o += c * c;
  }), 1 - s / o;
}
function Nx(e, t, n) {
  let i = 0, r = 0, s = 0, o = 0, a = 0;
  nd(e, t, n, (c, f) => {
    ++a, i += (c - i) / a, r += (f - r) / a, s += (c * f - s) / a, o += (c * c - o) / a;
  });
  const l = td(i, r, s, o), u = (c) => l[0] + l[1] * c;
  return {
    coef: l,
    predict: u,
    rSquared: Uu(e, t, n, r, u)
  };
}
function MT(e, t, n) {
  let i = 0, r = 0, s = 0, o = 0, a = 0;
  nd(e, t, n, (c, f) => {
    ++a, c = Math.log(c), i += (c - i) / a, r += (f - r) / a, s += (c * f - s) / a, o += (c * c - o) / a;
  });
  const l = td(i, r, s, o), u = (c) => l[0] + l[1] * Math.log(c);
  return {
    coef: l,
    predict: u,
    rSquared: Uu(e, t, n, r, u)
  };
}
function FT(e, t, n) {
  const [i, r, s, o] = sm(e, t, n);
  let a = 0, l = 0, u = 0, c = 0, f = 0, d, h, g;
  nd(e, t, n, (b, v) => {
    d = i[f++], h = Math.log(v), g = d * v, a += (v * h - a) / f, l += (g - l) / f, u += (g * h - u) / f, c += (d * g - c) / f;
  });
  const [p, m] = td(l / o, a / o, u / o, c / o), y = (b) => Math.exp(p + m * (b - s));
  return {
    coef: [Math.exp(p - m * s), m],
    predict: y,
    rSquared: Uu(e, t, n, o, y)
  };
}
function TT(e, t, n) {
  let i = 0, r = 0, s = 0, o = 0, a = 0, l = 0;
  nd(e, t, n, (f, d) => {
    const h = Math.log(f), g = Math.log(d);
    ++l, i += (h - i) / l, r += (g - r) / l, s += (h * g - s) / l, o += (h * h - o) / l, a += (d - a) / l;
  });
  const u = td(i, r, s, o), c = (f) => u[0] * Math.pow(f, u[1]);
  return u[0] = Math.exp(u[0]), {
    coef: u,
    predict: c,
    rSquared: Uu(e, t, n, a, c)
  };
}
function Dx(e, t, n) {
  const [i, r, s, o] = sm(e, t, n), a = i.length;
  let l = 0, u = 0, c = 0, f = 0, d = 0, h, g, p, m;
  for (h = 0; h < a; )
    g = i[h], p = r[h++], m = g * g, l += (m - l) / h, u += (m * g - u) / h, c += (m * m - c) / h, f += (g * p - f) / h, d += (m * p - d) / h;
  const y = c - l * l, b = l * y - u * u, v = (d * l - f * u) / b, w = (f * y - d * u) / b, _ = -v * l, S = (E) => (E = E - s, v * E * E + w * E + _ + o);
  return {
    coef: [_ - w * s + v * s * s + o, w - 2 * v * s, v],
    predict: S,
    rSquared: Uu(e, t, n, o, S)
  };
}
function OT(e, t, n, i) {
  if (i === 0)
    return Ox(e, t, n);
  if (i === 1)
    return Nx(e, t, n);
  if (i === 2)
    return Dx(e, t, n);
  const [r, s, o, a] = sm(e, t, n), l = r.length, u = [], c = [], f = i + 1;
  let d, h, g, p, m;
  for (d = 0; d < f; ++d) {
    for (g = 0, p = 0; g < l; ++g)
      p += Math.pow(r[g], d) * s[g];
    for (u.push(p), m = new Float64Array(f), h = 0; h < f; ++h) {
      for (g = 0, p = 0; g < l; ++g)
        p += Math.pow(r[g], d + h);
      m[h] = p;
    }
    c.push(m);
  }
  c.push(u);
  const y = V7(c), b = (v) => {
    v -= o;
    let w = a + y[0] + y[1] * v + y[2] * v * v;
    for (d = 3; d < f; ++d)
      w += y[d] * Math.pow(v, d);
    return w;
  };
  return {
    coef: G7(f, y, -o, a),
    predict: b,
    rSquared: Uu(e, t, n, a, b)
  };
}
function G7(e, t, n, i) {
  const r = Array(e);
  let s, o, a, l;
  for (s = 0; s < e; ++s)
    r[s] = 0;
  for (s = e - 1; s >= 0; --s)
    for (a = t[s], l = 1, r[s] += a, o = 1; o <= s; ++o)
      l *= (s + 1 - o) / o, r[s - o] += a * Math.pow(n, o) * l;
  return r[0] += i, r;
}
function V7(e) {
  const t = e.length - 1, n = [];
  let i, r, s, o, a;
  for (i = 0; i < t; ++i) {
    for (o = i, r = i + 1; r < t; ++r)
      Math.abs(e[i][r]) > Math.abs(e[i][o]) && (o = r);
    for (s = i; s < t + 1; ++s)
      a = e[s][i], e[s][i] = e[s][o], e[s][o] = a;
    for (r = i + 1; r < t; ++r)
      for (s = t; s >= i; s--)
        e[s][r] -= e[s][i] * e[i][r] / e[i][i];
  }
  for (r = t - 1; r >= 0; --r) {
    for (a = 0, s = r + 1; s < t; ++s)
      a += e[s][r] * n[s];
    n[r] = (e[t][r] - a) / e[r][r];
  }
  return n;
}
const bk = 2, vk = 1e-12;
function NT(e, t, n, i) {
  const [r, s, o, a] = sm(e, t, n, !0), l = r.length, u = Math.max(2, ~~(i * l)), c = new Float64Array(l), f = new Float64Array(l), d = new Float64Array(l).fill(1);
  for (let h = -1; ++h <= bk; ) {
    const g = [0, u - 1];
    for (let m = 0; m < l; ++m) {
      const y = r[m], b = g[0], v = g[1], w = y - r[b] > r[v] - y ? b : v;
      let _ = 0, S = 0, E = 0, C = 0, $ = 0;
      const N = 1 / Math.abs(r[w] - y || 1);
      for (let O = b; O <= v; ++O) {
        const F = r[O], x = s[O], k = Y7(Math.abs(y - F) * N) * d[O], A = F * k;
        _ += k, S += A, E += x * k, C += x * A, $ += F * A;
      }
      const [T, L] = td(S / _, E / _, C / _, $ / _);
      c[m] = T + L * y, f[m] = Math.abs(s[m] - c[m]), X7(r, m + 1, g);
    }
    if (h === bk)
      break;
    const p = bF(f);
    if (Math.abs(p) < vk)
      break;
    for (let m = 0, y, b; m < l; ++m)
      y = f[m] / (6 * p), d[m] = y >= 1 ? vk : (b = 1 - y * y) * b;
  }
  return K7(r, c, o, a);
}
function Y7(e) {
  return (e = 1 - e * e * e) * e * e;
}
function X7(e, t, n) {
  const i = e[t];
  let r = n[0], s = n[1] + 1;
  if (!(s >= e.length))
    for (; t > r && e[s] - i <= i - e[r]; )
      n[0] = ++r, n[1] = s, ++s;
}
function K7(e, t, n, i) {
  const r = e.length, s = [];
  let o = 0, a = 0, l = [], u;
  for (; o < r; ++o)
    u = e[o] + n, l[0] === u ? l[1] += (t[o] - l[1]) / ++a : (a = 0, l[1] += i, l = [u, t[o]], s.push(l));
  return l[1] += i, s;
}
const J7 = 0.5 * Math.PI / 180;
function om(e, t, n, i) {
  n = n || 25, i = Math.max(n, i || 200);
  const r = (p) => [p, e(p)], s = t[0], o = t[1], a = o - s, l = a / i, u = [r(s)], c = [];
  if (n === i) {
    for (let p = 1; p < i; ++p)
      u.push(r(s + p / n * a));
    return u.push(r(o)), u;
  } else {
    c.push(r(o));
    for (let p = n; --p > 0; )
      c.push(r(s + p / n * a));
  }
  let f = u[0], d = c[c.length - 1];
  const h = 1 / a, g = Q7(f[1], c);
  for (; d; ) {
    const p = r((f[0] + d[0]) / 2);
    p[0] - f[0] >= l && Z7(f, p, d, h, g) > J7 ? c.push(p) : (f = d, u.push(d), c.pop()), d = c[c.length - 1];
  }
  return u;
}
function Q7(e, t) {
  let n = e, i = e;
  const r = t.length;
  for (let s = 0; s < r; ++s) {
    const o = t[s][1];
    o < n && (n = o), o > i && (i = o);
  }
  return 1 / (i - n);
}
function Z7(e, t, n, i, r) {
  const s = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])), o = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
  return Math.abs(s - o);
}
function eB(e) {
  return (t) => {
    const n = e.length;
    let i = 1, r = String(e[0](t));
    for (; i < n; ++i)
      r += "|" + e[i](t);
    return r;
  };
}
function Uy(e) {
  return !e || !e.length ? function() {
    return "";
  } : e.length === 1 ? e[0] : eB(e);
}
function DT(e, t, n) {
  return n || e + (t ? "_" + t : "");
}
const s1 = () => {
}, tB = {
  init: s1,
  add: s1,
  rem: s1,
  idx: 0
}, Ef = {
  values: {
    init: (e) => e.cell.store = !0,
    value: (e) => e.cell.data.values(),
    idx: -1
  },
  count: {
    value: (e) => e.cell.num
  },
  __count__: {
    value: (e) => e.missing + e.valid
  },
  missing: {
    value: (e) => e.missing
  },
  valid: {
    value: (e) => e.valid
  },
  sum: {
    init: (e) => e.sum = 0,
    value: (e) => e.valid ? e.sum : void 0,
    add: (e, t) => e.sum += +t,
    rem: (e, t) => e.sum -= t
  },
  product: {
    init: (e) => e.product = 1,
    value: (e) => e.valid ? e.product : void 0,
    add: (e, t) => e.product *= t,
    rem: (e, t) => e.product /= t
  },
  mean: {
    init: (e) => e.mean = 0,
    value: (e) => e.valid ? e.mean : void 0,
    add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
    rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
  },
  average: {
    value: (e) => e.valid ? e.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (e) => e.dev = 0,
    value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
    add: (e, t) => e.dev += e.mean_d * (t - e.mean),
    rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (e) => e.valid > 1 ? e.dev / e.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (e) => e.cell.data.distinct(e.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (e) => e.cell.data.ci0(e.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (e) => e.cell.data.ci1(e.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (e) => e.cell.data.q2(e.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (e) => e.cell.data.q1(e.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (e) => e.cell.data.q3(e.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (e) => e.min = void 0,
    value: (e) => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
    add: (e, t) => {
      (t < e.min || e.min === void 0) && (e.min = t);
    },
    rem: (e, t) => {
      t <= e.min && (e.min = NaN);
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (e) => e.max = void 0,
    value: (e) => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
    add: (e, t) => {
      (t > e.max || e.max === void 0) && (e.max = t);
    },
    rem: (e, t) => {
      t >= e.max && (e.max = NaN);
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (e) => e.argmin = void 0,
    value: (e) => e.argmin || e.cell.data.argmin(e.get),
    add: (e, t, n) => {
      t < e.min && (e.argmin = n);
    },
    rem: (e, t) => {
      t <= e.min && (e.argmin = void 0);
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (e) => e.argmax = void 0,
    value: (e) => e.argmax || e.cell.data.argmax(e.get),
    add: (e, t, n) => {
      t > e.max && (e.argmax = n);
    },
    rem: (e, t) => {
      t >= e.max && (e.argmax = void 0);
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (e, t) => {
      e.exp = 0, e.exp_r = t;
    },
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) / (1 - e.exp_r ** e.valid) : void 0,
    add: (e, t) => e.exp = e.exp_r * e.exp + t,
    rem: (e, t) => e.exp = (e.exp - t / e.exp_r ** (e.valid - 1)) / e.exp_r
  },
  exponentialb: {
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
}, id = Object.keys(Ef).filter((e) => e !== "__count__");
function nB(e, t) {
  return (n, i) => we({
    name: e,
    aggregate_param: i,
    out: n || e
  }, tB, t);
}
[...id, "__count__"].forEach((e) => {
  Ef[e] = nB(e, Ef[e]);
});
function RT(e, t, n) {
  return Ef[e](n, t);
}
function LT(e, t) {
  return e.idx - t.idx;
}
function iB(e) {
  const t = {};
  e.forEach((i) => t[i.name] = i);
  const n = (i) => {
    i.req && i.req.forEach((r) => {
      t[r] || n(t[r] = Ef[r]());
    });
  };
  return e.forEach(n), Object.values(t).sort(LT);
}
function rB() {
  this.valid = 0, this.missing = 0, this._ops.forEach((e) => e.aggregate_param == null ? e.init(this) : e.init(this, e.aggregate_param));
}
function sB(e, t) {
  if (e == null || e === "") {
    ++this.missing;
    return;
  }
  e === e && (++this.valid, this._ops.forEach((n) => n.add(this, e, t)));
}
function oB(e, t) {
  if (e == null || e === "") {
    --this.missing;
    return;
  }
  e === e && (--this.valid, this._ops.forEach((n) => n.rem(this, e, t)));
}
function aB(e) {
  return this._out.forEach((t) => e[t.out] = t.value(this)), e;
}
function PT(e, t) {
  const n = t || on, i = iB(e), r = e.slice().sort(LT);
  function s(o) {
    this._ops = i, this._out = r, this.cell = o, this.init();
  }
  return s.prototype.init = rB, s.prototype.add = sB, s.prototype.rem = oB, s.prototype.set = aB, s.prototype.get = n, s.fields = e.map((o) => o.out), s;
}
function Rx(e) {
  this._key = e ? _i(e) : le, this.reset();
}
const Ht = Rx.prototype;
Ht.reset = function() {
  this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
};
Ht.add = function(e) {
  this._add.push(e);
};
Ht.rem = function(e) {
  this._rem.push(e);
};
Ht.values = function() {
  if (this._get = null, this._rem.length === 0)
    return this._add;
  const e = this._add, t = this._rem, n = this._key, i = e.length, r = t.length, s = Array(i - r), o = {};
  let a, l, u;
  for (a = 0; a < r; ++a)
    o[n(t[a])] = 1;
  for (a = 0, l = 0; a < i; ++a)
    o[n(u = e[a])] ? o[n(u)] = 0 : s[l++] = u;
  return this._rem = [], this._add = s;
};
Ht.distinct = function(e) {
  const t = this.values(), n = {};
  let i = t.length, r = 0, s;
  for (; --i >= 0; )
    s = e(t[i]) + "", ce(n, s) || (n[s] = 1, ++r);
  return r;
};
Ht.extent = function(e) {
  if (this._get !== e || !this._ext) {
    const t = this.values(), n = Z3(t, e);
    this._ext = [t[n[0]], t[n[1]]], this._get = e;
  }
  return this._ext;
};
Ht.argmin = function(e) {
  return this.extent(e)[0] || {};
};
Ht.argmax = function(e) {
  return this.extent(e)[1] || {};
};
Ht.min = function(e) {
  const t = this.extent(e)[0];
  return t != null ? e(t) : void 0;
};
Ht.max = function(e) {
  const t = this.extent(e)[1];
  return t != null ? e(t) : void 0;
};
Ht.quartile = function(e) {
  return (this._get !== e || !this._q) && (this._q = vx(this.values(), e), this._get = e), this._q;
};
Ht.q1 = function(e) {
  return this.quartile(e)[0];
};
Ht.q2 = function(e) {
  return this.quartile(e)[1];
};
Ht.q3 = function(e) {
  return this.quartile(e)[2];
};
Ht.ci = function(e) {
  return (this._get !== e || !this._ci) && (this._ci = ET(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
};
Ht.ci0 = function(e) {
  return this.ci(e)[0];
};
Ht.ci1 = function(e) {
  return this.ci(e)[1];
};
function go(e) {
  P.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
}
go.Definition = {
  type: "Aggregate",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: id
  }, {
    name: "aggregate_params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "drop",
    type: "boolean",
    default: !0
  }, {
    name: "cross",
    type: "boolean",
    default: !1
  }, {
    name: "key",
    type: "field"
  }]
};
Y(go, P, {
  transform(e, t) {
    const n = this, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.modified();
    return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (s) => n.add(s))) : (n.value = n.value || n.init(e), t.visit(t.REM, (s) => n.rem(s)), t.visit(t.ADD, (s) => n.add(s))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i);
  },
  cross() {
    const e = this, t = e.value, n = e._dnames, i = n.map(() => ({})), r = n.length;
    function s(a) {
      let l, u, c, f;
      for (l in a)
        for (c = a[l].tuple, u = 0; u < r; ++u)
          i[u][f = c[n[u]]] = f;
    }
    s(e._prev), s(t);
    function o(a, l, u) {
      const c = n[u], f = i[u++];
      for (const d in f) {
        const h = a ? a + "|" + d : d;
        l[c] = f[d], u < r ? o(h, l, u) : t[h] || e.cell(h, l);
      }
    }
    o("", {}, 0);
  },
  init(e) {
    const t = this._inputs = [], n = this._outputs = [], i = {};
    function r(b) {
      const v = J(tn(b)), w = v.length;
      let _ = 0, S;
      for (; _ < w; ++_)
        i[S = v[_]] || (i[S] = 1, t.push(S));
    }
    this._dims = J(e.groupby), this._dnames = this._dims.map((b) => {
      const v = lt(b);
      return r(b), n.push(v), v;
    }), this.cellkey = e.key ? e.key : Uy(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
    const s = e.fields || [null], o = e.ops || ["count"], a = e.aggregate_params || [null], l = e.as || [], u = s.length, c = {};
    let f, d, h, g, p, m, y;
    for (u !== o.length && B("Unmatched number of fields and aggregate ops."), y = 0; y < u; ++y) {
      if (f = s[y], d = o[y], h = a[y] || null, f == null && d !== "count" && B("Null aggregate field specified."), p = lt(f), m = DT(d, p, l[y]), n.push(m), d === "count") {
        this._counts.push(m);
        continue;
      }
      g = c[p], g || (r(f), g = c[p] = [], g.field = f, this._measures.push(g)), d !== "count" && (this._countOnly = !1), g.push(RT(d, h, m));
    }
    return this._measures = this._measures.map((b) => PT(b, b.field)), /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: Uy(),
  cell(e, t) {
    let n = this.value[e];
    return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n;
  },
  newcell(e, t) {
    const n = {
      key: e,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[e]),
      stamp: this.stamp,
      store: !1
    };
    if (!this._countOnly) {
      const i = this._measures, r = i.length;
      n.agg = Array(r);
      for (let s = 0; s < r; ++s)
        n.agg[s] = new i[s](n);
    }
    return n.store && (n.data = new Rx()), n;
  },
  newtuple(e, t) {
    const n = this._dnames, i = this._dims, r = i.length, s = {};
    for (let o = 0; o < r; ++o)
      s[n[o]] = i[o](e);
    return t ? pT(t.tuple, s) : Be(s);
  },
  clean() {
    const e = this.value;
    for (const t in e)
      e[t].num === 0 && delete e[t];
  },
  // -- Process Tuples -----
  add(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num += 1, this._countOnly)
      return;
    n.store && n.data.add(e);
    const i = n.agg;
    for (let r = 0, s = i.length; r < s; ++r)
      i[r].add(i[r].get(e), e);
  },
  rem(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num -= 1, this._countOnly)
      return;
    n.store && n.data.rem(e);
    const i = n.agg;
    for (let r = 0, s = i.length; r < s; ++r)
      i[r].rem(i[r].get(e), e);
  },
  celltuple(e) {
    const t = e.tuple, n = this._counts;
    e.store && e.data.values();
    for (let i = 0, r = n.length; i < r; ++i)
      t[n[i]] = e.num;
    if (!this._countOnly) {
      const i = e.agg;
      for (let r = 0, s = i.length; r < s; ++r)
        i[r].set(t);
    }
    return t;
  },
  changes(e) {
    const t = this._adds, n = this._mods, i = this._prev, r = this._drop, s = e.add, o = e.rem, a = e.mod;
    let l, u, c, f;
    if (i)
      for (u in i)
        l = i[u], (!r || l.num) && o.push(l.tuple);
    for (c = 0, f = this._alen; c < f; ++c)
      s.push(this.celltuple(t[c])), t[c] = null;
    for (c = 0, f = this._mlen; c < f; ++c)
      l = n[c], (l.num === 0 && r ? o : a).push(this.celltuple(l)), n[c] = null;
    return this._alen = this._mlen = 0, this._prev = null, e;
  }
});
const lB = 1e-14;
function Lx(e) {
  P.call(this, null, e);
}
Lx.Definition = {
  type: "Bin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "anchor",
    type: "number"
  }, {
    name: "maxbins",
    type: "number",
    default: 20
  }, {
    name: "base",
    type: "number",
    default: 10
  }, {
    name: "divide",
    type: "number",
    array: !0,
    default: [5, 2]
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "span",
    type: "number"
  }, {
    name: "step",
    type: "number"
  }, {
    name: "steps",
    type: "number",
    array: !0
  }, {
    name: "minstep",
    type: "number",
    default: 0
  }, {
    name: "nice",
    type: "boolean",
    default: !0
  }, {
    name: "name",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["bin0", "bin1"]
  }]
};
Y(Lx, P, {
  transform(e, t) {
    const n = e.interval !== !1, i = this._bins(e), r = i.start, s = i.step, o = e.as || ["bin0", "bin1"], a = o[0], l = o[1];
    let u;
    return e.modified() ? (t = t.reflow(!0), u = t.SOURCE) : u = t.modified(tn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(u, n ? (c) => {
      const f = i(c);
      c[a] = f, c[l] = f == null ? null : r + s * (1 + (f - r) / s);
    } : (c) => c[a] = i(c)), t.modifies(n ? o : a);
  },
  _bins(e) {
    if (this.value && !e.modified())
      return this.value;
    const t = e.field, n = _T(e), i = n.step;
    let r = n.start, s = r + Math.ceil((n.stop - r) / i) * i, o, a;
    (o = e.anchor) != null && (a = o - (r + i * Math.floor((o - r) / i)), r += a, s += a);
    const l = function(u) {
      let c = Qt(t(u));
      return c == null ? null : c < r ? -1 / 0 : c > s ? 1 / 0 : (c = Math.max(r, Math.min(c, s - i)), r + i * Math.floor(lB + (c - r) / i));
    };
    return l.start = r, l.stop = n.stop, l.step = i, this.value = Un(l, tn(t), e.name || "bin_" + lt(t));
  }
});
function IT(e, t, n) {
  const i = e;
  let r = t || [], s = n || [], o = {}, a = 0;
  return {
    add: (l) => s.push(l),
    remove: (l) => o[i(l)] = ++a,
    size: () => r.length,
    data: (l, u) => (a && (r = r.filter((c) => !o[i(c)]), o = {}, a = 0), u && l && r.sort(l), s.length && (r = l ? sF(l, r, s.sort(l)) : r.concat(s), s = []), r)
  };
}
function Px(e) {
  P.call(this, [], e);
}
Px.Definition = {
  type: "Collect",
  metadata: {
    source: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }]
};
Y(Px, P, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = IT(le, this.value, n.materialize(n.ADD).add), r = e.sort, s = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
    return n.visit(n.REM, i.remove), this.modified(s), this.value = n.source = i.data(el(r), s), t.source && t.source.root && (this.value.root = t.source.root), n;
  }
});
function zT(e) {
  Ye.call(this, null, uB, e);
}
Y(zT, Ye);
function uB(e) {
  return this.value && !e.modified() ? this.value : Jv(e.fields, e.orders);
}
function Ix(e) {
  P.call(this, null, e);
}
Ix.Definition = {
  type: "CountPattern",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "case",
    type: "enum",
    values: ["upper", "lower", "mixed"],
    default: "mixed"
  }, {
    name: "pattern",
    type: "string",
    default: '[\\w"]+'
  }, {
    name: "stopwords",
    type: "string",
    default: ""
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["text", "count"]
  }]
};
function cB(e, t, n) {
  switch (t) {
    case "upper":
      e = e.toUpperCase();
      break;
    case "lower":
      e = e.toLowerCase();
      break;
  }
  return e.match(n);
}
Y(Ix, P, {
  transform(e, t) {
    const n = (f) => (d) => {
      for (var h = cB(a(d), e.case, s) || [], g, p = 0, m = h.length; p < m; ++p)
        o.test(g = h[p]) || f(g);
    }, i = this._parameterCheck(e, t), r = this._counts, s = this._match, o = this._stop, a = e.field, l = e.as || ["text", "count"], u = n((f) => r[f] = 1 + (r[f] || 0)), c = n((f) => r[f] -= 1);
    return i ? t.visit(t.SOURCE, u) : (t.visit(t.ADD, u), t.visit(t.REM, c)), this._finish(t, l);
  },
  _parameterCheck(e, t) {
    let n = !1;
    return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n;
  },
  _finish(e, t) {
    const n = this._counts, i = this._tuples || (this._tuples = {}), r = t[0], s = t[1], o = e.fork(e.NO_SOURCE | e.NO_FIELDS);
    let a, l, u;
    for (a in n)
      l = i[a], u = n[a] || 0, !l && u ? (i[a] = l = Be({}), l[r] = a, l[s] = u, o.add.push(l)) : u === 0 ? (l && o.rem.push(l), n[a] = null, i[a] = null) : l[s] !== u && (l[s] = u, o.mod.push(l));
    return o.modifies(t);
  }
});
function zx(e) {
  P.call(this, null, e);
}
zx.Definition = {
  type: "Cross",
  metadata: {
    generates: !0
  },
  params: [{
    name: "filter",
    type: "expr"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["a", "b"]
  }]
};
Y(zx, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.as || ["a", "b"], r = i[0], s = i[1], o = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
    let a = this.value;
    return o ? (a && (n.rem = a), a = t.materialize(t.SOURCE).source, n.add = this.value = fB(a, r, s, e.filter || Ei)) : n.mod = a, n.source = this.value, n.modifies(i);
  }
});
function fB(e, t, n, i) {
  for (var r = [], s = {}, o = e.length, a = 0, l, u; a < o; ++a)
    for (s[t] = u = e[a], l = 0; l < o; ++l)
      s[n] = e[l], i(s) && (r.push(Be(s)), s = {}, s[t] = u);
  return r;
}
const xk = {
  kde: Ex,
  mixture: CT,
  normal: _x,
  lognormal: AT,
  uniform: $T
}, dB = "distributions", wk = "function", hB = "field";
function BT(e, t) {
  const n = e[wk];
  ce(xk, n) || B("Unknown distribution function: " + n);
  const i = xk[n]();
  for (const r in e)
    r === hB ? i.data((e.from || t()).map(e[r])) : r === dB ? i[r](e[r].map((s) => BT(s, t))) : typeof i[r] === wk && i[r](e[r]);
  return i;
}
function Bx(e) {
  P.call(this, null, e);
}
const jT = [{
  key: {
    function: "normal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "lognormal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "uniform"
  },
  params: [{
    name: "min",
    type: "number",
    default: 0
  }, {
    name: "max",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "kde"
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "from",
    type: "data"
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }]
}], gB = {
  key: {
    function: "mixture"
  },
  params: [{
    name: "distributions",
    type: "param",
    array: !0,
    params: jT
  }, {
    name: "weights",
    type: "number",
    array: !0
  }]
};
Bx.Definition = {
  type: "Density",
  metadata: {
    generates: !0
  },
  params: [{
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "method",
    type: "string",
    default: "pdf",
    values: ["pdf", "cdf"]
  }, {
    name: "distribution",
    type: "param",
    params: jT.concat(gB)
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
Y(Bx, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = BT(e.distribution, pB(t)), r = e.steps || e.minsteps || 25, s = e.steps || e.maxsteps || 200;
      let o = e.method || "pdf";
      o !== "pdf" && o !== "cdf" && B("Invalid density method: " + o), !e.extent && !i.data && B("Missing density extent parameter."), o = i[o];
      const a = e.as || ["value", "density"], l = e.extent || $r(i.data()), u = om(o, l, r, s).map((c) => {
        const f = {};
        return f[a[0]] = c[0], f[a[1]] = c[1], Be(f);
      });
      this.value && (n.rem = this.value), this.value = n.add = n.source = u;
    }
    return n;
  }
});
function pB(e) {
  return () => e.materialize(e.SOURCE).source;
}
function UT(e, t) {
  return e ? e.map((n, i) => t[i] || lt(n)) : null;
}
function jx(e, t, n) {
  const i = [], r = (f) => f(l);
  let s, o, a, l, u, c;
  if (t == null)
    i.push(e.map(n));
  else
    for (s = {}, o = 0, a = e.length; o < a; ++o)
      l = e[o], u = t.map(r), c = s[u], c || (s[u] = c = [], c.dims = u, i.push(c)), c.push(n(l));
  return i;
}
const qT = "bin";
function Ux(e) {
  P.call(this, null, e);
}
Ux.Definition = {
  type: "DotBin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "step",
    type: "number"
  }, {
    name: "smooth",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: qT
  }]
};
const mB = (e, t) => ed($r(e, t)) / 30;
Y(Ux, P, {
  transform(e, t) {
    if (this.value && !(e.modified() || t.changed()))
      return t;
    const n = t.materialize(t.SOURCE).source, i = jx(t.source, e.groupby, on), r = e.smooth || !1, s = e.field, o = e.step || mB(n, s), a = el((g, p) => s(g) - s(p)), l = e.as || qT, u = i.length;
    let c = 1 / 0, f = -1 / 0, d = 0, h;
    for (; d < u; ++d) {
      const g = i[d].sort(a);
      h = -1;
      for (const p of ST(g, o, r, s))
        p < c && (c = p), p > f && (f = p), g[++h][l] = p;
    }
    return this.value = {
      start: c,
      stop: f,
      step: o
    }, t.reflow(!0).modifies(l);
  }
});
function WT(e) {
  Ye.call(this, null, yB, e), this.modified(!0);
}
Y(WT, Ye);
function yB(e) {
  const t = e.expr;
  return this.value && !e.modified("expr") ? this.value : Un((n) => t(n, e), tn(t), lt(t));
}
function qx(e) {
  P.call(this, [void 0, void 0], e);
}
qx.Definition = {
  type: "Extent",
  metadata: {},
  params: [{
    name: "field",
    type: "field",
    required: !0
  }]
};
Y(qx, P, {
  transform(e, t) {
    const n = this.value, i = e.field, r = t.changed() || t.modified(i.fields) || e.modified("field");
    let s = n[0], o = n[1];
    if ((r || s == null) && (s = 1 / 0, o = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, (a) => {
      const l = Qt(i(a));
      l != null && (l < s && (s = l), l > o && (o = l));
    }), !Number.isFinite(s) || !Number.isFinite(o)) {
      let a = lt(i);
      a && (a = ` for field "${a}"`), t.dataflow.warn(`Infinite extent${a}: [${s}, ${o}]`), s = o = void 0;
    }
    this.value = [s, o];
  }
});
function Wx(e, t) {
  Ye.call(this, e), this.parent = t, this.count = 0;
}
Y(Wx, Ye, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(e) {
    return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(e) {
    this.count += 1, this.value.add.push(e);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(e) {
    this.count -= 1, this.value.rem.push(e);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(e) {
    this.value.mod.push(e);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(e) {
    this.value.init(e, e.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function am(e) {
  P.call(this, {}, e), this._keys = Lu();
  const t = this._targets = [];
  t.active = 0, t.forEach = (n) => {
    for (let i = 0, r = t.active; i < r; ++i)
      n(t[i], i, t);
  };
}
Y(am, P, {
  activate(e) {
    this._targets[this._targets.active++] = e;
  },
  // parent argument provided by PreFacet subclass
  subflow(e, t, n, i) {
    const r = this.value;
    let s = ce(r, e) && r[e], o, a;
    return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (a = i || (a = this._group[e]) && a.tuple, o = n.dataflow, s = new Wx(n.fork(n.NO_SOURCE), this), o.add(s).connect(t(o, e, a)), r[e] = s, this.activate(s)), s;
  },
  clean() {
    const e = this.value;
    let t = 0;
    for (const n in e)
      if (e[n].count === 0) {
        const i = e[n].detachSubflow;
        i && i(), delete e[n], ++t;
      }
    if (t) {
      const n = this._targets.filter((i) => i && i.count > 0);
      this.initTargets(n);
    }
  },
  initTargets(e) {
    const t = this._targets, n = t.length, i = e ? e.length : 0;
    let r = 0;
    for (; r < i; ++r)
      t[r] = e[r];
    for (; r < n && t[r] != null; ++r)
      t[r] = null;
    t.active = i;
  },
  transform(e, t) {
    const n = t.dataflow, i = e.key, r = e.subflow, s = this._keys, o = e.modified("key"), a = (l) => this.subflow(l, r, t);
    return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (l) => {
      const u = le(l), c = s.get(u);
      c !== void 0 && (s.delete(u), a(c).rem(l));
    }), t.visit(t.ADD, (l) => {
      const u = i(l);
      s.set(le(l), u), a(u).add(l);
    }), o || t.modified(i.fields) ? t.visit(t.MOD, (l) => {
      const u = le(l), c = s.get(u), f = i(l);
      c === f ? a(f).mod(l) : (s.set(u, f), a(c).rem(l), a(f).add(l));
    }) : t.changed(t.MOD) && t.visit(t.MOD, (l) => {
      a(s.get(le(l))).mod(l);
    }), o && t.visit(t.REFLOW, (l) => {
      const u = le(l), c = s.get(u), f = i(l);
      c !== f && (s.set(u, f), a(c).rem(l), a(f).add(l));
    }), t.clean() ? n.runAfter(() => {
      this.clean(), s.clean();
    }) : s.empty > n.cleanThreshold && n.runAfter(s.clean), t;
  }
});
function HT(e) {
  Ye.call(this, null, bB, e);
}
Y(HT, Ye);
function bB(e) {
  return this.value && !e.modified() ? this.value : j(e.name) ? J(e.name).map((t) => _i(t)) : _i(e.name, e.as);
}
function Hx(e) {
  P.call(this, Lu(), e);
}
Hx.Definition = {
  type: "Filter",
  metadata: {
    changes: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }]
};
Y(Hx, P, {
  transform(e, t) {
    const n = t.dataflow, i = this.value, r = t.fork(), s = r.add, o = r.rem, a = r.mod, l = e.expr;
    let u = !0;
    t.visit(t.REM, (f) => {
      const d = le(f);
      i.has(d) ? i.delete(d) : o.push(f);
    }), t.visit(t.ADD, (f) => {
      l(f, e) ? s.push(f) : i.set(le(f), 1);
    });
    function c(f) {
      const d = le(f), h = l(f, e), g = i.get(d);
      h && g ? (i.delete(d), s.push(f)) : !h && !g ? (i.set(d, 1), o.push(f)) : u && h && !g && a.push(f);
    }
    return t.visit(t.MOD, c), e.modified() && (u = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r;
  }
});
function Gx(e) {
  P.call(this, [], e);
}
Gx.Definition = {
  type: "Flatten",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "index",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Y(Gx, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = UT(i, e.as || []), s = e.index || null, o = r.length;
    return n.rem = this.value, t.visit(t.SOURCE, (a) => {
      const l = i.map((g) => g(a)), u = l.reduce((g, p) => Math.max(g, p.length), 0);
      let c = 0, f, d, h;
      for (; c < u; ++c) {
        for (d = px(a), f = 0; f < o; ++f)
          d[r[f]] = (h = l[f][c]) == null ? null : h;
        s && (d[s] = c), n.add.push(d);
      }
    }), this.value = n.source = n.add, s && n.modifies(s), n.modifies(r);
  }
});
function Vx(e) {
  P.call(this, [], e);
}
Vx.Definition = {
  type: "Fold",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["key", "value"]
  }]
};
Y(Vx, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = i.map(lt), s = e.as || ["key", "value"], o = s[0], a = s[1], l = i.length;
    return n.rem = this.value, t.visit(t.SOURCE, (u) => {
      for (let c = 0, f; c < l; ++c)
        f = px(u), f[o] = r[c], f[a] = i[c](u), n.add.push(f);
    }), this.value = n.source = n.add, n.modifies(s);
  }
});
function Yx(e) {
  P.call(this, null, e);
}
Yx.Definition = {
  type: "Formula",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }, {
    name: "as",
    type: "string",
    required: !0
  }, {
    name: "initonly",
    type: "boolean"
  }]
};
Y(Yx, P, {
  transform(e, t) {
    const n = e.expr, i = e.as, r = e.modified(), s = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
    return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(s, (o) => o[i] = n(o, e));
  }
});
function GT(e) {
  P.call(this, [], e);
}
Y(GT, P, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = e.generator;
    let r = this.value, s = e.size - r.length, o, a, l;
    if (s > 0) {
      for (o = []; --s >= 0; )
        o.push(l = Be(i(e))), r.push(l);
      n.add = n.add.length ? n.materialize(n.ADD).add.concat(o) : o;
    } else
      a = r.slice(0, -s), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(a) : a, r = r.slice(-s);
    return n.source = this.value = r, n;
  }
});
const Vd = {
  value: "value",
  median: bF,
  mean: e9,
  min: Ty,
  max: va
}, vB = [];
function Xx(e) {
  P.call(this, [], e);
}
Xx.Definition = {
  type: "Impute",
  metadata: {
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "keyvals",
    array: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "enum",
    default: "value",
    values: ["value", "mean", "median", "max", "min"]
  }, {
    name: "value",
    default: 0
  }]
};
function xB(e) {
  var t = e.method || Vd.value, n;
  if (Vd[t] == null)
    B("Unrecognized imputation method: " + t);
  else
    return t === Vd.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : Vd[t];
}
function wB(e) {
  const t = e.field;
  return (n) => n ? t(n) : NaN;
}
Y(Xx, P, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = xB(e), r = wB(e), s = lt(e.field), o = lt(e.key), a = (e.groupby || []).map(lt), l = _B(t.source, e.groupby, e.key, e.keyvals), u = [], c = this.value, f = l.domain.length, d, h, g, p, m, y, b, v, w, _;
    for (m = 0, v = l.length; m < v; ++m)
      for (d = l[m], g = d.values, h = NaN, b = 0; b < f; ++b)
        if (d[b] == null) {
          for (p = l.domain[b], _ = {
            _impute: !0
          }, y = 0, w = g.length; y < w; ++y)
            _[a[y]] = g[y];
          _[o] = p, _[s] = Number.isNaN(h) ? h = i(d, r) : h, u.push(Be(_));
        }
    return u.length && (n.add = n.materialize(n.ADD).add.concat(u)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = u, n;
  }
});
function _B(e, t, n, i) {
  var r = (y) => y(m), s = [], o = i ? i.slice() : [], a = {}, l = {}, u, c, f, d, h, g, p, m;
  for (o.forEach((y, b) => a[y] = b + 1), d = 0, p = e.length; d < p; ++d)
    m = e[d], g = n(m), h = a[g] || (a[g] = o.push(g)), c = (u = t ? t.map(r) : vB) + "", (f = l[c]) || (f = l[c] = [], s.push(f), f.values = u), f[h - 1] = m;
  return s.domain = o, s;
}
function Kx(e) {
  go.call(this, e);
}
Kx.Definition = {
  type: "JoinAggregate",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: id
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "key",
    type: "field"
  }]
};
Y(Kx, go, {
  transform(e, t) {
    const n = this, i = e.modified();
    let r;
    return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, (s) => n.add(s))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, (s) => n.rem(s)), t.visit(t.ADD, (s) => n.add(s))), n.changes(), t.visit(t.SOURCE, (s) => {
      we(s, r[n.cellkey(s)].tuple);
    }), t.reflow(i).modifies(this._outputs);
  },
  changes() {
    const e = this._adds, t = this._mods;
    let n, i;
    for (n = 0, i = this._alen; n < i; ++n)
      this.celltuple(e[n]), e[n] = null;
    for (n = 0, i = this._mlen; n < i; ++n)
      this.celltuple(t[n]), t[n] = null;
    this._alen = this._mlen = 0;
  }
});
function Jx(e) {
  P.call(this, null, e);
}
Jx.Definition = {
  type: "KDE",
  metadata: {
    generates: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "cumulative",
    type: "boolean",
    default: !1
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
Y(Jx, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = jx(i, e.groupby, e.field), s = (e.groupby || []).map(lt), o = e.bandwidth, a = e.cumulative ? "cdf" : "pdf", l = e.as || ["value", "density"], u = [];
      let c = e.extent, f = e.steps || e.minsteps || 25, d = e.steps || e.maxsteps || 200;
      a !== "pdf" && a !== "cdf" && B("Invalid density method: " + a), e.resolve === "shared" && (c || (c = $r(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
        const g = Ex(h, o)[a], p = e.counts ? h.length : 1, m = c || $r(h);
        om(g, m, f, d).forEach((y) => {
          const b = {};
          for (let v = 0; v < s.length; ++v)
            b[s[v]] = h.dims[v];
          b[l[0]] = y[0], b[l[1]] = y[1] * p, u.push(Be(b));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = u;
    }
    return n;
  }
});
function VT(e) {
  Ye.call(this, null, EB, e);
}
Y(VT, Ye);
function EB(e) {
  return this.value && !e.modified() ? this.value : Zv(e.fields, e.flat);
}
function YT(e) {
  P.call(this, [], e), this._pending = null;
}
Y(YT, P, {
  transform(e, t) {
    const n = t.dataflow;
    return this._pending ? o1(this, t, this._pending) : SB(e) ? t.StopPropagation : e.values ? o1(this, t, n.parse(e.values, e.format)) : e.async ? {
      async: n.request(e.url, e.format).then((r) => (this._pending = J(r.data), (s) => s.touch(this)))
    } : n.request(e.url, e.format).then((i) => o1(this, t, J(i.data)));
  }
});
function SB(e) {
  return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
}
function o1(e, t, n) {
  n.forEach(Be);
  const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
  return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i;
}
function Qx(e) {
  P.call(this, {}, e);
}
Qx.Definition = {
  type: "Lookup",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "index",
    type: "index",
    params: [{
      name: "from",
      type: "data",
      required: !0
    }, {
      name: "key",
      type: "field",
      required: !0
    }]
  }, {
    name: "values",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0
  }, {
    name: "default",
    default: null
  }]
};
Y(Qx, P, {
  transform(e, t) {
    const n = e.fields, i = e.index, r = e.values, s = e.default == null ? null : e.default, o = e.modified(), a = n.length;
    let l = o ? t.SOURCE : t.ADD, u = t, c = e.as, f, d, h;
    return r ? (d = r.length, a > 1 && !c && B('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== a * d && B('The "as" parameter has too few output field names.'), c = c || r.map(lt), f = function(g) {
      for (var p = 0, m = 0, y, b; p < a; ++p)
        if (b = i.get(n[p](g)), b == null)
          for (y = 0; y < d; ++y, ++m)
            g[c[m]] = s;
        else
          for (y = 0; y < d; ++y, ++m)
            g[c[m]] = r[y](b);
    }) : (c || B("Missing output field names."), f = function(g) {
      for (var p = 0, m; p < a; ++p)
        m = i.get(n[p](g)), g[c[p]] = m ?? s;
    }), o ? u = t.reflow(!0) : (h = n.some((g) => t.modified(g.fields)), l |= h ? t.MOD : 0), t.visit(l, f), u.modifies(c);
  }
});
function XT(e) {
  Ye.call(this, null, kB, e);
}
Y(XT, Ye);
function kB(e) {
  if (this.value && !e.modified())
    return this.value;
  const t = e.extents, n = t.length;
  let i = 1 / 0, r = -1 / 0, s, o;
  for (s = 0; s < n; ++s)
    o = t[s], o[0] < i && (i = o[0]), o[1] > r && (r = o[1]);
  return [i, r];
}
function KT(e) {
  Ye.call(this, null, AB, e);
}
Y(KT, Ye);
function AB(e) {
  return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
}
function JT(e) {
  P.call(this, null, e);
}
Y(JT, P, {
  transform(e, t) {
    return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function Zx(e) {
  go.call(this, e);
}
Zx.Definition = {
  type: "Pivot",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "value",
    type: "field",
    required: !0
  }, {
    name: "op",
    type: "enum",
    values: id,
    default: "sum"
  }, {
    name: "limit",
    type: "number",
    default: 0
  }, {
    name: "key",
    type: "field"
  }]
};
Y(Zx, go, {
  _transform: go.prototype.transform,
  transform(e, t) {
    return this._transform(CB(e, t), t);
  }
});
function CB(e, t) {
  const n = e.field, i = e.value, r = (e.op === "count" ? "__count__" : e.op) || "sum", s = tn(n).concat(tn(i)), o = MB(n, e.limit || 0, t);
  return t.changed() && e.set("__pivot__", null, null, !0), {
    key: e.key,
    groupby: e.groupby,
    ops: o.map(() => r),
    fields: o.map((a) => $B(a, n, i, s)),
    as: o.map((a) => a + ""),
    modified: e.modified.bind(e)
  };
}
function $B(e, t, n, i) {
  return Un((r) => t(r) === e ? n(r) : NaN, i, e + "");
}
function MB(e, t, n) {
  const i = {}, r = [];
  return n.visit(n.SOURCE, (s) => {
    const o = e(s);
    i[o] || (i[o] = 1, r.push(o));
  }), r.sort(qp), t ? r.slice(0, t) : r;
}
function QT(e) {
  am.call(this, e);
}
Y(QT, am, {
  transform(e, t) {
    const n = e.subflow, i = e.field, r = (s) => this.subflow(le(s), n, t, s);
    return (e.modified("field") || i && t.modified(tn(i))) && B("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (s) => {
      const o = r(s);
      i(s).forEach((a) => o.mod(a));
    }), t.visit(t.ADD, (s) => {
      const o = r(s);
      i(s).forEach((a) => o.add(Be(a)));
    }), t.visit(t.REM, (s) => {
      const o = r(s);
      i(s).forEach((a) => o.rem(a));
    })) : (t.visit(t.MOD, (s) => r(s).mod(s)), t.visit(t.ADD, (s) => r(s).add(s)), t.visit(t.REM, (s) => r(s).rem(s))), t.clean() && t.runAfter(() => this.clean()), t;
  }
});
function e2(e) {
  P.call(this, null, e);
}
e2.Definition = {
  type: "Project",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }]
};
Y(e2, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = UT(e.fields, e.as || []), s = i ? (a, l) => FB(a, l, i, r) : Zp;
    let o;
    return this.value ? o = this.value : (t = t.addAll(), o = this.value = {}), t.visit(t.REM, (a) => {
      const l = le(a);
      n.rem.push(o[l]), o[l] = null;
    }), t.visit(t.ADD, (a) => {
      const l = s(a, Be({}));
      o[le(a)] = l, n.add.push(l);
    }), t.visit(t.MOD, (a) => {
      n.mod.push(s(a, o[le(a)]));
    }), n;
  }
});
function FB(e, t, n, i) {
  for (let r = 0, s = n.length; r < s; ++r)
    t[i[r]] = n[r](e);
  return t;
}
function ZT(e) {
  P.call(this, null, e);
}
Y(ZT, P, {
  transform(e, t) {
    return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function t2(e) {
  P.call(this, null, e);
}
t2.Definition = {
  type: "Quantile",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "probs",
    type: "number",
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 0.01
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["prob", "value"]
  }]
};
const TB = 1e-14;
Y(t2, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.as || ["prob", "value"];
    if (this.value && !e.modified() && !t.changed())
      return n.source = this.value, n;
    const r = t.materialize(t.SOURCE).source, s = jx(r, e.groupby, e.field), o = (e.groupby || []).map(lt), a = [], l = e.step || 0.01, u = e.probs || Xn(l / 2, 1 - TB, l), c = u.length;
    return s.forEach((f) => {
      const d = bx(f, u);
      for (let h = 0; h < c; ++h) {
        const g = {};
        for (let p = 0; p < o.length; ++p)
          g[o[p]] = f.dims[p];
        g[i[0]] = u[h], g[i[1]] = d[h], a.push(Be(g));
      }
    }), this.value && (n.rem = this.value), this.value = n.add = n.source = a, n;
  }
});
function e5(e) {
  P.call(this, null, e);
}
Y(e5, P, {
  transform(e, t) {
    let n, i;
    return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (r) => {
      const s = le(r);
      n.rem.push(i[s]), i[s] = null;
    }), t.visit(t.ADD, (r) => {
      const s = px(r);
      i[le(r)] = s, n.add.push(s);
    }), t.visit(t.MOD, (r) => {
      const s = i[le(r)];
      for (const o in r)
        s[o] = r[o], n.modifies(o);
      n.mod.push(s);
    })), n;
  }
});
function n2(e) {
  P.call(this, [], e), this.count = 0;
}
n2.Definition = {
  type: "Sample",
  metadata: {},
  params: [{
    name: "size",
    type: "number",
    default: 1e3
  }]
};
Y(n2, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.modified("size"), r = e.size, s = this.value.reduce((c, f) => (c[le(f)] = 1, c), {});
    let o = this.value, a = this.count, l = 0;
    function u(c) {
      let f, d;
      o.length < r ? o.push(c) : (d = ~~((a + 1) * ki()), d < o.length && d >= l && (f = o[d], s[le(f)] && n.rem.push(f), o[d] = c)), ++a;
    }
    if (t.rem.length && (t.visit(t.REM, (c) => {
      const f = le(c);
      s[f] && (s[f] = -1, n.rem.push(c)), --a;
    }), o = o.filter((c) => s[le(c)] !== -1)), (t.rem.length || i) && o.length < r && t.source && (l = a = o.length, t.visit(t.SOURCE, (c) => {
      s[le(c)] || u(c);
    }), l = -1), i && o.length > r) {
      const c = o.length - r;
      for (let f = 0; f < c; ++f)
        s[le(o[f])] = -1, n.rem.push(o[f]);
      o = o.slice(c);
    }
    return t.mod.length && t.visit(t.MOD, (c) => {
      s[le(c)] && n.mod.push(c);
    }), t.add.length && t.visit(t.ADD, u), (t.add.length || l < 0) && (n.add = o.filter((c) => !s[le(c)])), this.count = a, this.value = n.source = o, n;
  }
});
function i2(e) {
  P.call(this, null, e);
}
i2.Definition = {
  type: "Sequence",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "start",
    type: "number",
    required: !0
  }, {
    name: "stop",
    type: "number",
    required: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "as",
    type: "string",
    default: "data"
  }]
};
Y(i2, P, {
  transform(e, t) {
    if (this.value && !e.modified())
      return;
    const n = t.materialize().fork(t.MOD), i = e.as || "data";
    return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = Xn(e.start, e.stop, e.step || 1).map((r) => {
      const s = {};
      return s[i] = r, Be(s);
    }), n.add = t.add.concat(this.value), n;
  }
});
function t5(e) {
  P.call(this, null, e), this.modified(!0);
}
Y(t5, P, {
  transform(e, t) {
    return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function r2(e) {
  P.call(this, null, e);
}
const n5 = ["unit0", "unit1"];
r2.Definition = {
  type: "TimeUnit",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "units",
    type: "enum",
    values: ox,
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "maxbins",
    type: "number",
    default: 40
  }, {
    name: "extent",
    type: "date",
    array: !0
  }, {
    name: "timezone",
    type: "enum",
    default: "local",
    values: ["local", "utc"]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: n5
  }]
};
Y(r2, P, {
  transform(e, t) {
    const n = e.field, i = e.interval !== !1, r = e.timezone === "utc", s = this._floor(e, t), o = (r ? ju : Bu)(s.unit).offset, a = e.as || n5, l = a[0], u = a[1], c = s.step;
    let f = s.start || 1 / 0, d = s.stop || -1 / 0, h = t.ADD;
    return (e.modified() || t.changed(t.REM) || t.modified(tn(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (g) => {
      const p = n(g);
      let m, y;
      p == null ? (g[l] = null, i && (g[u] = null)) : (g[l] = m = y = s(p), i && (g[u] = y = o(m, c)), m < f && (f = m), y > d && (d = y));
    }), s.start = f, s.stop = d, t.modifies(i ? a : l);
  },
  _floor(e, t) {
    const n = e.timezone === "utc", {
      units: i,
      step: r
    } = e.units ? {
      units: e.units,
      step: e.step || 1
    } : GF({
      extent: e.extent || $r(t.materialize(t.SOURCE).source, e.field),
      maxbins: e.maxbins
    }), s = ax(i), o = this.value || {}, a = (n ? PF : LF)(s, r);
    return a.unit = Oe(s), a.units = s, a.step = r, a.start = o.start, a.stop = o.stop, this.value = a;
  }
});
function i5(e) {
  P.call(this, Lu(), e);
}
Y(i5, P, {
  transform(e, t) {
    const n = t.dataflow, i = e.field, r = this.value, s = (a) => r.set(i(a), a);
    let o = !0;
    return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, s)) : t.changed() ? (t.visit(t.REM, (a) => r.delete(i(a))), t.visit(t.ADD, s)) : o = !1, this.modified(o), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork();
  }
});
function r5(e) {
  P.call(this, null, e);
}
Y(r5, P, {
  transform(e, t) {
    (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(el(e.sort)) : t.source).map(e.field));
  }
});
function OB(e, t, n, i) {
  const r = Sf[e](t, n);
  return {
    init: r.init || Xs,
    update: function(s, o) {
      o[i] = r.next(s);
    }
  };
}
const Sf = {
  row_number: function() {
    return {
      next: (e) => e.index + 1
    };
  },
  rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e;
      }
    };
  },
  dense_rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? ++e : e;
      }
    };
  },
  percent_rank: function() {
    const e = Sf.rank(), t = e.next;
    return {
      init: e.init,
      next: (n) => (t(n) - 1) / (n.data.length - 1)
    };
  },
  cume_dist: function() {
    let e;
    return {
      init: () => e = 0,
      next: (t) => {
        const n = t.data, i = t.compare;
        let r = t.index;
        if (e < r) {
          for (; r + 1 < n.length && !i(n[r], n[r + 1]); )
            ++r;
          e = r;
        }
        return (1 + e) / n.length;
      }
    };
  },
  ntile: function(e, t) {
    t = +t, t > 0 || B("ntile num must be greater than zero.");
    const n = Sf.cume_dist(), i = n.next;
    return {
      init: n.init,
      next: (r) => Math.ceil(t * i(r))
    };
  },
  lag: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index - t;
        return i >= 0 ? e(n.data[i]) : null;
      }
    };
  },
  lead: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index + t, r = n.data;
        return i < r.length ? e(r[i]) : null;
      }
    };
  },
  first_value: function(e) {
    return {
      next: (t) => e(t.data[t.i0])
    };
  },
  last_value: function(e) {
    return {
      next: (t) => e(t.data[t.i1 - 1])
    };
  },
  nth_value: function(e, t) {
    return t = +t, t > 0 || B("nth_value nth must be greater than zero."), {
      next: (n) => {
        const i = n.i0 + (t - 1);
        return i < n.i1 ? e(n.data[i]) : null;
      }
    };
  },
  prev_value: function(e) {
    let t;
    return {
      init: () => t = null,
      next: (n) => {
        const i = e(n.data[n.index]);
        return i != null ? t = i : t;
      }
    };
  },
  next_value: function(e) {
    let t, n;
    return {
      init: () => (t = null, n = -1),
      next: (i) => {
        const r = i.data;
        return i.index <= n ? t : (n = NB(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n]);
      }
    };
  }
};
function NB(e, t, n) {
  for (let i = t.length; n < i; ++n)
    if (e(t[n]) != null)
      return n;
  return -1;
}
const DB = Object.keys(Sf);
function s5(e) {
  const t = J(e.ops), n = J(e.fields), i = J(e.params), r = J(e.aggregate_params), s = J(e.as), o = this.outputs = [], a = this.windows = [], l = {}, u = {}, c = [], f = [];
  let d = !0;
  function h(g) {
    J(tn(g)).forEach((p) => l[p] = 1);
  }
  h(e.sort), t.forEach((g, p) => {
    const m = n[p], y = i[p], b = r[p] || null, v = lt(m), w = DT(g, v, s[p]);
    if (h(m), o.push(w), ce(Sf, g))
      a.push(OB(g, m, y, w));
    else {
      if (m == null && g !== "count" && B("Null aggregate field specified."), g === "count") {
        c.push(w);
        return;
      }
      d = !1;
      let _ = u[v];
      _ || (_ = u[v] = [], _.field = m, f.push(_)), _.push(RT(g, b, w));
    }
  }), (c.length || f.length) && (this.cell = RB(f, c, d)), this.inputs = Object.keys(l);
}
const o5 = s5.prototype;
o5.init = function() {
  this.windows.forEach((e) => e.init()), this.cell && this.cell.init();
};
o5.update = function(e, t) {
  const n = this.cell, i = this.windows, r = e.data, s = i && i.length;
  let o;
  if (n) {
    for (o = e.p0; o < e.i0; ++o)
      n.rem(r[o]);
    for (o = e.p1; o < e.i1; ++o)
      n.add(r[o]);
    n.set(t);
  }
  for (o = 0; o < s; ++o)
    i[o].update(e, t);
};
function RB(e, t, n) {
  e = e.map((l) => PT(l, l.field));
  const i = {
    num: 0,
    agg: null,
    store: !1,
    count: t
  };
  if (!n)
    for (var r = e.length, s = i.agg = Array(r), o = 0; o < r; ++o)
      s[o] = new e[o](i);
  if (i.store)
    var a = i.data = new Rx();
  return i.add = function(l) {
    if (i.num += 1, !n) {
      a && a.add(l);
      for (let u = 0; u < r; ++u)
        s[u].add(s[u].get(l), l);
    }
  }, i.rem = function(l) {
    if (i.num -= 1, !n) {
      a && a.rem(l);
      for (let u = 0; u < r; ++u)
        s[u].rem(s[u].get(l), l);
    }
  }, i.set = function(l) {
    let u, c;
    for (a && a.values(), u = 0, c = t.length; u < c; ++u)
      l[t[u]] = i.num;
    if (!n)
      for (u = 0, c = s.length; u < c; ++u)
        s[u].set(l);
  }, i.init = function() {
    i.num = 0, a && a.reset();
    for (let l = 0; l < r; ++l)
      s[l].init();
  }, i;
}
function s2(e) {
  P.call(this, {}, e), this._mlen = 0, this._mods = [];
}
s2.Definition = {
  type: "Window",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: DB.concat(id)
  }, {
    name: "params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "aggregate_params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "frame",
    type: "number",
    null: !0,
    array: !0,
    length: 2,
    default: [null, 0]
  }, {
    name: "ignorePeers",
    type: "boolean",
    default: !1
  }]
};
Y(s2, P, {
  transform(e, t) {
    this.stamp = t.stamp;
    const n = e.modified(), i = el(e.sort), r = Uy(e.groupby), s = (a) => this.group(r(a));
    let o = this.state;
    (!o || n) && (o = this.state = new s5(e)), n || t.modified(o.inputs) ? (this.value = {}, t.visit(t.SOURCE, (a) => s(a).add(a))) : (t.visit(t.REM, (a) => s(a).remove(a)), t.visit(t.ADD, (a) => s(a).add(a)));
    for (let a = 0, l = this._mlen; a < l; ++a)
      LB(this._mods[a], o, i, e);
    return this._mlen = 0, this._mods = [], t.reflow(n).modifies(o.outputs);
  },
  group(e) {
    let t = this.value[e];
    return t || (t = this.value[e] = IT(le), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
  }
});
function LB(e, t, n, i) {
  const r = i.sort, s = r && !i.ignorePeers, o = i.frame || [null, 0], a = e.data(n), l = a.length, u = s ? Pu(r) : null, c = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: a,
    compare: r || an(-1)
  };
  t.init();
  for (let f = 0; f < l; ++f)
    PB(c, o, f, l), s && IB(c, u), t.update(c, a[f]);
}
function PB(e, t, n, i) {
  e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n;
}
function IB(e, t) {
  const n = e.i0, i = e.i1 - 1, r = e.compare, s = e.data, o = s.length - 1;
  n > 0 && !r(s[n], s[n - 1]) && (e.i0 = t.left(s, s[n])), i < o && !r(s[i], s[i + 1]) && (e.i1 = t.right(s, s[i]));
}
const zB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aggregate: go,
  bin: Lx,
  collect: Px,
  compare: zT,
  countpattern: Ix,
  cross: zx,
  density: Bx,
  dotbin: Ux,
  expression: WT,
  extent: qx,
  facet: am,
  field: HT,
  filter: Hx,
  flatten: Gx,
  fold: Vx,
  formula: Yx,
  generate: GT,
  impute: Xx,
  joinaggregate: Kx,
  kde: Jx,
  key: VT,
  load: YT,
  lookup: Qx,
  multiextent: XT,
  multivalues: KT,
  params: JT,
  pivot: Zx,
  prefacet: QT,
  project: e2,
  proxy: ZT,
  quantile: t2,
  relay: e5,
  sample: n2,
  sequence: i2,
  sieve: t5,
  subflow: Wx,
  timeunit: r2,
  tupleindex: i5,
  values: r5,
  window: s2
}, Symbol.toStringTag, { value: "Module" }));
function je(e) {
  return function() {
    return e;
  };
}
const _k = Math.abs, Gt = Math.atan2, Go = Math.cos, BB = Math.max, a1 = Math.min, cr = Math.sin, ha = Math.sqrt, Yt = 1e-12, su = Math.PI, hg = su / 2, a5 = 2 * su;
function jB(e) {
  return e > 1 ? 0 : e < -1 ? su : Math.acos(e);
}
function Ek(e) {
  return e >= 1 ? hg : e <= -1 ? -hg : Math.asin(e);
}
const qy = Math.PI, Wy = 2 * qy, ra = 1e-6, UB = Wy - ra;
function l5(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function qB(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return l5;
  const n = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * n) / n + i[r];
  };
}
let o2 = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? l5 : qB(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, i, r) {
    this._append`Q${+t},${+n},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, i, r, s, o) {
    this._append`C${+t},${+n},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, n, i, r, s) {
    if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = i - t, u = r - n, c = o - t, f = a - n, d = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (d > ra)
      if (!(Math.abs(f * l - u * c) > ra) || !s)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let h = i - o, g = r - a, p = l * l + u * u, m = h * h + g * g, y = Math.sqrt(p), b = Math.sqrt(d), v = s * Math.tan((qy - Math.acos((p + d - m) / (2 * y * b))) / 2), w = v / b, _ = v / y;
        Math.abs(w - 1) > ra && this._append`L${t + w * c},${n + w * f}`, this._append`A${s},${s},0,0,${+(f * h > c * g)},${this._x1 = t + _ * l},${this._y1 = n + _ * u}`;
      }
  }
  arc(t, n, i, r, s, o) {
    if (t = +t, n = +n, i = +i, o = !!o, i < 0)
      throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), l = i * Math.sin(r), u = t + a, c = n + l, f = 1 ^ o, d = o ? r - s : s - r;
    this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > ra || Math.abs(this._y1 - c) > ra) && this._append`L${u},${c}`, i && (d < 0 && (d = d % Wy + Wy), d > UB ? this._append`A${i},${i},0,1,${f},${t - a},${n - l}A${i},${i},0,1,${f},${this._x1 = u},${this._y1 = c}` : d > ra && this._append`A${i},${i},0,${+(d >= qy)},${f},${this._x1 = t + i * Math.cos(s)},${this._y1 = n + i * Math.sin(s)}`);
  }
  rect(t, n, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
};
function lm() {
  return new o2();
}
lm.prototype = o2.prototype;
function um(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const i = Math.floor(n);
      if (!(i >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = i;
    }
    return e;
  }, () => new o2(t);
}
function WB(e) {
  return e.innerRadius;
}
function HB(e) {
  return e.outerRadius;
}
function GB(e) {
  return e.startAngle;
}
function VB(e) {
  return e.endAngle;
}
function YB(e) {
  return e && e.padAngle;
}
function XB(e, t, n, i, r, s, o, a) {
  var l = n - e, u = i - t, c = o - r, f = a - s, d = f * l - c * u;
  if (!(d * d < Yt))
    return d = (c * (t - s) - f * (e - r)) / d, [e + d * l, t + d * u];
}
function Yd(e, t, n, i, r, s, o) {
  var a = e - n, l = t - i, u = (o ? s : -s) / ha(a * a + l * l), c = u * l, f = -u * a, d = e + c, h = t + f, g = n + c, p = i + f, m = (d + g) / 2, y = (h + p) / 2, b = g - d, v = p - h, w = b * b + v * v, _ = r - s, S = d * p - g * h, E = (v < 0 ? -1 : 1) * ha(BB(0, _ * _ * w - S * S)), C = (S * v - b * E) / w, $ = (-S * b - v * E) / w, N = (S * v + b * E) / w, T = (-S * b + v * E) / w, L = C - m, O = $ - y, F = N - m, x = T - y;
  return L * L + O * O > F * F + x * x && (C = N, $ = T), {
    cx: C,
    cy: $,
    x01: -c,
    y01: -f,
    x11: C * (r / _ - 1),
    y11: $ * (r / _ - 1)
  };
}
function KB() {
  var e = WB, t = HB, n = je(0), i = null, r = GB, s = VB, o = YB, a = null, l = um(u);
  function u() {
    var c, f, d = +e.apply(this, arguments), h = +t.apply(this, arguments), g = r.apply(this, arguments) - hg, p = s.apply(this, arguments) - hg, m = _k(p - g), y = p > g;
    if (a || (a = c = l()), h < d && (f = h, h = d, d = f), !(h > Yt))
      a.moveTo(0, 0);
    else if (m > a5 - Yt)
      a.moveTo(h * Go(g), h * cr(g)), a.arc(0, 0, h, g, p, !y), d > Yt && (a.moveTo(d * Go(p), d * cr(p)), a.arc(0, 0, d, p, g, y));
    else {
      var b = g, v = p, w = g, _ = p, S = m, E = m, C = o.apply(this, arguments) / 2, $ = C > Yt && (i ? +i.apply(this, arguments) : ha(d * d + h * h)), N = a1(_k(h - d) / 2, +n.apply(this, arguments)), T = N, L = N, O, F;
      if ($ > Yt) {
        var x = Ek($ / d * cr(C)), k = Ek($ / h * cr(C));
        (S -= x * 2) > Yt ? (x *= y ? 1 : -1, w += x, _ -= x) : (S = 0, w = _ = (g + p) / 2), (E -= k * 2) > Yt ? (k *= y ? 1 : -1, b += k, v -= k) : (E = 0, b = v = (g + p) / 2);
      }
      var A = h * Go(b), M = h * cr(b), D = d * Go(_), R = d * cr(_);
      if (N > Yt) {
        var U = h * Go(v), W = h * cr(v), ne = d * Go(w), Z = d * cr(w), re;
        if (m < su)
          if (re = XB(A, M, ne, Z, U, W, D, R)) {
            var Ce = A - re[0], Et = M - re[1], ln = U - re[0], te = W - re[1], ye = 1 / cr(jB((Ce * ln + Et * te) / (ha(Ce * Ce + Et * Et) * ha(ln * ln + te * te))) / 2), ve = ha(re[0] * re[0] + re[1] * re[1]);
            T = a1(N, (d - ve) / (ye - 1)), L = a1(N, (h - ve) / (ye + 1));
          } else
            T = L = 0;
      }
      E > Yt ? L > Yt ? (O = Yd(ne, Z, A, M, h, L, y), F = Yd(U, W, D, R, h, L, y), a.moveTo(O.cx + O.x01, O.cy + O.y01), L < N ? a.arc(O.cx, O.cy, L, Gt(O.y01, O.x01), Gt(F.y01, F.x01), !y) : (a.arc(O.cx, O.cy, L, Gt(O.y01, O.x01), Gt(O.y11, O.x11), !y), a.arc(0, 0, h, Gt(O.cy + O.y11, O.cx + O.x11), Gt(F.cy + F.y11, F.cx + F.x11), !y), a.arc(F.cx, F.cy, L, Gt(F.y11, F.x11), Gt(F.y01, F.x01), !y))) : (a.moveTo(A, M), a.arc(0, 0, h, b, v, !y)) : a.moveTo(A, M), !(d > Yt) || !(S > Yt) ? a.lineTo(D, R) : T > Yt ? (O = Yd(D, R, U, W, d, -T, y), F = Yd(A, M, ne, Z, d, -T, y), a.lineTo(O.cx + O.x01, O.cy + O.y01), T < N ? a.arc(O.cx, O.cy, T, Gt(O.y01, O.x01), Gt(F.y01, F.x01), !y) : (a.arc(O.cx, O.cy, T, Gt(O.y01, O.x01), Gt(O.y11, O.x11), !y), a.arc(0, 0, d, Gt(O.cy + O.y11, O.cx + O.x11), Gt(F.cy + F.y11, F.cx + F.x11), y), a.arc(F.cx, F.cy, T, Gt(F.y11, F.x11), Gt(F.y01, F.x01), !y))) : a.arc(0, 0, d, _, w, y);
    }
    if (a.closePath(), c)
      return a = null, c + "" || null;
  }
  return u.centroid = function() {
    var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, f = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - su / 2;
    return [Go(f) * c, cr(f) * c];
  }, u.innerRadius = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : je(+c), u) : e;
  }, u.outerRadius = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : je(+c), u) : t;
  }, u.cornerRadius = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : je(+c), u) : n;
  }, u.padRadius = function(c) {
    return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : je(+c), u) : i;
  }, u.startAngle = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : je(+c), u) : r;
  }, u.endAngle = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : je(+c), u) : s;
  }, u.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : je(+c), u) : o;
  }, u.context = function(c) {
    return arguments.length ? (a = c ?? null, u) : a;
  }, u;
}
function u5(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function c5(e) {
  this._context = e;
}
c5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function a2(e) {
  return new c5(e);
}
function f5(e) {
  return e[0];
}
function d5(e) {
  return e[1];
}
function h5(e, t) {
  var n = je(!0), i = null, r = a2, s = null, o = um(a);
  e = typeof e == "function" ? e : e === void 0 ? f5 : je(e), t = typeof t == "function" ? t : t === void 0 ? d5 : je(t);
  function a(l) {
    var u, c = (l = u5(l)).length, f, d = !1, h;
    for (i == null && (s = r(h = o())), u = 0; u <= c; ++u)
      !(u < c && n(f = l[u], u, l)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+e(f, u, l), +t(f, u, l));
    if (h)
      return s = null, h + "" || null;
  }
  return a.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : je(+l), a) : e;
  }, a.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : je(+l), a) : t;
  }, a.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : je(!!l), a) : n;
  }, a.curve = function(l) {
    return arguments.length ? (r = l, i != null && (s = r(i)), a) : r;
  }, a.context = function(l) {
    return arguments.length ? (l == null ? i = s = null : s = r(i = l), a) : i;
  }, a;
}
function g5(e, t, n) {
  var i = null, r = je(!0), s = null, o = a2, a = null, l = um(u);
  e = typeof e == "function" ? e : e === void 0 ? f5 : je(+e), t = typeof t == "function" ? t : je(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? d5 : je(+n);
  function u(f) {
    var d, h, g, p = (f = u5(f)).length, m, y = !1, b, v = new Array(p), w = new Array(p);
    for (s == null && (a = o(b = l())), d = 0; d <= p; ++d) {
      if (!(d < p && r(m = f[d], d, f)) === y)
        if (y = !y)
          h = d, a.areaStart(), a.lineStart();
        else {
          for (a.lineEnd(), a.lineStart(), g = d - 1; g >= h; --g)
            a.point(v[g], w[g]);
          a.lineEnd(), a.areaEnd();
        }
      y && (v[d] = +e(m, d, f), w[d] = +t(m, d, f), a.point(i ? +i(m, d, f) : v[d], n ? +n(m, d, f) : w[d]));
    }
    if (b)
      return a = null, b + "" || null;
  }
  function c() {
    return h5().defined(r).curve(o).context(s);
  }
  return u.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : je(+f), i = null, u) : e;
  }, u.x0 = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : je(+f), u) : e;
  }, u.x1 = function(f) {
    return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : je(+f), u) : i;
  }, u.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : je(+f), n = null, u) : t;
  }, u.y0 = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : je(+f), u) : t;
  }, u.y1 = function(f) {
    return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : je(+f), u) : n;
  }, u.lineX0 = u.lineY0 = function() {
    return c().x(e).y(t);
  }, u.lineY1 = function() {
    return c().x(e).y(n);
  }, u.lineX1 = function() {
    return c().x(i).y(t);
  }, u.defined = function(f) {
    return arguments.length ? (r = typeof f == "function" ? f : je(!!f), u) : r;
  }, u.curve = function(f) {
    return arguments.length ? (o = f, s != null && (a = o(s)), u) : o;
  }, u.context = function(f) {
    return arguments.length ? (f == null ? s = a = null : a = o(s = f), u) : s;
  }, u;
}
const JB = {
  draw(e, t) {
    const n = ha(t / su);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, a5);
  }
};
function QB(e, t) {
  let n = null, i = um(r);
  e = typeof e == "function" ? e : je(e || JB), t = typeof t == "function" ? t : je(t === void 0 ? 64 : +t);
  function r() {
    let s;
    if (n || (n = s = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), s)
      return n = null, s + "" || null;
  }
  return r.type = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : je(s), r) : e;
  }, r.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : je(+s), r) : t;
  }, r.context = function(s) {
    return arguments.length ? (n = s ?? null, r) : n;
  }, r;
}
function po() {
}
function gg(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function cm(e) {
  this._context = e;
}
cm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        gg(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        gg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function ZB(e) {
  return new cm(e);
}
function p5(e) {
  this._context = e;
}
p5.prototype = {
  areaStart: po,
  areaEnd: po,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        gg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function ej(e) {
  return new p5(e);
}
function m5(e) {
  this._context = e;
}
m5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
        break;
      case 3:
        this._point = 4;
      default:
        gg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function tj(e) {
  return new m5(e);
}
function y5(e, t) {
  this._basis = new cm(e), this._beta = t;
}
y5.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var i = e[0], r = t[0], s = e[n] - i, o = t[n] - r, a = -1, l; ++a <= n; )
        l = a / n, this._basis.point(
          this._beta * e[a] + (1 - this._beta) * (i + l * s),
          this._beta * t[a] + (1 - this._beta) * (r + l * o)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const nj = function e(t) {
  function n(i) {
    return t === 1 ? new cm(i) : new y5(i, t);
  }
  return n.beta = function(i) {
    return e(+i);
  }, n;
}(0.85);
function pg(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function l2(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
l2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        pg(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        pg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const ij = function e(t) {
  function n(i) {
    return new l2(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function u2(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
u2.prototype = {
  areaStart: po,
  areaEnd: po,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        pg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const rj = function e(t) {
  function n(i) {
    return new u2(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function c2(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
c2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        pg(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const sj = function e(t) {
  function n(i) {
    return new c2(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function f2(e, t, n) {
  var i = e._x1, r = e._y1, s = e._x2, o = e._y2;
  if (e._l01_a > Yt) {
    var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    i = (i * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, r = (r * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > Yt) {
    var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, c = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * u + e._x1 * e._l23_2a - t * e._l12_2a) / c, o = (o * u + e._y1 * e._l23_2a - n * e._l12_2a) / c;
  }
  e._context.bezierCurveTo(i, r, s, o, e._x2, e._y2);
}
function b5(e, t) {
  this._context = e, this._alpha = t;
}
b5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        f2(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const oj = function e(t) {
  function n(i) {
    return t ? new b5(i, t) : new l2(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function v5(e, t) {
  this._context = e, this._alpha = t;
}
v5.prototype = {
  areaStart: po,
  areaEnd: po,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        f2(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const aj = function e(t) {
  function n(i) {
    return t ? new v5(i, t) : new u2(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function x5(e, t) {
  this._context = e, this._alpha = t;
}
x5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        f2(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const lj = function e(t) {
  function n(i) {
    return t ? new x5(i, t) : new c2(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function w5(e) {
  this._context = e;
}
w5.prototype = {
  areaStart: po,
  areaEnd: po,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function uj(e) {
  return new w5(e);
}
function Sk(e) {
  return e < 0 ? -1 : 1;
}
function kk(e, t, n) {
  var i = e._x1 - e._x0, r = t - e._x1, s = (e._y1 - e._y0) / (i || r < 0 && -0), o = (n - e._y1) / (r || i < 0 && -0), a = (s * r + o * i) / (i + r);
  return (Sk(s) + Sk(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
}
function Ak(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function l1(e, t, n) {
  var i = e._x0, r = e._y0, s = e._x1, o = e._y1, a = (s - i) / 3;
  e._context.bezierCurveTo(i + a, r + a * t, s - a, o - a * n, s, o);
}
function mg(e) {
  this._context = e;
}
mg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        l1(this, this._t0, Ak(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, l1(this, Ak(this, n = kk(this, e, t)), n);
          break;
        default:
          l1(this, this._t0, n = kk(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function _5(e) {
  this._context = new E5(e);
}
(_5.prototype = Object.create(mg.prototype)).point = function(e, t) {
  mg.prototype.point.call(this, t, e);
};
function E5(e) {
  this._context = e;
}
E5.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, i, r, s) {
    this._context.bezierCurveTo(t, e, i, n, s, r);
  }
};
function cj(e) {
  return new mg(e);
}
function fj(e) {
  return new _5(e);
}
function S5(e) {
  this._context = e;
}
S5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var i = Ck(e), r = Ck(t), s = 0, o = 1; o < n; ++s, ++o)
          this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[o], t[o]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Ck(e) {
  var t, n = e.length - 1, i, r = new Array(n), s = new Array(n), o = new Array(n);
  for (r[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    r[t] = 1, s[t] = 4, o[t] = 4 * e[t] + 2 * e[t + 1];
  for (r[n - 1] = 2, s[n - 1] = 7, o[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    i = r[t] / s[t - 1], s[t] -= i, o[t] -= i * o[t - 1];
  for (r[n - 1] = o[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
    r[t] = (o[t] - r[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
    s[t] = 2 * e[t + 1] - r[t + 1];
  return [r, s];
}
function dj(e) {
  return new S5(e);
}
function fm(e, t) {
  this._context = e, this._t = t;
}
fm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function hj(e) {
  return new fm(e, 0.5);
}
function gj(e) {
  return new fm(e, 0);
}
function pj(e) {
  return new fm(e, 1);
}
function lo(e, t) {
  if (typeof document < "u" && document.createElement) {
    const n = document.createElement("canvas");
    if (n && n.getContext)
      return n.width = e, n.height = t, n;
  }
  return null;
}
const mj = () => typeof Image < "u" ? Image : null;
function Ir(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Oo(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const Hy = Symbol("implicit");
function d2() {
  var e = new WS(), t = [], n = [], i = Hy;
  function r(s) {
    let o = e.get(s);
    if (o === void 0) {
      if (i !== Hy)
        return i;
      e.set(s, o = t.push(s) - 1);
    }
    return n[o % n.length];
  }
  return r.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new WS();
    for (const o of s)
      e.has(o) || e.set(o, t.push(o) - 1);
    return r;
  }, r.range = function(s) {
    return arguments.length ? (n = Array.from(s), r) : n.slice();
  }, r.unknown = function(s) {
    return arguments.length ? (i = s, r) : i;
  }, r.copy = function() {
    return d2(t, n).unknown(i);
  }, Ir.apply(r, arguments), r;
}
function qu(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function rd(e, t) {
  var n = Object.create(e.prototype);
  for (var i in t)
    n[i] = t[i];
  return n;
}
function No() {
}
var Ma = 0.7, ou = 1 / Ma, Ul = "\\s*([+-]?\\d+)\\s*", kf = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", wr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", yj = /^#([0-9a-f]{3,8})$/, bj = new RegExp(`^rgb\\(${Ul},${Ul},${Ul}\\)$`), vj = new RegExp(`^rgb\\(${wr},${wr},${wr}\\)$`), xj = new RegExp(`^rgba\\(${Ul},${Ul},${Ul},${kf}\\)$`), wj = new RegExp(`^rgba\\(${wr},${wr},${wr},${kf}\\)$`), _j = new RegExp(`^hsl\\(${kf},${wr},${wr}\\)$`), Ej = new RegExp(`^hsla\\(${kf},${wr},${wr},${kf}\\)$`), $k = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
qu(No, Af, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Mk,
  // Deprecated! Use color.formatHex.
  formatHex: Mk,
  formatHex8: Sj,
  formatHsl: kj,
  formatRgb: Fk,
  toString: Fk
});
function Mk() {
  return this.rgb().formatHex();
}
function Sj() {
  return this.rgb().formatHex8();
}
function kj() {
  return k5(this).formatHsl();
}
function Fk() {
  return this.rgb().formatRgb();
}
function Af(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = yj.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Tk(t) : n === 3 ? new $t(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Xd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Xd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = bj.exec(e)) ? new $t(t[1], t[2], t[3], 1) : (t = vj.exec(e)) ? new $t(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = xj.exec(e)) ? Xd(t[1], t[2], t[3], t[4]) : (t = wj.exec(e)) ? Xd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = _j.exec(e)) ? Dk(t[1], t[2] / 100, t[3] / 100, 1) : (t = Ej.exec(e)) ? Dk(t[1], t[2] / 100, t[3] / 100, t[4]) : $k.hasOwnProperty(e) ? Tk($k[e]) : e === "transparent" ? new $t(NaN, NaN, NaN, 0) : null;
}
function Tk(e) {
  return new $t(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Xd(e, t, n, i) {
  return i <= 0 && (e = t = n = NaN), new $t(e, t, n, i);
}
function h2(e) {
  return e instanceof No || (e = Af(e)), e ? (e = e.rgb(), new $t(e.r, e.g, e.b, e.opacity)) : new $t();
}
function mo(e, t, n, i) {
  return arguments.length === 1 ? h2(e) : new $t(e, t, n, i ?? 1);
}
function $t(e, t, n, i) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
}
qu($t, mo, rd(No, {
  brighter(e) {
    return e = e == null ? ou : Math.pow(ou, e), new $t(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ma : Math.pow(Ma, e), new $t(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new $t(xa(this.r), xa(this.g), xa(this.b), yg(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ok,
  // Deprecated! Use color.formatHex.
  formatHex: Ok,
  formatHex8: Aj,
  formatRgb: Nk,
  toString: Nk
}));
function Ok() {
  return `#${ga(this.r)}${ga(this.g)}${ga(this.b)}`;
}
function Aj() {
  return `#${ga(this.r)}${ga(this.g)}${ga(this.b)}${ga((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Nk() {
  const e = yg(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${xa(this.r)}, ${xa(this.g)}, ${xa(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function yg(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function xa(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function ga(e) {
  return e = xa(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Dk(e, t, n, i) {
  return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ji(e, t, n, i);
}
function k5(e) {
  if (e instanceof ji)
    return new ji(e.h, e.s, e.l, e.opacity);
  if (e instanceof No || (e = Af(e)), !e)
    return new ji();
  if (e instanceof ji)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.min(t, n, i), s = Math.max(t, n, i), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (t === s ? o = (n - i) / a + (n < i) * 6 : n === s ? o = (i - t) / a + 2 : o = (t - n) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new ji(o, a, l, e.opacity);
}
function bg(e, t, n, i) {
  return arguments.length === 1 ? k5(e) : new ji(e, t, n, i ?? 1);
}
function ji(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
qu(ji, bg, rd(No, {
  brighter(e) {
    return e = e == null ? ou : Math.pow(ou, e), new ji(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ma : Math.pow(Ma, e), new ji(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - i;
    return new $t(
      u1(e >= 240 ? e - 240 : e + 120, r, i),
      u1(e, r, i),
      u1(e < 120 ? e + 240 : e - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new ji(Rk(this.h), Kd(this.s), Kd(this.l), yg(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = yg(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Rk(this.h)}, ${Kd(this.s) * 100}%, ${Kd(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Rk(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Kd(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function u1(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const A5 = Math.PI / 180, C5 = 180 / Math.PI, vg = 18, $5 = 0.96422, M5 = 1, F5 = 0.82521, T5 = 4 / 29, ql = 6 / 29, O5 = 3 * ql * ql, Cj = ql * ql * ql;
function N5(e) {
  if (e instanceof _r)
    return new _r(e.l, e.a, e.b, e.opacity);
  if (e instanceof cs)
    return D5(e);
  e instanceof $t || (e = h2(e));
  var t = h1(e.r), n = h1(e.g), i = h1(e.b), r = c1((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / M5), s, o;
  return t === n && n === i ? s = o = r : (s = c1((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / $5), o = c1((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / F5)), new _r(116 * r - 16, 500 * (s - r), 200 * (r - o), e.opacity);
}
function xg(e, t, n, i) {
  return arguments.length === 1 ? N5(e) : new _r(e, t, n, i ?? 1);
}
function _r(e, t, n, i) {
  this.l = +e, this.a = +t, this.b = +n, this.opacity = +i;
}
qu(_r, xg, rd(No, {
  brighter(e) {
    return new _r(this.l + vg * (e ?? 1), this.a, this.b, this.opacity);
  },
  darker(e) {
    return new _r(this.l - vg * (e ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
    return t = $5 * f1(t), e = M5 * f1(e), n = F5 * f1(n), new $t(
      d1(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
      d1(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
      d1(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
      this.opacity
    );
  }
}));
function c1(e) {
  return e > Cj ? Math.pow(e, 1 / 3) : e / O5 + T5;
}
function f1(e) {
  return e > ql ? e * e * e : O5 * (e - T5);
}
function d1(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function h1(e) {
  return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function $j(e) {
  if (e instanceof cs)
    return new cs(e.h, e.c, e.l, e.opacity);
  if (e instanceof _r || (e = N5(e)), e.a === 0 && e.b === 0)
    return new cs(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
  var t = Math.atan2(e.b, e.a) * C5;
  return new cs(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function wg(e, t, n, i) {
  return arguments.length === 1 ? $j(e) : new cs(e, t, n, i ?? 1);
}
function cs(e, t, n, i) {
  this.h = +e, this.c = +t, this.l = +n, this.opacity = +i;
}
function D5(e) {
  if (isNaN(e.h))
    return new _r(e.l, 0, 0, e.opacity);
  var t = e.h * A5;
  return new _r(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
qu(cs, wg, rd(No, {
  brighter(e) {
    return new cs(this.h, this.c, this.l + vg * (e ?? 1), this.opacity);
  },
  darker(e) {
    return new cs(this.h, this.c, this.l - vg * (e ?? 1), this.opacity);
  },
  rgb() {
    return D5(this).rgb();
  }
}));
var R5 = -0.14861, g2 = 1.78277, p2 = -0.29227, dm = -0.90649, Cf = 1.97294, Lk = Cf * dm, Pk = Cf * g2, Ik = g2 * p2 - dm * R5;
function Mj(e) {
  if (e instanceof wa)
    return new wa(e.h, e.s, e.l, e.opacity);
  e instanceof $t || (e = h2(e));
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = (Ik * i + Lk * t - Pk * n) / (Ik + Lk - Pk), s = i - r, o = (Cf * (n - r) - p2 * s) / dm, a = Math.sqrt(o * o + s * s) / (Cf * r * (1 - r)), l = a ? Math.atan2(o, s) * C5 - 120 : NaN;
  return new wa(l < 0 ? l + 360 : l, a, r, e.opacity);
}
function Gy(e, t, n, i) {
  return arguments.length === 1 ? Mj(e) : new wa(e, t, n, i ?? 1);
}
function wa(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
qu(wa, Gy, rd(No, {
  brighter(e) {
    return e = e == null ? ou : Math.pow(ou, e), new wa(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ma : Math.pow(Ma, e), new wa(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * A5, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), i = Math.cos(e), r = Math.sin(e);
    return new $t(
      255 * (t + n * (R5 * i + g2 * r)),
      255 * (t + n * (p2 * i + dm * r)),
      255 * (t + n * (Cf * i)),
      this.opacity
    );
  }
}));
function L5(e, t, n, i, r) {
  var s = e * e, o = s * e;
  return ((1 - 3 * e + 3 * s - o) * t + (4 - 6 * s + 3 * o) * n + (1 + 3 * e + 3 * s - 3 * o) * i + o * r) / 6;
}
function P5(e) {
  var t = e.length - 1;
  return function(n) {
    var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), r = e[i], s = e[i + 1], o = i > 0 ? e[i - 1] : 2 * r - s, a = i < t - 1 ? e[i + 2] : 2 * s - r;
    return L5((n - i / t) * t, o, r, s, a);
  };
}
function I5(e) {
  var t = e.length;
  return function(n) {
    var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t), r = e[(i + t - 1) % t], s = e[i % t], o = e[(i + 1) % t], a = e[(i + 2) % t];
    return L5((n - i / t) * t, r, s, o, a);
  };
}
const hm = (e) => () => e;
function z5(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function Fj(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(i) {
    return Math.pow(e + i * t, n);
  };
}
function gm(e, t) {
  var n = t - e;
  return n ? z5(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : hm(isNaN(e) ? t : e);
}
function Tj(e) {
  return (e = +e) == 1 ? Mt : function(t, n) {
    return n - t ? Fj(t, n, e) : hm(isNaN(t) ? n : t);
  };
}
function Mt(e, t) {
  var n = t - e;
  return n ? z5(e, n) : hm(isNaN(e) ? t : e);
}
const Vy = function e(t) {
  var n = Tj(t);
  function i(r, s) {
    var o = n((r = mo(r)).r, (s = mo(s)).r), a = n(r.g, s.g), l = n(r.b, s.b), u = Mt(r.opacity, s.opacity);
    return function(c) {
      return r.r = o(c), r.g = a(c), r.b = l(c), r.opacity = u(c), r + "";
    };
  }
  return i.gamma = e, i;
}(1);
function B5(e) {
  return function(t) {
    var n = t.length, i = new Array(n), r = new Array(n), s = new Array(n), o, a;
    for (o = 0; o < n; ++o)
      a = mo(t[o]), i[o] = a.r || 0, r[o] = a.g || 0, s[o] = a.b || 0;
    return i = e(i), r = e(r), s = e(s), a.opacity = 1, function(l) {
      return a.r = i(l), a.g = r(l), a.b = s(l), a + "";
    };
  };
}
var Oj = B5(P5), Nj = B5(I5);
function m2(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < n; ++r)
      i[r] = e[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function j5(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function Dj(e, t) {
  return (j5(t) ? m2 : U5)(e, t);
}
function U5(e, t) {
  var n = t ? t.length : 0, i = e ? Math.min(n, e.length) : 0, r = new Array(i), s = new Array(n), o;
  for (o = 0; o < i; ++o)
    r[o] = Do(e[o], t[o]);
  for (; o < n; ++o)
    s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o)
      s[o] = r[o](a);
    return s;
  };
}
function q5(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(i) {
    return n.setTime(e * (1 - i) + t * i), n;
  };
}
function zi(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function W5(e, t) {
  var n = {}, i = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = Do(e[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in n)
      i[r] = n[r](s);
    return i;
  };
}
var Yy = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, g1 = new RegExp(Yy.source, "g");
function Rj(e) {
  return function() {
    return e;
  };
}
function Lj(e) {
  return function(t) {
    return e(t) + "";
  };
}
function H5(e, t) {
  var n = Yy.lastIndex = g1.lastIndex = 0, i, r, s, o = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (i = Yy.exec(e)) && (r = g1.exec(t)); )
    (s = r.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: zi(i, r) })), n = g1.lastIndex;
  return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? Lj(l[0].x) : Rj(t) : (t = l.length, function(u) {
    for (var c = 0, f; c < t; ++c)
      a[(f = l[c]).i] = f.x(u);
    return a.join("");
  });
}
function Do(e, t) {
  var n = typeof t, i;
  return t == null || n === "boolean" ? hm(t) : (n === "number" ? zi : n === "string" ? (i = Af(t)) ? (t = i, Vy) : H5 : t instanceof Af ? Vy : t instanceof Date ? q5 : j5(t) ? m2 : Array.isArray(t) ? U5 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? W5 : zi)(e, t);
}
function Pj(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
function Ij(e, t) {
  var n = gm(+e, +t);
  return function(i) {
    var r = n(i);
    return r - 360 * Math.floor(r / 360);
  };
}
function sd(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var zk = 180 / Math.PI, Xy = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function G5(e, t, n, i, r, s) {
  var o, a, l;
  return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (l = e * n + t * i) && (n -= e * l, i -= t * l), (a = Math.sqrt(n * n + i * i)) && (n /= a, i /= a, l /= a), e * i < t * n && (e = -e, t = -t, l = -l, o = -o), {
    translateX: r,
    translateY: s,
    rotate: Math.atan2(t, e) * zk,
    skewX: Math.atan(l) * zk,
    scaleX: o,
    scaleY: a
  };
}
var Jd;
function zj(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Xy : G5(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Bj(e) {
  return e == null || (Jd || (Jd = document.createElementNS("http://www.w3.org/2000/svg", "g")), Jd.setAttribute("transform", e), !(e = Jd.transform.baseVal.consolidate())) ? Xy : (e = e.matrix, G5(e.a, e.b, e.c, e.d, e.e, e.f));
}
function V5(e, t, n, i) {
  function r(u) {
    return u.length ? u.pop() + " " : "";
  }
  function s(u, c, f, d, h, g) {
    if (u !== f || c !== d) {
      var p = h.push("translate(", null, t, null, n);
      g.push({ i: p - 4, x: zi(u, f) }, { i: p - 2, x: zi(c, d) });
    } else
      (f || d) && h.push("translate(" + f + t + d + n);
  }
  function o(u, c, f, d) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), d.push({ i: f.push(r(f) + "rotate(", null, i) - 2, x: zi(u, c) })) : c && f.push(r(f) + "rotate(" + c + i);
  }
  function a(u, c, f, d) {
    u !== c ? d.push({ i: f.push(r(f) + "skewX(", null, i) - 2, x: zi(u, c) }) : c && f.push(r(f) + "skewX(" + c + i);
  }
  function l(u, c, f, d, h, g) {
    if (u !== f || c !== d) {
      var p = h.push(r(h) + "scale(", null, ",", null, ")");
      g.push({ i: p - 4, x: zi(u, f) }, { i: p - 2, x: zi(c, d) });
    } else
      (f !== 1 || d !== 1) && h.push(r(h) + "scale(" + f + "," + d + ")");
  }
  return function(u, c) {
    var f = [], d = [];
    return u = e(u), c = e(c), s(u.translateX, u.translateY, c.translateX, c.translateY, f, d), o(u.rotate, c.rotate, f, d), a(u.skewX, c.skewX, f, d), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, d), u = c = null, function(h) {
      for (var g = -1, p = d.length, m; ++g < p; )
        f[(m = d[g]).i] = m.x(h);
      return f.join("");
    };
  };
}
var jj = V5(zj, "px, ", "px)", "deg)"), Uj = V5(Bj, ", ", ")", ")"), qj = 1e-12;
function Bk(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Wj(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Hj(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Gj = function e(t, n, i) {
  function r(s, o) {
    var a = s[0], l = s[1], u = s[2], c = o[0], f = o[1], d = o[2], h = c - a, g = f - l, p = h * h + g * g, m, y;
    if (p < qj)
      y = Math.log(d / u) / t, m = function(E) {
        return [
          a + E * h,
          l + E * g,
          u * Math.exp(t * E * y)
        ];
      };
    else {
      var b = Math.sqrt(p), v = (d * d - u * u + i * p) / (2 * u * n * b), w = (d * d - u * u - i * p) / (2 * d * n * b), _ = Math.log(Math.sqrt(v * v + 1) - v), S = Math.log(Math.sqrt(w * w + 1) - w);
      y = (S - _) / t, m = function(E) {
        var C = E * y, $ = Bk(_), N = u / (n * b) * ($ * Hj(t * C + _) - Wj(_));
        return [
          a + N * h,
          l + N * g,
          u * $ / Bk(t * C + _)
        ];
      };
    }
    return m.duration = y * 1e3 * t / Math.SQRT2, m;
  }
  return r.rho = function(s) {
    var o = Math.max(1e-3, +s), a = o * o, l = a * a;
    return e(o, a, l);
  }, r;
}(Math.SQRT2, 2, 4);
function Y5(e) {
  return function(t, n) {
    var i = e((t = bg(t)).h, (n = bg(n)).h), r = Mt(t.s, n.s), s = Mt(t.l, n.l), o = Mt(t.opacity, n.opacity);
    return function(a) {
      return t.h = i(a), t.s = r(a), t.l = s(a), t.opacity = o(a), t + "";
    };
  };
}
const Vj = Y5(gm);
var Yj = Y5(Mt);
function Xj(e, t) {
  var n = Mt((e = xg(e)).l, (t = xg(t)).l), i = Mt(e.a, t.a), r = Mt(e.b, t.b), s = Mt(e.opacity, t.opacity);
  return function(o) {
    return e.l = n(o), e.a = i(o), e.b = r(o), e.opacity = s(o), e + "";
  };
}
function X5(e) {
  return function(t, n) {
    var i = e((t = wg(t)).h, (n = wg(n)).h), r = Mt(t.c, n.c), s = Mt(t.l, n.l), o = Mt(t.opacity, n.opacity);
    return function(a) {
      return t.h = i(a), t.c = r(a), t.l = s(a), t.opacity = o(a), t + "";
    };
  };
}
const Kj = X5(gm);
var Jj = X5(Mt);
function K5(e) {
  return function t(n) {
    n = +n;
    function i(r, s) {
      var o = e((r = Gy(r)).h, (s = Gy(s)).h), a = Mt(r.s, s.s), l = Mt(r.l, s.l), u = Mt(r.opacity, s.opacity);
      return function(c) {
        return r.h = o(c), r.s = a(c), r.l = l(Math.pow(c, n)), r.opacity = u(c), r + "";
      };
    }
    return i.gamma = t, i;
  }(1);
}
const Qj = K5(gm);
var Zj = K5(Mt);
function y2(e, t) {
  t === void 0 && (t = e, e = Do);
  for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i; )
    s[n] = e(r, r = t[++n]);
  return function(o) {
    var a = Math.max(0, Math.min(i - 1, Math.floor(o *= i)));
    return s[a](o - a);
  };
}
function eU(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e(i / (t - 1));
  return n;
}
const tU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: Do,
  interpolateArray: Dj,
  interpolateBasis: P5,
  interpolateBasisClosed: I5,
  interpolateCubehelix: Qj,
  interpolateCubehelixLong: Zj,
  interpolateDate: q5,
  interpolateDiscrete: Pj,
  interpolateHcl: Kj,
  interpolateHclLong: Jj,
  interpolateHsl: Vj,
  interpolateHslLong: Yj,
  interpolateHue: Ij,
  interpolateLab: Xj,
  interpolateNumber: zi,
  interpolateNumberArray: m2,
  interpolateObject: W5,
  interpolateRgb: Vy,
  interpolateRgbBasis: Oj,
  interpolateRgbBasisClosed: Nj,
  interpolateRound: sd,
  interpolateString: H5,
  interpolateTransformCss: jj,
  interpolateTransformSvg: Uj,
  interpolateZoom: Gj,
  piecewise: y2,
  quantize: eU
}, Symbol.toStringTag, { value: "Module" }));
function nU(e) {
  return function() {
    return e;
  };
}
function Ky(e) {
  return +e;
}
var jk = [0, 1];
function On(e) {
  return e;
}
function Jy(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : nU(isNaN(t) ? NaN : 0.5);
}
function iU(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(i) {
    return Math.max(e, Math.min(t, i));
  };
}
function rU(e, t, n) {
  var i = e[0], r = e[1], s = t[0], o = t[1];
  return r < i ? (i = Jy(r, i), s = n(o, s)) : (i = Jy(i, r), s = n(s, o)), function(a) {
    return s(i(a));
  };
}
function sU(e, t, n) {
  var i = Math.min(e.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = Jy(e[o], e[o + 1]), s[o] = n(t[o], t[o + 1]);
  return function(a) {
    var l = fo(e, a, 1, i) - 1;
    return s[l](r[l](a));
  };
}
function od(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function pm() {
  var e = jk, t = jk, n = Do, i, r, s, o = On, a, l, u;
  function c() {
    var d = Math.min(e.length, t.length);
    return o !== On && (o = iU(e[0], e[d - 1])), a = d > 2 ? sU : rU, l = u = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? s : (l || (l = a(e.map(i), t, n)))(i(o(d)));
  }
  return f.invert = function(d) {
    return o(r((u || (u = a(t, e.map(i), zi)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (e = Array.from(d, Ky), c()) : e.slice();
  }, f.range = function(d) {
    return arguments.length ? (t = Array.from(d), c()) : t.slice();
  }, f.rangeRound = function(d) {
    return t = Array.from(d), n = sd, c();
  }, f.clamp = function(d) {
    return arguments.length ? (o = d ? !0 : On, c()) : o !== On;
  }, f.interpolate = function(d) {
    return arguments.length ? (n = d, c()) : n;
  }, f.unknown = function(d) {
    return arguments.length ? (s = d, f) : s;
  }, function(d, h) {
    return i = d, r = h, c();
  };
}
function J5() {
  return pm()(On, On);
}
function Q5(e, t, n, i) {
  var r = ho(e, t, n), s;
  switch (i = $a(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(e), Math.abs(t));
      return i.precision == null && !isNaN(s = SF(r, o)) && (i.precision = s), rx(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = kF(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = EF(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return Wp(i);
}
function nl(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var i = t();
    return My(i[0], i[i.length - 1], n ?? 10);
  }, e.tickFormat = function(n, i) {
    var r = t();
    return Q5(r[0], r[r.length - 1], n ?? 10, i);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], l, u, c = 10;
    for (a < o && (u = o, o = a, a = u, u = r, r = s, s = u); c-- > 0; ) {
      if (u = Fy(o, a, n), u === l)
        return i[r] = o, i[s] = a, t(i);
      if (u > 0)
        o = Math.floor(o / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        o = Math.ceil(o * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return e;
  }, e;
}
function Z5() {
  var e = J5();
  return e.copy = function() {
    return od(e, Z5());
  }, Ir.apply(e, arguments), nl(e);
}
function eO(e) {
  var t;
  function n(i) {
    return i == null || isNaN(i = +i) ? t : i;
  }
  return n.invert = n, n.domain = n.range = function(i) {
    return arguments.length ? (e = Array.from(i, Ky), n) : e.slice();
  }, n.unknown = function(i) {
    return arguments.length ? (t = i, n) : t;
  }, n.copy = function() {
    return eO(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Ky) : [0, 1], nl(n);
}
function tO(e, t) {
  e = e.slice();
  var n = 0, i = e.length - 1, r = e[n], s = e[i], o;
  return s < r && (o = n, n = i, i = o, o = r, r = s, s = o), e[n] = t.floor(r), e[i] = t.ceil(s), e;
}
function Uk(e) {
  return Math.log(e);
}
function qk(e) {
  return Math.exp(e);
}
function oU(e) {
  return -Math.log(-e);
}
function aU(e) {
  return -Math.exp(-e);
}
function lU(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function uU(e) {
  return e === 10 ? lU : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function cU(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Wk(e) {
  return (t, n) => -e(-t, n);
}
function b2(e) {
  const t = e(Uk, qk), n = t.domain;
  let i = 10, r, s;
  function o() {
    return r = cU(i), s = uU(i), n()[0] < 0 ? (r = Wk(r), s = Wk(s), e(oU, aU)) : e(Uk, qk), t;
  }
  return t.base = function(a) {
    return arguments.length ? (i = +a, o()) : i;
  }, t.domain = function(a) {
    return arguments.length ? (n(a), o()) : n();
  }, t.ticks = (a) => {
    const l = n();
    let u = l[0], c = l[l.length - 1];
    const f = c < u;
    f && ([u, c] = [c, u]);
    let d = r(u), h = r(c), g, p;
    const m = a == null ? 10 : +a;
    let y = [];
    if (!(i % 1) && h - d < m) {
      if (d = Math.floor(d), h = Math.ceil(h), u > 0) {
        for (; d <= h; ++d)
          for (g = 1; g < i; ++g)
            if (p = d < 0 ? g / s(-d) : g * s(d), !(p < u)) {
              if (p > c)
                break;
              y.push(p);
            }
      } else
        for (; d <= h; ++d)
          for (g = i - 1; g >= 1; --g)
            if (p = d > 0 ? g / s(-d) : g * s(d), !(p < u)) {
              if (p > c)
                break;
              y.push(p);
            }
      y.length * 2 < m && (y = My(u, c, m));
    } else
      y = My(d, h, Math.min(h - d, m)).map(s);
    return f ? y.reverse() : y;
  }, t.tickFormat = (a, l) => {
    if (a == null && (a = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = $a(l)).precision == null && (l.trim = !0), l = Wp(l)), a === 1 / 0)
      return l;
    const u = Math.max(1, i * a / t.ticks().length);
    return (c) => {
      let f = c / s(Math.round(r(c)));
      return f * i < i - 0.5 && (f *= i), f <= u ? l(c) : "";
    };
  }, t.nice = () => n(tO(n(), {
    floor: (a) => s(Math.floor(r(a))),
    ceil: (a) => s(Math.ceil(r(a)))
  })), t;
}
function nO() {
  const e = b2(pm()).domain([1, 10]);
  return e.copy = () => od(e, nO()).base(e.base()), Ir.apply(e, arguments), e;
}
function Hk(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function Gk(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function v2(e) {
  var t = 1, n = e(Hk(t), Gk(t));
  return n.constant = function(i) {
    return arguments.length ? e(Hk(t = +i), Gk(t)) : t;
  }, nl(n);
}
function iO() {
  var e = v2(pm());
  return e.copy = function() {
    return od(e, iO()).constant(e.constant());
  }, Ir.apply(e, arguments);
}
function Vk(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function fU(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function dU(e) {
  return e < 0 ? -e * e : e * e;
}
function x2(e) {
  var t = e(On, On), n = 1;
  function i() {
    return n === 1 ? e(On, On) : n === 0.5 ? e(fU, dU) : e(Vk(n), Vk(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, i()) : n;
  }, nl(t);
}
function w2() {
  var e = x2(pm());
  return e.copy = function() {
    return od(e, w2()).exponent(e.exponent());
  }, Ir.apply(e, arguments), e;
}
function hU() {
  return w2.apply(null, arguments).exponent(0.5);
}
function rO() {
  var e = [], t = [], n = [], i;
  function r() {
    var o = 0, a = Math.max(1, t.length);
    for (n = new Array(a - 1); ++o < a; )
      n[o - 1] = yF(e, o / a);
    return s;
  }
  function s(o) {
    return o == null || isNaN(o = +o) ? i : t[fo(n, o)];
  }
  return s.invertExtent = function(o) {
    var a = t.indexOf(o);
    return a < 0 ? [NaN, NaN] : [
      a > 0 ? n[a - 1] : e[0],
      a < n.length ? n[a] : e[e.length - 1]
    ];
  }, s.domain = function(o) {
    if (!arguments.length)
      return e.slice();
    e = [];
    for (let a of o)
      a != null && !isNaN(a = +a) && e.push(a);
    return e.sort(hs), r();
  }, s.range = function(o) {
    return arguments.length ? (t = Array.from(o), r()) : t.slice();
  }, s.unknown = function(o) {
    return arguments.length ? (i = o, s) : i;
  }, s.quantiles = function() {
    return n.slice();
  }, s.copy = function() {
    return rO().domain(e).range(t).unknown(i);
  }, Ir.apply(s, arguments);
}
function sO() {
  var e = 0, t = 1, n = 1, i = [0.5], r = [0, 1], s;
  function o(l) {
    return l != null && l <= l ? r[fo(i, l, 0, n)] : s;
  }
  function a() {
    var l = -1;
    for (i = new Array(n); ++l < n; )
      i[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return o;
  }
  return o.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, a()) : [e, t];
  }, o.range = function(l) {
    return arguments.length ? (n = (r = Array.from(l)).length - 1, a()) : r.slice();
  }, o.invertExtent = function(l) {
    var u = r.indexOf(l);
    return u < 0 ? [NaN, NaN] : u < 1 ? [e, i[0]] : u >= n ? [i[n - 1], t] : [i[u - 1], i[u]];
  }, o.unknown = function(l) {
    return arguments.length && (s = l), o;
  }, o.thresholds = function() {
    return i.slice();
  }, o.copy = function() {
    return sO().domain([e, t]).range(r).unknown(s);
  }, Ir.apply(nl(o), arguments);
}
function oO() {
  var e = [0.5], t = [0, 1], n, i = 1;
  function r(s) {
    return s != null && s <= s ? t[fo(e, s, 0, i)] : n;
  }
  return r.domain = function(s) {
    return arguments.length ? (e = Array.from(s), i = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(s) {
    return arguments.length ? (t = Array.from(s), i = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(s) {
    var o = t.indexOf(s);
    return [e[o - 1], e[o]];
  }, r.unknown = function(s) {
    return arguments.length ? (n = s, r) : n;
  }, r.copy = function() {
    return oO().domain(e).range(t).unknown(n);
  }, Ir.apply(r, arguments);
}
function gU(e) {
  return new Date(e);
}
function pU(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function _2(e, t, n, i, r, s, o, a, l, u) {
  var c = J5(), f = c.invert, d = c.domain, h = u(".%L"), g = u(":%S"), p = u("%I:%M"), m = u("%I %p"), y = u("%a %d"), b = u("%b %d"), v = u("%B"), w = u("%Y");
  function _(S) {
    return (l(S) < S ? h : a(S) < S ? g : o(S) < S ? p : s(S) < S ? m : i(S) < S ? r(S) < S ? y : b : n(S) < S ? v : w)(S);
  }
  return c.invert = function(S) {
    return new Date(f(S));
  }, c.domain = function(S) {
    return arguments.length ? d(Array.from(S, pU)) : d().map(gU);
  }, c.ticks = function(S) {
    var E = d();
    return e(E[0], E[E.length - 1], S ?? 10);
  }, c.tickFormat = function(S, E) {
    return E == null ? _ : u(E);
  }, c.nice = function(S) {
    var E = d();
    return (!S || typeof S.range != "function") && (S = t(E[0], E[E.length - 1], S ?? 10)), S ? d(tO(E, S)) : c;
  }, c.copy = function() {
    return od(c, _2(e, t, n, i, r, s, o, a, l, u));
  }, c;
}
function mU() {
  return Ir.apply(_2(_9, E9, Mr, xf, Iu, gs, Vp, Hp, us, ux).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function yU() {
  return Ir.apply(_2(x9, w9, Fr, wf, zu, oo, Yp, Gp, us, cx).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function mm() {
  var e = 0, t = 1, n, i, r, s, o = On, a = !1, l;
  function u(f) {
    return f == null || isNaN(f = +f) ? l : o(r === 0 ? 0.5 : (f = (s(f) - n) * r, a ? Math.max(0, Math.min(1, f)) : f));
  }
  u.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = s(e = +e), i = s(t = +t), r = n === i ? 0 : 1 / (i - n), u) : [e, t];
  }, u.clamp = function(f) {
    return arguments.length ? (a = !!f, u) : a;
  }, u.interpolator = function(f) {
    return arguments.length ? (o = f, u) : o;
  };
  function c(f) {
    return function(d) {
      var h, g;
      return arguments.length ? ([h, g] = d, o = f(h, g), u) : [o(0), o(1)];
    };
  }
  return u.range = c(Do), u.rangeRound = c(sd), u.unknown = function(f) {
    return arguments.length ? (l = f, u) : l;
  }, function(f) {
    return s = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), u;
  };
}
function Ro(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function E2() {
  var e = nl(mm()(On));
  return e.copy = function() {
    return Ro(e, E2());
  }, Oo.apply(e, arguments);
}
function aO() {
  var e = b2(mm()).domain([1, 10]);
  return e.copy = function() {
    return Ro(e, aO()).base(e.base());
  }, Oo.apply(e, arguments);
}
function lO() {
  var e = v2(mm());
  return e.copy = function() {
    return Ro(e, lO()).constant(e.constant());
  }, Oo.apply(e, arguments);
}
function S2() {
  var e = x2(mm());
  return e.copy = function() {
    return Ro(e, S2()).exponent(e.exponent());
  }, Oo.apply(e, arguments);
}
function bU() {
  return S2.apply(null, arguments).exponent(0.5);
}
function ym() {
  var e = 0, t = 0.5, n = 1, i = 1, r, s, o, a, l, u = On, c, f = !1, d;
  function h(p) {
    return isNaN(p = +p) ? d : (p = 0.5 + ((p = +c(p)) - s) * (i * p < i * s ? a : l), u(f ? Math.max(0, Math.min(1, p)) : p));
  }
  h.domain = function(p) {
    return arguments.length ? ([e, t, n] = p, r = c(e = +e), s = c(t = +t), o = c(n = +n), a = r === s ? 0 : 0.5 / (s - r), l = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, h) : [e, t, n];
  }, h.clamp = function(p) {
    return arguments.length ? (f = !!p, h) : f;
  }, h.interpolator = function(p) {
    return arguments.length ? (u = p, h) : u;
  };
  function g(p) {
    return function(m) {
      var y, b, v;
      return arguments.length ? ([y, b, v] = m, u = y2(p, [y, b, v]), h) : [u(0), u(0.5), u(1)];
    };
  }
  return h.range = g(Do), h.rangeRound = g(sd), h.unknown = function(p) {
    return arguments.length ? (d = p, h) : d;
  }, function(p) {
    return c = p, r = p(e), s = p(t), o = p(n), a = r === s ? 0 : 0.5 / (s - r), l = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, h;
  };
}
function uO() {
  var e = nl(ym()(On));
  return e.copy = function() {
    return Ro(e, uO());
  }, Oo.apply(e, arguments);
}
function cO() {
  var e = b2(ym()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return Ro(e, cO()).base(e.base());
  }, Oo.apply(e, arguments);
}
function fO() {
  var e = v2(ym());
  return e.copy = function() {
    return Ro(e, fO()).constant(e.constant());
  }, Oo.apply(e, arguments);
}
function k2() {
  var e = x2(ym());
  return e.copy = function() {
    return Ro(e, k2()).exponent(e.exponent());
  }, Oo.apply(e, arguments);
}
function vU() {
  return k2.apply(null, arguments).exponent(0.5);
}
function A2(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const xU = "identity", au = "linear", _s = "log", ad = "pow", ld = "sqrt", bm = "symlog", Fa = "time", Ta = "utc", Er = "sequential", Wu = "diverging", lu = "quantile", vm = "quantize", xm = "threshold", C2 = "ordinal", Qy = "point", dO = "band", $2 = "bin-ordinal", _t = "continuous", ud = "discrete", cd = "discretizing", Mi = "interpolating", M2 = "temporal";
function wU(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function _U(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], s = -1, o, a, l, u;
    for (r < i && (a = i, i = r, r = a), l = 0, u = n.length; l < u; ++l)
      n[l] >= i && n[l] <= r && (s < 0 && (s = l), o = l);
    if (!(s < 0))
      return i = e.invertExtent(n[s]), r = e.invertExtent(n[o]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function F2() {
  const e = d2().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, s, o = !1, a = 0, l = 0, u = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], g = A2(f, a, l);
    let p = i[d - 0];
    r = (h - p) / (g || 1), o && (r = Math.floor(r)), p += (h - p - r * (f - a)) * u, s = r * (1 - a), o && (p = Math.round(p), s = Math.round(s));
    const m = Xn(f).map((y) => p + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], o = !0, c();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (o = !!f, c()) : o;
  }, e.padding = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), a = l, c()) : a;
  }, e.paddingInner = function(f) {
    return arguments.length ? (a = Math.max(0, Math.min(1, f)), c()) : a;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.align = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), g = h.length - 1;
    let p = +f[0], m = +f[1], y, b, v;
    if (!(p !== p || m !== m) && (m < p && (v = p, p = m, m = v), !(m < h[0] || p > i[1 - d])))
      return y = Math.max(0, fo(h, p) - 1), b = p === m ? y : fo(h, m) - 1, p - h[y] > s + 1e-10 && ++y, d && (v = y, y = g - b, b = g - v), y > b ? void 0 : t().slice(y, b + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return F2().domain(t()).range(i).round(o).paddingInner(a).paddingOuter(l).align(u);
  }, c();
}
function hO(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return hO(t());
  }, e;
}
function EU() {
  return hO(F2().paddingInner(1));
}
var SU = Array.prototype.map;
function kU(e) {
  return SU.call(e, Qt);
}
const AU = Array.prototype.slice;
function gO() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[(fo(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = kU(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = AU.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return Q5(e[0], Oe(e), i ?? 10, r);
  }, n.copy = function() {
    return gO().domain(n.domain()).range(n.range());
  }, n;
}
const _g = /* @__PURE__ */ new Map(), pO = Symbol("vega_scale");
function mO(e) {
  return e[pO] = !0, e;
}
function CU(e) {
  return e && e[pO] === !0;
}
function $U(e, t, n) {
  const i = function() {
    const s = t();
    return s.invertRange || (s.invertRange = s.invert ? wU(s) : s.invertExtent ? _U(s) : void 0), s.type = e, mO(s);
  };
  return i.metadata = Ji(J(n)), i;
}
function Ie(e, t, n) {
  return arguments.length > 1 ? (_g.set(e, $U(e, t, n)), this) : yO(e) ? _g.get(e) : void 0;
}
Ie(xU, eO);
Ie(au, Z5, _t);
Ie(_s, nO, [_t, _s]);
Ie(ad, w2, _t);
Ie(ld, hU, _t);
Ie(bm, iO, _t);
Ie(Fa, mU, [_t, M2]);
Ie(Ta, yU, [_t, M2]);
Ie(Er, E2, [_t, Mi]);
Ie(`${Er}-${au}`, E2, [_t, Mi]);
Ie(`${Er}-${_s}`, aO, [_t, Mi, _s]);
Ie(`${Er}-${ad}`, S2, [_t, Mi]);
Ie(`${Er}-${ld}`, bU, [_t, Mi]);
Ie(`${Er}-${bm}`, lO, [_t, Mi]);
Ie(`${Wu}-${au}`, uO, [_t, Mi]);
Ie(`${Wu}-${_s}`, cO, [_t, Mi, _s]);
Ie(`${Wu}-${ad}`, k2, [_t, Mi]);
Ie(`${Wu}-${ld}`, vU, [_t, Mi]);
Ie(`${Wu}-${bm}`, fO, [_t, Mi]);
Ie(lu, rO, [cd, lu]);
Ie(vm, sO, cd);
Ie(xm, oO, cd);
Ie($2, gO, [ud, cd]);
Ie(C2, d2, ud);
Ie(dO, F2, ud);
Ie(Qy, EU, ud);
function yO(e) {
  return _g.has(e);
}
function il(e, t) {
  const n = _g.get(e);
  return n && n.metadata[t];
}
function T2(e) {
  return il(e, _t);
}
function uu(e) {
  return il(e, ud);
}
function Zy(e) {
  return il(e, cd);
}
function bO(e) {
  return il(e, _s);
}
function MU(e) {
  return il(e, M2);
}
function vO(e) {
  return il(e, Mi);
}
function xO(e) {
  return il(e, lu);
}
const FU = ["clamp", "base", "constant", "exponent"];
function wO(e, t) {
  const n = t[0], i = Oe(t) - n;
  return function(r) {
    return e(n + r * i);
  };
}
function wm(e, t, n) {
  return y2(O2(t || "rgb", n), e);
}
function _O(e, t) {
  const n = new Array(t), i = t + 1;
  for (let r = 0; r < t; )
    n[r] = e(++r / i);
  return n;
}
function EO(e, t, n) {
  const i = n - t;
  let r, s, o;
  return !i || !Number.isFinite(i) ? an(0.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), o = Ie(s)().domain([t, n]).range([0, 1]), FU.forEach((a) => e[a] ? o[a](e[a]()) : 0), o);
}
function O2(e, t) {
  const n = tU[TU(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function TU(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const OU = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, NU = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function SO(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function kO(e, t) {
  for (const n in e)
    N2(n, t(e[n]));
}
const Yk = {};
kO(NU, SO);
kO(OU, (e) => wm(SO(e)));
function N2(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (Yk[e] = t, this) : Yk[e];
}
const Dh = "symbol", DU = "discrete", RU = "gradient", LU = (e) => j(e) ? e.map((t) => String(t)) : String(e), PU = (e, t) => e[1] - t[1], IU = (e, t) => t[1] - e[1];
function D2(e, t, n) {
  let i;
  return Re(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(ed(e.domain()) / n || 1) + 1))), ee(t) && (i = t.step, t = t.interval), Q(t) && (t = e.type === Fa ? Bu(t) : e.type == Ta ? ju(t) : B("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
}
function AO(e, t, n) {
  let i = e.range(), r = i[0], s = Oe(i), o = PU;
  if (r > s && (i = s, s = r, r = i, o = IU), r = Math.floor(r), s = Math.ceil(s), t = t.map((a) => [a, e(a)]).filter((a) => r <= a[1] && a[1] <= s).sort(o).map((a) => a[0]), n > 0 && t.length > 1) {
    const a = [t[0], Oe(t)];
    for (; t.length > n && t.length >= 3; )
      t = t.filter((l, u) => !(u % 2));
    t.length < 3 && (t = a);
  }
  return t;
}
function R2(e, t) {
  return e.bins ? AO(e, e.bins) : e.ticks ? e.ticks(t) : e.domain();
}
function CO(e, t, n, i, r, s) {
  const o = t.type;
  let a = LU;
  if (o === Fa || r === Fa)
    a = e.timeFormat(i);
  else if (o === Ta || r === Ta)
    a = e.utcFormat(i);
  else if (bO(o)) {
    const l = e.formatFloat(i);
    if (s || t.bins)
      a = l;
    else {
      const u = $O(t, n, !1);
      a = (c) => u(c) ? l(c) : "";
    }
  } else if (t.tickFormat) {
    const l = t.domain();
    a = e.formatSpan(l[0], l[l.length - 1], n, i);
  } else
    i && (a = e.format(i));
  return a;
}
function $O(e, t, n) {
  const i = R2(e, t), r = e.base(), s = Math.log(r), o = Math.max(1, r * t / i.length), a = (l) => {
    let u = l / Math.pow(r, Math.round(Math.log(l) / s));
    return u * r < r - 0.5 && (u *= r), u <= o;
  };
  return n ? i.filter(a) : a;
}
const eb = {
  [lu]: "quantiles",
  [vm]: "thresholds",
  [xm]: "domain"
}, MO = {
  [lu]: "quantiles",
  [vm]: "domain"
};
function FO(e, t) {
  return e.bins ? jU(e.bins) : e.type === _s ? $O(e, t, !0) : eb[e.type] ? BU(e[eb[e.type]]()) : R2(e, t);
}
function zU(e, t, n) {
  const i = t[MO[t.type]](), r = i.length;
  let s = r > 1 ? i[1] - i[0] : i[0], o;
  for (o = 1; o < r; ++o)
    s = Math.min(s, i[o] - i[o - 1]);
  return e.formatSpan(0, s, 3 * 10, n);
}
function BU(e) {
  const t = [-1 / 0].concat(e);
  return t.max = 1 / 0, t;
}
function jU(e) {
  const t = e.slice(0, -1);
  return t.max = Oe(e), t;
}
const UU = (e) => eb[e.type] || e.bins;
function TO(e, t, n, i, r, s, o) {
  const a = MO[t.type] && s !== Fa && s !== Ta ? zU(e, t, r) : CO(e, t, n, r, s, o);
  return i === Dh && UU(t) ? qU(a) : i === DU ? WU(a) : HU(a);
}
const qU = (e) => (t, n, i) => {
  const r = Xk(i[n + 1], Xk(i.max, 1 / 0)), s = Kk(t, e), o = Kk(r, e);
  return s && o ? s + "  " + o : o ? "< " + o : " " + s;
}, Xk = (e, t) => e ?? t, WU = (e) => (t, n) => n ? e(t) : null, HU = (e) => (t) => e(t), Kk = (e, t) => Number.isFinite(e) ? t(e) : null;
function GU(e) {
  const t = e.domain(), n = t.length - 1;
  let i = +t[0], r = +Oe(t), s = r - i;
  if (e.type === xm) {
    const o = n ? s / n : 0.1;
    i -= o, r += o, s = r - i;
  }
  return (o) => (o - i) / s;
}
function VU(e, t, n, i) {
  const r = i || t.type;
  return Q(n) && MU(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === Fa ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === Ta ? e.utcFormat("%A, %d %B %Y, %X UTC") : TO(e, t, 5, null, n, i, !0);
}
function OO(e, t, n) {
  n = n || {};
  const i = Math.max(3, n.maxlen || 7), r = VU(e, t, n.format, n.formatType);
  if (Zy(t.type)) {
    const s = FO(t).slice(1).map(r), o = s.length;
    return `${o} boundar${o === 1 ? "y" : "ies"}: ${s.join(", ")}`;
  } else if (uu(t.type)) {
    const s = t.domain(), o = s.length, a = o > i ? s.slice(0, i - 2).map(r).join(", ") + ", ending with " + s.slice(-1).map(r) : s.map(r).join(", ");
    return `${o} value${o === 1 ? "" : "s"}: ${a}`;
  } else {
    const s = t.domain();
    return `values from ${r(s[0])} to ${r(Oe(s))}`;
  }
}
let NO = 0;
function YU() {
  NO = 0;
}
const Eg = "p_";
function L2(e) {
  return e && e.gradient;
}
function DO(e, t, n) {
  const i = e.gradient;
  let r = e.id, s = i === "radial" ? Eg : "";
  return r || (r = e.id = "gradient_" + NO++, i === "radial" ? (e.x1 = fr(e.x1, 0.5), e.y1 = fr(e.y1, 0.5), e.r1 = fr(e.r1, 0), e.x2 = fr(e.x2, 0.5), e.y2 = fr(e.y2, 0.5), e.r2 = fr(e.r2, 0.5), s = Eg) : (e.x1 = fr(e.x1, 0), e.y1 = fr(e.y1, 0), e.x2 = fr(e.x2, 1), e.y2 = fr(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + s + r + ")";
}
function fr(e, t) {
  return e ?? t;
}
function RO(e, t) {
  var n = [], i;
  return i = {
    gradient: "linear",
    x1: e ? e[0] : 0,
    y1: e ? e[1] : 0,
    x2: t ? t[0] : 1,
    y2: t ? t[1] : 0,
    stops: n,
    stop: function(r, s) {
      return n.push({
        offset: r,
        color: s
      }), i;
    }
  };
}
const Jk = {
  basis: {
    curve: ZB
  },
  "basis-closed": {
    curve: ej
  },
  "basis-open": {
    curve: tj
  },
  bundle: {
    curve: nj,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: ij,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: sj,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: rj,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: oj,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: aj,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: lj,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: a2
  },
  "linear-closed": {
    curve: uj
  },
  monotone: {
    horizontal: fj,
    vertical: cj
  },
  natural: {
    curve: dj
  },
  step: {
    curve: hj
  },
  "step-after": {
    curve: pj
  },
  "step-before": {
    curve: gj
  }
};
function P2(e, t, n) {
  var i = ce(Jk, e) && Jk[e], r = null;
  return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
}
const XU = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
}, KU = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, JU = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, QU = /^((\s+,?\s*)|(,\s*))/, ZU = /^[01]/;
function cu(e) {
  const t = [];
  return (e.match(KU) || []).forEach((i) => {
    let r = i[0];
    const s = r.toLowerCase(), o = XU[s], a = eq(s, o, i.slice(1).trim()), l = a.length;
    if (l < o || l && l % o !== 0)
      throw Error("Invalid SVG path, incorrect parameter count");
    if (t.push([r, ...a.slice(0, o)]), l !== o) {
      s === "m" && (r = r === "M" ? "L" : "l");
      for (let u = o; u < l; u += o)
        t.push([r, ...a.slice(u, u + o)]);
    }
  }), t;
}
function eq(e, t, n) {
  const i = [];
  for (let r = 0; t && r < n.length; )
    for (let s = 0; s < t; ++s) {
      const o = e === "a" && (s === 3 || s === 4) ? ZU : JU, a = n.slice(r).match(o);
      if (a === null)
        throw Error("Invalid SVG path, incorrect parameter type");
      r += a[0].length, i.push(+a[0]);
      const l = n.slice(r).match(QU);
      l !== null && (r += l[0].length);
    }
  return i;
}
const yo = Math.PI / 180, tq = 1e-14, aa = Math.PI / 2, yr = Math.PI * 2, bl = Math.sqrt(3) / 2;
var p1 = {}, m1 = {}, LO = [].join;
function nq(e, t, n, i, r, s, o, a, l) {
  const u = LO.call(arguments);
  if (p1[u])
    return p1[u];
  const c = o * yo, f = Math.sin(c), d = Math.cos(c);
  n = Math.abs(n), i = Math.abs(i);
  const h = d * (a - e) * 0.5 + f * (l - t) * 0.5, g = d * (l - t) * 0.5 - f * (a - e) * 0.5;
  let p = h * h / (n * n) + g * g / (i * i);
  p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
  const m = d / n, y = f / n, b = -f / i, v = d / i, w = m * a + y * l, _ = b * a + v * l, S = m * e + y * t, E = b * e + v * t;
  let $ = 1 / ((S - w) * (S - w) + (E - _) * (E - _)) - 0.25;
  $ < 0 && ($ = 0);
  let N = Math.sqrt($);
  s == r && (N = -N);
  const T = 0.5 * (w + S) - N * (E - _), L = 0.5 * (_ + E) + N * (S - w), O = Math.atan2(_ - L, w - T);
  let x = Math.atan2(E - L, S - T) - O;
  x < 0 && s === 1 ? x += yr : x > 0 && s === 0 && (x -= yr);
  const k = Math.ceil(Math.abs(x / (aa + 1e-3))), A = [];
  for (let M = 0; M < k; ++M) {
    const D = O + M * x / k, R = O + (M + 1) * x / k;
    A[M] = [T, L, D, R, n, i, f, d];
  }
  return p1[u] = A;
}
function iq(e) {
  const t = LO.call(e);
  if (m1[t])
    return m1[t];
  var n = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7];
  const c = u * o, f = -l * a, d = l * o, h = u * a, g = Math.cos(r), p = Math.sin(r), m = Math.cos(s), y = Math.sin(s), b = 0.5 * (s - r), v = Math.sin(b * 0.5), w = 8 / 3 * v * v / Math.sin(b), _ = n + g - w * p, S = i + p + w * g, E = n + m, C = i + y, $ = E + w * y, N = C - w * m;
  return m1[t] = [c * _ + f * S, d * _ + h * S, c * $ + f * N, d * $ + h * N, c * E + f * C, d * E + h * C];
}
const ui = ["l", 0, 0, 0, 0, 0, 0, 0];
function rq(e, t, n) {
  const i = ui[0] = e[0];
  if (i === "a" || i === "A")
    ui[1] = t * e[1], ui[2] = n * e[2], ui[3] = e[3], ui[4] = e[4], ui[5] = e[5], ui[6] = t * e[6], ui[7] = n * e[7];
  else if (i === "h" || i === "H")
    ui[1] = t * e[1];
  else if (i === "v" || i === "V")
    ui[1] = n * e[1];
  else
    for (var r = 1, s = e.length; r < s; ++r)
      ui[r] = (r % 2 == 1 ? t : n) * e[r];
  return ui;
}
function $f(e, t, n, i, r, s) {
  var o, a = null, l = 0, u = 0, c = 0, f = 0, d, h, g, p, m = 0, y = 0;
  n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), s == null && (s = r), e.beginPath && e.beginPath();
  for (var b = 0, v = t.length; b < v; ++b) {
    switch (o = t[b], (r !== 1 || s !== 1) && (o = rq(o, r, s)), o[0]) {
      case "l":
        l += o[1], u += o[2], e.lineTo(l + n, u + i);
        break;
      case "L":
        l = o[1], u = o[2], e.lineTo(l + n, u + i);
        break;
      case "h":
        l += o[1], e.lineTo(l + n, u + i);
        break;
      case "H":
        l = o[1], e.lineTo(l + n, u + i);
        break;
      case "v":
        u += o[1], e.lineTo(l + n, u + i);
        break;
      case "V":
        u = o[1], e.lineTo(l + n, u + i);
        break;
      case "m":
        l += o[1], u += o[2], m = l, y = u, e.moveTo(l + n, u + i);
        break;
      case "M":
        l = o[1], u = o[2], m = l, y = u, e.moveTo(l + n, u + i);
        break;
      case "c":
        d = l + o[5], h = u + o[6], c = l + o[3], f = u + o[4], e.bezierCurveTo(
          l + o[1] + n,
          // x1
          u + o[2] + i,
          // y1
          c + n,
          // x2
          f + i,
          // y2
          d + n,
          h + i
        ), l = d, u = h;
        break;
      case "C":
        l = o[5], u = o[6], c = o[3], f = o[4], e.bezierCurveTo(o[1] + n, o[2] + i, c + n, f + i, l + n, u + i);
        break;
      case "s":
        d = l + o[3], h = u + o[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, l + o[1] + n, u + o[2] + i, d + n, h + i), c = l + o[1], f = u + o[2], l = d, u = h;
        break;
      case "S":
        d = o[3], h = o[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, o[1] + n, o[2] + i, d + n, h + i), l = d, u = h, c = o[1], f = o[2];
        break;
      case "q":
        d = l + o[3], h = u + o[4], c = l + o[1], f = u + o[2], e.quadraticCurveTo(c + n, f + i, d + n, h + i), l = d, u = h;
        break;
      case "Q":
        d = o[3], h = o[4], e.quadraticCurveTo(o[1] + n, o[2] + i, d + n, h + i), l = d, u = h, c = o[1], f = o[2];
        break;
      case "t":
        d = l + o[1], h = u + o[2], a[0].match(/[QqTt]/) === null ? (c = l, f = u) : a[0] === "t" ? (c = 2 * l - g, f = 2 * u - p) : a[0] === "q" && (c = 2 * l - c, f = 2 * u - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), l = d, u = h, c = l + o[1], f = u + o[2];
        break;
      case "T":
        d = o[1], h = o[2], c = 2 * l - c, f = 2 * u - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), l = d, u = h;
        break;
      case "a":
        Qk(e, l + n, u + i, [o[1], o[2], o[3], o[4], o[5], o[6] + l + n, o[7] + u + i]), l += o[6], u += o[7];
        break;
      case "A":
        Qk(e, l + n, u + i, [o[1], o[2], o[3], o[4], o[5], o[6] + n, o[7] + i]), l = o[6], u = o[7];
        break;
      case "z":
      case "Z":
        l = m, u = y, e.closePath();
        break;
    }
    a = o;
  }
}
function Qk(e, t, n, i) {
  const r = nq(
    i[5],
    // end x
    i[6],
    // end y
    i[0],
    // radius x
    i[1],
    // radius y
    i[3],
    // large flag
    i[4],
    // sweep flag
    i[2],
    // rotation
    t,
    n
  );
  for (let s = 0; s < r.length; ++s) {
    const o = iq(r[s]);
    e.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
  }
}
const Zk = 0.5773502691896257, eA = {
  circle: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(n, 0), e.arc(0, 0, n, 0, yr);
    }
  },
  cross: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 2.5;
      e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath();
    }
  },
  diamond: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
    }
  },
  square: {
    draw: function(e, t) {
      var n = Math.sqrt(t), i = -n / 2;
      e.rect(i, i, n, n);
    }
  },
  arrow: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 7, r = n / 2.5, s = n / 8;
      e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -s), e.lineTo(r, -s), e.lineTo(0, -n), e.lineTo(-r, -s), e.lineTo(-i, -s), e.closePath();
    }
  },
  wedge: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n, r = i - n * Zk, s = n / 4;
      e.moveTo(0, -i - r), e.lineTo(-s, i - r), e.lineTo(s, i - r), e.closePath();
    }
  },
  triangle: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n, r = i - n * Zk;
      e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
    }
  },
  "triangle-up": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n;
      e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath();
    }
  },
  "triangle-down": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n;
      e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath();
    }
  },
  "triangle-right": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n;
      e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath();
    }
  },
  "triangle-left": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = bl * n;
      e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath();
    }
  },
  stroke: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(n, 0);
    }
  }
};
function PO(e) {
  return ce(eA, e) ? eA[e] : sq(e);
}
var y1 = {};
function sq(e) {
  if (!ce(y1, e)) {
    const t = cu(e);
    y1[e] = {
      draw: function(n, i) {
        $f(n, t, 0, 0, Math.sqrt(i) / 2);
      }
    };
  }
  return y1[e];
}
const Bs = 0.448084975506;
function oq(e) {
  return e.x;
}
function aq(e) {
  return e.y;
}
function lq(e) {
  return e.width;
}
function uq(e) {
  return e.height;
}
function Kr(e) {
  return typeof e == "function" ? e : () => +e;
}
function Qd(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function IO() {
  var e = oq, t = aq, n = lq, i = uq, r = Kr(0), s = r, o = r, a = r, l = null;
  function u(c, f, d) {
    var h, g = f ?? +e.call(this, c), p = d ?? +t.call(this, c), m = +n.call(this, c), y = +i.call(this, c), b = Math.min(m, y) / 2, v = Qd(+r.call(this, c), 0, b), w = Qd(+s.call(this, c), 0, b), _ = Qd(+o.call(this, c), 0, b), S = Qd(+a.call(this, c), 0, b);
    if (l || (l = h = lm()), v <= 0 && w <= 0 && _ <= 0 && S <= 0)
      l.rect(g, p, m, y);
    else {
      var E = g + m, C = p + y;
      l.moveTo(g + v, p), l.lineTo(E - w, p), l.bezierCurveTo(E - Bs * w, p, E, p + Bs * w, E, p + w), l.lineTo(E, C - S), l.bezierCurveTo(E, C - Bs * S, E - Bs * S, C, E - S, C), l.lineTo(g + _, C), l.bezierCurveTo(g + Bs * _, C, g, C - Bs * _, g, C - _), l.lineTo(g, p + v), l.bezierCurveTo(g, p + Bs * v, g + Bs * v, p, g + v, p), l.closePath();
    }
    if (h)
      return l = null, h + "" || null;
  }
  return u.x = function(c) {
    return arguments.length ? (e = Kr(c), u) : e;
  }, u.y = function(c) {
    return arguments.length ? (t = Kr(c), u) : t;
  }, u.width = function(c) {
    return arguments.length ? (n = Kr(c), u) : n;
  }, u.height = function(c) {
    return arguments.length ? (i = Kr(c), u) : i;
  }, u.cornerRadius = function(c, f, d, h) {
    return arguments.length ? (r = Kr(c), s = f != null ? Kr(f) : r, a = d != null ? Kr(d) : r, o = h != null ? Kr(h) : s, u) : r;
  }, u.context = function(c) {
    return arguments.length ? (l = c ?? null, u) : l;
  }, u;
}
function zO() {
  var e, t, n, i, r = null, s, o, a, l;
  function u(f, d, h) {
    const g = h / 2;
    if (s) {
      var p = a - d, m = f - o;
      if (p || m) {
        var y = Math.hypot(p, m), b = (p /= y) * l, v = (m /= y) * l, w = Math.atan2(m, p);
        r.moveTo(o - b, a - v), r.lineTo(f - p * g, d - m * g), r.arc(f, d, g, w - Math.PI, w), r.lineTo(o + b, a + v), r.arc(o, a, l, w, w + Math.PI);
      } else
        r.arc(f, d, g, 0, yr);
      r.closePath();
    } else
      s = 1;
    o = f, a = d, l = g;
  }
  function c(f) {
    var d, h = f.length, g, p = !1, m;
    for (r == null && (r = m = lm()), d = 0; d <= h; ++d)
      !(d < h && i(g = f[d], d, f)) === p && (p = !p) && (s = 0), p && u(+e(g, d, f), +t(g, d, f), +n(g, d, f));
    if (m)
      return r = null, m + "" || null;
  }
  return c.x = function(f) {
    return arguments.length ? (e = f, c) : e;
  }, c.y = function(f) {
    return arguments.length ? (t = f, c) : t;
  }, c.size = function(f) {
    return arguments.length ? (n = f, c) : n;
  }, c.defined = function(f) {
    return arguments.length ? (i = f, c) : i;
  }, c.context = function(f) {
    return arguments.length ? (f == null ? r = null : r = f, c) : r;
  }, c;
}
function fd(e, t) {
  return e ?? t;
}
const dd = (e) => e.x || 0, hd = (e) => e.y || 0, cq = (e) => e.width || 0, fq = (e) => e.height || 0, dq = (e) => (e.x || 0) + (e.width || 0), hq = (e) => (e.y || 0) + (e.height || 0), gq = (e) => e.startAngle || 0, pq = (e) => e.endAngle || 0, mq = (e) => e.padAngle || 0, yq = (e) => e.innerRadius || 0, bq = (e) => e.outerRadius || 0, vq = (e) => e.cornerRadius || 0, xq = (e) => fd(e.cornerRadiusTopLeft, e.cornerRadius) || 0, wq = (e) => fd(e.cornerRadiusTopRight, e.cornerRadius) || 0, _q = (e) => fd(e.cornerRadiusBottomRight, e.cornerRadius) || 0, Eq = (e) => fd(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, Sq = (e) => fd(e.size, 64), kq = (e) => e.size || 1, _m = (e) => e.defined !== !1, Aq = (e) => PO(e.shape || "circle"), Cq = KB().startAngle(gq).endAngle(pq).padAngle(mq).innerRadius(yq).outerRadius(bq).cornerRadius(vq), $q = g5().x(dd).y1(hd).y0(hq).defined(_m), Mq = g5().y(hd).x1(dd).x0(dq).defined(_m), Fq = h5().x(dd).y(hd).defined(_m), Tq = IO().x(dd).y(hd).width(cq).height(fq).cornerRadius(xq, wq, _q, Eq), Oq = QB().type(Aq).size(Sq), Nq = zO().x(dd).y(hd).defined(_m).size(kq);
function I2(e) {
  return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
}
function Dq(e, t) {
  return Cq.context(e)(t);
}
function Rq(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return (n.orient === "horizontal" ? Mq : $q).curve(P2(i, n.orient, n.tension)).context(e)(t);
}
function Lq(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return Fq.curve(P2(i, n.orient, n.tension)).context(e)(t);
}
function Hu(e, t, n, i) {
  return Tq.context(e)(t, n, i);
}
function Pq(e, t) {
  return (t.mark.shape || t.shape).context(e)(t);
}
function Iq(e, t) {
  return Oq.context(e)(t);
}
function zq(e, t) {
  return Nq.context(e)(t);
}
var BO = 1;
function jO() {
  BO = 1;
}
function z2(e, t, n) {
  var i = t.clip, r = e._defs, s = t.clip_id || (t.clip_id = "clip" + BO++), o = r.clipping[s] || (r.clipping[s] = {
    id: s
  });
  return Ee(i) ? o.path = i(null) : I2(n) ? o.path = Hu(null, n, 0, 0) : (o.width = n.width || 0, o.height = n.height || 0), "url(#" + s + ")";
}
function ht(e) {
  this.clear(), e && this.union(e);
}
ht.prototype = {
  clone() {
    return new ht(this);
  },
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(e) {
    return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
  },
  set(e, t, n, i) {
    return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this;
  },
  add(e, t) {
    return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
  },
  expand(e) {
    return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
  },
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  },
  scale(e) {
    return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
  },
  translate(e, t) {
    return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
  },
  rotate(e, t, n) {
    const i = this.rotatedPoints(e, t, n);
    return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
  },
  rotatedPoints(e, t, n) {
    var {
      x1: i,
      y1: r,
      x2: s,
      y2: o
    } = this, a = Math.cos(e), l = Math.sin(e), u = t - t * a + n * l, c = n - t * l - n * a;
    return [a * i - l * r + u, l * i + a * r + c, a * i - l * o + u, l * i + a * o + c, a * s - l * r + u, l * s + a * r + c, a * s - l * o + u, l * s + a * o + c];
  },
  union(e) {
    return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
  },
  intersect(e) {
    return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
  },
  encloses(e) {
    return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
  },
  alignsWith(e) {
    return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
  },
  intersects(e) {
    return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
  },
  contains(e, t) {
    return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Em(e) {
  this.mark = e, this.bounds = this.bounds || new ht();
}
function Sm(e) {
  Em.call(this, e), this.items = this.items || [];
}
Y(Sm, Em);
function B2(e) {
  this._pending = 0, this._loader = e || Kp();
}
function tA(e) {
  e._pending += 1;
}
function hc(e) {
  e._pending -= 1;
}
B2.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(e) {
    const t = this;
    return tA(t), t._loader.sanitize(e, {
      context: "href"
    }).then((n) => (hc(t), n)).catch(() => (hc(t), null));
  },
  loadImage(e) {
    const t = this, n = mj();
    return tA(t), t._loader.sanitize(e, {
      context: "image"
    }).then((i) => {
      const r = i.href;
      if (!r || !n)
        throw {
          url: r
        };
      const s = new n(), o = ce(i, "crossOrigin") ? i.crossOrigin : "anonymous";
      return o != null && (s.crossOrigin = o), s.onload = () => hc(t), s.onerror = () => hc(t), s.src = r, s;
    }).catch((i) => (hc(t), {
      complete: !1,
      width: 0,
      height: 0,
      src: i && i.url || ""
    }));
  },
  ready() {
    const e = this;
    return new Promise((t) => {
      function n(i) {
        e.pending() ? setTimeout(() => {
          n(!0);
        }, 10) : t(i);
      }
      n(!1);
    });
  }
};
function Fs(e, t, n) {
  if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
    const i = t.strokeWidth != null ? +t.strokeWidth : 1;
    e.expand(i + (n ? Bq(t, i) : 0));
  }
  return e;
}
function Bq(e, t) {
  return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
}
const jq = yr - 1e-8;
let km, Rh, Lh, pa, tb, Ph, nb, ib;
const Ks = (e, t) => km.add(e, t), Ih = (e, t) => Ks(Rh = e, Lh = t), nA = (e) => Ks(e, km.y1), iA = (e) => Ks(km.x1, e), la = (e, t) => tb * e + nb * t, ua = (e, t) => Ph * e + ib * t, b1 = (e, t) => Ks(la(e, t), ua(e, t)), v1 = (e, t) => Ih(la(e, t), ua(e, t));
function gd(e, t) {
  return km = e, t ? (pa = t * yo, tb = ib = Math.cos(pa), Ph = Math.sin(pa), nb = -Ph) : (tb = ib = 1, pa = Ph = nb = 0), Uq;
}
const Uq = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: v1,
  lineTo: v1,
  rect(e, t, n, i) {
    pa ? (b1(e + n, t), b1(e + n, t + i), b1(e, t + i), v1(e, t)) : (Ks(e + n, t + i), Ih(e, t));
  },
  quadraticCurveTo(e, t, n, i) {
    const r = la(e, t), s = ua(e, t), o = la(n, i), a = ua(n, i);
    rA(Rh, r, o, nA), rA(Lh, s, a, iA), Ih(o, a);
  },
  bezierCurveTo(e, t, n, i, r, s) {
    const o = la(e, t), a = ua(e, t), l = la(n, i), u = ua(n, i), c = la(r, s), f = ua(r, s);
    sA(Rh, o, l, c, nA), sA(Lh, a, u, f, iA), Ih(c, f);
  },
  arc(e, t, n, i, r, s) {
    if (i += pa, r += pa, Rh = n * Math.cos(r) + e, Lh = n * Math.sin(r) + t, Math.abs(r - i) > jq)
      Ks(e - n, t - n), Ks(e + n, t + n);
    else {
      const o = (u) => Ks(n * Math.cos(u) + e, n * Math.sin(u) + t);
      let a, l;
      if (o(i), o(r), r !== i)
        if (i = i % yr, i < 0 && (i += yr), r = r % yr, r < 0 && (r += yr), r < i && (s = !s, a = i, i = r, r = a), s)
          for (r -= yr, a = i - i % aa, l = 0; l < 4 && a > r; ++l, a -= aa)
            o(a);
        else
          for (a = i - i % aa + aa, l = 0; l < 4 && a < r; ++l, a = a + aa)
            o(a);
    }
  }
};
function rA(e, t, n, i) {
  const r = (e - t) / (e + n - 2 * t);
  0 < r && r < 1 && i(e + (t - e) * r);
}
function sA(e, t, n, i, r) {
  const s = i - e + 3 * t - 3 * n, o = e + n - 2 * t, a = e - t;
  let l = 0, u = 0, c;
  Math.abs(s) > tq ? (c = o * o + a * s, c >= 0 && (c = Math.sqrt(c), l = (-o + c) / s, u = (-o - c) / s)) : l = 0.5 * a / o, 0 < l && l < 1 && r(oA(l, e, t, n, i)), 0 < u && u < 1 && r(oA(u, e, t, n, i));
}
function oA(e, t, n, i, r) {
  const s = 1 - e, o = s * s, a = e * e;
  return o * s * t + 3 * o * e * n + 3 * s * a * i + a * e * r;
}
var uo = (uo = lo(1, 1)) ? uo.getContext("2d") : null;
const rb = new ht();
function j2(e) {
  return function(t, n) {
    if (!uo)
      return !0;
    e(uo, t), rb.clear().union(t.bounds).intersect(n).round();
    const {
      x1: i,
      y1: r,
      x2: s,
      y2: o
    } = rb;
    for (let a = r; a <= o; ++a)
      for (let l = i; l <= s; ++l)
        if (uo.isPointInPath(l, a))
          return !0;
    return !1;
  };
}
function U2(e, t) {
  return t.contains(e.x || 0, e.y || 0);
}
function UO(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.width || 0, s = e.height || 0;
  return t.intersects(rb.set(n, i, n + r, i + s));
}
function qO(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.x2 != null ? e.x2 : n, s = e.y2 != null ? e.y2 : i;
  return Rl(t, n, i, r, s);
}
function Rl(e, t, n, i, r) {
  const {
    x1: s,
    y1: o,
    x2: a,
    y2: l
  } = e, u = i - t, c = r - n;
  let f = 0, d = 1, h, g, p, m;
  for (m = 0; m < 4; ++m) {
    if (m === 0 && (h = -u, g = -(s - t)), m === 1 && (h = u, g = a - t), m === 2 && (h = -c, g = -(o - n)), m === 3 && (h = c, g = l - n), Math.abs(h) < 1e-10 && g < 0)
      return !1;
    if (p = g / h, h < 0) {
      if (p > d)
        return !1;
      p > f && (f = p);
    } else if (h > 0) {
      if (p < f)
        return !1;
      p < d && (d = p);
    }
  }
  return !0;
}
function fu(e, t) {
  e.globalCompositeOperation = t.blend || "source-over";
}
function Ni(e, t) {
  return e ?? t;
}
function aA(e, t) {
  const n = t.length;
  for (let i = 0; i < n; ++i)
    e.addColorStop(t[i].offset, t[i].color);
  return e;
}
function qq(e, t, n) {
  const i = n.width(), r = n.height();
  let s;
  if (t.gradient === "radial")
    s = e.createRadialGradient(n.x1 + Ni(t.x1, 0.5) * i, n.y1 + Ni(t.y1, 0.5) * r, Math.max(i, r) * Ni(t.r1, 0), n.x1 + Ni(t.x2, 0.5) * i, n.y1 + Ni(t.y2, 0.5) * r, Math.max(i, r) * Ni(t.r2, 0.5));
  else {
    const o = Ni(t.x1, 0), a = Ni(t.y1, 0), l = Ni(t.x2, 1), u = Ni(t.y2, 0);
    if (o === l || a === u || i === r)
      s = e.createLinearGradient(n.x1 + o * i, n.y1 + a * r, n.x1 + l * i, n.y1 + u * r);
    else {
      const c = lo(Math.ceil(i), Math.ceil(r)), f = c.getContext("2d");
      return f.scale(i, r), f.fillStyle = aA(f.createLinearGradient(o, a, l, u), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
    }
  }
  return aA(s, t.stops);
}
function WO(e, t, n) {
  return L2(n) ? qq(e, n, t.bounds) : n;
}
function Sg(e, t, n) {
  return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = WO(e, t, t.fill), !0) : !1;
}
var Wq = [];
function du(e, t, n) {
  var i = (i = t.strokeWidth) != null ? i : 1;
  return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = WO(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || Wq), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
}
function Hq(e, t) {
  return e.zindex - t.zindex || e.index - t.index;
}
function q2(e) {
  if (!e.zdirty)
    return e.zitems;
  var t = e.items, n = [], i, r, s;
  for (r = 0, s = t.length; r < s; ++r)
    i = t[r], i.index = r, i.zindex && n.push(i);
  return e.zdirty = !1, e.zitems = n.sort(Hq);
}
function Zi(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return;
  const s = q2(e);
  if (s && s.length) {
    for (i = 0, r = n.length; i < r; ++i)
      n[i].zindex || t(n[i]);
    n = s;
  }
  for (i = 0, r = n.length; i < r; ++i)
    t(n[i]);
}
function kg(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return null;
  const s = q2(e);
  for (s && s.length && (n = s), r = n.length; --r >= 0; )
    if (i = t(n[r]))
      return i;
  if (n === s) {
    for (n = e.items, r = n.length; --r >= 0; )
      if (!n[r].zindex && (i = t(n[r])))
        return i;
  }
  return null;
}
function W2(e) {
  return function(t, n, i) {
    Zi(n, (r) => {
      (!i || i.intersects(r.bounds)) && HO(e, t, r, r);
    });
  };
}
function Gq(e) {
  return function(t, n, i) {
    n.items.length && (!i || i.intersects(n.bounds)) && HO(e, t, n.items[0], n.items);
  };
}
function HO(e, t, n, i) {
  var r = n.opacity == null ? 1 : n.opacity;
  r !== 0 && (e(t, i) || (fu(t, n), n.fill && Sg(t, n, r) && t.fill(), n.stroke && du(t, n, r) && t.stroke()));
}
function Am(e) {
  return e = e || Ei, function(t, n, i, r, s, o) {
    return i *= t.pixelRatio, r *= t.pixelRatio, kg(n, (a) => {
      const l = a.bounds;
      if (!(l && !l.contains(s, o) || !l) && e(t, a, i, r, s, o))
        return a;
    });
  };
}
function pd(e, t) {
  return function(n, i, r, s) {
    var o = Array.isArray(i) ? i[0] : i, a = t ?? o.fill, l = o.stroke && n.isPointInStroke, u, c;
    return l && (u = o.strokeWidth, c = o.strokeCap, n.lineWidth = u ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : a && n.isPointInPath(r, s) || l && n.isPointInStroke(r, s);
  };
}
function H2(e) {
  return Am(pd(e));
}
function _a(e, t) {
  return "translate(" + e + "," + t + ")";
}
function G2(e) {
  return "rotate(" + e + ")";
}
function Vq(e, t) {
  return "scale(" + e + "," + t + ")";
}
function GO(e) {
  return _a(e.x || 0, e.y || 0);
}
function Yq(e) {
  return _a(e.x || 0, e.y || 0) + (e.angle ? " " + G2(e.angle) : "");
}
function Xq(e) {
  return _a(e.x || 0, e.y || 0) + (e.angle ? " " + G2(e.angle) : "") + (e.scaleX || e.scaleY ? " " + Vq(e.scaleX || 1, e.scaleY || 1) : "");
}
function V2(e, t, n) {
  function i(o, a) {
    o("transform", Yq(a)), o("d", t(null, a));
  }
  function r(o, a) {
    return t(gd(o, a.angle), a), Fs(o, a).translate(a.x || 0, a.y || 0);
  }
  function s(o, a) {
    var l = a.x || 0, u = a.y || 0, c = a.angle || 0;
    o.translate(l, u), c && o.rotate(c *= yo), o.beginPath(), t(o, a), c && o.rotate(-c), o.translate(-l, -u);
  }
  return {
    type: e,
    tag: "path",
    nested: !1,
    attr: i,
    bound: r,
    draw: W2(s),
    pick: H2(s),
    isect: n || j2(s)
  };
}
var Kq = V2("arc", Dq);
function Jq(e, t) {
  for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, s = 1 / 0, o, a; --r >= 0; )
    e[r].defined !== !1 && (a = Math.abs(e[r][i] - n), a < s && (s = a, o = e[r]));
  return o;
}
function Qq(e, t) {
  for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, s, o; --i >= 0; )
    if (e[i].defined !== !1 && (r = e[i].x - t[0], s = e[i].y - t[1], o = r * r + s * s, o < n))
      return e[i];
  return null;
}
function Zq(e, t) {
  for (var n = e.length, i, r, s; --n >= 0; )
    if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], s = i * i + r * r, i = e[n].size || 1, s < i * i))
      return e[n];
  return null;
}
function Y2(e, t, n) {
  function i(l, u) {
    var c = u.mark.items;
    c.length && l("d", t(null, c));
  }
  function r(l, u) {
    var c = u.items;
    return c.length === 0 ? l : (t(gd(l), c), Fs(l, c[0]));
  }
  function s(l, u) {
    l.beginPath(), t(l, u);
  }
  const o = pd(s);
  function a(l, u, c, f, d, h) {
    var g = u.items, p = u.bounds;
    return !g || !g.length || p && !p.contains(d, h) ? null : (c *= l.pixelRatio, f *= l.pixelRatio, o(l, g, c, f) ? g[0] : null);
  }
  return {
    type: e,
    tag: "path",
    nested: !0,
    attr: i,
    bound: r,
    draw: Gq(s),
    pick: a,
    isect: U2,
    tip: n
  };
}
var eW = Y2("area", Rq, Jq);
function tW(e, t) {
  var n = t.clip;
  e.save(), Ee(n) ? (e.beginPath(), n(e), e.clip()) : VO(e, t.group);
}
function VO(e, t) {
  e.beginPath(), I2(t) ? Hu(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
}
function YO(e) {
  const t = Ni(e.strokeWidth, 1);
  return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
}
function nW(e, t) {
  e("transform", GO(t));
}
function XO(e, t) {
  const n = YO(t);
  e("d", Hu(null, t, n, n));
}
function iW(e, t) {
  e("class", "background"), e("aria-hidden", !0), XO(e, t);
}
function rW(e, t) {
  e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? XO(e, t) : e("d", "");
}
function sW(e, t, n) {
  const i = t.clip ? z2(n, t, t) : null;
  e("clip-path", i);
}
function oW(e, t) {
  if (!t.clip && t.items) {
    const n = t.items, i = n.length;
    for (let r = 0; r < i; ++r)
      e.union(n[r].bounds);
  }
  return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), Fs(e, t), e.translate(t.x || 0, t.y || 0);
}
function Mf(e, t, n, i) {
  const r = YO(t);
  e.beginPath(), Hu(e, t, (n || 0) + r, (i || 0) + r);
}
const aW = pd(Mf), lW = pd(Mf, !1), uW = pd(Mf, !0);
function cW(e, t, n, i) {
  Zi(t, (r) => {
    const s = r.x || 0, o = r.y || 0, a = r.strokeForeground, l = r.opacity == null ? 1 : r.opacity;
    (r.stroke || r.fill) && l && (Mf(e, r, s, o), fu(e, r), r.fill && Sg(e, r, l) && e.fill(), r.stroke && !a && du(e, r, l) && e.stroke()), e.save(), e.translate(s, o), r.clip && VO(e, r), n && n.translate(-s, -o), Zi(r, (u) => {
      (u.marktype === "group" || i == null || i.includes(u.marktype)) && this.draw(e, u, n, i);
    }), n && n.translate(s, o), e.restore(), a && r.stroke && l && (Mf(e, r, s, o), fu(e, r), du(e, r, l) && e.stroke());
  });
}
function fW(e, t, n, i, r, s) {
  if (t.bounds && !t.bounds.contains(r, s) || !t.items)
    return null;
  const o = n * e.pixelRatio, a = i * e.pixelRatio;
  return kg(t, (l) => {
    let u, c, f;
    const d = l.bounds;
    if (d && !d.contains(r, s))
      return;
    c = l.x || 0, f = l.y || 0;
    const h = c + (l.width || 0), g = f + (l.height || 0), p = l.clip;
    if (p && (r < c || r > h || s < f || s > g))
      return;
    if (e.save(), e.translate(c, f), c = r - c, f = s - f, p && I2(l) && !uW(e, l, o, a))
      return e.restore(), null;
    const m = l.strokeForeground, y = t.interactive !== !1;
    return y && m && l.stroke && lW(e, l, o, a) ? (e.restore(), l) : (u = kg(l, (b) => dW(b, c, f) ? this.pick(b, n, i, c, f) : null), !u && y && (l.fill || !m && l.stroke) && aW(e, l, o, a) && (u = l), e.restore(), u || null);
  });
}
function dW(e, t, n) {
  return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
}
var hW = {
  type: "group",
  tag: "g",
  nested: !1,
  attr: nW,
  bound: oW,
  draw: cW,
  pick: fW,
  isect: UO,
  content: sW,
  background: iW,
  foreground: rW
}, Ff = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function X2(e, t) {
  var n = e.image;
  return (!n || e.url && e.url !== n.url) && (n = {
    complete: !1,
    width: 0,
    height: 0
  }, t.loadImage(e.url).then((i) => {
    e.image = i, e.image.url = e.url;
  })), n;
}
function K2(e, t) {
  return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
}
function J2(e, t) {
  return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
}
function Cm(e, t) {
  return e === "center" ? t / 2 : e === "right" ? t : 0;
}
function $m(e, t) {
  return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
}
function gW(e, t, n) {
  const i = X2(t, n), r = K2(t, i), s = J2(t, i), o = (t.x || 0) - Cm(t.align, r), a = (t.y || 0) - $m(t.baseline, s), l = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
  e("href", l, Ff["xmlns:xlink"], "xlink:href"), e("transform", _a(o, a)), e("width", r), e("height", s), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
}
function pW(e, t) {
  const n = t.image, i = K2(t, n), r = J2(t, n), s = (t.x || 0) - Cm(t.align, i), o = (t.y || 0) - $m(t.baseline, r);
  return e.set(s, o, s + i, o + r);
}
function mW(e, t, n) {
  Zi(t, (i) => {
    if (n && !n.intersects(i.bounds))
      return;
    const r = X2(i, this);
    let s = K2(i, r), o = J2(i, r);
    if (s === 0 || o === 0)
      return;
    let a = (i.x || 0) - Cm(i.align, s), l = (i.y || 0) - $m(i.baseline, o), u, c, f, d;
    i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = s / c, l += (o - d) / 2, o = d) : (d = o * c, a += (s - d) / 2, s = d))), (r.complete || r.toDataURL) && (fu(e, i), e.globalAlpha = (u = i.opacity) != null ? u : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, a, l, s, o));
  });
}
var yW = {
  type: "image",
  tag: "image",
  nested: !1,
  attr: gW,
  bound: pW,
  draw: mW,
  pick: Am(),
  isect: Ei,
  // bounds check is sufficient
  get: X2,
  xOffset: Cm,
  yOffset: $m
}, bW = Y2("line", Lq, Qq);
function vW(e, t) {
  var n = t.scaleX || 1, i = t.scaleY || 1;
  (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", Xq(t)), e("d", t.path);
}
function zh(e, t) {
  var n = t.path;
  if (n == null)
    return !0;
  var i = t.x || 0, r = t.y || 0, s = t.scaleX || 1, o = t.scaleY || 1, a = (t.angle || 0) * yo, l = t.pathCache;
  (!l || l.path !== n) && ((t.pathCache = l = cu(n)).path = n), a && e.rotate && e.translate ? (e.translate(i, r), e.rotate(a), $f(e, l, 0, 0, s, o), e.rotate(-a), e.translate(-i, -r)) : $f(e, l, i, r, s, o);
}
function xW(e, t) {
  return zh(gd(e, t.angle), t) ? e.set(0, 0, 0, 0) : Fs(e, t, !0);
}
var wW = {
  type: "path",
  tag: "path",
  nested: !1,
  attr: vW,
  bound: xW,
  draw: W2(zh),
  pick: H2(zh),
  isect: j2(zh)
};
function _W(e, t) {
  e("d", Hu(null, t));
}
function EW(e, t) {
  var n, i;
  return Fs(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
}
function lA(e, t) {
  e.beginPath(), Hu(e, t);
}
var SW = {
  type: "rect",
  tag: "path",
  nested: !1,
  attr: _W,
  bound: EW,
  draw: W2(lA),
  pick: H2(lA),
  isect: UO
};
function kW(e, t) {
  e("transform", GO(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
}
function AW(e, t) {
  var n, i;
  return Fs(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t);
}
function KO(e, t, n) {
  var i, r, s, o;
  return t.stroke && du(e, t, n) ? (i = t.x || 0, r = t.y || 0, s = t.x2 != null ? t.x2 : i, o = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(s, o), !0) : !1;
}
function CW(e, t, n) {
  Zi(t, (i) => {
    if (!(n && !n.intersects(i.bounds))) {
      var r = i.opacity == null ? 1 : i.opacity;
      r && KO(e, i, r) && (fu(e, i), e.stroke());
    }
  });
}
function $W(e, t, n, i) {
  return e.isPointInStroke ? KO(e, t, 1) && e.isPointInStroke(n, i) : !1;
}
var MW = {
  type: "rule",
  tag: "line",
  nested: !1,
  attr: kW,
  bound: AW,
  draw: CW,
  pick: Am($W),
  isect: qO
}, FW = V2("shape", Pq), TW = V2("symbol", Iq, U2);
const uA = rF();
var Zn = {
  height: zr,
  measureWidth: Q2,
  estimateWidth: Ag,
  width: Ag,
  canvas: JO
};
JO(!0);
function JO(e) {
  Zn.width = e && uo ? Q2 : Ag;
}
function Ag(e, t) {
  return QO(vo(e, t), zr(e));
}
function QO(e, t) {
  return ~~(0.8 * e.length * t);
}
function Q2(e, t) {
  return zr(e) <= 0 || !(t = vo(e, t)) ? 0 : ZO(t, Mm(e));
}
function ZO(e, t) {
  const n = `(${t}) ${e}`;
  let i = uA.get(n);
  return i === void 0 && (uo.font = t, i = uo.measureText(e).width, uA.set(n, i)), i;
}
function zr(e) {
  return e.fontSize != null ? +e.fontSize || 0 : 11;
}
function bo(e) {
  return e.lineHeight != null ? e.lineHeight : zr(e) + 2;
}
function OW(e) {
  return j(e) ? e.length > 1 ? e : e[0] : e;
}
function md(e) {
  return OW(e.lineBreak && e.text && !j(e.text) ? e.text.split(e.lineBreak) : e.text);
}
function Z2(e) {
  const t = md(e);
  return (j(t) ? t.length - 1 : 0) * bo(e);
}
function vo(e, t) {
  const n = t == null ? "" : (t + "").trim();
  return e.limit > 0 && n.length ? DW(e, n) : n;
}
function NW(e) {
  if (Zn.width === Q2) {
    const t = Mm(e);
    return (n) => ZO(n, t);
  } else if (Zn.width === Ag) {
    const t = zr(e);
    return (n) => QO(n, t);
  } else
    return (t) => Zn.width(e, t);
}
function DW(e, t) {
  var n = +e.limit, i = NW(e);
  if (i(t) < n)
    return t;
  var r = e.ellipsis || "", s = e.dir === "rtl", o = 0, a = t.length, l;
  if (n -= i(r), s) {
    for (; o < a; )
      l = o + a >>> 1, i(t.slice(l)) > n ? o = l + 1 : a = l;
    return r + t.slice(o);
  } else {
    for (; o < a; )
      l = 1 + (o + a >>> 1), i(t.slice(0, l)) < n ? o = l : a = l - 1;
    return t.slice(0, o) + r;
  }
}
function yd(e, t) {
  var n = e.font;
  return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
}
function Mm(e, t) {
  return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + zr(e) + "px " + yd(e, t);
}
function ew(e) {
  var t = e.baseline, n = zr(e);
  return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * bo(e) : t === "line-bottom" ? 0.29 * n - 0.5 * bo(e) : 0);
}
const RW = {
  left: "start",
  center: "middle",
  right: "end"
}, tf = new ht();
function Fm(e) {
  var t = e.x || 0, n = e.y || 0, i = e.radius || 0, r;
  return i && (r = (e.theta || 0) - aa, t += i * Math.cos(r), n += i * Math.sin(r)), tf.x1 = t, tf.y1 = n, tf;
}
function LW(e, t) {
  var n = t.dx || 0, i = (t.dy || 0) + ew(t), r = Fm(t), s = r.x1, o = r.y1, a = t.angle || 0, l;
  e("text-anchor", RW[t.align] || "start"), a ? (l = _a(s, o) + " " + G2(a), (n || i) && (l += " " + _a(n, i))) : l = _a(s + n, o + i), e("transform", l);
}
function tw(e, t, n) {
  var i = Zn.height(t), r = t.align, s = Fm(t), o = s.x1, a = s.y1, l = t.dx || 0, u = (t.dy || 0) + ew(t) - Math.round(0.8 * i), c = md(t), f;
  if (j(c) ? (i += bo(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, Zn.width(t, h)), 0)) : f = Zn.width(t, c), r === "center" ? l -= f / 2 : r === "right" && (l -= f), e.set(l += o, u += a, l + f, u + i), t.angle && !n)
    e.rotate(t.angle * yo, o, a);
  else if (n === 2)
    return e.rotatedPoints(t.angle * yo, o, a);
  return e;
}
function PW(e, t, n) {
  Zi(t, (i) => {
    var r = i.opacity == null ? 1 : i.opacity, s, o, a, l, u, c, f;
    if (!(n && !n.intersects(i.bounds) || // bounds check
    r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
      if (e.font = Mm(i), e.textAlign = i.align || "left", s = Fm(i), o = s.x1, a = s.y1, i.angle && (e.save(), e.translate(o, a), e.rotate(i.angle * yo), o = a = 0), o += i.dx || 0, a += (i.dy || 0) + ew(i), c = md(i), fu(e, i), j(c))
        for (u = bo(i), l = 0; l < c.length; ++l)
          f = vo(i, c[l]), i.fill && Sg(e, i, r) && e.fillText(f, o, a), i.stroke && du(e, i, r) && e.strokeText(f, o, a), a += u;
      else
        f = vo(i, c), i.fill && Sg(e, i, r) && e.fillText(f, o, a), i.stroke && du(e, i, r) && e.strokeText(f, o, a);
      i.angle && e.restore();
    }
  });
}
function IW(e, t, n, i, r, s) {
  if (t.fontSize <= 0)
    return !1;
  if (!t.angle)
    return !0;
  var o = Fm(t), a = o.x1, l = o.y1, u = tw(tf, t, 1), c = -t.angle * yo, f = Math.cos(c), d = Math.sin(c), h = f * r - d * s + (a - f * a + d * l), g = d * r + f * s + (l - d * a - f * l);
  return u.contains(h, g);
}
function zW(e, t) {
  const n = tw(tf, e, 2);
  return Rl(t, n[0], n[1], n[2], n[3]) || Rl(t, n[0], n[1], n[4], n[5]) || Rl(t, n[4], n[5], n[6], n[7]) || Rl(t, n[2], n[3], n[6], n[7]);
}
var BW = {
  type: "text",
  tag: "text",
  nested: !1,
  attr: LW,
  bound: tw,
  draw: PW,
  pick: Am(IW),
  isect: zW
}, jW = Y2("trail", zq, Zq), si = {
  arc: Kq,
  area: eW,
  group: hW,
  image: yW,
  line: bW,
  path: wW,
  rect: SW,
  rule: MW,
  shape: FW,
  symbol: TW,
  text: BW,
  trail: jW
};
function sb(e, t, n) {
  var i = si[e.mark.marktype], r = t || i.bound;
  return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new ht()), e, n);
}
var cA = {
  mark: null
};
function eN(e, t, n) {
  var i = si[e.marktype], r = i.bound, s = e.items, o = s && s.length, a, l, u, c;
  if (i.nested)
    return o ? u = s[0] : (cA.mark = e, u = cA), c = sb(u, r, n), t = t && t.union(c) || c, t;
  if (t = t || e.bounds && e.bounds.clear() || new ht(), o)
    for (a = 0, l = s.length; a < l; ++a)
      t.union(sb(s[a], r, n));
  return e.bounds = t;
}
const UW = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function tN(e, t) {
  return JSON.stringify(e, UW, t);
}
function nN(e) {
  const t = typeof e == "string" ? JSON.parse(e) : e;
  return iN(t);
}
function iN(e) {
  var t = e.marktype, n = e.items, i, r, s;
  if (n)
    for (r = 0, s = n.length; r < s; ++r)
      i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && iN(n[r]);
  return t && eN(e), e;
}
function nw(e) {
  arguments.length ? this.root = nN(e) : (this.root = rN({
    marktype: "group",
    name: "root",
    role: "frame"
  }), this.root.items = [new Sm(this.root)]);
}
nw.prototype = {
  toJSON(e) {
    return tN(this.root, e || 0);
  },
  mark(e, t, n) {
    t = t || this.root.items[0];
    const i = rN(e, t);
    return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i;
  }
};
function rN(e, t) {
  const n = {
    bounds: new ht(),
    clip: !!e.clip,
    group: t,
    interactive: e.interactive !== !1,
    items: [],
    marktype: e.marktype,
    name: e.name || void 0,
    role: e.role || void 0,
    zindex: e.zindex || 0
  };
  return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
}
function Js(e, t, n) {
  return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
}
function iw(e, t) {
  t = t.toLowerCase();
  for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
    if (n[i].tagName.toLowerCase() === t)
      return n[i];
}
function mt(e, t, n, i) {
  var r = e.childNodes[t], s;
  return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (s = r || null, r = Js(e.ownerDocument, n, i), e.insertBefore(r, s)), r;
}
function fi(e, t) {
  for (var n = e.childNodes, i = n.length; i > t; )
    e.removeChild(n[--i]);
  return e;
}
function sN(e) {
  return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
}
function Tm(e, t) {
  const n = t.getBoundingClientRect();
  return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
}
function qW(e, t, n, i) {
  var r = e && e.mark, s, o;
  if (r && (s = si[r.marktype]).tip) {
    for (o = Tm(t, n), o[0] -= i[0], o[1] -= i[1]; e = e.mark.group; )
      o[0] -= e.x || 0, o[1] -= e.y || 0;
    e = s.tip(r.items, o);
  }
  return e;
}
function xo(e, t) {
  this._active = null, this._handlers = {}, this._loader = e || Kp(), this._tooltip = t || WW;
}
function WW(e, t, n, i) {
  e.element().setAttribute("title", i || "");
}
xo.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(e, t, n) {
    return this._el = e, this._obj = n || null, this.origin(t);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(e) {
    return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice();
  },
  /**
   * Get / set the scenegraph root.
   */
  scene(e) {
    return arguments.length ? (this._scene = e, this) : this._scene;
  },
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  },
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  },
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(e, t, n) {
    for (let i = e ? e.length : 0; --i >= 0; )
      if (e[i].type === t && (!n || e[i].handler === n))
        return i;
    return -1;
  },
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(e) {
    const t = this._handlers, n = [];
    if (e)
      n.push(...t[this.eventName(e)]);
    else
      for (const i in t)
        n.push(...t[i]);
    return n;
  },
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(e) {
    const t = e.indexOf(".");
    return t < 0 ? e : e.slice(0, t);
  },
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(e, t, n) {
    this._loader.sanitize(n, {
      context: "href"
    }).then((i) => {
      const r = new MouseEvent(e.type, e), s = Js(null, "a");
      for (const o in i)
        s.setAttribute(o, i[o]);
      s.dispatchEvent(r);
    }).catch(() => {
    });
  },
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(e, t, n) {
    if (t && t.tooltip != null) {
      t = qW(t, e, this.canvas(), this._origin);
      const i = n && t && t.tooltip || null;
      this._tooltip.call(this._obj, this, e, t, i);
    }
  },
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(e) {
    const t = this.canvas();
    if (!t)
      return;
    const n = t.getBoundingClientRect(), i = this._origin, r = e.bounds, s = r.width(), o = r.height();
    let a = r.x1 + i[0] + n.left, l = r.y1 + i[1] + n.top;
    for (; e.mark && (e = e.mark.group); )
      a += e.x || 0, l += e.y || 0;
    return {
      x: a,
      y: l,
      width: s,
      height: o,
      left: a,
      top: l,
      right: a + s,
      bottom: l + o
    };
  }
};
function li(e) {
  this._el = null, this._bgcolor = null, this._loader = new B2(e);
}
li.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._el = e, this.resize(t, n, i, r);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this;
  },
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  },
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(e, t) {
    const n = this;
    return n._call = function() {
      n._render(e, t);
    }, n._call(), n._call = null, n;
  },
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  },
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(e, t) {
    const n = this.render(e, t);
    return this._ready ? this._ready.then(() => n) : Promise.resolve(n);
  },
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(e, t) {
    var n = this, i = n._loader[e](t);
    if (!n._ready) {
      const r = n._call;
      n._ready = n._loader.ready().then((s) => {
        s && r(), n._ready = null;
      });
    }
    return i;
  },
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(e) {
    return this._load("sanitizeURL", e);
  },
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(e) {
    return this._load("loadImage", e);
  }
};
const HW = "keydown", GW = "keypress", VW = "keyup", oN = "dragenter", Bh = "dragleave", aN = "dragover", ob = "pointerdown", YW = "pointerup", Cg = "pointermove", nf = "pointerout", lN = "pointerover", ab = "mousedown", XW = "mouseup", uN = "mousemove", lb = "mouseout", cN = "mouseover", $g = "click", KW = "dblclick", JW = "wheel", fN = "mousewheel", Mg = "touchstart", Fg = "touchmove", Tg = "touchend", QW = [HW, GW, VW, oN, Bh, aN, ob, YW, Cg, nf, lN, ab, XW, uN, lb, cN, $g, KW, JW, fN, Mg, Fg, Tg], ub = Cg, Tf = nf, cb = $g;
function wo(e, t) {
  xo.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {};
}
const ZW = (e) => e === Mg || e === Fg || e === Tg ? [Mg, Fg, Tg] : [e];
function fA(e, t) {
  ZW(t).forEach((n) => eH(e, n));
}
function eH(e, t) {
  const n = e.canvas();
  n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
}
function Ic(e, t, n) {
  t.forEach((i) => e.fire(i, n));
}
function dA(e, t, n) {
  return function(i) {
    const r = this._active, s = this.pickEvent(i);
    s === r ? Ic(this, e, i) : ((!r || !r.exit) && Ic(this, n, i), this._active = s, Ic(this, t, i), Ic(this, e, i));
  };
}
function hA(e) {
  return function(t) {
    Ic(this, e, t), this._active = null;
  };
}
Y(wo, xo, {
  initialize(e, t, n) {
    return this._canvas = e && iw(e, "canvas"), [$g, ab, ob, Cg, nf, Bh].forEach((i) => fA(this, i)), xo.prototype.initialize.call(this, e, t, n);
  },
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  },
  // supported events
  events: QW,
  // to keep old versions of firefox happy
  DOMMouseScroll(e) {
    this.fire(fN, e);
  },
  pointermove: dA([Cg, uN], [lN, cN], [nf, lb]),
  dragover: dA([aN], [oN], [Bh]),
  pointerout: hA([nf, lb]),
  dragleave: hA([Bh]),
  pointerdown(e) {
    this._down = this._active, this.fire(ob, e);
  },
  mousedown(e) {
    this._down = this._active, this.fire(ab, e);
  },
  click(e) {
    this._down === this._active && (this.fire($g, e), this._down = null);
  },
  touchstart(e) {
    this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(Mg, e, !0);
  },
  touchmove(e) {
    this.fire(Fg, e, !0);
  },
  touchend(e) {
    this.fire(Tg, e, !0), this._touch = null;
  },
  // fire an event
  fire(e, t, n) {
    const i = n ? this._touch : this._active, r = this._handlers[e];
    if (t.vegaType = e, e === cb && i && i.href ? this.handleHref(t, i, i.href) : (e === ub || e === Tf) && this.handleTooltip(t, i, e !== Tf), r)
      for (let s = 0, o = r.length; s < o; ++s)
        r[s].handler.call(this._obj, t, i);
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    return this._handlerIndex(i[n], e, t) < 0 && (fA(this, e), (i[n] || (i[n] = [])).push({
      type: e,
      handler: t
    })), this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && i.splice(r, 1), this;
  },
  pickEvent(e) {
    const t = Tm(e, this._canvas), n = this._origin;
    return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1]);
  },
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(e, t, n, i, r) {
    const s = this.context();
    return si[e.marktype].pick.call(this, s, e, t, n, i, r);
  }
});
function tH() {
  return typeof window < "u" && window.devicePixelRatio || 1;
}
function nH(e, t, n, i, r, s) {
  const o = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, a = e.getContext("2d"), l = o ? tH() : r;
  e.width = t * l, e.height = n * l;
  for (const u in s)
    a[u] = s[u];
  return o && l !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), a.pixelRatio = l, a.setTransform(l, 0, 0, l, l * i[0], l * i[1]), e;
}
function Of(e) {
  li.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new ht(), this._tempb = new ht();
}
const gA = li.prototype, iH = (e, t, n) => new ht().set(0, 0, t, n).translate(-e[0], -e[1]);
function rH(e, t, n) {
  return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
}
Y(Of, li, {
  initialize(e, t, n, i, r, s) {
    return this._options = s || {}, this._canvas = this._options.externalContext ? null : lo(1, 1, this._options.type), e && this._canvas && (fi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), gA.initialize.call(this, e, t, n, i, r);
  },
  resize(e, t, n, i) {
    if (gA.resize.call(this, e, t, n, i), this._canvas)
      nH(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const r = this._options.externalContext;
      r || B("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
    }
    return this._redraw = !0, this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(e) {
    const t = this._tempb.clear().union(e.bounds);
    let n = e.mark.group;
    for (; n; )
      t.translate(n.x || 0, n.y || 0), n = n.mark.group;
    this._dirty.union(t);
  },
  _render(e, t) {
    const n = this.context(), i = this._origin, r = this._width, s = this._height, o = this._dirty, a = iH(i, r, s);
    n.save();
    const l = this._redraw || o.empty() ? (this._redraw = !1, a.expand(1)) : rH(n, a.intersect(o), i);
    return this.clear(-i[0], -i[1], r, s), this.draw(n, e, l, t), n.restore(), o.clear(), this;
  },
  draw(e, t, n, i) {
    if (t.marktype !== "group" && i != null && !i.includes(t.marktype))
      return;
    const r = si[t.marktype];
    t.clip && tW(e, t), r.draw.call(this, e, t, n, i), t.clip && e.restore();
  },
  clear(e, t, n, i) {
    const r = this._options, s = this.context();
    r.type !== "pdf" && !r.externalContext && s.clearRect(e, t, n, i), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(e, t, n, i));
  }
});
function rw(e, t) {
  xo.call(this, e, t);
  const n = this;
  n._hrefHandler = fb(n, (i, r) => {
    r && r.href && n.handleHref(i, r, r.href);
  }), n._tooltipHandler = fb(n, (i, r) => {
    n.handleTooltip(i, r, i.type !== Tf);
  });
}
const fb = (e, t) => (n) => {
  let i = n.target.__data__;
  i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
};
Y(rw, xo, {
  initialize(e, t, n) {
    let i = this._svg;
    return i && (i.removeEventListener(cb, this._hrefHandler), i.removeEventListener(ub, this._tooltipHandler), i.removeEventListener(Tf, this._tooltipHandler)), this._svg = i = e && iw(e, "svg"), i && (i.addEventListener(cb, this._hrefHandler), i.addEventListener(ub, this._tooltipHandler), i.addEventListener(Tf, this._tooltipHandler)), xo.prototype.initialize.call(this, e, t, n);
  },
  canvas() {
    return this._svg;
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    if (this._handlerIndex(i[n], e, t) < 0) {
      const s = {
        type: e,
        handler: t,
        listener: fb(this, t)
      };
      (i[n] || (i[n] = [])).push(s), this._svg && this._svg.addEventListener(n, s.listener);
    }
    return this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this;
  }
});
const dN = "aria-hidden", sw = "aria-label", ow = "role", aw = "aria-roledescription", hN = "graphics-object", lw = "graphics-symbol", gN = (e, t, n) => ({
  [ow]: e,
  [aw]: t,
  [sw]: n || void 0
}), sH = Ji(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), pA = {
  axis: {
    desc: "axis",
    caption: lH
  },
  legend: {
    desc: "legend",
    caption: uH
  },
  "title-text": {
    desc: "title",
    caption: (e) => `Title text '${yA(e)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (e) => `Subtitle text '${yA(e)}'`
  }
}, mA = {
  ariaRole: ow,
  ariaRoleDescription: aw,
  description: sw
};
function pN(e, t) {
  const n = t.aria === !1;
  if (e(dN, n || void 0), n || t.description == null)
    for (const i in mA)
      e(mA[i], void 0);
  else {
    const i = t.mark.marktype;
    e(sw, t.description), e(ow, t.ariaRole || (i === "group" ? hN : lw)), e(aw, t.ariaRoleDescription || `${i} mark`);
  }
}
function mN(e) {
  return e.aria === !1 ? {
    [dN]: !0
  } : sH[e.role] ? null : pA[e.role] ? aH(e, pA[e.role]) : oH(e);
}
function oH(e) {
  const t = e.marktype, n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
  return gN(n ? hN : lw, `${t} mark container`, e.description);
}
function aH(e, t) {
  try {
    const n = e.items[0], i = t.caption || (() => "");
    return gN(t.role || lw, t.desc, n.description || i(n));
  } catch {
    return null;
  }
}
function yA(e) {
  return J(e.text).join(" ");
}
function lH(e) {
  const t = e.datum, n = e.orient, i = t.title ? yN(e) : null, r = e.context, s = r.scales[t.scale].value, o = r.dataflow.locale(), a = s.type;
  return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${uu(a) ? "discrete" : a} scale with ${OO(o, s, e)}`;
}
function uH(e) {
  const t = e.datum, n = t.title ? yN(e) : null, i = `${t.type || ""} legend`.trim(), r = t.scales, s = Object.keys(r), o = e.context, a = o.scales[r[s[0]]].value, l = o.dataflow.locale();
  return fH(i) + (n ? ` titled '${n}'` : "") + ` for ${cH(s)} with ${OO(l, a, e)}`;
}
function yN(e) {
  try {
    return J(Oe(e.items).items[0].text).join(" ");
  } catch {
    return null;
  }
}
function cH(e) {
  return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + Oe(e);
}
function fH(e) {
  return e.length ? e[0].toUpperCase() + e.slice(1) : e;
}
const bN = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), dH = (e) => bN(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function uw() {
  let e = "", t = "", n = "";
  const i = [], r = () => t = n = "", s = (l) => {
    t && (e += `${t}>${n}`, r()), i.push(l);
  }, o = (l, u) => (u != null && (t += ` ${l}="${dH(u)}"`), a), a = {
    open(l) {
      s(l), t = "<" + l;
      for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++)
        c[f - 1] = arguments[f];
      for (const d of c)
        for (const h in d)
          o(h, d[h]);
      return a;
    },
    close() {
      const l = i.pop();
      return t ? e += t + (n ? `>${n}</${l}>` : "/>") : e += `</${l}>`, r(), a;
    },
    attr: o,
    text: (l) => (n += bN(l), a),
    toString: () => e
  };
  return a;
}
const vN = (e) => xN(uw(), e) + "";
function xN(e, t) {
  if (e.open(t.tagName), t.hasAttributes()) {
    const n = t.attributes, i = n.length;
    for (let r = 0; r < i; ++r)
      e.attr(n[r].name, n[r].value);
  }
  if (t.hasChildNodes()) {
    const n = t.childNodes;
    for (const i of n)
      i.nodeType === 3 ? e.text(i.nodeValue) : xN(e, i);
  }
  return e.close();
}
const Og = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
}, Ng = {
  blend: "mix-blend-mode"
}, wN = {
  fill: "none",
  "stroke-miterlimit": 10
}, gc = 0, bA = "http://www.w3.org/2000/xmlns/", pt = Ff.xmlns;
function Om(e) {
  li.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
}
const x1 = li.prototype;
Y(Om, li, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._defs = {}, this._clearDefs(), e && (this._svg = mt(e, 0, "svg", pt), this._svg.setAttributeNS(bA, "xmlns", pt), this._svg.setAttributeNS(bA, "xmlns:xlink", Ff["xmlns:xlink"]), this._svg.setAttribute("version", Ff.version), this._svg.setAttribute("class", "marks"), fi(e, 1), this._root = mt(this._svg, gc, "g", pt), Qs(this._root, wN), fi(this._svg, gc + 1)), this.background(this._bgcolor), x1.initialize.call(this, e, t, n, i, r);
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), x1.background.apply(this, arguments);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return x1.resize.call(this, e, t, n, i), this._svg && (Qs(this._svg, {
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
  },
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const e = this._svg, t = this._bgcolor;
    if (!e)
      return null;
    let n;
    t && (e.removeAttribute("style"), n = mt(e, gc, "rect", pt), Qs(n, {
      width: this._width,
      height: this._height,
      fill: t
    }));
    const i = vN(e);
    return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(e, t) {
    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e, void 0, t), fi(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
  },
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(e) {
    e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e));
  },
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(e) {
    return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID;
  },
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = !0;
    const e = this._dirty;
    if (!e.length || !this._dirtyID)
      return !0;
    const t = ++this._dirtyID;
    let n, i, r, s, o, a, l;
    for (o = 0, a = e.length; o < a; ++o)
      if (n = e[o], i = n.mark, i.marktype !== r && (r = i.marktype, s = si[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, vA(n, t), i.items.forEach((u) => {
        u.dirty = t;
      })), !i.zdirty) {
        if (n.exit) {
          s.nested && i.items.length ? (l = i.items[0], l._svg && this._update(s, l._svg, l)) : n._svg && (l = n._svg.parentNode, l && l.removeChild(n._svg)), n._svg = null;
          continue;
        }
        n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, vA(n, t)) : this._update(s, n._svg, n), n._update = t);
      }
    return !this._dirtyAll;
  },
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(e, t, n, i) {
    if (!this.isDirty(t))
      return t._svg;
    const r = this._svg, s = t.marktype, o = si[s], a = t.interactive === !1 ? "none" : null, l = o.tag === "g", u = xA(t, e, n, "g", r);
    if (s !== "group" && i != null && !i.includes(s))
      return fi(u, 0), t._svg;
    u.setAttribute("class", sN(t));
    const c = mN(t);
    for (const g in c)
      fn(u, g, c[g]);
    l || fn(u, "pointer-events", a), fn(u, "clip-path", t.clip ? z2(this, t, t.group) : null);
    let f = null, d = 0;
    const h = (g) => {
      const p = this.isDirty(g), m = xA(g, u, f, o.tag, r);
      p && (this._update(o, m, g), l && pH(this, m, g, i)), f = m, ++d;
    };
    return o.nested ? t.items.length && h(t.items[0]) : Zi(t, h), fi(u, d), u;
  },
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(e, t, n) {
    fs = t, Kt = t.__values__, pN(rf, n), e.attr(rf, n, this);
    const i = yH[e.type];
    i && i.call(this, e, t, n), fs && this.style(fs, n);
  },
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(e, t) {
    if (t != null) {
      for (const n in Og) {
        let i = n === "font" ? yd(t) : t[n];
        if (i === Kt[n])
          continue;
        const r = Og[n];
        i == null ? e.removeAttribute(r) : (L2(i) && (i = DO(i, this._defs.gradient, _N())), e.setAttribute(r, i + "")), Kt[n] = i;
      }
      for (const n in Ng)
        jh(e, Ng[n], t[n]);
    }
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const e = this._svg, t = this._defs;
    let n = t.el, i = 0;
    for (const r in t.gradient)
      n || (t.el = n = mt(e, gc + 1, "defs", pt)), i = hH(n, t.gradient[r], i);
    for (const r in t.clipping)
      n || (t.el = n = mt(e, gc + 1, "defs", pt)), i = gH(n, t.clipping[r], i);
    n && (i === 0 ? (e.removeChild(n), t.el = null) : fi(n, i));
  },
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const e = this._defs;
    e.gradient = {}, e.clipping = {};
  }
});
function vA(e, t) {
  for (; e && e.dirty !== t; e = e.mark.group)
    if (e.dirty = t, e.mark && e.mark.dirty !== t)
      e.mark.dirty = t;
    else
      return;
}
function hH(e, t, n) {
  let i, r, s;
  if (t.gradient === "radial") {
    let o = mt(e, n++, "pattern", pt);
    Qs(o, {
      id: Eg + t.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    }), o = mt(o, 0, "rect", pt), Qs(o, {
      width: 1,
      height: 1,
      fill: `url(${_N()}#${t.id})`
    }), e = mt(e, n++, "radialGradient", pt), Qs(e, {
      id: t.id,
      fx: t.x1,
      fy: t.y1,
      fr: t.r1,
      cx: t.x2,
      cy: t.y2,
      r: t.r2
    });
  } else
    e = mt(e, n++, "linearGradient", pt), Qs(e, {
      id: t.id,
      x1: t.x1,
      x2: t.x2,
      y1: t.y1,
      y2: t.y2
    });
  for (i = 0, r = t.stops.length; i < r; ++i)
    s = mt(e, i, "stop", pt), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
  return fi(e, i), n;
}
function gH(e, t, n) {
  let i;
  return e = mt(e, n, "clipPath", pt), e.setAttribute("id", t.id), t.path ? (i = mt(e, 0, "path", pt), i.setAttribute("d", t.path)) : (i = mt(e, 0, "rect", pt), Qs(i, {
    x: 0,
    y: 0,
    width: t.width,
    height: t.height
  })), fi(e, 1), n + 1;
}
function pH(e, t, n, i) {
  t = t.lastChild.previousSibling;
  let r, s = 0;
  Zi(n, (o) => {
    r = e.mark(t, o, r, i), ++s;
  }), fi(t, 1 + s);
}
function xA(e, t, n, i, r) {
  let s = e._svg, o;
  if (!s && (o = t.ownerDocument, s = Js(o, i, pt), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
    fill: "default"
  }, i === "g"))) {
    const a = Js(o, "path", pt);
    s.appendChild(a), a.__data__ = e;
    const l = Js(o, "g", pt);
    s.appendChild(l), l.__data__ = e;
    const u = Js(o, "path", pt);
    s.appendChild(u), u.__data__ = e, u.__values__ = {
      fill: "default"
    };
  }
  return (s.ownerSVGElement !== r || mH(s, n)) && t.insertBefore(s, n ? n.nextSibling : t.firstChild), s;
}
function mH(e, t) {
  return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
}
let fs = null, Kt = null;
const yH = {
  group(e, t, n) {
    const i = fs = t.childNodes[2];
    Kt = i.__values__, e.foreground(rf, n, this), Kt = t.__values__, fs = t.childNodes[1], e.content(rf, n, this);
    const r = fs = t.childNodes[0];
    e.background(rf, n, this);
    const s = n.mark.interactive === !1 ? "none" : null;
    if (s !== Kt.events && (fn(i, "pointer-events", s), fn(r, "pointer-events", s), Kt.events = s), n.strokeForeground && n.stroke) {
      const o = n.fill;
      fn(i, "display", null), this.style(r, n), fn(r, "stroke", null), o && (n.fill = null), Kt = i.__values__, this.style(i, n), o && (n.fill = o), fs = null;
    } else
      fn(i, "display", "none");
  },
  image(e, t, n) {
    n.smooth === !1 ? (jh(t, "image-rendering", "optimizeSpeed"), jh(t, "image-rendering", "pixelated")) : jh(t, "image-rendering", null);
  },
  text(e, t, n) {
    const i = md(n);
    let r, s, o, a;
    j(i) ? (s = i.map((l) => vo(n, l)), r = s.join(`
`), r !== Kt.text && (fi(t, 0), o = t.ownerDocument, a = bo(n), s.forEach((l, u) => {
      const c = Js(o, "tspan", pt);
      c.__data__ = n, c.textContent = l, u && (c.setAttribute("x", 0), c.setAttribute("dy", a)), t.appendChild(c);
    }), Kt.text = r)) : (s = vo(n, i), s !== Kt.text && (t.textContent = s, Kt.text = s)), fn(t, "font-family", yd(n)), fn(t, "font-size", zr(n) + "px"), fn(t, "font-style", n.fontStyle), fn(t, "font-variant", n.fontVariant), fn(t, "font-weight", n.fontWeight);
  }
};
function rf(e, t, n) {
  t !== Kt[e] && (n ? bH(fs, e, t, n) : fn(fs, e, t), Kt[e] = t);
}
function jh(e, t, n) {
  n !== Kt[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Kt[t] = n);
}
function Qs(e, t) {
  for (const n in t)
    fn(e, n, t[n]);
}
function fn(e, t, n) {
  n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
}
function bH(e, t, n, i) {
  n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
}
function _N() {
  let e;
  return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
}
function cw(e) {
  li.call(this, e), this._text = null, this._defs = {
    gradient: {},
    clipping: {}
  };
}
Y(cw, li, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(e) {
    const t = uw();
    t.open("svg", we({}, Ff, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const n = this._bgcolor;
    return n && n !== "transparent" && n !== "none" && t.open("rect", {
      width: this._width,
      height: this._height,
      fill: n
    }).close(), t.open("g", wN, {
      transform: "translate(" + this._origin + ")"
    }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this;
  },
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(e, t) {
    const n = si[t.marktype], i = n.tag, r = [pN, n.attr];
    e.open("g", {
      class: sN(t),
      "clip-path": t.clip ? z2(this, t, t.group) : null
    }, mN(t), {
      "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
    });
    const s = (o) => {
      const a = this.href(o);
      if (a && e.open("a", a), e.open(i, this.attr(t, o, r, i !== "g" ? i : null)), i === "text") {
        const l = md(o);
        if (j(l)) {
          const u = {
            x: 0,
            dy: bo(o)
          };
          for (let c = 0; c < l.length; ++c)
            e.open("tspan", c ? u : null).text(vo(o, l[c])).close();
        } else
          e.text(vo(o, l));
      } else if (i === "g") {
        const l = o.strokeForeground, u = o.fill, c = o.stroke;
        l && c && (o.stroke = null), e.open("path", this.attr(t, o, n.background, "bgrect")).close(), e.open("g", this.attr(t, o, n.content)), Zi(o, (f) => this.mark(e, f)), e.close(), l && c ? (u && (o.fill = null), o.stroke = c, e.open("path", this.attr(t, o, n.foreground, "bgrect")).close(), u && (o.fill = u)) : e.open("path", this.attr(t, o, n.foreground, "bgfore")).close();
      }
      e.close(), a && e.close();
    };
    return n.nested ? t.items && t.items.length && s(t.items[0]) : Zi(t, s), e.close();
  },
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(e) {
    const t = e.href;
    let n;
    if (t) {
      if (n = this._hrefs && this._hrefs[t])
        return n;
      this.sanitizeURL(t).then((i) => {
        i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i;
      });
    }
    return null;
  },
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(e, t, n, i) {
    const r = {}, s = (o, a, l, u) => {
      r[u || o] = a;
    };
    return Array.isArray(n) ? n.forEach((o) => o(s, t, this)) : n(s, t, this), i && vH(r, t, e, i, this._defs), r;
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(e) {
    const t = this._defs.gradient, n = this._defs.clipping;
    if (Object.keys(t).length + Object.keys(n).length !== 0) {
      e.open("defs");
      for (const r in t) {
        const s = t[r], o = s.stops;
        s.gradient === "radial" ? (e.open("pattern", {
          id: Eg + r,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        }), e.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + r + ")"
        }).close(), e.close(), e.open("radialGradient", {
          id: r,
          fx: s.x1,
          fy: s.y1,
          fr: s.r1,
          cx: s.x2,
          cy: s.y2,
          r: s.r2
        })) : e.open("linearGradient", {
          id: r,
          x1: s.x1,
          x2: s.x2,
          y1: s.y1,
          y2: s.y2
        });
        for (let a = 0; a < o.length; ++a)
          e.open("stop", {
            offset: o[a].offset,
            "stop-color": o[a].color
          }).close();
        e.close();
      }
      for (const r in n) {
        const s = n[r];
        e.open("clipPath", {
          id: r
        }), s.path ? e.open("path", {
          d: s.path
        }).close() : e.open("rect", {
          x: 0,
          y: 0,
          width: s.width,
          height: s.height
        }).close(), e.close();
      }
      e.close();
    }
  }
});
function vH(e, t, n, i, r) {
  let s;
  if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
    return e;
  i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = yd(t), e["font-size"] = zr(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
  for (const o in Og) {
    let a = t[o];
    const l = Og[o];
    a === "transparent" && (l === "fill" || l === "stroke") || a != null && (L2(a) && (a = DO(a, r.gradient, "")), e[l] = a);
  }
  for (const o in Ng) {
    const a = t[o];
    a != null && (s = s || [], s.push(`${Ng[o]}: ${a};`));
  }
  return s && (e.style = s.join(" ")), e;
}
const Pi = {
  svgMarkTypes: ["text"],
  svgOnTop: !0,
  debug: !1
};
function xH(e) {
  Pi.svgMarkTypes = e.svgMarkTypes ?? ["text"], Pi.svgOnTop = e.svgOnTop ?? !0, Pi.debug = e.debug ?? !1;
}
function Dg(e) {
  li.call(this, e), this._svgRenderer = new Om(e), this._canvasRenderer = new Of(e);
}
const wA = li.prototype;
Y(Dg, li, {
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    this._root_el = mt(e, 0, "div");
    const s = mt(this._root_el, 0, "div"), o = mt(this._root_el, 1, "div");
    return this._root_el.style.position = "relative", Pi.debug || (s.style.height = "100%", o.style.position = "absolute", o.style.top = "0", o.style.left = "0", o.style.height = "100%", o.style.width = "100%"), this._svgEl = Pi.svgOnTop ? o : s, this._canvasEl = Pi.svgOnTop ? s : o, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, t, n, i, r), this._svgRenderer.initialize(this._svgEl, t, n, i, r), wA.initialize.call(this, e, t, n, i, r);
  },
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(e) {
    return Pi.svgMarkTypes.includes(e.mark.marktype) ? this._svgRenderer.dirty(e) : this._canvasRenderer.dirty(e), this;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(e, t) {
    const i = (t ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"]).filter((r) => !Pi.svgMarkTypes.includes(r));
    this._svgRenderer.render(e, Pi.svgMarkTypes), this._canvasRenderer.render(e, i);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return wA.resize.call(this, e, t, n, i), this._svgRenderer.resize(e, t, n, i), this._canvasRenderer.resize(e, t, n, i), this;
  },
  background(e) {
    return Pi.svgOnTop ? this._canvasRenderer.background(e) : this._svgRenderer.background(e), this;
  }
});
function fw(e, t) {
  wo.call(this, e, t);
}
Y(fw, wo, {
  initialize(e, t, n) {
    const i = mt(mt(e, 0, "div"), Pi.svgOnTop ? 0 : 1, "div");
    return wo.prototype.initialize.call(this, i, t, n);
  }
});
const EN = "canvas", SN = "hybrid", kN = "png", AN = "svg", CN = "none", Zs = {
  Canvas: EN,
  PNG: kN,
  SVG: AN,
  Hybrid: SN,
  None: CN
}, Oa = {};
Oa[EN] = Oa[kN] = {
  renderer: Of,
  headless: Of,
  handler: wo
};
Oa[AN] = {
  renderer: Om,
  headless: cw,
  handler: rw
};
Oa[SN] = {
  renderer: Dg,
  headless: Dg,
  handler: fw
};
Oa[CN] = {};
function Nm(e, t) {
  return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Oa[e] = t, this) : Oa[e];
}
function $N(e, t, n) {
  const i = [], r = new ht().union(t), s = e.marktype;
  return s ? MN(e, r, n, i) : s === "group" ? FN(e, r, n, i) : B("Intersect scene must be mark node or group item.");
}
function MN(e, t, n, i) {
  if (wH(e, t, n)) {
    const r = e.items, s = e.marktype, o = r.length;
    let a = 0;
    if (s === "group")
      for (; a < o; ++a)
        FN(r[a], t, n, i);
    else
      for (const l = si[s].isect; a < o; ++a) {
        const u = r[a];
        TN(u, t, l) && i.push(u);
      }
  }
  return i;
}
function wH(e, t, n) {
  return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
}
function FN(e, t, n, i) {
  n && n(e.mark) && TN(e, t, si.group.isect) && i.push(e);
  const r = e.items, s = r && r.length;
  if (s) {
    const o = e.x || 0, a = e.y || 0;
    t.translate(-o, -a);
    for (let l = 0; l < s; ++l)
      MN(r[l], t, n, i);
    t.translate(o, a);
  }
  return i;
}
function TN(e, t, n) {
  const i = e.bounds;
  return t.encloses(i) || t.intersects(i) && n(e, t);
}
const w1 = new ht();
function ON(e) {
  const t = e.clip;
  if (Ee(t))
    t(gd(w1.clear()));
  else if (t)
    w1.set(0, 0, e.group.width, e.group.height);
  else
    return;
  e.bounds.intersect(w1);
}
const _H = 1e-9;
function dw(e, t, n) {
  return e === t ? !0 : n === "path" ? NN(e, t) : e instanceof Date && t instanceof Date ? +e == +t : Re(e) && Re(t) ? Math.abs(e - t) <= _H : !e || !t || !ee(e) && !ee(t) ? e == t : EH(e, t);
}
function NN(e, t) {
  return dw(cu(e), cu(t));
}
function EH(e, t) {
  var n = Object.keys(e), i = Object.keys(t), r, s;
  if (n.length !== i.length)
    return !1;
  for (n.sort(), i.sort(), s = n.length - 1; s >= 0; s--)
    if (n[s] != i[s])
      return !1;
  for (s = n.length - 1; s >= 0; s--)
    if (r = n[s], !dw(e[r], t[r], r))
      return !1;
  return typeof e == typeof t;
}
function SH() {
  jO(), YU();
}
const hu = "top", Ui = "left", qi = "right", _o = "bottom", kH = "top-left", AH = "top-right", CH = "bottom-left", $H = "bottom-right", hw = "start", db = "middle", dn = "end", MH = "x", FH = "y", Dm = "group", gw = "axis", pw = "title", TH = "frame", OH = "scope", mw = "legend", DN = "row-header", RN = "row-footer", LN = "row-title", PN = "column-header", IN = "column-footer", zN = "column-title", NH = "padding", DH = "symbol", BN = "fit", jN = "fit-x", UN = "fit-y", RH = "pad", yw = "none", Zd = "all", hb = "each", bw = "flush", eo = "column", to = "row";
function qN(e) {
  P.call(this, null, e);
}
Y(qN, P, {
  transform(e, t) {
    const n = t.dataflow, i = e.mark, r = i.marktype, s = si[r], o = s.bound;
    let a = i.bounds, l;
    if (s.nested)
      i.items.length && n.dirty(i.items[0]), a = eh(i, o), i.items.forEach((u) => {
        u.bounds.clear().union(a);
      });
    else if (r === Dm || e.modified())
      switch (t.visit(t.MOD, (u) => n.dirty(u)), a.clear(), i.items.forEach((u) => a.union(eh(u, o))), i.role) {
        case gw:
        case mw:
        case pw:
          t.reflow();
      }
    else
      l = t.changed(t.REM), t.visit(t.ADD, (u) => {
        a.union(eh(u, o));
      }), t.visit(t.MOD, (u) => {
        l = l || a.alignsWith(u.bounds), n.dirty(u), a.union(eh(u, o));
      }), l && (a.clear(), i.items.forEach((u) => a.union(u.bounds)));
    return ON(i), t.modifies("bounds");
  }
});
function eh(e, t, n) {
  return t(e.bounds.clear(), e, n);
}
const _A = ":vega_identifier:";
function vw(e) {
  P.call(this, 0, e);
}
vw.Definition = {
  type: "Identifier",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "as",
    type: "string",
    required: !0
  }]
};
Y(vw, P, {
  transform(e, t) {
    const n = LH(t.dataflow), i = e.as;
    let r = n.value;
    return t.visit(t.ADD, (s) => s[i] = s[i] || ++r), n.set(this.value = r), t;
  }
});
function LH(e) {
  return e._signals[_A] || (e._signals[_A] = e.add(0));
}
function WN(e) {
  P.call(this, null, e);
}
Y(WN, P, {
  transform(e, t) {
    let n = this.value;
    n || (n = t.dataflow.scenegraph().mark(e.markdef, PH(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
    const i = n.marktype === Dm ? Sm : Em;
    return t.visit(t.ADD, (r) => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
  }
});
function PH(e) {
  const t = e.groups, n = e.parent;
  return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
}
function HN(e) {
  P.call(this, null, e);
}
const EA = {
  parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
  greedy: (e, t) => {
    let n;
    return e.filter((i, r) => !r || !GN(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0);
  }
}, GN = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2), SA = (e, t) => {
  for (var n = 1, i = e.length, r = e[0].bounds, s; n < i; r = s, ++n)
    if (GN(r, s = e[n].bounds, t))
      return !0;
}, IH = (e) => {
  const t = e.bounds;
  return t.width() > 1 && t.height() > 1;
}, zH = (e, t, n) => {
  var i = e.range(), r = new ht();
  return t === hu || t === _o ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), (s) => r.encloses(s.bounds);
}, kA = (e) => (e.forEach((t) => t.opacity = 1), e), AA = (e, t) => e.reflow(t.modified()).modifies("opacity");
Y(HN, P, {
  transform(e, t) {
    const n = EA[e.method] || EA.parity, i = e.separation || 0;
    let r = t.materialize(t.SOURCE).source, s, o;
    if (!r || !r.length)
      return;
    if (!e.method)
      return e.modified("method") && (kA(r), t = AA(t, e)), t;
    if (r = r.filter(IH), !r.length)
      return;
    if (e.sort && (r = r.slice().sort(e.sort)), s = kA(r), t = AA(t, e), s.length >= 3 && SA(s, i)) {
      do
        s = n(s, i);
      while (s.length >= 3 && SA(s, i));
      s.length < 3 && !Oe(r).opacity && (s.length > 1 && (Oe(s).opacity = 0), Oe(r).opacity = 1);
    }
    e.boundScale && e.boundTolerance >= 0 && (o = zH(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach((l) => {
      o(l) || (l.opacity = 0);
    }));
    const a = s[0].mark.bounds.clear();
    return r.forEach((l) => {
      l.opacity && a.union(l.bounds);
    }), t;
  }
});
function VN(e) {
  P.call(this, null, e);
}
Y(VN, P, {
  transform(e, t) {
    const n = t.dataflow;
    if (t.visit(t.ALL, (i) => n.dirty(i)), t.fields && t.fields.zindex) {
      const i = t.source && t.source[0];
      i && (i.mark.zdirty = !0);
    }
  }
});
const Xt = new ht();
function Ll(e, t, n) {
  return e[t] === n ? 0 : (e[t] = n, 1);
}
function BH(e) {
  var t = e.items[0].orient;
  return t === Ui || t === qi;
}
function jH(e) {
  let t = +e.grid;
  return [
    e.ticks ? t++ : -1,
    // ticks index
    e.labels ? t++ : -1,
    // labels index
    t + +e.domain
    // title index
  ];
}
function UH(e, t, n, i) {
  var r = t.items[0], s = r.datum, o = r.translate != null ? r.translate : 0.5, a = r.orient, l = jH(s), u = r.range, c = r.offset, f = r.position, d = r.minExtent, h = r.maxExtent, g = s.title && r.items[l[2]].items[0], p = r.titlePadding, m = r.bounds, y = g && Z2(g), b = 0, v = 0, w, _;
  switch (Xt.clear().union(m), m.clear(), (w = l[0]) > -1 && m.union(r.items[w].bounds), (w = l[1]) > -1 && m.union(r.items[w].bounds), a) {
    case hu:
      b = f || 0, v = -c, _ = Math.max(d, Math.min(h, -m.y1)), m.add(0, -_).add(u, 0), g && th(e, g, _, p, y, 0, -1, m);
      break;
    case Ui:
      b = -c, v = f || 0, _ = Math.max(d, Math.min(h, -m.x1)), m.add(-_, 0).add(0, u), g && th(e, g, _, p, y, 1, -1, m);
      break;
    case qi:
      b = n + c, v = f || 0, _ = Math.max(d, Math.min(h, m.x2)), m.add(0, 0).add(_, u), g && th(e, g, _, p, y, 1, 1, m);
      break;
    case _o:
      b = f || 0, v = i + c, _ = Math.max(d, Math.min(h, m.y2)), m.add(0, 0).add(u, _), g && th(e, g, _, p, 0, 0, 1, m);
      break;
    default:
      b = r.x, v = r.y;
  }
  return Fs(m.translate(b, v), r), Ll(r, "x", b + o) | Ll(r, "y", v + o) && (r.bounds = Xt, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
}
function th(e, t, n, i, r, s, o, a) {
  const l = t.bounds;
  if (t.auto) {
    const u = o * (n + r + i);
    let c = 0, f = 0;
    e.dirty(t), s ? c = (t.x || 0) - (t.x = u) : f = (t.y || 0) - (t.y = u), t.mark.bounds.clear().union(l.translate(-c, -f)), e.dirty(t);
  }
  a.union(l);
}
const CA = (e, t) => Math.floor(Math.min(e, t)), $A = (e, t) => Math.ceil(Math.max(e, t));
function qH(e) {
  var t = e.items, n = t.length, i = 0, r, s;
  const o = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i)
    if (r = t[i], s = r.items, r.marktype === Dm)
      switch (r.role) {
        case gw:
        case mw:
        case pw:
          break;
        case DN:
          o.rowheaders.push(...s);
          break;
        case RN:
          o.rowfooters.push(...s);
          break;
        case PN:
          o.colheaders.push(...s);
          break;
        case IN:
          o.colfooters.push(...s);
          break;
        case LN:
          o.rowtitle = s[0];
          break;
        case zN:
          o.coltitle = s[0];
          break;
        default:
          o.marks.push(...s);
      }
  return o;
}
function WH(e) {
  return new ht().set(0, 0, e.width || 0, e.height || 0);
}
function HH(e) {
  const t = e.bounds.clone();
  return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
}
function Ze(e, t, n) {
  const i = ee(e) ? e[t] : e;
  return i ?? (n !== void 0 ? n : 0);
}
function MA(e) {
  return e < 0 ? Math.ceil(-e) : 0;
}
function YN(e, t, n) {
  var i = !n.nodirty, r = n.bounds === bw ? WH : HH, s = Xt.set(0, 0, 0, 0), o = Ze(n.align, eo), a = Ze(n.align, to), l = Ze(n.padding, eo), u = Ze(n.padding, to), c = n.columns || t.length, f = c <= 0 ? 1 : Math.ceil(t.length / c), d = t.length, h = Array(d), g = Array(c), p = 0, m = Array(d), y = Array(f), b = 0, v = Array(d), w = Array(d), _ = Array(d), S, E, C, $, N, T, L, O, F, x, k;
  for (E = 0; E < c; ++E)
    g[E] = 0;
  for (E = 0; E < f; ++E)
    y[E] = 0;
  for (E = 0; E < d; ++E)
    T = t[E], N = _[E] = r(T), T.x = T.x || 0, v[E] = 0, T.y = T.y || 0, w[E] = 0, C = E % c, $ = ~~(E / c), p = Math.max(p, L = Math.ceil(N.x2)), b = Math.max(b, O = Math.ceil(N.y2)), g[C] = Math.max(g[C], L), y[$] = Math.max(y[$], O), h[E] = l + MA(N.x1), m[E] = u + MA(N.y1), i && e.dirty(t[E]);
  for (E = 0; E < d; ++E)
    E % c === 0 && (h[E] = 0), E < c && (m[E] = 0);
  if (o === hb)
    for (C = 1; C < c; ++C) {
      for (k = 0, E = C; E < d; E += c)
        k < h[E] && (k = h[E]);
      for (E = C; E < d; E += c)
        h[E] = k + g[C - 1];
    }
  else if (o === Zd) {
    for (k = 0, E = 0; E < d; ++E)
      E % c && k < h[E] && (k = h[E]);
    for (E = 0; E < d; ++E)
      E % c && (h[E] = k + p);
  } else
    for (o = !1, C = 1; C < c; ++C)
      for (E = C; E < d; E += c)
        h[E] += g[C - 1];
  if (a === hb)
    for ($ = 1; $ < f; ++$) {
      for (k = 0, E = $ * c, S = E + c; E < S; ++E)
        k < m[E] && (k = m[E]);
      for (E = $ * c; E < S; ++E)
        m[E] = k + y[$ - 1];
    }
  else if (a === Zd) {
    for (k = 0, E = c; E < d; ++E)
      k < m[E] && (k = m[E]);
    for (E = c; E < d; ++E)
      m[E] = k + b;
  } else
    for (a = !1, $ = 1; $ < f; ++$)
      for (E = $ * c, S = E + c; E < S; ++E)
        m[E] += y[$ - 1];
  for (F = 0, E = 0; E < d; ++E)
    F = h[E] + (E % c ? F : 0), v[E] += F - t[E].x;
  for (C = 0; C < c; ++C)
    for (x = 0, E = C; E < d; E += c)
      x += m[E], w[E] += x - t[E].y;
  if (o && Ze(n.center, eo) && f > 1)
    for (E = 0; E < d; ++E)
      N = o === Zd ? p : g[E % c], F = N - _[E].x2 - t[E].x - v[E], F > 0 && (v[E] += F / 2);
  if (a && Ze(n.center, to) && c !== 1)
    for (E = 0; E < d; ++E)
      N = a === Zd ? b : y[~~(E / c)], x = N - _[E].y2 - t[E].y - w[E], x > 0 && (w[E] += x / 2);
  for (E = 0; E < d; ++E)
    s.union(_[E].translate(v[E], w[E]));
  switch (F = Ze(n.anchor, MH), x = Ze(n.anchor, FH), Ze(n.anchor, eo)) {
    case dn:
      F -= s.width();
      break;
    case db:
      F -= s.width() / 2;
  }
  switch (Ze(n.anchor, to)) {
    case dn:
      x -= s.height();
      break;
    case db:
      x -= s.height() / 2;
  }
  for (F = Math.round(F), x = Math.round(x), s.clear(), E = 0; E < d; ++E)
    t[E].mark.bounds.clear();
  for (E = 0; E < d; ++E)
    T = t[E], T.x += v[E] += F, T.y += w[E] += x, s.union(T.mark.bounds.union(T.bounds.translate(v[E], w[E]))), i && e.dirty(T);
  return s;
}
function GH(e, t, n) {
  var i = qH(t), r = i.marks, s = n.bounds === bw ? VH : YH, o = n.offset, a = n.columns || r.length, l = a <= 0 ? 1 : Math.ceil(r.length / a), u = l * a, c, f, d, h, g, p, m;
  const y = YN(e, r, n);
  y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = Ze(n.headerBand, to, null), c = nh(e, i.rowheaders, r, a, l, -Ze(o, "rowHeader"), CA, 0, s, "x1", 0, a, 1, p)), i.colheaders && (p = Ze(n.headerBand, eo, null), f = nh(e, i.colheaders, r, a, a, -Ze(o, "columnHeader"), CA, 1, s, "y1", 0, 1, a, p)), i.rowfooters && (p = Ze(n.footerBand, to, null), d = nh(e, i.rowfooters, r, a, l, Ze(o, "rowFooter"), $A, 0, s, "x2", a - 1, a, 1, p)), i.colfooters && (p = Ze(n.footerBand, eo, null), h = nh(e, i.colfooters, r, a, a, Ze(o, "columnFooter"), $A, 1, s, "y2", u - a, 1, a, p)), i.rowtitle && (g = Ze(n.titleAnchor, to), m = Ze(o, "rowTitle"), m = g === dn ? d + m : c - m, p = Ze(n.titleBand, to, 0.5), FA(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = Ze(n.titleAnchor, eo), m = Ze(o, "columnTitle"), m = g === dn ? h + m : f - m, p = Ze(n.titleBand, eo, 0.5), FA(e, i.coltitle, m, 1, y, p));
}
function VH(e, t) {
  return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
}
function YH(e, t) {
  return e.bounds[t];
}
function nh(e, t, n, i, r, s, o, a, l, u, c, f, d, h) {
  var g = n.length, p = 0, m = 0, y, b, v, w, _, S, E, C, $;
  if (!g)
    return p;
  for (y = c; y < g; y += f)
    n[y] && (p = o(p, l(n[y], u)));
  if (!t.length)
    return p;
  for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += s, b = 0, w = t.length; b < w; ++b)
    e.dirty(t[b]), t[b].mark.bounds.clear();
  for (y = c, b = 0, w = t.length; b < w; ++b, y += f) {
    for (S = t[b], _ = S.mark.bounds, v = y; v >= 0 && (E = n[v]) == null; v -= d)
      ;
    a ? (C = h == null ? E.x : Math.round(E.bounds.x1 + h * E.bounds.width()), $ = p) : (C = p, $ = h == null ? E.y : Math.round(E.bounds.y1 + h * E.bounds.height())), _.union(S.bounds.translate(C - (S.x || 0), $ - (S.y || 0))), S.x = C, S.y = $, e.dirty(S), m = o(m, _[u]);
  }
  return m;
}
function FA(e, t, n, i, r, s) {
  if (t) {
    e.dirty(t);
    var o = n, a = n;
    i ? o = Math.round(r.x1 + s * r.width()) : a = Math.round(r.y1 + s * r.height()), t.bounds.translate(o - (t.x || 0), a - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = o, t.y = a, e.dirty(t);
  }
}
function XH(e, t) {
  const n = e[t] || {};
  return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r;
}
function KH(e, t) {
  let n = -1 / 0;
  return e.forEach((i) => {
    i.offset != null && (n = Math.max(n, i.offset));
  }), n > -1 / 0 ? n : t;
}
function JH(e, t, n, i, r, s, o) {
  const a = XH(n, t), l = KH(e, a("offset", 0)), u = a("anchor", hw), c = u === dn ? 1 : u === db ? 0.5 : 0, f = {
    align: hb,
    bounds: a("bounds", bw),
    columns: a("direction") === "vertical" ? 1 : e.length,
    padding: a("margin", 8),
    center: a("center"),
    nodirty: !0
  };
  switch (t) {
    case Ui:
      f.anchor = {
        x: Math.floor(i.x1) - l,
        column: dn,
        y: c * (o || i.height() + 2 * i.y1),
        row: u
      };
      break;
    case qi:
      f.anchor = {
        x: Math.ceil(i.x2) + l,
        y: c * (o || i.height() + 2 * i.y1),
        row: u
      };
      break;
    case hu:
      f.anchor = {
        y: Math.floor(r.y1) - l,
        row: dn,
        x: c * (s || r.width() + 2 * r.x1),
        column: u
      };
      break;
    case _o:
      f.anchor = {
        y: Math.ceil(r.y2) + l,
        x: c * (s || r.width() + 2 * r.x1),
        column: u
      };
      break;
    case kH:
      f.anchor = {
        x: l,
        y: l
      };
      break;
    case AH:
      f.anchor = {
        x: s - l,
        y: l,
        column: dn
      };
      break;
    case CH:
      f.anchor = {
        x: l,
        y: o - l,
        row: dn
      };
      break;
    case $H:
      f.anchor = {
        x: s - l,
        y: o - l,
        column: dn,
        row: dn
      };
      break;
  }
  return f;
}
function QH(e, t) {
  var n = t.items[0], i = n.datum, r = n.orient, s = n.bounds, o = n.x, a = n.y, l, u;
  return n._bounds ? n._bounds.clear().union(s) : n._bounds = s.clone(), s.clear(), eG(e, n, n.items[0].items[0]), s = ZH(n, s), l = 2 * n.padding, u = 2 * n.padding, s.empty() || (l = Math.ceil(s.width() + l), u = Math.ceil(s.height() + u)), i.type === DH && tG(n.items[0].items[0].items[0].items), r !== yw && (n.x = o = 0, n.y = a = 0), n.width = l, n.height = u, Fs(s.set(o, a, o + l, a + u), n), n.mark.bounds.clear().union(s), n;
}
function ZH(e, t) {
  return e.items.forEach((n) => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t;
}
function eG(e, t, n) {
  var i = t.padding, r = i - n.x, s = i - n.y;
  if (!t.datum.title)
    (r || s) && pc(e, n, r, s);
  else {
    var o = t.items[1].items[0], a = o.anchor, l = t.titlePadding || 0, u = i - o.x, c = i - o.y;
    switch (o.orient) {
      case Ui:
        r += Math.ceil(o.bounds.width()) + l;
        break;
      case qi:
      case _o:
        break;
      default:
        s += o.bounds.height() + l;
    }
    switch ((r || s) && pc(e, n, r, s), o.orient) {
      case Ui:
        c += vl(t, n, o, a, 1, 1);
        break;
      case qi:
        u += vl(t, n, o, dn, 0, 0) + l, c += vl(t, n, o, a, 1, 1);
        break;
      case _o:
        u += vl(t, n, o, a, 0, 0), c += vl(t, n, o, dn, -1, 0, 1) + l;
        break;
      default:
        u += vl(t, n, o, a, 0, 0);
    }
    (u || c) && pc(e, o, u, c), (u = Math.round(o.bounds.x1 - i)) < 0 && (pc(e, n, -u, 0), pc(e, o, -u, 0));
  }
}
function vl(e, t, n, i, r, s, o) {
  const a = e.datum.type !== "symbol", l = n.datum.vgrad, u = a && (s || !l) && !o ? t.items[0] : t, c = u.bounds[r ? "y2" : "x2"] - e.padding, f = l && s ? c : 0, d = l && s ? 0 : c, h = r <= 0 ? 0 : Z2(n);
  return Math.round(i === hw ? f : i === dn ? d - h : 0.5 * (c - h));
}
function pc(e, t, n, i) {
  t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t);
}
function tG(e) {
  const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
  e.forEach((n) => {
    n.width = t[n.column], n.height = n.bounds.y2 - n.y;
  });
}
function nG(e, t, n, i, r) {
  var s = t.items[0], o = s.frame, a = s.orient, l = s.anchor, u = s.offset, c = s.padding, f = s.items[0].items[0], d = s.items[1] && s.items[1].items[0], h = a === Ui || a === qi ? i : n, g = 0, p = 0, m = 0, y = 0, b = 0, v;
  if (o !== Dm ? a === Ui ? (g = r.y2, h = r.y1) : a === qi ? (g = r.y1, h = r.y2) : (g = r.x1, h = r.x2) : a === Ui && (g = i, h = 0), v = l === hw ? g : l === dn ? h : (g + h) / 2, d && d.text) {
    switch (a) {
      case hu:
      case _o:
        b = f.bounds.height() + c;
        break;
      case Ui:
        y = f.bounds.width() + c;
        break;
      case qi:
        y = -f.bounds.width() - c;
        break;
    }
    Xt.clear().union(d.bounds), Xt.translate(y - (d.x || 0), b - (d.y || 0)), Ll(d, "x", y) | Ll(d, "y", b) && (e.dirty(d), d.bounds.clear().union(Xt), d.mark.bounds.clear().union(Xt), e.dirty(d)), Xt.clear().union(d.bounds);
  } else
    Xt.clear();
  switch (Xt.union(f.bounds), a) {
    case hu:
      p = v, m = r.y1 - Xt.height() - u;
      break;
    case Ui:
      p = r.x1 - Xt.width() - u, m = v;
      break;
    case qi:
      p = r.x2 + Xt.width() + u, m = v;
      break;
    case _o:
      p = v, m = r.y2 + u;
      break;
    default:
      p = s.x, m = s.y;
  }
  return Ll(s, "x", p) | Ll(s, "y", m) && (Xt.translate(p, m), e.dirty(s), s.bounds.clear().union(Xt), t.bounds.clear().union(Xt), e.dirty(s)), s.bounds;
}
function XN(e) {
  P.call(this, null, e);
}
Y(XN, P, {
  transform(e, t) {
    const n = t.dataflow;
    return e.mark.items.forEach((i) => {
      e.layout && GH(n, i, e.layout), rG(n, i, e);
    }), iG(e.mark.group) ? t.reflow() : t;
  }
});
function iG(e) {
  return e && e.mark.role !== "legend-entry";
}
function rG(e, t, n) {
  var i = t.items, r = Math.max(0, t.width || 0), s = Math.max(0, t.height || 0), o = new ht().set(0, 0, r, s), a = o.clone(), l = o.clone(), u = [], c, f, d, h, g, p;
  for (g = 0, p = i.length; g < p; ++g)
    switch (f = i[g], f.role) {
      case gw:
        h = BH(f) ? a : l, h.union(UH(e, f, r, s));
        break;
      case pw:
        c = f;
        break;
      case mw:
        u.push(QH(e, f));
        break;
      case TH:
      case OH:
      case DN:
      case RN:
      case LN:
      case PN:
      case IN:
      case zN:
        a.union(f.bounds), l.union(f.bounds);
        break;
      default:
        o.union(f.bounds);
    }
  if (u.length) {
    const m = {};
    u.forEach((y) => {
      d = y.orient || qi, d !== yw && (m[d] || (m[d] = [])).push(y);
    });
    for (const y in m) {
      const b = m[y];
      YN(e, b, JH(b, y, n.legends, a, l, r, s));
    }
    u.forEach((y) => {
      const b = y.bounds;
      if (b.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = b, e.dirty(y)), n.autosize && (n.autosize.type === BN || n.autosize.type === jN || n.autosize.type === UN))
        switch (y.orient) {
          case Ui:
          case qi:
            o.add(b.x1, 0).add(b.x2, 0);
            break;
          case hu:
          case _o:
            o.add(0, b.y1).add(0, b.y2);
        }
      else
        o.union(b);
    });
  }
  o.union(a).union(l), c && o.union(nG(e, c, r, s, o)), t.clip && o.set(0, 0, t.width || 0, t.height || 0), sG(e, t, o, n);
}
function sG(e, t, n, i) {
  const r = i.autosize || {}, s = r.type;
  if (e._autosize < 1 || !s)
    return;
  let o = e._width, a = e._height, l = Math.max(0, t.width || 0), u = Math.max(0, Math.ceil(-n.x1)), c = Math.max(0, t.height || 0), f = Math.max(0, Math.ceil(-n.y1));
  const d = Math.max(0, Math.ceil(n.x2 - l)), h = Math.max(0, Math.ceil(n.y2 - c));
  if (r.contains === NH) {
    const g = e.padding();
    o -= g.left + g.right, a -= g.top + g.bottom;
  }
  s === yw ? (u = 0, f = 0, l = o, c = a) : s === BN ? (l = Math.max(0, o - u - d), c = Math.max(0, a - f - h)) : s === jN ? (l = Math.max(0, o - u - d), a = c + f + h) : s === UN ? (o = l + u + d, c = Math.max(0, a - f - h)) : s === RH && (o = l + u + d, a = c + f + h), e._resizeView(o, a, l, c, [u, f], r.resize);
}
const oG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bound: qN,
  identifier: vw,
  mark: WN,
  overlap: HN,
  render: VN,
  viewlayout: XN
}, Symbol.toStringTag, { value: "Module" }));
function KN(e) {
  P.call(this, null, e);
}
Y(KN, P, {
  transform(e, t) {
    if (this.value && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, s = e.scale, o = e.count == null ? e.values ? e.values.length : 10 : e.count, a = D2(s, o, e.minstep), l = e.format || CO(n, s, a, e.formatSpecifier, e.formatType, !!e.values), u = e.values ? AO(s, e.values, a) : R2(s, a);
    return r && (i.rem = r), r = u.map((c, f) => Be({
      index: f / (u.length - 1 || 1),
      value: c,
      label: l(c)
    })), e.extra && r.length && r.push(Be({
      index: -1,
      extra: {
        value: r[0].value
      },
      label: ""
    })), i.source = r, i.add = r, this.value = r, i;
  }
});
function JN(e) {
  P.call(this, null, e);
}
function aG() {
  return Be({});
}
function lG(e) {
  const t = Lu().test((n) => n.exit);
  return t.lookup = (n) => t.get(e(n)), t;
}
Y(JN, P, {
  transform(e, t) {
    var n = t.dataflow, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.item || aG, s = e.key || le, o = this.value;
    return j(i.encode) && (i.encode = null), o && (e.modified("key") || t.modified(s)) && B("DataJoin does not support modified key function or fields."), o || (t = t.addAll(), this.value = o = lG(s)), t.visit(t.ADD, (a) => {
      const l = s(a);
      let u = o.get(l);
      u ? u.exit ? (o.empty--, i.add.push(u)) : i.mod.push(u) : (u = r(a), o.set(l, u), i.add.push(u)), u.datum = a, u.exit = !1;
    }), t.visit(t.MOD, (a) => {
      const l = s(a), u = o.get(l);
      u && (u.datum = a, i.mod.push(u));
    }), t.visit(t.REM, (a) => {
      const l = s(a), u = o.get(l);
      a === u.datum && !u.exit && (i.rem.push(u), u.exit = !0, ++o.empty);
    }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && o.empty > n.cleanThreshold) && n.runAfter(o.clean), i;
  }
});
function QN(e) {
  P.call(this, null, e);
}
Y(QN, P, {
  transform(e, t) {
    var n = t.fork(t.ADD_REM), i = e.mod || !1, r = e.encoders, s = t.encode;
    if (j(s))
      if (n.changed() || s.every((f) => r[f]))
        s = s[0], n.encode = null;
      else
        return t.StopPropagation;
    var o = s === "enter", a = r.update || js, l = r.enter || js, u = r.exit || js, c = (s && !o ? r[s] : a) || js;
    if (t.changed(t.ADD) && (t.visit(t.ADD, (f) => {
      l(f, e), a(f, e);
    }), n.modifies(l.output), n.modifies(a.output), c !== js && c !== a && (t.visit(t.ADD, (f) => {
      c(f, e);
    }), n.modifies(c.output))), t.changed(t.REM) && u !== js && (t.visit(t.REM, (f) => {
      u(f, e);
    }), n.modifies(u.output)), o || c !== js) {
      const f = t.MOD | (e.modified() ? t.REFLOW : 0);
      o ? (t.visit(f, (d) => {
        const h = l(d, e) || i;
        (c(d, e) || h) && n.mod.push(d);
      }), n.mod.length && n.modifies(l.output)) : t.visit(f, (d) => {
        (c(d, e) || i) && n.mod.push(d);
      }), n.mod.length && n.modifies(c.output);
    }
    return n.changed() ? n : t.StopPropagation;
  }
});
function ZN(e) {
  P.call(this, [], e);
}
Y(ZN, P, {
  transform(e, t) {
    if (this.value != null && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, s = e.type || Dh, o = e.scale, a = +e.limit, l = D2(o, e.count == null ? 5 : e.count, e.minstep), u = !!e.values || s === Dh, c = e.format || TO(n, o, l, s, e.formatSpecifier, e.formatType, u), f = e.values || FO(o, l), d, h, g, p, m;
    return r && (i.rem = r), s === Dh ? (a && f.length > a ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, a - 1), m = !0) : r = f, Ee(g = e.size) ? (!e.values && o(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, b) => Math.max(y, g(b, e)), 0)) : g = an(p = g || 8), r = r.map((y, b) => Be({
      index: b,
      label: c(y, b, r),
      value: y,
      offset: p,
      size: g(y, e)
    })), m && (m = f[r.length], r.push(Be({
      index: r.length,
      label: `${f.length - r.length} entries`,
      value: m,
      offset: p,
      size: g(m, e)
    })))) : s === RU ? (d = o.domain(), h = EO(o, d[0], Oe(d)), f.length < 3 && !e.values && d[0] !== Oe(d) && (f = [d[0], Oe(d)]), r = f.map((y, b) => Be({
      index: b,
      label: c(y, b, f),
      value: y,
      perc: h(y)
    }))) : (g = f.length - 1, h = GU(o), r = f.map((y, b) => Be({
      index: b,
      label: c(y, b, f),
      value: y,
      perc: b ? h(y) : 0,
      perc2: b === g ? 1 : h(f[b + 1])
    }))), i.source = r, i.add = r, this.value = r, i;
  }
});
const uG = (e) => e.source.x, cG = (e) => e.source.y, fG = (e) => e.target.x, dG = (e) => e.target.y;
function xw(e) {
  P.call(this, {}, e);
}
xw.Definition = {
  type: "LinkPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sourceX",
    type: "field",
    default: "source.x"
  }, {
    name: "sourceY",
    type: "field",
    default: "source.y"
  }, {
    name: "targetX",
    type: "field",
    default: "target.x"
  }, {
    name: "targetY",
    type: "field",
    default: "target.y"
  }, {
    name: "orient",
    type: "enum",
    default: "vertical",
    values: ["horizontal", "vertical", "radial"]
  }, {
    name: "shape",
    type: "enum",
    default: "line",
    values: ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    name: "require",
    type: "signal"
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
Y(xw, P, {
  transform(e, t) {
    var n = e.sourceX || uG, i = e.sourceY || cG, r = e.targetX || fG, s = e.targetY || dG, o = e.as || "path", a = e.orient || "vertical", l = e.shape || "line", u = TA.get(l + "-" + a) || TA.get(l);
    return u || B("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
      c[o] = u(n(c), i(c), r(c), s(c));
    }), t.reflow(e.modified()).modifies(o);
  }
});
const eD = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i, hG = (e, t, n, i) => eD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), tD = (e, t, n, i) => {
  var r = n - e, s = i - t, o = Math.hypot(r, s) / 2, a = 180 * Math.atan2(s, r) / Math.PI;
  return "M" + e + "," + t + "A" + o + "," + o + " " + a + " 0 1 " + n + "," + i;
}, gG = (e, t, n, i) => tD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), nD = (e, t, n, i) => {
  const r = n - e, s = i - t, o = 0.2 * (r + s), a = 0.2 * (s - r);
  return "M" + e + "," + t + "C" + (e + o) + "," + (t + a) + " " + (n + a) + "," + (i - o) + " " + n + "," + i;
}, pG = (e, t, n, i) => nD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), mG = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n, yG = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i, bG = (e, t, n, i) => {
  const r = Math.cos(e), s = Math.sin(e), o = Math.cos(n), a = Math.sin(n), l = Math.abs(n - e) > Math.PI ? n <= e : n > e;
  return "M" + t * r + "," + t * s + "A" + t + "," + t + " 0 0," + (l ? 1 : 0) + " " + t * o + "," + t * a + "L" + i * o + "," + i * a;
}, vG = (e, t, n, i) => {
  const r = (e + n) / 2;
  return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i;
}, xG = (e, t, n, i) => {
  const r = (t + i) / 2;
  return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i;
}, wG = (e, t, n, i) => {
  const r = Math.cos(e), s = Math.sin(e), o = Math.cos(n), a = Math.sin(n), l = (t + i) / 2;
  return "M" + t * r + "," + t * s + "C" + l * r + "," + l * s + " " + l * o + "," + l * a + " " + i * o + "," + i * a;
}, TA = Lu({
  line: eD,
  "line-radial": hG,
  arc: tD,
  "arc-radial": gG,
  curve: nD,
  "curve-radial": pG,
  "orthogonal-horizontal": mG,
  "orthogonal-vertical": yG,
  "orthogonal-radial": bG,
  "diagonal-horizontal": vG,
  "diagonal-vertical": xG,
  "diagonal-radial": wG
});
function ww(e) {
  P.call(this, null, e);
}
ww.Definition = {
  type: "Pie",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "startAngle",
    type: "number",
    default: 0
  }, {
    name: "endAngle",
    type: "number",
    default: 6.283185307179586
  }, {
    name: "sort",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["startAngle", "endAngle"]
  }]
};
Y(ww, P, {
  transform(e, t) {
    var n = e.as || ["startAngle", "endAngle"], i = n[0], r = n[1], s = e.field || Nu, o = e.startAngle || 0, a = e.endAngle != null ? e.endAngle : 2 * Math.PI, l = t.source, u = l.map(s), c = u.length, f = o, d = (a - o) / xF(u), h = Xn(c), g, p, m;
    for (e.sort && h.sort((y, b) => u[y] - u[b]), g = 0; g < c; ++g)
      m = u[h[g]], p = l[h[g]], p[i] = f, p[r] = f += m * d;
    return this.value = u, t.reflow(e.modified()).modifies(n);
  }
});
const _G = 5;
function EG(e) {
  const t = e.type;
  return !e.bins && (t === au || t === ad || t === ld);
}
function iD(e) {
  return T2(e) && e !== Er;
}
const SG = Ji(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function rD(e) {
  P.call(this, null, e), this.modified(!0);
}
Y(rD, P, {
  transform(e, t) {
    var n = t.dataflow, i = this.value, r = kG(e);
    (!i || r !== i.type) && (this.value = i = Ie(r)());
    for (r in e)
      if (!SG[r]) {
        if (r === "padding" && iD(i.type))
          continue;
        Ee(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r);
      }
    return TG(i, e, FG(i, e, CG(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function kG(e) {
  var t = e.type, n = "", i;
  return t === Er ? Er + "-" + au : (AG(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? Er + "-" : i === 3 ? Wu + "-" : ""), (n + t || au).toLowerCase());
}
function AG(e) {
  const t = e.type;
  return T2(t) && t !== Fa && t !== Ta && (e.scheme || e.range && e.range.length && e.range.every(Q));
}
function CG(e, t, n) {
  const i = $G(e, t.domainRaw, n);
  if (i > -1)
    return i;
  var r = t.domain, s = e.type, o = t.zero || t.zero === void 0 && EG(e), a, l;
  if (!r)
    return 0;
  if (iD(s) && t.padding && r[0] !== Oe(r) && (r = MG(s, r, t.range, t.padding, t.exponent, t.constant)), (o || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (a = (r = r.slice()).length - 1 || 1, o && (r[0] > 0 && (r[0] = 0), r[a] < 0 && (r[a] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[a] = t.domainMax), t.domainMid != null)) {
    l = t.domainMid;
    const u = l > r[a] ? a + 1 : l < r[0] ? 0 : a;
    u !== a && n.warn("Scale domainMid exceeds domain min or max.", l), r.splice(u, 0, l);
  }
  return e.domain(sD(s, r, n)), s === C2 && e.unknown(t.domainImplicit ? Hy : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && D2(e, t.nice) || null), r.length;
}
function $G(e, t, n) {
  return t ? (e.domain(sD(e.type, t, n)), t.length) : -1;
}
function MG(e, t, n, i, r, s) {
  var o = Math.abs(Oe(n) - n[0]), a = o / (o - 2 * i), l = e === _s ? Xv(t, null, a) : e === ld ? sg(t, null, a, 0.5) : e === ad ? sg(t, null, a, r || 1) : e === bm ? Kv(t, null, a, s || 1) : Yv(t, null, a);
  return t = t.slice(), t[0] = l[0], t[t.length - 1] = l[1], t;
}
function sD(e, t, n) {
  if (bO(e)) {
    var i = Math.abs(t.reduce((r, s) => r + (s < 0 ? -1 : s > 0 ? 1 : 0), 0));
    i !== t.length && n.warn("Log scale domain includes zero: " + X(t));
  }
  return t;
}
function FG(e, t, n) {
  let i = t.bins;
  if (i && !j(i)) {
    const r = e.domain(), s = r[0], o = Oe(r), a = i.step;
    let l = i.start == null ? s : i.start, u = i.stop == null ? o : i.stop;
    a || B("Scale bins parameter missing step property."), l < s && (l = a * Math.ceil(s / a)), u > o && (u = a * Math.floor(o / a)), i = Xn(l, u + a / 2, a);
  }
  return i ? e.bins = i : e.bins && delete e.bins, e.type === $2 && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n;
}
function TG(e, t, n) {
  var i = e.type, r = t.round || !1, s = t.range;
  if (t.rangeStep != null)
    s = OG(i, t, n);
  else if (t.scheme && (s = NG(i, t, n), Ee(s))) {
    if (e.interpolator)
      return e.interpolator(s);
    B(`Scale type ${i} does not support interpolating color schemes.`);
  }
  if (s && vO(i))
    return e.interpolator(wm(gb(s, t.reverse), t.interpolate, t.interpolateGamma));
  s && t.interpolate && e.interpolate ? e.interpolate(O2(t.interpolate, t.interpolateGamma)) : Ee(e.round) ? e.round(r) : Ee(e.rangeRound) && e.interpolate(r ? sd : Do), s && e.range(gb(s, t.reverse));
}
function OG(e, t, n) {
  e !== dO && e !== Qy && B("Only band and point scales support rangeStep.");
  var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0, r = e === Qy ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
  return [0, t.rangeStep * A2(n, r, i)];
}
function NG(e, t, n) {
  var i = t.schemeExtent, r, s;
  return j(t.scheme) ? s = wm(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = N2(r), s || B(`Unrecognized scheme name: ${t.scheme}`)), n = e === xm ? n + 1 : e === $2 ? n - 1 : e === lu || e === vm ? +t.schemeCount || _G : n, vO(e) ? OA(s, i, t.reverse) : Ee(s) ? _O(OA(s, i), n) : e === C2 ? s : s.slice(0, n);
}
function OA(e, t, n) {
  return Ee(e) && (t || n) ? wO(e, gb(t || [0, 1], n)) : e;
}
function gb(e, t) {
  return t ? e.slice().reverse() : e;
}
function oD(e) {
  P.call(this, null, e);
}
Y(oD, P, {
  transform(e, t) {
    const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
    return n && t.source.sort(el(e.sort)), this.modified(n), t;
  }
});
const NA = "zero", aD = "center", lD = "normalize", uD = ["y0", "y1"];
function _w(e) {
  P.call(this, null, e);
}
_w.Definition = {
  type: "Stack",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "offset",
    type: "enum",
    default: NA,
    values: [NA, aD, lD]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: uD
  }]
};
Y(_w, P, {
  transform(e, t) {
    var n = e.as || uD, i = n[0], r = n[1], s = el(e.sort), o = e.field || Nu, a = e.offset === aD ? DG : e.offset === lD ? RG : LG, l, u, c, f;
    for (l = PG(t.source, e.groupby, s, o), u = 0, c = l.length, f = l.max; u < c; ++u)
      a(l[u], f, o, i, r);
    return t.reflow(e.modified()).modifies(n);
  }
});
function DG(e, t, n, i, r) {
  for (var s = (t - e.sum) / 2, o = e.length, a = 0, l; a < o; ++a)
    l = e[a], l[i] = s, l[r] = s += Math.abs(n(l));
}
function RG(e, t, n, i, r) {
  for (var s = 1 / e.sum, o = 0, a = e.length, l = 0, u = 0, c; l < a; ++l)
    c = e[l], c[i] = o, c[r] = o = s * (u += Math.abs(n(c)));
}
function LG(e, t, n, i, r) {
  for (var s = 0, o = 0, a = e.length, l = 0, u, c; l < a; ++l)
    c = e[l], u = +n(c), u < 0 ? (c[i] = o, c[r] = o += u) : (c[i] = s, c[r] = s += u);
}
function PG(e, t, n, i) {
  var r = [], s = (p) => p(c), o, a, l, u, c, f, d, h, g;
  if (t == null)
    r.push(e.slice());
  else
    for (o = {}, a = 0, l = e.length; a < l; ++a)
      c = e[a], f = t.map(s), d = o[f], d || (o[f] = d = [], r.push(d)), d.push(c);
  for (f = 0, g = 0, u = r.length; f < u; ++f) {
    for (d = r[f], a = 0, h = 0, l = d.length; a < l; ++a)
      h += Math.abs(i(d[a]));
    d.sum = h, h > g && (g = h), n && d.sort(n);
  }
  return r.max = g, r;
}
const IG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  axisticks: KN,
  datajoin: JN,
  encode: QN,
  legendentries: ZN,
  linkpath: xw,
  pie: ww,
  scale: rD,
  sortitems: oD,
  stack: _w
}, Symbol.toStringTag, { value: "Module" }));
var fe = 1e-6, Rg = 1e-12, Ae = Math.PI, at = Ae / 2, Lg = Ae / 4, wn = Ae * 2, ut = 180 / Ae, ke = Ae / 180, Te = Math.abs, Gu = Math.atan, Ai = Math.atan2, he = Math.cos, ih = Math.ceil, cD = Math.exp, pb = Math.hypot, Pg = Math.log, _1 = Math.pow, ue = Math.sin, gi = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, _n = Math.sqrt, Ew = Math.tan;
function fD(e) {
  return e > 1 ? 0 : e < -1 ? Ae : Math.acos(e);
}
function In(e) {
  return e > 1 ? at : e < -1 ? -at : Math.asin(e);
}
function Bt() {
}
function Ig(e, t) {
  e && RA.hasOwnProperty(e.type) && RA[e.type](e, t);
}
var DA = {
  Feature: function(e, t) {
    Ig(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, i = -1, r = n.length; ++i < r; )
      Ig(n[i].geometry, t);
  }
}, RA = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      e = n[i], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    mb(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      mb(n[i], t, 0);
  },
  Polygon: function(e, t) {
    LA(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      LA(n[i], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, i = -1, r = n.length; ++i < r; )
      Ig(n[i], t);
  }
};
function mb(e, t, n) {
  var i = -1, r = e.length - n, s;
  for (t.lineStart(); ++i < r; )
    s = e[i], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function LA(e, t) {
  var n = -1, i = e.length;
  for (t.polygonStart(); ++n < i; )
    mb(e[n], t, 1);
  t.polygonEnd();
}
function ss(e, t) {
  e && DA.hasOwnProperty(e.type) ? DA[e.type](e, t) : Ig(e, t);
}
var zg = new bn(), Bg = new bn(), dD, hD, yb, bb, vb, Or = {
  point: Bt,
  lineStart: Bt,
  lineEnd: Bt,
  polygonStart: function() {
    zg = new bn(), Or.lineStart = zG, Or.lineEnd = BG;
  },
  polygonEnd: function() {
    var e = +zg;
    Bg.add(e < 0 ? wn + e : e), this.lineStart = this.lineEnd = this.point = Bt;
  },
  sphere: function() {
    Bg.add(wn);
  }
};
function zG() {
  Or.point = jG;
}
function BG() {
  gD(dD, hD);
}
function jG(e, t) {
  Or.point = gD, dD = e, hD = t, e *= ke, t *= ke, yb = e, bb = he(t = t / 2 + Lg), vb = ue(t);
}
function gD(e, t) {
  e *= ke, t *= ke, t = t / 2 + Lg;
  var n = e - yb, i = n >= 0 ? 1 : -1, r = i * n, s = he(t), o = ue(t), a = vb * o, l = bb * s + a * he(r), u = a * i * ue(r);
  zg.add(Ai(u, l)), yb = e, bb = s, vb = o;
}
function UG(e) {
  return Bg = new bn(), ss(e, Or), Bg * 2;
}
function jg(e) {
  return [Ai(e[1], e[0]), In(e[2])];
}
function Na(e) {
  var t = e[0], n = e[1], i = he(n);
  return [i * he(t), i * ue(t), ue(n)];
}
function rh(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function gu(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function E1(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function sh(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function Ug(e) {
  var t = _n(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var nt, Mn, it, Gn, sa, pD, mD, Wl, sf, Gs, Es, ns = {
  point: xb,
  lineStart: PA,
  lineEnd: IA,
  polygonStart: function() {
    ns.point = bD, ns.lineStart = qG, ns.lineEnd = WG, sf = new bn(), Or.polygonStart();
  },
  polygonEnd: function() {
    Or.polygonEnd(), ns.point = xb, ns.lineStart = PA, ns.lineEnd = IA, zg < 0 ? (nt = -(it = 180), Mn = -(Gn = 90)) : sf > fe ? Gn = 90 : sf < -fe && (Mn = -90), Es[0] = nt, Es[1] = it;
  },
  sphere: function() {
    nt = -(it = 180), Mn = -(Gn = 90);
  }
};
function xb(e, t) {
  Gs.push(Es = [nt = e, it = e]), t < Mn && (Mn = t), t > Gn && (Gn = t);
}
function yD(e, t) {
  var n = Na([e * ke, t * ke]);
  if (Wl) {
    var i = gu(Wl, n), r = [i[1], -i[0], 0], s = gu(r, i);
    Ug(s), s = jg(s);
    var o = e - sa, a = o > 0 ? 1 : -1, l = s[0] * ut * a, u, c = Te(o) > 180;
    c ^ (a * sa < l && l < a * e) ? (u = s[1] * ut, u > Gn && (Gn = u)) : (l = (l + 360) % 360 - 180, c ^ (a * sa < l && l < a * e) ? (u = -s[1] * ut, u < Mn && (Mn = u)) : (t < Mn && (Mn = t), t > Gn && (Gn = t))), c ? e < sa ? Hn(nt, e) > Hn(nt, it) && (it = e) : Hn(e, it) > Hn(nt, it) && (nt = e) : it >= nt ? (e < nt && (nt = e), e > it && (it = e)) : e > sa ? Hn(nt, e) > Hn(nt, it) && (it = e) : Hn(e, it) > Hn(nt, it) && (nt = e);
  } else
    Gs.push(Es = [nt = e, it = e]);
  t < Mn && (Mn = t), t > Gn && (Gn = t), Wl = n, sa = e;
}
function PA() {
  ns.point = yD;
}
function IA() {
  Es[0] = nt, Es[1] = it, ns.point = xb, Wl = null;
}
function bD(e, t) {
  if (Wl) {
    var n = e - sa;
    sf.add(Te(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
  } else
    pD = e, mD = t;
  Or.point(e, t), yD(e, t);
}
function qG() {
  Or.lineStart();
}
function WG() {
  bD(pD, mD), Or.lineEnd(), Te(sf) > fe && (nt = -(it = 180)), Es[0] = nt, Es[1] = it, Wl = null;
}
function Hn(e, t) {
  return (t -= e) < 0 ? t + 360 : t;
}
function HG(e, t) {
  return e[0] - t[0];
}
function zA(e, t) {
  return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
}
function GG(e) {
  var t, n, i, r, s, o, a;
  if (Gn = it = -(nt = Mn = 1 / 0), Gs = [], ss(e, ns), n = Gs.length) {
    for (Gs.sort(HG), t = 1, i = Gs[0], s = [i]; t < n; ++t)
      r = Gs[t], zA(i, r[0]) || zA(i, r[1]) ? (Hn(i[0], r[1]) > Hn(i[0], i[1]) && (i[1] = r[1]), Hn(r[0], i[1]) > Hn(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
    for (o = -1 / 0, n = s.length - 1, t = 0, i = s[n]; t <= n; i = r, ++t)
      r = s[t], (a = Hn(i[1], r[0])) > o && (o = a, nt = r[0], it = i[1]);
  }
  return Gs = Es = null, nt === 1 / 0 || Mn === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[nt, Mn], [it, Gn]];
}
var zc, qg, Wg, Hg, Gg, Vg, Yg, Xg, wb, _b, Eb, vD, xD, hn, gn, pn, Wi = {
  sphere: Bt,
  point: Sw,
  lineStart: BA,
  lineEnd: jA,
  polygonStart: function() {
    Wi.lineStart = XG, Wi.lineEnd = KG;
  },
  polygonEnd: function() {
    Wi.lineStart = BA, Wi.lineEnd = jA;
  }
};
function Sw(e, t) {
  e *= ke, t *= ke;
  var n = he(t);
  bd(n * he(e), n * ue(e), ue(t));
}
function bd(e, t, n) {
  ++zc, Wg += (e - Wg) / zc, Hg += (t - Hg) / zc, Gg += (n - Gg) / zc;
}
function BA() {
  Wi.point = VG;
}
function VG(e, t) {
  e *= ke, t *= ke;
  var n = he(t);
  hn = n * he(e), gn = n * ue(e), pn = ue(t), Wi.point = YG, bd(hn, gn, pn);
}
function YG(e, t) {
  e *= ke, t *= ke;
  var n = he(t), i = n * he(e), r = n * ue(e), s = ue(t), o = Ai(_n((o = gn * s - pn * r) * o + (o = pn * i - hn * s) * o + (o = hn * r - gn * i) * o), hn * i + gn * r + pn * s);
  qg += o, Vg += o * (hn + (hn = i)), Yg += o * (gn + (gn = r)), Xg += o * (pn + (pn = s)), bd(hn, gn, pn);
}
function jA() {
  Wi.point = Sw;
}
function XG() {
  Wi.point = JG;
}
function KG() {
  wD(vD, xD), Wi.point = Sw;
}
function JG(e, t) {
  vD = e, xD = t, e *= ke, t *= ke, Wi.point = wD;
  var n = he(t);
  hn = n * he(e), gn = n * ue(e), pn = ue(t), bd(hn, gn, pn);
}
function wD(e, t) {
  e *= ke, t *= ke;
  var n = he(t), i = n * he(e), r = n * ue(e), s = ue(t), o = gn * s - pn * r, a = pn * i - hn * s, l = hn * r - gn * i, u = pb(o, a, l), c = In(u), f = u && -c / u;
  wb.add(f * o), _b.add(f * a), Eb.add(f * l), qg += c, Vg += c * (hn + (hn = i)), Yg += c * (gn + (gn = r)), Xg += c * (pn + (pn = s)), bd(hn, gn, pn);
}
function QG(e) {
  zc = qg = Wg = Hg = Gg = Vg = Yg = Xg = 0, wb = new bn(), _b = new bn(), Eb = new bn(), ss(e, Wi);
  var t = +wb, n = +_b, i = +Eb, r = pb(t, n, i);
  return r < Rg && (t = Vg, n = Yg, i = Xg, qg < fe && (t = Wg, n = Hg, i = Gg), r = pb(t, n, i), r < Rg) ? [NaN, NaN] : [Ai(n, t) * ut, In(i / r) * ut];
}
function Sb(e, t) {
  function n(i, r) {
    return i = e(i, r), t(i[0], i[1]);
  }
  return e.invert && t.invert && (n.invert = function(i, r) {
    return i = t.invert(i, r), i && e.invert(i[0], i[1]);
  }), n;
}
function kb(e, t) {
  return Te(e) > Ae && (e -= Math.round(e / wn) * wn), [e, t];
}
kb.invert = kb;
function _D(e, t, n) {
  return (e %= wn) ? t || n ? Sb(qA(e), WA(t, n)) : qA(e) : t || n ? WA(t, n) : kb;
}
function UA(e) {
  return function(t, n) {
    return t += e, Te(t) > Ae && (t -= Math.round(t / wn) * wn), [t, n];
  };
}
function qA(e) {
  var t = UA(e);
  return t.invert = UA(-e), t;
}
function WA(e, t) {
  var n = he(e), i = ue(e), r = he(t), s = ue(t);
  function o(a, l) {
    var u = he(l), c = he(a) * u, f = ue(a) * u, d = ue(l), h = d * n + c * i;
    return [
      Ai(f * r - h * s, c * n - d * i),
      In(h * r + f * s)
    ];
  }
  return o.invert = function(a, l) {
    var u = he(l), c = he(a) * u, f = ue(a) * u, d = ue(l), h = d * r - f * s;
    return [
      Ai(f * r + d * s, c * n + h * i),
      In(h * n - c * i)
    ];
  }, o;
}
function ZG(e) {
  e = _D(e[0] * ke, e[1] * ke, e.length > 2 ? e[2] * ke : 0);
  function t(n) {
    return n = e(n[0] * ke, n[1] * ke), n[0] *= ut, n[1] *= ut, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * ke, n[1] * ke), n[0] *= ut, n[1] *= ut, n;
  }, t;
}
function eV(e, t, n, i, r, s) {
  if (n) {
    var o = he(t), a = ue(t), l = i * n;
    r == null ? (r = t + i * wn, s = t - l / 2) : (r = HA(o, r), s = HA(o, s), (i > 0 ? r < s : r > s) && (r += i * wn));
    for (var u, c = r; i > 0 ? c > s : c < s; c -= l)
      u = jg([o, -a * he(c), -a * ue(c)]), e.point(u[0], u[1]);
  }
}
function HA(e, t) {
  t = Na(t), t[0] -= e, Ug(t);
  var n = fD(-t[1]);
  return ((-t[2] < 0 ? -n : n) + wn - fe) % wn;
}
function ED() {
  var e = [], t;
  return {
    point: function(n, i, r) {
      t.push([n, i, r]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Bt,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function Uh(e, t) {
  return Te(e[0] - t[0]) < fe && Te(e[1] - t[1]) < fe;
}
function oh(e, t, n, i) {
  this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
}
function SD(e, t, n, i, r) {
  var s = [], o = [], a, l;
  if (e.forEach(function(g) {
    if (!((p = g.length - 1) <= 0)) {
      var p, m = g[0], y = g[p], b;
      if (Uh(m, y)) {
        if (!m[2] && !y[2]) {
          for (r.lineStart(), a = 0; a < p; ++a)
            r.point((m = g[a])[0], m[1]);
          r.lineEnd();
          return;
        }
        y[0] += 2 * fe;
      }
      s.push(b = new oh(m, g, null, !0)), o.push(b.o = new oh(m, null, b, !1)), s.push(b = new oh(y, g, null, !1)), o.push(b.o = new oh(y, null, b, !0));
    }
  }), !!s.length) {
    for (o.sort(t), GA(s), GA(o), a = 0, l = o.length; a < l; ++a)
      o[a].e = n = !n;
    for (var u = s[0], c, f; ; ) {
      for (var d = u, h = !0; d.v; )
        if ((d = d.n) === u)
          return;
      c = d.z, r.lineStart();
      do {
        if (d.v = d.o.v = !0, d.e) {
          if (h)
            for (a = 0, l = c.length; a < l; ++a)
              r.point((f = c[a])[0], f[1]);
          else
            i(d.x, d.n.x, 1, r);
          d = d.n;
        } else {
          if (h)
            for (c = d.p.z, a = c.length - 1; a >= 0; --a)
              r.point((f = c[a])[0], f[1]);
          else
            i(d.x, d.p.x, -1, r);
          d = d.p;
        }
        d = d.o, c = d.z, h = !h;
      } while (!d.v);
      r.lineEnd();
    }
  }
}
function GA(e) {
  if (t = e.length) {
    for (var t, n = 0, i = e[0], r; ++n < t; )
      i.n = r = e[n], r.p = i, i = r;
    i.n = r = e[0], r.p = i;
  }
}
function S1(e) {
  return Te(e[0]) <= Ae ? e[0] : gi(e[0]) * ((Te(e[0]) + Ae) % wn - Ae);
}
function tV(e, t) {
  var n = S1(t), i = t[1], r = ue(i), s = [ue(n), -he(n), 0], o = 0, a = 0, l = new bn();
  r === 1 ? i = at + fe : r === -1 && (i = -at - fe);
  for (var u = 0, c = e.length; u < c; ++u)
    if (d = (f = e[u]).length)
      for (var f, d, h = f[d - 1], g = S1(h), p = h[1] / 2 + Lg, m = ue(p), y = he(p), b = 0; b < d; ++b, g = w, m = S, y = E, h = v) {
        var v = f[b], w = S1(v), _ = v[1] / 2 + Lg, S = ue(_), E = he(_), C = w - g, $ = C >= 0 ? 1 : -1, N = $ * C, T = N > Ae, L = m * S;
        if (l.add(Ai(L * $ * ue(N), y * E + L * he(N))), o += T ? C + $ * wn : C, T ^ g >= n ^ w >= n) {
          var O = gu(Na(h), Na(v));
          Ug(O);
          var F = gu(s, O);
          Ug(F);
          var x = (T ^ C >= 0 ? -1 : 1) * In(F[2]);
          (i > x || i === x && (O[0] || O[1])) && (a += T ^ C >= 0 ? 1 : -1);
        }
      }
  return (o < -fe || o < fe && l < -Rg) ^ a & 1;
}
function kD(e, t, n, i) {
  return function(r) {
    var s = t(r), o = ED(), a = t(o), l = !1, u, c, f, d = {
      point: h,
      lineStart: p,
      lineEnd: m,
      polygonStart: function() {
        d.point = y, d.lineStart = b, d.lineEnd = v, c = [], u = [];
      },
      polygonEnd: function() {
        d.point = h, d.lineStart = p, d.lineEnd = m, c = vF(c);
        var w = tV(u, i);
        c.length ? (l || (r.polygonStart(), l = !0), SD(c, iV, w, n, r)) : w && (l || (r.polygonStart(), l = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null;
      },
      sphere: function() {
        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
      }
    };
    function h(w, _) {
      e(w, _) && r.point(w, _);
    }
    function g(w, _) {
      s.point(w, _);
    }
    function p() {
      d.point = g, s.lineStart();
    }
    function m() {
      d.point = h, s.lineEnd();
    }
    function y(w, _) {
      f.push([w, _]), a.point(w, _);
    }
    function b() {
      a.lineStart(), f = [];
    }
    function v() {
      y(f[0][0], f[0][1]), a.lineEnd();
      var w = a.clean(), _ = o.result(), S, E = _.length, C, $, N;
      if (f.pop(), u.push(f), f = null, !!E) {
        if (w & 1) {
          if ($ = _[0], (C = $.length - 1) > 0) {
            for (l || (r.polygonStart(), l = !0), r.lineStart(), S = 0; S < C; ++S)
              r.point((N = $[S])[0], N[1]);
            r.lineEnd();
          }
          return;
        }
        E > 1 && w & 2 && _.push(_.pop().concat(_.shift())), c.push(_.filter(nV));
      }
    }
    return d;
  };
}
function nV(e) {
  return e.length > 1;
}
function iV(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - at - fe : at - e[1]) - ((t = t.x)[0] < 0 ? t[1] - at - fe : at - t[1]);
}
const VA = kD(
  function() {
    return !0;
  },
  rV,
  oV,
  [-Ae, -at]
);
function rV(e) {
  var t = NaN, n = NaN, i = NaN, r;
  return {
    lineStart: function() {
      e.lineStart(), r = 1;
    },
    point: function(s, o) {
      var a = s > 0 ? Ae : -Ae, l = Te(s - t);
      Te(l - Ae) < fe ? (e.point(t, n = (n + o) / 2 > 0 ? at : -at), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), r = 0) : i !== a && l >= Ae && (Te(t - i) < fe && (t -= i * fe), Te(s - a) < fe && (s -= a * fe), n = sV(t, n, s, o), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = s, n = o), i = a;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - r;
    }
  };
}
function sV(e, t, n, i) {
  var r, s, o = ue(e - n);
  return Te(o) > fe ? Gu((ue(t) * (s = he(i)) * ue(n) - ue(i) * (r = he(t)) * ue(e)) / (r * s * o)) : (t + i) / 2;
}
function oV(e, t, n, i) {
  var r;
  if (e == null)
    r = n * at, i.point(-Ae, r), i.point(0, r), i.point(Ae, r), i.point(Ae, 0), i.point(Ae, -r), i.point(0, -r), i.point(-Ae, -r), i.point(-Ae, 0), i.point(-Ae, r);
  else if (Te(e[0] - t[0]) > fe) {
    var s = e[0] < t[0] ? Ae : -Ae;
    r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r);
  } else
    i.point(t[0], t[1]);
}
function aV(e) {
  var t = he(e), n = 6 * ke, i = t > 0, r = Te(t) > fe;
  function s(c, f, d, h) {
    eV(h, e, n, d, c, f);
  }
  function o(c, f) {
    return he(c) * he(f) > t;
  }
  function a(c) {
    var f, d, h, g, p;
    return {
      lineStart: function() {
        g = h = !1, p = 1;
      },
      point: function(m, y) {
        var b = [m, y], v, w = o(m, y), _ = i ? w ? 0 : u(m, y) : w ? u(m + (m < 0 ? Ae : -Ae), y) : 0;
        if (!f && (g = h = w) && c.lineStart(), w !== h && (v = l(f, b), (!v || Uh(f, v) || Uh(b, v)) && (b[2] = 1)), w !== h)
          p = 0, w ? (c.lineStart(), v = l(b, f), c.point(v[0], v[1])) : (v = l(f, b), c.point(v[0], v[1], 2), c.lineEnd()), f = v;
        else if (r && f && i ^ w) {
          var S;
          !(_ & d) && (S = l(b, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(S[0][0], S[0][1]), c.point(S[1][0], S[1][1]), c.lineEnd()) : (c.point(S[1][0], S[1][1]), c.lineEnd(), c.lineStart(), c.point(S[0][0], S[0][1], 3)));
        }
        w && (!f || !Uh(f, b)) && c.point(b[0], b[1]), f = b, h = w, d = _;
      },
      lineEnd: function() {
        h && c.lineEnd(), f = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return p | (g && h) << 1;
      }
    };
  }
  function l(c, f, d) {
    var h = Na(c), g = Na(f), p = [1, 0, 0], m = gu(h, g), y = rh(m, m), b = m[0], v = y - b * b;
    if (!v)
      return !d && c;
    var w = t * y / v, _ = -t * b / v, S = gu(p, m), E = sh(p, w), C = sh(m, _);
    E1(E, C);
    var $ = S, N = rh(E, $), T = rh($, $), L = N * N - T * (rh(E, E) - 1);
    if (!(L < 0)) {
      var O = _n(L), F = sh($, (-N - O) / T);
      if (E1(F, E), F = jg(F), !d)
        return F;
      var x = c[0], k = f[0], A = c[1], M = f[1], D;
      k < x && (D = x, x = k, k = D);
      var R = k - x, U = Te(R - Ae) < fe, W = U || R < fe;
      if (!U && M < A && (D = A, A = M, M = D), W ? U ? A + M > 0 ^ F[1] < (Te(F[0] - x) < fe ? A : M) : A <= F[1] && F[1] <= M : R > Ae ^ (x <= F[0] && F[0] <= k)) {
        var ne = sh($, (-N + O) / T);
        return E1(ne, E), [F, jg(ne)];
      }
    }
  }
  function u(c, f) {
    var d = i ? e : Ae - e, h = 0;
    return c < -d ? h |= 1 : c > d && (h |= 2), f < -d ? h |= 4 : f > d && (h |= 8), h;
  }
  return kD(o, a, s, i ? [0, -e] : [-Ae, e - Ae]);
}
function lV(e, t, n, i, r, s) {
  var o = e[0], a = e[1], l = t[0], u = t[1], c = 0, f = 1, d = l - o, h = u - a, g;
  if (g = n - o, !(!d && g > 0)) {
    if (g /= d, d < 0) {
      if (g < c)
        return;
      g < f && (f = g);
    } else if (d > 0) {
      if (g > f)
        return;
      g > c && (c = g);
    }
    if (g = r - o, !(!d && g < 0)) {
      if (g /= d, d < 0) {
        if (g > f)
          return;
        g > c && (c = g);
      } else if (d > 0) {
        if (g < c)
          return;
        g < f && (f = g);
      }
      if (g = i - a, !(!h && g > 0)) {
        if (g /= h, h < 0) {
          if (g < c)
            return;
          g < f && (f = g);
        } else if (h > 0) {
          if (g > f)
            return;
          g > c && (c = g);
        }
        if (g = s - a, !(!h && g < 0)) {
          if (g /= h, h < 0) {
            if (g > f)
              return;
            g > c && (c = g);
          } else if (h > 0) {
            if (g < c)
              return;
            g < f && (f = g);
          }
          return c > 0 && (e[0] = o + c * d, e[1] = a + c * h), f < 1 && (t[0] = o + f * d, t[1] = a + f * h), !0;
        }
      }
    }
  }
}
var Bc = 1e9, ah = -Bc;
function AD(e, t, n, i) {
  function r(u, c) {
    return e <= u && u <= n && t <= c && c <= i;
  }
  function s(u, c, f, d) {
    var h = 0, g = 0;
    if (u == null || (h = o(u, f)) !== (g = o(c, f)) || l(u, c) < 0 ^ f > 0)
      do
        d.point(h === 0 || h === 3 ? e : n, h > 1 ? i : t);
      while ((h = (h + f + 4) % 4) !== g);
    else
      d.point(c[0], c[1]);
  }
  function o(u, c) {
    return Te(u[0] - e) < fe ? c > 0 ? 0 : 3 : Te(u[0] - n) < fe ? c > 0 ? 2 : 1 : Te(u[1] - t) < fe ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
  }
  function a(u, c) {
    return l(u.x, c.x);
  }
  function l(u, c) {
    var f = o(u, 1), d = o(c, 1);
    return f !== d ? f - d : f === 0 ? c[1] - u[1] : f === 1 ? u[0] - c[0] : f === 2 ? u[1] - c[1] : c[0] - u[0];
  }
  return function(u) {
    var c = u, f = ED(), d, h, g, p, m, y, b, v, w, _, S, E = {
      point: C,
      lineStart: L,
      lineEnd: O,
      polygonStart: N,
      polygonEnd: T
    };
    function C(x, k) {
      r(x, k) && c.point(x, k);
    }
    function $() {
      for (var x = 0, k = 0, A = h.length; k < A; ++k)
        for (var M = h[k], D = 1, R = M.length, U = M[0], W, ne, Z = U[0], re = U[1]; D < R; ++D)
          W = Z, ne = re, U = M[D], Z = U[0], re = U[1], ne <= i ? re > i && (Z - W) * (i - ne) > (re - ne) * (e - W) && ++x : re <= i && (Z - W) * (i - ne) < (re - ne) * (e - W) && --x;
      return x;
    }
    function N() {
      c = f, d = [], h = [], S = !0;
    }
    function T() {
      var x = $(), k = S && x, A = (d = vF(d)).length;
      (k || A) && (u.polygonStart(), k && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), A && SD(d, a, x, s, u), u.polygonEnd()), c = u, d = h = g = null;
    }
    function L() {
      E.point = F, h && h.push(g = []), _ = !0, w = !1, b = v = NaN;
    }
    function O() {
      d && (F(p, m), y && w && f.rejoin(), d.push(f.result())), E.point = C, w && c.lineEnd();
    }
    function F(x, k) {
      var A = r(x, k);
      if (h && g.push([x, k]), _)
        p = x, m = k, y = A, _ = !1, A && (c.lineStart(), c.point(x, k));
      else if (A && w)
        c.point(x, k);
      else {
        var M = [b = Math.max(ah, Math.min(Bc, b)), v = Math.max(ah, Math.min(Bc, v))], D = [x = Math.max(ah, Math.min(Bc, x)), k = Math.max(ah, Math.min(Bc, k))];
        lV(M, D, e, t, n, i) ? (w || (c.lineStart(), c.point(M[0], M[1])), c.point(D[0], D[1]), A || c.lineEnd(), S = !1) : A && (c.lineStart(), c.point(x, k), S = !1);
      }
      b = x, v = k, w = A;
    }
    return E;
  };
}
function YA(e, t, n) {
  var i = Xn(e, t - fe, n).concat(t);
  return function(r) {
    return i.map(function(s) {
      return [r, s];
    });
  };
}
function XA(e, t, n) {
  var i = Xn(e, t - fe, n).concat(t);
  return function(r) {
    return i.map(function(s) {
      return [s, r];
    });
  };
}
function uV() {
  var e, t, n, i, r, s, o, a, l = 10, u = l, c = 90, f = 360, d, h, g, p, m = 2.5;
  function y() {
    return { type: "MultiLineString", coordinates: b() };
  }
  function b() {
    return Xn(ih(i / c) * c, n, c).map(g).concat(Xn(ih(a / f) * f, o, f).map(p)).concat(Xn(ih(t / l) * l, e, l).filter(function(v) {
      return Te(v % c) > fe;
    }).map(d)).concat(Xn(ih(s / u) * u, r, u).filter(function(v) {
      return Te(v % f) > fe;
    }).map(h));
  }
  return y.lines = function() {
    return b().map(function(v) {
      return { type: "LineString", coordinates: v };
    });
  }, y.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        g(i).concat(
          p(o).slice(1),
          g(n).reverse().slice(1),
          p(a).reverse().slice(1)
        )
      ]
    };
  }, y.extent = function(v) {
    return arguments.length ? y.extentMajor(v).extentMinor(v) : y.extentMinor();
  }, y.extentMajor = function(v) {
    return arguments.length ? (i = +v[0][0], n = +v[1][0], a = +v[0][1], o = +v[1][1], i > n && (v = i, i = n, n = v), a > o && (v = a, a = o, o = v), y.precision(m)) : [[i, a], [n, o]];
  }, y.extentMinor = function(v) {
    return arguments.length ? (t = +v[0][0], e = +v[1][0], s = +v[0][1], r = +v[1][1], t > e && (v = t, t = e, e = v), s > r && (v = s, s = r, r = v), y.precision(m)) : [[t, s], [e, r]];
  }, y.step = function(v) {
    return arguments.length ? y.stepMajor(v).stepMinor(v) : y.stepMinor();
  }, y.stepMajor = function(v) {
    return arguments.length ? (c = +v[0], f = +v[1], y) : [c, f];
  }, y.stepMinor = function(v) {
    return arguments.length ? (l = +v[0], u = +v[1], y) : [l, u];
  }, y.precision = function(v) {
    return arguments.length ? (m = +v, d = YA(s, r, 90), h = XA(t, e, m), g = YA(a, o, 90), p = XA(i, n, m), y) : m;
  }, y.extentMajor([[-180, -90 + fe], [180, 90 - fe]]).extentMinor([[-180, -80 - fe], [180, 80 + fe]]);
}
const Nf = (e) => e;
var k1 = new bn(), Ab = new bn(), CD, $D, Cb, $b, os = {
  point: Bt,
  lineStart: Bt,
  lineEnd: Bt,
  polygonStart: function() {
    os.lineStart = cV, os.lineEnd = dV;
  },
  polygonEnd: function() {
    os.lineStart = os.lineEnd = os.point = Bt, k1.add(Te(Ab)), Ab = new bn();
  },
  result: function() {
    var e = k1 / 2;
    return k1 = new bn(), e;
  }
};
function cV() {
  os.point = fV;
}
function fV(e, t) {
  os.point = MD, CD = Cb = e, $D = $b = t;
}
function MD(e, t) {
  Ab.add($b * e - Cb * t), Cb = e, $b = t;
}
function dV() {
  MD(CD, $D);
}
var pu = 1 / 0, Kg = pu, Df = -pu, Jg = Df, Qg = {
  point: hV,
  lineStart: Bt,
  lineEnd: Bt,
  polygonStart: Bt,
  polygonEnd: Bt,
  result: function() {
    var e = [[pu, Kg], [Df, Jg]];
    return Df = Jg = -(Kg = pu = 1 / 0), e;
  }
};
function hV(e, t) {
  e < pu && (pu = e), e > Df && (Df = e), t < Kg && (Kg = t), t > Jg && (Jg = t);
}
var Mb = 0, Fb = 0, jc = 0, Zg = 0, ep = 0, Pl = 0, Tb = 0, Ob = 0, Uc = 0, FD, TD, br, vr, di = {
  point: Da,
  lineStart: KA,
  lineEnd: JA,
  polygonStart: function() {
    di.lineStart = mV, di.lineEnd = yV;
  },
  polygonEnd: function() {
    di.point = Da, di.lineStart = KA, di.lineEnd = JA;
  },
  result: function() {
    var e = Uc ? [Tb / Uc, Ob / Uc] : Pl ? [Zg / Pl, ep / Pl] : jc ? [Mb / jc, Fb / jc] : [NaN, NaN];
    return Mb = Fb = jc = Zg = ep = Pl = Tb = Ob = Uc = 0, e;
  }
};
function Da(e, t) {
  Mb += e, Fb += t, ++jc;
}
function KA() {
  di.point = gV;
}
function gV(e, t) {
  di.point = pV, Da(br = e, vr = t);
}
function pV(e, t) {
  var n = e - br, i = t - vr, r = _n(n * n + i * i);
  Zg += r * (br + e) / 2, ep += r * (vr + t) / 2, Pl += r, Da(br = e, vr = t);
}
function JA() {
  di.point = Da;
}
function mV() {
  di.point = bV;
}
function yV() {
  OD(FD, TD);
}
function bV(e, t) {
  di.point = OD, Da(FD = br = e, TD = vr = t);
}
function OD(e, t) {
  var n = e - br, i = t - vr, r = _n(n * n + i * i);
  Zg += r * (br + e) / 2, ep += r * (vr + t) / 2, Pl += r, r = vr * e - br * t, Tb += r * (br + e), Ob += r * (vr + t), Uc += r * 3, Da(br = e, vr = t);
}
function ND(e) {
  this._context = e;
}
ND.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, wn);
        break;
      }
    }
  },
  result: Bt
};
var Nb = new bn(), A1, DD, RD, qc, Wc, Rf = {
  point: Bt,
  lineStart: function() {
    Rf.point = vV;
  },
  lineEnd: function() {
    A1 && LD(DD, RD), Rf.point = Bt;
  },
  polygonStart: function() {
    A1 = !0;
  },
  polygonEnd: function() {
    A1 = null;
  },
  result: function() {
    var e = +Nb;
    return Nb = new bn(), e;
  }
};
function vV(e, t) {
  Rf.point = LD, DD = qc = e, RD = Wc = t;
}
function LD(e, t) {
  qc -= e, Wc -= t, Nb.add(_n(qc * qc + Wc * Wc)), qc = e, Wc = t;
}
let QA, tp, ZA, eC;
class tC {
  constructor(t) {
    this._append = t == null ? PD : xV(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== ZA || this._append !== tp) {
          const i = this._radius, r = this._;
          this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, ZA = i, tp = this._append, eC = this._, this._ = r;
        }
        this._ += eC;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function PD(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function xV(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return PD;
  if (t !== QA) {
    const n = 10 ** t;
    QA = t, tp = function(r) {
      let s = 1;
      this._ += r[0];
      for (const o = r.length; s < o; ++s)
        this._ += Math.round(arguments[s] * n) / n + r[s];
    };
  }
  return tp;
}
function ID(e, t) {
  let n = 3, i = 4.5, r, s;
  function o(a) {
    return a && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), ss(a, r(s))), s.result();
  }
  return o.area = function(a) {
    return ss(a, r(os)), os.result();
  }, o.measure = function(a) {
    return ss(a, r(Rf)), Rf.result();
  }, o.bounds = function(a) {
    return ss(a, r(Qg)), Qg.result();
  }, o.centroid = function(a) {
    return ss(a, r(di)), di.result();
  }, o.projection = function(a) {
    return arguments.length ? (r = a == null ? (e = null, Nf) : (e = a).stream, o) : e;
  }, o.context = function(a) {
    return arguments.length ? (s = a == null ? (t = null, new tC(n)) : new ND(t = a), typeof i != "function" && s.pointRadius(i), o) : t;
  }, o.pointRadius = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : (s.pointRadius(+a), +a), o) : i;
  }, o.digits = function(a) {
    if (!arguments.length)
      return n;
    if (a == null)
      n = null;
    else {
      const l = Math.floor(a);
      if (!(l >= 0))
        throw new RangeError(`invalid digits: ${a}`);
      n = l;
    }
    return t === null && (s = new tC(n)), o;
  }, o.projection(e).digits(n).context(t);
}
function Rm(e) {
  return function(t) {
    var n = new Db();
    for (var i in e)
      n[i] = e[i];
    return n.stream = t, n;
  };
}
function Db() {
}
Db.prototype = {
  constructor: Db,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function kw(e, t, n) {
  var i = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), ss(n, e.stream(Qg)), t(Qg.result()), i != null && e.clipExtent(i), e;
}
function Lm(e, t, n) {
  return kw(e, function(i) {
    var r = t[1][0] - t[0][0], s = t[1][1] - t[0][1], o = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])), a = +t[0][0] + (r - o * (i[1][0] + i[0][0])) / 2, l = +t[0][1] + (s - o * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * o).translate([a, l]);
  }, n);
}
function Aw(e, t, n) {
  return Lm(e, [[0, 0], t], n);
}
function Cw(e, t, n) {
  return kw(e, function(i) {
    var r = +t, s = r / (i[1][0] - i[0][0]), o = (r - s * (i[1][0] + i[0][0])) / 2, a = -s * i[0][1];
    e.scale(150 * s).translate([o, a]);
  }, n);
}
function $w(e, t, n) {
  return kw(e, function(i) {
    var r = +t, s = r / (i[1][1] - i[0][1]), o = -s * i[0][0], a = (r - s * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * s).translate([o, a]);
  }, n);
}
var nC = 16, wV = he(30 * ke);
function iC(e, t) {
  return +t ? EV(e, t) : _V(e);
}
function _V(e) {
  return Rm({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function EV(e, t) {
  function n(i, r, s, o, a, l, u, c, f, d, h, g, p, m) {
    var y = u - i, b = c - r, v = y * y + b * b;
    if (v > 4 * t && p--) {
      var w = o + d, _ = a + h, S = l + g, E = _n(w * w + _ * _ + S * S), C = In(S /= E), $ = Te(Te(S) - 1) < fe || Te(s - f) < fe ? (s + f) / 2 : Ai(_, w), N = e($, C), T = N[0], L = N[1], O = T - i, F = L - r, x = b * O - y * F;
      (x * x / v > t || Te((y * O + b * F) / v - 0.5) > 0.3 || o * d + a * h + l * g < wV) && (n(i, r, s, o, a, l, T, L, $, w /= E, _ /= E, S, p, m), m.point(T, L), n(T, L, $, w, _, S, u, c, f, d, h, g, p, m));
    }
  }
  return function(i) {
    var r, s, o, a, l, u, c, f, d, h, g, p, m = {
      point: y,
      lineStart: b,
      lineEnd: w,
      polygonStart: function() {
        i.polygonStart(), m.lineStart = _;
      },
      polygonEnd: function() {
        i.polygonEnd(), m.lineStart = b;
      }
    };
    function y(C, $) {
      C = e(C, $), i.point(C[0], C[1]);
    }
    function b() {
      f = NaN, m.point = v, i.lineStart();
    }
    function v(C, $) {
      var N = Na([C, $]), T = e(C, $);
      n(f, d, c, h, g, p, f = T[0], d = T[1], c = C, h = N[0], g = N[1], p = N[2], nC, i), i.point(f, d);
    }
    function w() {
      m.point = y, i.lineEnd();
    }
    function _() {
      b(), m.point = S, m.lineEnd = E;
    }
    function S(C, $) {
      v(r = C, $), s = f, o = d, a = h, l = g, u = p, m.point = v;
    }
    function E() {
      n(f, d, c, h, g, p, s, o, r, a, l, u, nC, i), m.lineEnd = w, w();
    }
    return m;
  };
}
var SV = Rm({
  point: function(e, t) {
    this.stream.point(e * ke, t * ke);
  }
});
function kV(e) {
  return Rm({
    point: function(t, n) {
      var i = e(t, n);
      return this.stream.point(i[0], i[1]);
    }
  });
}
function AV(e, t, n, i, r) {
  function s(o, a) {
    return o *= i, a *= r, [t + e * o, n - e * a];
  }
  return s.invert = function(o, a) {
    return [(o - t) / e * i, (n - a) / e * r];
  }, s;
}
function rC(e, t, n, i, r, s) {
  if (!s)
    return AV(e, t, n, i, r);
  var o = he(s), a = ue(s), l = o * e, u = a * e, c = o / e, f = a / e, d = (a * n - o * t) / e, h = (a * t + o * n) / e;
  function g(p, m) {
    return p *= i, m *= r, [l * p - u * m + t, n - u * p - l * m];
  }
  return g.invert = function(p, m) {
    return [i * (c * p - f * m + d), r * (h - f * p - c * m)];
  }, g;
}
function Br(e) {
  return zD(function() {
    return e;
  })();
}
function zD(e) {
  var t, n = 150, i = 480, r = 250, s = 0, o = 0, a = 0, l = 0, u = 0, c, f = 0, d = 1, h = 1, g = null, p = VA, m = null, y, b, v, w = Nf, _ = 0.5, S, E, C, $, N;
  function T(x) {
    return C(x[0] * ke, x[1] * ke);
  }
  function L(x) {
    return x = C.invert(x[0], x[1]), x && [x[0] * ut, x[1] * ut];
  }
  T.stream = function(x) {
    return $ && N === x ? $ : $ = SV(kV(c)(p(S(w(N = x)))));
  }, T.preclip = function(x) {
    return arguments.length ? (p = x, g = void 0, F()) : p;
  }, T.postclip = function(x) {
    return arguments.length ? (w = x, m = y = b = v = null, F()) : w;
  }, T.clipAngle = function(x) {
    return arguments.length ? (p = +x ? aV(g = x * ke) : (g = null, VA), F()) : g * ut;
  }, T.clipExtent = function(x) {
    return arguments.length ? (w = x == null ? (m = y = b = v = null, Nf) : AD(m = +x[0][0], y = +x[0][1], b = +x[1][0], v = +x[1][1]), F()) : m == null ? null : [[m, y], [b, v]];
  }, T.scale = function(x) {
    return arguments.length ? (n = +x, O()) : n;
  }, T.translate = function(x) {
    return arguments.length ? (i = +x[0], r = +x[1], O()) : [i, r];
  }, T.center = function(x) {
    return arguments.length ? (s = x[0] % 360 * ke, o = x[1] % 360 * ke, O()) : [s * ut, o * ut];
  }, T.rotate = function(x) {
    return arguments.length ? (a = x[0] % 360 * ke, l = x[1] % 360 * ke, u = x.length > 2 ? x[2] % 360 * ke : 0, O()) : [a * ut, l * ut, u * ut];
  }, T.angle = function(x) {
    return arguments.length ? (f = x % 360 * ke, O()) : f * ut;
  }, T.reflectX = function(x) {
    return arguments.length ? (d = x ? -1 : 1, O()) : d < 0;
  }, T.reflectY = function(x) {
    return arguments.length ? (h = x ? -1 : 1, O()) : h < 0;
  }, T.precision = function(x) {
    return arguments.length ? (S = iC(E, _ = x * x), F()) : _n(_);
  }, T.fitExtent = function(x, k) {
    return Lm(T, x, k);
  }, T.fitSize = function(x, k) {
    return Aw(T, x, k);
  }, T.fitWidth = function(x, k) {
    return Cw(T, x, k);
  }, T.fitHeight = function(x, k) {
    return $w(T, x, k);
  };
  function O() {
    var x = rC(n, 0, 0, d, h, f).apply(null, t(s, o)), k = rC(n, i - x[0], r - x[1], d, h, f);
    return c = _D(a, l, u), E = Sb(t, k), C = Sb(c, E), S = iC(E, _), F();
  }
  function F() {
    return $ = N = null, T;
  }
  return function() {
    return t = e.apply(this, arguments), T.invert = t.invert && L, O();
  };
}
function Mw(e) {
  var t = 0, n = Ae / 3, i = zD(e), r = i(t, n);
  return r.parallels = function(s) {
    return arguments.length ? i(t = s[0] * ke, n = s[1] * ke) : [t * ut, n * ut];
  }, r;
}
function CV(e) {
  var t = he(e);
  function n(i, r) {
    return [i * t, ue(r) / t];
  }
  return n.invert = function(i, r) {
    return [i / t, In(r * t)];
  }, n;
}
function $V(e, t) {
  var n = ue(e), i = (n + ue(t)) / 2;
  if (Te(i) < fe)
    return CV(e);
  var r = 1 + n * (2 * i - n), s = _n(r) / i;
  function o(a, l) {
    var u = _n(r - 2 * i * ue(l)) / i;
    return [u * ue(a *= i), s - u * he(a)];
  }
  return o.invert = function(a, l) {
    var u = s - l, c = Ai(a, Te(u)) * gi(u);
    return u * i < 0 && (c -= Ae * gi(a) * gi(u)), [c / i, In((r - (a * a + u * u) * i * i) / (2 * i))];
  }, o;
}
function np() {
  return Mw($V).scale(155.424).center([0, 33.6442]);
}
function BD() {
  return np().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function MV(e) {
  var t = e.length;
  return {
    point: function(n, i) {
      for (var r = -1; ++r < t; )
        e[r].point(n, i);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function FV() {
  var e, t, n = BD(), i, r = np().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), s, o = np().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), a, l, u = { point: function(d, h) {
    l = [d, h];
  } };
  function c(d) {
    var h = d[0], g = d[1];
    return l = null, i.point(h, g), l || (s.point(h, g), l) || (a.point(h, g), l);
  }
  c.invert = function(d) {
    var h = n.scale(), g = n.translate(), p = (d[0] - g[0]) / h, m = (d[1] - g[1]) / h;
    return (m >= 0.12 && m < 0.234 && p >= -0.425 && p < -0.214 ? r : m >= 0.166 && m < 0.234 && p >= -0.214 && p < -0.115 ? o : n).invert(d);
  }, c.stream = function(d) {
    return e && t === d ? e : e = MV([n.stream(t = d), r.stream(d), o.stream(d)]);
  }, c.precision = function(d) {
    return arguments.length ? (n.precision(d), r.precision(d), o.precision(d), f()) : n.precision();
  }, c.scale = function(d) {
    return arguments.length ? (n.scale(d), r.scale(d * 0.35), o.scale(d), c.translate(n.translate())) : n.scale();
  }, c.translate = function(d) {
    if (!arguments.length)
      return n.translate();
    var h = n.scale(), g = +d[0], p = +d[1];
    return i = n.translate(d).clipExtent([[g - 0.455 * h, p - 0.238 * h], [g + 0.455 * h, p + 0.238 * h]]).stream(u), s = r.translate([g - 0.307 * h, p + 0.201 * h]).clipExtent([[g - 0.425 * h + fe, p + 0.12 * h + fe], [g - 0.214 * h - fe, p + 0.234 * h - fe]]).stream(u), a = o.translate([g - 0.205 * h, p + 0.212 * h]).clipExtent([[g - 0.214 * h + fe, p + 0.166 * h + fe], [g - 0.115 * h - fe, p + 0.234 * h - fe]]).stream(u), f();
  }, c.fitExtent = function(d, h) {
    return Lm(c, d, h);
  }, c.fitSize = function(d, h) {
    return Aw(c, d, h);
  }, c.fitWidth = function(d, h) {
    return Cw(c, d, h);
  }, c.fitHeight = function(d, h) {
    return $w(c, d, h);
  };
  function f() {
    return e = t = null, c;
  }
  return c.scale(1070);
}
function jD(e) {
  return function(t, n) {
    var i = he(t), r = he(n), s = e(i * r);
    return s === 1 / 0 ? [2, 0] : [
      s * r * ue(t),
      s * ue(n)
    ];
  };
}
function vd(e) {
  return function(t, n) {
    var i = _n(t * t + n * n), r = e(i), s = ue(r), o = he(r);
    return [
      Ai(t * s, i * o),
      In(i && n * s / i)
    ];
  };
}
var UD = jD(function(e) {
  return _n(2 / (1 + e));
});
UD.invert = vd(function(e) {
  return 2 * In(e / 2);
});
function TV() {
  return Br(UD).scale(124.75).clipAngle(180 - 1e-3);
}
var qD = jD(function(e) {
  return (e = fD(e)) && e / ue(e);
});
qD.invert = vd(function(e) {
  return e;
});
function OV() {
  return Br(qD).scale(79.4188).clipAngle(180 - 1e-3);
}
function Pm(e, t) {
  return [e, Pg(Ew((at + t) / 2))];
}
Pm.invert = function(e, t) {
  return [e, 2 * Gu(cD(t)) - at];
};
function NV() {
  return WD(Pm).scale(961 / wn);
}
function WD(e) {
  var t = Br(e), n = t.center, i = t.scale, r = t.translate, s = t.clipExtent, o = null, a, l, u;
  t.scale = function(f) {
    return arguments.length ? (i(f), c()) : i();
  }, t.translate = function(f) {
    return arguments.length ? (r(f), c()) : r();
  }, t.center = function(f) {
    return arguments.length ? (n(f), c()) : n();
  }, t.clipExtent = function(f) {
    return arguments.length ? (f == null ? o = a = l = u = null : (o = +f[0][0], a = +f[0][1], l = +f[1][0], u = +f[1][1]), c()) : o == null ? null : [[o, a], [l, u]];
  };
  function c() {
    var f = Ae * i(), d = t(ZG(t.rotate()).invert([0, 0]));
    return s(o == null ? [[d[0] - f, d[1] - f], [d[0] + f, d[1] + f]] : e === Pm ? [[Math.max(d[0] - f, o), a], [Math.min(d[0] + f, l), u]] : [[o, Math.max(d[1] - f, a)], [l, Math.min(d[1] + f, u)]]);
  }
  return c();
}
function lh(e) {
  return Ew((at + e) / 2);
}
function DV(e, t) {
  var n = he(e), i = e === t ? ue(e) : Pg(n / he(t)) / Pg(lh(t) / lh(e)), r = n * _1(lh(e), i) / i;
  if (!i)
    return Pm;
  function s(o, a) {
    r > 0 ? a < -at + fe && (a = -at + fe) : a > at - fe && (a = at - fe);
    var l = r / _1(lh(a), i);
    return [l * ue(i * o), r - l * he(i * o)];
  }
  return s.invert = function(o, a) {
    var l = r - a, u = gi(i) * _n(o * o + l * l), c = Ai(o, Te(l)) * gi(l);
    return l * i < 0 && (c -= Ae * gi(o) * gi(l)), [c / i, 2 * Gu(_1(r / u, 1 / i)) - at];
  }, s;
}
function RV() {
  return Mw(DV).scale(109.5).parallels([30, 30]);
}
function ip(e, t) {
  return [e, t];
}
ip.invert = ip;
function LV() {
  return Br(ip).scale(152.63);
}
function PV(e, t) {
  var n = he(e), i = e === t ? ue(e) : (n - he(t)) / (t - e), r = n / i + e;
  if (Te(i) < fe)
    return ip;
  function s(o, a) {
    var l = r - a, u = i * o;
    return [l * ue(u), r - l * he(u)];
  }
  return s.invert = function(o, a) {
    var l = r - a, u = Ai(o, Te(l)) * gi(l);
    return l * i < 0 && (u -= Ae * gi(o) * gi(l)), [u / i, r - gi(i) * _n(o * o + l * l)];
  }, s;
}
function IV() {
  return Mw(PV).scale(131.154).center([0, 13.9389]);
}
var of = 1.340264, af = -0.081106, lf = 893e-6, uf = 3796e-6, rp = _n(3) / 2, zV = 12;
function HD(e, t) {
  var n = In(rp * ue(t)), i = n * n, r = i * i * i;
  return [
    e * he(n) / (rp * (of + 3 * af * i + r * (7 * lf + 9 * uf * i))),
    n * (of + af * i + r * (lf + uf * i))
  ];
}
HD.invert = function(e, t) {
  for (var n = t, i = n * n, r = i * i * i, s = 0, o, a, l; s < zV && (a = n * (of + af * i + r * (lf + uf * i)) - t, l = of + 3 * af * i + r * (7 * lf + 9 * uf * i), n -= o = a / l, i = n * n, r = i * i * i, !(Te(o) < Rg)); ++s)
    ;
  return [
    rp * e * (of + 3 * af * i + r * (7 * lf + 9 * uf * i)) / he(n),
    In(ue(n) / rp)
  ];
};
function BV() {
  return Br(HD).scale(177.158);
}
function GD(e, t) {
  var n = he(t), i = he(e) * n;
  return [n * ue(e) / i, ue(t) / i];
}
GD.invert = vd(Gu);
function jV() {
  return Br(GD).scale(144.049).clipAngle(60);
}
function UV() {
  var e = 1, t = 0, n = 0, i = 1, r = 1, s = 0, o, a, l = null, u, c, f, d = 1, h = 1, g = Rm({
    point: function(w, _) {
      var S = v([w, _]);
      this.stream.point(S[0], S[1]);
    }
  }), p = Nf, m, y;
  function b() {
    return d = e * i, h = e * r, m = y = null, v;
  }
  function v(w) {
    var _ = w[0] * d, S = w[1] * h;
    if (s) {
      var E = S * o - _ * a;
      _ = _ * o + S * a, S = E;
    }
    return [_ + t, S + n];
  }
  return v.invert = function(w) {
    var _ = w[0] - t, S = w[1] - n;
    if (s) {
      var E = S * o + _ * a;
      _ = _ * o - S * a, S = E;
    }
    return [_ / d, S / h];
  }, v.stream = function(w) {
    return m && y === w ? m : m = g(p(y = w));
  }, v.postclip = function(w) {
    return arguments.length ? (p = w, l = u = c = f = null, b()) : p;
  }, v.clipExtent = function(w) {
    return arguments.length ? (p = w == null ? (l = u = c = f = null, Nf) : AD(l = +w[0][0], u = +w[0][1], c = +w[1][0], f = +w[1][1]), b()) : l == null ? null : [[l, u], [c, f]];
  }, v.scale = function(w) {
    return arguments.length ? (e = +w, b()) : e;
  }, v.translate = function(w) {
    return arguments.length ? (t = +w[0], n = +w[1], b()) : [t, n];
  }, v.angle = function(w) {
    return arguments.length ? (s = w % 360 * ke, a = ue(s), o = he(s), b()) : s * ut;
  }, v.reflectX = function(w) {
    return arguments.length ? (i = w ? -1 : 1, b()) : i < 0;
  }, v.reflectY = function(w) {
    return arguments.length ? (r = w ? -1 : 1, b()) : r < 0;
  }, v.fitExtent = function(w, _) {
    return Lm(v, w, _);
  }, v.fitSize = function(w, _) {
    return Aw(v, w, _);
  }, v.fitWidth = function(w, _) {
    return Cw(v, w, _);
  }, v.fitHeight = function(w, _) {
    return $w(v, w, _);
  }, v;
}
function VD(e, t) {
  var n = t * t, i = n * n;
  return [
    e * (0.8707 - 0.131979 * n + i * (-0.013791 + i * (3971e-6 * n - 1529e-6 * i))),
    t * (1.007226 + n * (0.015085 + i * (-0.044475 + 0.028874 * n - 5916e-6 * i)))
  ];
}
VD.invert = function(e, t) {
  var n = t, i = 25, r;
  do {
    var s = n * n, o = s * s;
    n -= r = (n * (1.007226 + s * (0.015085 + o * (-0.044475 + 0.028874 * s - 5916e-6 * o))) - t) / (1.007226 + s * (0.015085 * 3 + o * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * o)));
  } while (Te(r) > fe && --i > 0);
  return [
    e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),
    n
  ];
};
function qV() {
  return Br(VD).scale(175.295);
}
function YD(e, t) {
  return [he(t) * ue(e), ue(t)];
}
YD.invert = vd(In);
function WV() {
  return Br(YD).scale(249.5).clipAngle(90 + fe);
}
function XD(e, t) {
  var n = he(t), i = 1 + he(e) * n;
  return [n * ue(e) / i, ue(t) / i];
}
XD.invert = vd(function(e) {
  return 2 * Gu(e);
});
function HV() {
  return Br(XD).scale(250).clipAngle(142);
}
function KD(e, t) {
  return [Pg(Ew((at + t) / 2)), -e];
}
KD.invert = function(e, t) {
  return [-t, 2 * Gu(cD(e)) - at];
};
function GV() {
  var e = WD(KD), t = e.center, n = e.rotate;
  return e.center = function(i) {
    return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
  }, e.rotate = function(i) {
    return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
var VV = Math.abs, Rb = Math.cos, sp = Math.sin, YV = 1e-6, JD = Math.PI, Lb = JD / 2, sC = XV(2);
function oC(e) {
  return e > 1 ? Lb : e < -1 ? -Lb : Math.asin(e);
}
function XV(e) {
  return e > 0 ? Math.sqrt(e) : 0;
}
function KV(e, t) {
  var n = e * sp(t), i = 30, r;
  do
    t -= r = (t + sp(t) - n) / (1 + Rb(t));
  while (VV(r) > YV && --i > 0);
  return t / 2;
}
function JV(e, t, n) {
  function i(r, s) {
    return [e * r * Rb(s = KV(n, s)), t * sp(s)];
  }
  return i.invert = function(r, s) {
    return s = oC(s / t), [r / (e * Rb(s)), oC((2 * s + sp(2 * s)) / n)];
  }, i;
}
var QV = JV(sC / Lb, sC, JD);
function ZV() {
  return Br(QV).scale(169.529);
}
const eY = ID(), Pb = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function tY(e, t) {
  return function n() {
    const i = t();
    return i.type = e, i.path = ID().projection(i), i.copy = i.copy || function() {
      const r = n();
      return Pb.forEach((s) => {
        i[s] && r[s](i[s]());
      }), r.path.pointRadius(i.path.pointRadius()), r;
    }, mO(i);
  };
}
function Fw(e, t) {
  if (!e || typeof e != "string")
    throw new Error("Projection type must be a name string.");
  return e = e.toLowerCase(), arguments.length > 1 ? (op[e] = tY(e, t), this) : op[e] || null;
}
function QD(e) {
  return e && e.path || eY;
}
const op = {
  // base d3-geo projection types
  albers: BD,
  albersusa: FV,
  azimuthalequalarea: TV,
  azimuthalequidistant: OV,
  conicconformal: RV,
  conicequalarea: np,
  conicequidistant: IV,
  equalEarth: BV,
  equirectangular: LV,
  gnomonic: jV,
  identity: UV,
  mercator: NV,
  mollweide: ZV,
  naturalEarth1: qV,
  orthographic: WV,
  stereographic: HV,
  transversemercator: GV
};
for (const e in op)
  Fw(e, op[e]);
function nY() {
}
const Jr = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function ZD() {
  var e = 1, t = 1, n = a;
  function i(l, u) {
    return u.map((c) => r(l, c));
  }
  function r(l, u) {
    var c = [], f = [];
    return s(l, u, (d) => {
      n(d, l, u), iY(d) > 0 ? c.push([d]) : f.push(d);
    }), f.forEach((d) => {
      for (var h = 0, g = c.length, p; h < g; ++h)
        if (rY((p = c[h])[0], d) !== -1) {
          p.push(d);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: u,
      coordinates: c
    };
  }
  function s(l, u, c) {
    var f = new Array(), d = new Array(), h, g, p, m, y, b;
    for (h = g = -1, m = l[0] >= u, Jr[m << 1].forEach(v); ++h < e - 1; )
      p = m, m = l[h + 1] >= u, Jr[p | m << 1].forEach(v);
    for (Jr[m << 0].forEach(v); ++g < t - 1; ) {
      for (h = -1, m = l[g * e + e] >= u, y = l[g * e] >= u, Jr[m << 1 | y << 2].forEach(v); ++h < e - 1; )
        p = m, m = l[g * e + e + h + 1] >= u, b = y, y = l[g * e + h + 1] >= u, Jr[p | m << 1 | y << 2 | b << 3].forEach(v);
      Jr[m | y << 3].forEach(v);
    }
    for (h = -1, y = l[g * e] >= u, Jr[y << 2].forEach(v); ++h < e - 1; )
      b = y, y = l[g * e + h + 1] >= u, Jr[y << 2 | b << 3].forEach(v);
    Jr[y << 3].forEach(v);
    function v(w) {
      var _ = [w[0][0] + h, w[0][1] + g], S = [w[1][0] + h, w[1][1] + g], E = o(_), C = o(S), $, N;
      ($ = d[E]) ? (N = f[C]) ? (delete d[$.end], delete f[N.start], $ === N ? ($.ring.push(S), c($.ring)) : f[$.start] = d[N.end] = {
        start: $.start,
        end: N.end,
        ring: $.ring.concat(N.ring)
      }) : (delete d[$.end], $.ring.push(S), d[$.end = C] = $) : ($ = f[C]) ? (N = d[E]) ? (delete f[$.start], delete d[N.end], $ === N ? ($.ring.push(S), c($.ring)) : f[N.start] = d[$.end] = {
        start: N.start,
        end: $.end,
        ring: N.ring.concat($.ring)
      }) : (delete f[$.start], $.ring.unshift(_), f[$.start = E] = $) : f[E] = d[C] = {
        start: E,
        end: C,
        ring: [_, S]
      };
    }
  }
  function o(l) {
    return l[0] * 2 + l[1] * (e + 1) * 4;
  }
  function a(l, u, c) {
    l.forEach((f) => {
      var d = f[0], h = f[1], g = d | 0, p = h | 0, m, y = u[p * e + g];
      d > 0 && d < e && g === d && (m = u[p * e + g - 1], f[0] = d + (c - m) / (y - m) - 0.5), h > 0 && h < t && p === h && (m = u[(p - 1) * e + g], f[1] = h + (c - m) / (y - m) - 0.5);
    });
  }
  return i.contour = r, i.size = function(l) {
    if (!arguments.length)
      return [e, t];
    var u = Math.floor(l[0]), c = Math.floor(l[1]);
    return u >= 0 && c >= 0 || B("invalid size"), e = u, t = c, i;
  }, i.smooth = function(l) {
    return arguments.length ? (n = l ? a : nY, i) : n === a;
  }, i;
}
function iY(e) {
  for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return i;
}
function rY(e, t) {
  for (var n = -1, i = t.length, r; ++n < i; )
    if (r = sY(e, t[n]))
      return r;
  return 0;
}
function sY(e, t) {
  for (var n = t[0], i = t[1], r = -1, s = 0, o = e.length, a = o - 1; s < o; a = s++) {
    var l = e[s], u = l[0], c = l[1], f = e[a], d = f[0], h = f[1];
    if (oY(l, f, t))
      return 0;
    c > i != h > i && n < (d - u) * (i - c) / (h - c) + u && (r = -r);
  }
  return r;
}
function oY(e, t, n) {
  var i;
  return aY(e, t, n) && lY(e[i = +(e[0] === t[0])], n[i], t[i]);
}
function aY(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function lY(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function eR(e, t, n) {
  return function(i) {
    var r = $r(i), s = n ? Math.min(r[0], 0) : r[0], o = r[1], a = o - s, l = t ? ho(s, o, e) : a / (e + 1);
    return Xn(s + l, o, l);
  };
}
function Tw(e) {
  P.call(this, null, e);
}
Tw.Definition = {
  type: "Isocontour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "levels",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "zero",
    type: "boolean",
    default: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }, {
    name: "scale",
    type: "number",
    expr: !0
  }, {
    name: "translate",
    type: "number",
    array: !0,
    expr: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    default: "contour"
  }]
};
Y(Tw, P, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = e.field || on, s = ZD().smooth(e.smooth !== !1), o = e.thresholds || uY(i, r, e), a = e.as === null ? null : e.as || "contour", l = [];
    return i.forEach((u) => {
      const c = r(u), f = s.size([c.width, c.height])(c.values, j(o) ? o : o(c.values));
      cY(f, c, u, e), f.forEach((d) => {
        l.push(Zp(u, Be(a != null ? {
          [a]: d
        } : d)));
      });
    }), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n;
  }
});
function uY(e, t, n) {
  const i = eR(n.levels || 10, n.nice, n.zero !== !1);
  return n.resolve !== "shared" ? i : i(e.map((r) => va(t(r).values)));
}
function cY(e, t, n, i) {
  let r = i.scale || t.scale, s = i.translate || t.translate;
  if (Ee(r) && (r = r(n, i)), Ee(s) && (s = s(n, i)), (r === 1 || r == null) && !s)
    return;
  const o = (Re(r) ? r : r[0]) || 1, a = (Re(r) ? r : r[1]) || 1, l = s && s[0] || 0, u = s && s[1] || 0;
  e.forEach(tR(t, o, a, l, u));
}
function tR(e, t, n, i, r) {
  const s = e.x1 || 0, o = e.y1 || 0, a = t * n < 0;
  function l(f) {
    f.forEach(u);
  }
  function u(f) {
    a && f.reverse(), f.forEach(c);
  }
  function c(f) {
    f[0] = (f[0] - s) * t + i, f[1] = (f[1] - o) * n + r;
  }
  return function(f) {
    return f.coordinates.forEach(l), f;
  };
}
function aC(e, t, n) {
  const i = e >= 0 ? e : xx(t, n);
  return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
}
function C1(e) {
  return Ee(e) ? e : an(+e);
}
function nR() {
  var e = (l) => l[0], t = (l) => l[1], n = Nu, i = [-1, -1], r = 960, s = 500, o = 2;
  function a(l, u) {
    const c = aC(i[0], l, e) >> o, f = aC(i[1], l, t) >> o, d = c ? c + 2 : 0, h = f ? f + 2 : 0, g = 2 * d + (r >> o), p = 2 * h + (s >> o), m = new Float32Array(g * p), y = new Float32Array(g * p);
    let b = m;
    l.forEach((w) => {
      const _ = d + (+e(w) >> o), S = h + (+t(w) >> o);
      _ >= 0 && _ < g && S >= 0 && S < p && (m[_ + S * g] += +n(w));
    }), c > 0 && f > 0 ? (xl(g, p, m, y, c), wl(g, p, y, m, f), xl(g, p, m, y, c), wl(g, p, y, m, f), xl(g, p, m, y, c), wl(g, p, y, m, f)) : c > 0 ? (xl(g, p, m, y, c), xl(g, p, y, m, c), xl(g, p, m, y, c), b = y) : f > 0 && (wl(g, p, m, y, f), wl(g, p, y, m, f), wl(g, p, m, y, f), b = y);
    const v = u ? Math.pow(2, -2 * o) : 1 / xF(b);
    for (let w = 0, _ = g * p; w < _; ++w)
      b[w] *= v;
    return {
      values: b,
      scale: 1 << o,
      width: g,
      height: p,
      x1: d,
      y1: h,
      x2: d + (r >> o),
      y2: h + (s >> o)
    };
  }
  return a.x = function(l) {
    return arguments.length ? (e = C1(l), a) : e;
  }, a.y = function(l) {
    return arguments.length ? (t = C1(l), a) : t;
  }, a.weight = function(l) {
    return arguments.length ? (n = C1(l), a) : n;
  }, a.size = function(l) {
    if (!arguments.length)
      return [r, s];
    var u = +l[0], c = +l[1];
    return u >= 0 && c >= 0 || B("invalid size"), r = u, s = c, a;
  }, a.cellSize = function(l) {
    return arguments.length ? ((l = +l) >= 1 || B("invalid cell size"), o = Math.floor(Math.log(l) / Math.LN2), a) : 1 << o;
  }, a.bandwidth = function(l) {
    return arguments.length ? (l = J(l), l.length === 1 && (l = [+l[0], +l[0]]), l.length !== 2 && B("invalid bandwidth"), i = l, a) : i;
  }, a;
}
function xl(e, t, n, i, r) {
  const s = (r << 1) + 1;
  for (let o = 0; o < t; ++o)
    for (let a = 0, l = 0; a < e + r; ++a)
      a < e && (l += n[a + o * e]), a >= r && (a >= s && (l -= n[a - s + o * e]), i[a - r + o * e] = l / Math.min(a + 1, e - 1 + s - a, s));
}
function wl(e, t, n, i, r) {
  const s = (r << 1) + 1;
  for (let o = 0; o < e; ++o)
    for (let a = 0, l = 0; a < t + r; ++a)
      a < t && (l += n[o + a * e]), a >= r && (a >= s && (l -= n[o + (a - s) * e]), i[o + (a - r) * e] = l / Math.min(a + 1, t - 1 + s - a, s));
}
function Ow(e) {
  P.call(this, null, e);
}
Ow.Definition = {
  type: "KDE2D",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: "grid"
  }]
};
const fY = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function iR(e, t) {
  return fY.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
}
Y(Ow, P, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = dY(i, e.groupby), s = (e.groupby || []).map(lt), o = iR(nR(), e), a = e.as || "grid", l = [];
    function u(c, f) {
      for (let d = 0; d < s.length; ++d)
        c[s[d]] = f[d];
      return c;
    }
    return l = r.map((c) => Be(u({
      [a]: o(c, e.counts)
    }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n;
  }
});
function dY(e, t) {
  var n = [], i = (c) => c(a), r, s, o, a, l, u;
  if (t == null)
    n.push(e);
  else
    for (r = {}, s = 0, o = e.length; s < o; ++s)
      a = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(a);
  return n;
}
function Nw(e) {
  P.call(this, null, e);
}
Nw.Definition = {
  type: "Contour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "values",
    type: "number",
    array: !0
  }, {
    name: "x",
    type: "field"
  }, {
    name: "y",
    type: "field"
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number"
  }, {
    name: "count",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }]
};
Y(Nw, P, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = ZD().smooth(e.smooth !== !1), r = e.values, s = e.thresholds || eR(e.count || 10, e.nice, !!r), o = e.size, a, l;
    return r || (r = t.materialize(t.SOURCE).source, a = iR(nR(), e)(r, !0), l = tR(a, a.scale || 1, a.scale || 1, 0, 0), o = [a.width, a.height], r = a.values), s = j(s) ? s : s(r), r = i.size(o)(r, s), l && r.forEach(l), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(Be), n;
  }
});
const Ib = "Feature", Dw = "FeatureCollection", hY = "MultiPoint";
function Rw(e) {
  P.call(this, null, e);
}
Rw.Definition = {
  type: "GeoJSON",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    length: 2
  }, {
    name: "geojson",
    type: "field"
  }]
};
Y(Rw, P, {
  transform(e, t) {
    var n = this._features, i = this._points, r = e.fields, s = r && r[0], o = r && r[1], a = e.geojson || !r && on, l = t.ADD, u;
    u = e.modified() || t.changed(t.REM) || t.modified(tn(a)) || s && t.modified(tn(s)) || o && t.modified(tn(o)), (!this.value || u) && (l = t.SOURCE, this._features = n = [], this._points = i = []), a && t.visit(l, (c) => n.push(a(c))), s && o && (t.visit(l, (c) => {
      var f = s(c), d = o(c);
      f != null && d != null && (f = +f) === f && (d = +d) === d && i.push([f, d]);
    }), n = n.concat({
      type: Ib,
      geometry: {
        type: hY,
        coordinates: i
      }
    })), this.value = {
      type: Dw,
      features: n
    };
  }
});
function Lw(e) {
  P.call(this, null, e);
}
Lw.Definition = {
  type: "GeoPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
Y(Lw, P, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.field || on, s = e.as || "path", o = n.SOURCE;
    !i || e.modified() ? (this.value = i = QD(e.projection), n.materialize().reflow()) : o = r === on || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
    const a = gY(i, e.pointRadius);
    return n.visit(o, (l) => l[s] = i(r(l))), i.pointRadius(a), n.modifies(s);
  }
});
function gY(e, t) {
  const n = e.pointRadius();
  return e.context(null), t != null && e.pointRadius(t), n;
}
function Pw(e) {
  P.call(this, null, e);
}
Pw.Definition = {
  type: "GeoPoint",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection",
    required: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["x", "y"]
  }]
};
Y(Pw, P, {
  transform(e, t) {
    var n = e.projection, i = e.fields[0], r = e.fields[1], s = e.as || ["x", "y"], o = s[0], a = s[1], l;
    function u(c) {
      const f = n([i(c), r(c)]);
      f ? (c[o] = f[0], c[a] = f[1]) : (c[o] = void 0, c[a] = void 0);
    }
    return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, u) : (l = t.modified(i.fields) || t.modified(r.fields), t.visit(l ? t.ADD_MOD : t.ADD, u)), t.modifies(s);
  }
});
function Iw(e) {
  P.call(this, null, e);
}
Iw.Definition = {
  type: "GeoShape",
  metadata: {
    modifies: !0,
    nomod: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field",
    default: "datum"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "shape"
  }]
};
Y(Iw, P, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.as || "shape", s = n.ADD;
    return (!i || e.modified()) && (this.value = i = pY(QD(e.projection), e.field || _i("datum"), e.pointRadius), n.materialize().reflow(), s = n.SOURCE), n.visit(s, (o) => o[r] = i), n.modifies(r);
  }
});
function pY(e, t, n) {
  const i = n == null ? (r) => e(t(r)) : (r) => {
    var s = e.pointRadius(), o = e.pointRadius(n)(t(r));
    return e.pointRadius(s), o;
  };
  return i.context = (r) => (e.context(r), i), i;
}
function zw(e) {
  P.call(this, [], e), this.generator = uV();
}
zw.Definition = {
  type: "Graticule",
  metadata: {
    changes: !0,
    generates: !0
  },
  params: [{
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMajor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMinor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "step",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "stepMajor",
    type: "number",
    array: !0,
    length: 2,
    default: [90, 360]
  }, {
    name: "stepMinor",
    type: "number",
    array: !0,
    length: 2,
    default: [10, 10]
  }, {
    name: "precision",
    type: "number",
    default: 2.5
  }]
};
Y(zw, P, {
  transform(e, t) {
    var n = this.value, i = this.generator, r;
    if (!n.length || e.modified())
      for (const s in e)
        Ee(i[s]) && i[s](e[s]);
    return r = i(), n.length ? t.mod.push(pT(n[0], r)) : t.add.push(Be(r)), n[0] = r, t;
  }
});
function Bw(e) {
  P.call(this, null, e);
}
Bw.Definition = {
  type: "heatmap",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "color",
    type: "string",
    expr: !0
  }, {
    name: "opacity",
    type: "number",
    expr: !0
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "as",
    type: "string",
    default: "image"
  }]
};
Y(Bw, P, {
  transform(e, t) {
    if (!t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.materialize(t.SOURCE).source, i = e.resolve === "shared", r = e.field || on, s = yY(e.opacity, e), o = mY(e.color, e), a = e.as || "image", l = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: i ? va(n.map((u) => va(r(u).values))) : 0
    };
    return n.forEach((u) => {
      const c = r(u), f = we({}, u, l);
      i || (f.$max = va(c.values || [])), u[a] = bY(c, f, o.dep ? o : an(o(f)), s.dep ? s : an(s(f)));
    }), t.reflow(!0).modifies(a);
  }
});
function mY(e, t) {
  let n;
  return Ee(e) ? (n = (i) => mo(e(i, t)), n.dep = rR(e)) : n = an(mo(e || "#888")), n;
}
function yY(e, t) {
  let n;
  return Ee(e) ? (n = (i) => e(i, t), n.dep = rR(e)) : e ? n = an(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
}
function rR(e) {
  if (!Ee(e))
    return !1;
  const t = Ji(tn(e));
  return t.$x || t.$y || t.$value || t.$max;
}
function bY(e, t, n, i) {
  const r = e.width, s = e.height, o = e.x1 || 0, a = e.y1 || 0, l = e.x2 || r, u = e.y2 || s, c = e.values, f = c ? (m) => c[m] : Xs, d = lo(l - o, u - a), h = d.getContext("2d"), g = h.getImageData(0, 0, l - o, u - a), p = g.data;
  for (let m = a, y = 0; m < u; ++m) {
    t.$y = m - a;
    for (let b = o, v = m * r; b < l; ++b, y += 4) {
      t.$x = b - o, t.$value = f(b + v);
      const w = n(t);
      p[y + 0] = w.r, p[y + 1] = w.g, p[y + 2] = w.b, p[y + 3] = ~~(255 * i(t));
    }
  }
  return h.putImageData(g, 0, 0), d;
}
function sR(e) {
  P.call(this, null, e), this.modified(!0);
}
Y(sR, P, {
  transform(e, t) {
    let n = this.value;
    return !n || e.modified("type") ? (this.value = n = xY(e.type), Pb.forEach((i) => {
      e[i] != null && lC(n, i, e[i]);
    })) : Pb.forEach((i) => {
      e.modified(i) && lC(n, i, e[i]);
    }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && vY(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function vY(e, t) {
  const n = wY(t.fit);
  t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
}
function xY(e) {
  const t = Fw((e || "mercator").toLowerCase());
  return t || B("Unrecognized projection type: " + e), t();
}
function lC(e, t, n) {
  Ee(e[t]) && e[t](n);
}
function wY(e) {
  return e = J(e), e.length === 1 ? e[0] : {
    type: Dw,
    features: e.reduce((t, n) => t.concat(_Y(n)), [])
  };
}
function _Y(e) {
  return e.type === Dw ? e.features : J(e).filter((t) => t != null).map((t) => t.type === Ib ? t : {
    type: Ib,
    geometry: t
  });
}
const EY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contour: Nw,
  geojson: Rw,
  geopath: Lw,
  geopoint: Pw,
  geoshape: Iw,
  graticule: zw,
  heatmap: Bw,
  isocontour: Tw,
  kde2d: Ow,
  projection: sR
}, Symbol.toStringTag, { value: "Module" }));
function SY(e, t) {
  var n, i = 1;
  e == null && (e = 0), t == null && (t = 0);
  function r() {
    var s, o = n.length, a, l = 0, u = 0;
    for (s = 0; s < o; ++s)
      a = n[s], l += a.x, u += a.y;
    for (l = (l / o - e) * i, u = (u / o - t) * i, s = 0; s < o; ++s)
      a = n[s], a.x -= l, a.y -= u;
  }
  return r.initialize = function(s) {
    n = s;
  }, r.x = function(s) {
    return arguments.length ? (e = +s, r) : e;
  }, r.y = function(s) {
    return arguments.length ? (t = +s, r) : t;
  }, r.strength = function(s) {
    return arguments.length ? (i = +s, r) : i;
  }, r;
}
function kY(e) {
  const t = +this._x.call(null, e), n = +this._y.call(null, e);
  return oR(this.cover(t, n), t, n, e);
}
function oR(e, t, n, i) {
  if (isNaN(t) || isNaN(n))
    return e;
  var r, s = e._root, o = { data: i }, a = e._x0, l = e._y0, u = e._x1, c = e._y1, f, d, h, g, p, m, y, b;
  if (!s)
    return e._root = o, e;
  for (; s.length; )
    if ((p = t >= (f = (a + u) / 2)) ? a = f : u = f, (m = n >= (d = (l + c) / 2)) ? l = d : c = d, r = s, !(s = s[y = m << 1 | p]))
      return r[y] = o, e;
  if (h = +e._x.call(null, s.data), g = +e._y.call(null, s.data), t === h && n === g)
    return o.next = s, r ? r[y] = o : e._root = o, e;
  do
    r = r ? r[y] = new Array(4) : e._root = new Array(4), (p = t >= (f = (a + u) / 2)) ? a = f : u = f, (m = n >= (d = (l + c) / 2)) ? l = d : c = d;
  while ((y = m << 1 | p) === (b = (g >= d) << 1 | h >= f));
  return r[b] = s, r[y] = o, e;
}
function AY(e) {
  var t, n, i = e.length, r, s, o = new Array(i), a = new Array(i), l = 1 / 0, u = 1 / 0, c = -1 / 0, f = -1 / 0;
  for (n = 0; n < i; ++n)
    isNaN(r = +this._x.call(null, t = e[n])) || isNaN(s = +this._y.call(null, t)) || (o[n] = r, a[n] = s, r < l && (l = r), r > c && (c = r), s < u && (u = s), s > f && (f = s));
  if (l > c || u > f)
    return this;
  for (this.cover(l, u).cover(c, f), n = 0; n < i; ++n)
    oR(this, o[n], a[n], e[n]);
  return this;
}
function CY(e, t) {
  if (isNaN(e = +e) || isNaN(t = +t))
    return this;
  var n = this._x0, i = this._y0, r = this._x1, s = this._y1;
  if (isNaN(n))
    r = (n = Math.floor(e)) + 1, s = (i = Math.floor(t)) + 1;
  else {
    for (var o = r - n || 1, a = this._root, l, u; n > e || e >= r || i > t || t >= s; )
      switch (u = (t < i) << 1 | e < n, l = new Array(4), l[u] = a, a = l, o *= 2, u) {
        case 0:
          r = n + o, s = i + o;
          break;
        case 1:
          n = r - o, s = i + o;
          break;
        case 2:
          r = n + o, i = s - o;
          break;
        case 3:
          n = r - o, i = s - o;
          break;
      }
    this._root && this._root.length && (this._root = a);
  }
  return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this;
}
function $Y() {
  var e = [];
  return this.visit(function(t) {
    if (!t.length)
      do
        e.push(t.data);
      while (t = t.next);
  }), e;
}
function MY(e) {
  return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function mn(e, t, n, i, r) {
  this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r;
}
function FY(e, t, n) {
  var i, r = this._x0, s = this._y0, o, a, l, u, c = this._x1, f = this._y1, d = [], h = this._root, g, p;
  for (h && d.push(new mn(h, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = d.pop(); )
    if (!(!(h = g.node) || (o = g.x0) > c || (a = g.y0) > f || (l = g.x1) < r || (u = g.y1) < s))
      if (h.length) {
        var m = (o + l) / 2, y = (a + u) / 2;
        d.push(
          new mn(h[3], m, y, l, u),
          new mn(h[2], o, y, m, u),
          new mn(h[1], m, a, l, y),
          new mn(h[0], o, a, m, y)
        ), (p = (t >= y) << 1 | e >= m) && (g = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - p], d[d.length - 1 - p] = g);
      } else {
        var b = e - +this._x.call(null, h.data), v = t - +this._y.call(null, h.data), w = b * b + v * v;
        if (w < n) {
          var _ = Math.sqrt(n = w);
          r = e - _, s = t - _, c = e + _, f = t + _, i = h.data;
        }
      }
  return i;
}
function TY(e) {
  if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e)))
    return this;
  var t, n = this._root, i, r, s, o = this._x0, a = this._y0, l = this._x1, u = this._y1, c, f, d, h, g, p, m, y;
  if (!n)
    return this;
  if (n.length)
    for (; ; ) {
      if ((g = c >= (d = (o + l) / 2)) ? o = d : l = d, (p = f >= (h = (a + u) / 2)) ? a = h : u = h, t = n, !(n = n[m = p << 1 | g]))
        return this;
      if (!n.length)
        break;
      (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m);
    }
  for (; n.data !== e; )
    if (r = n, !(n = n.next))
      return this;
  return (s = n.next) && delete n.next, r ? (s ? r.next = s : delete r.next, this) : t ? (s ? t[m] = s : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = s, this);
}
function OY(e) {
  for (var t = 0, n = e.length; t < n; ++t)
    this.remove(e[t]);
  return this;
}
function NY() {
  return this._root;
}
function DY() {
  var e = 0;
  return this.visit(function(t) {
    if (!t.length)
      do
        ++e;
      while (t = t.next);
  }), e;
}
function RY(e) {
  var t = [], n, i = this._root, r, s, o, a, l;
  for (i && t.push(new mn(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop(); )
    if (!e(i = n.node, s = n.x0, o = n.y0, a = n.x1, l = n.y1) && i.length) {
      var u = (s + a) / 2, c = (o + l) / 2;
      (r = i[3]) && t.push(new mn(r, u, c, a, l)), (r = i[2]) && t.push(new mn(r, s, c, u, l)), (r = i[1]) && t.push(new mn(r, u, o, a, c)), (r = i[0]) && t.push(new mn(r, s, o, u, c));
    }
  return this;
}
function LY(e) {
  var t = [], n = [], i;
  for (this._root && t.push(new mn(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop(); ) {
    var r = i.node;
    if (r.length) {
      var s, o = i.x0, a = i.y0, l = i.x1, u = i.y1, c = (o + l) / 2, f = (a + u) / 2;
      (s = r[0]) && t.push(new mn(s, o, a, c, f)), (s = r[1]) && t.push(new mn(s, c, a, l, f)), (s = r[2]) && t.push(new mn(s, o, f, c, u)), (s = r[3]) && t.push(new mn(s, c, f, l, u));
    }
    n.push(i);
  }
  for (; i = n.pop(); )
    e(i.node, i.x0, i.y0, i.x1, i.y1);
  return this;
}
function PY(e) {
  return e[0];
}
function IY(e) {
  return arguments.length ? (this._x = e, this) : this._x;
}
function zY(e) {
  return e[1];
}
function BY(e) {
  return arguments.length ? (this._y = e, this) : this._y;
}
function jw(e, t, n) {
  var i = new Uw(t ?? PY, n ?? zY, NaN, NaN, NaN, NaN);
  return e == null ? i : i.addAll(e);
}
function Uw(e, t, n, i, r, s) {
  this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this._root = void 0;
}
function uC(e) {
  for (var t = { data: e.data }, n = t; e = e.next; )
    n = n.next = { data: e.data };
  return t;
}
var Sn = jw.prototype = Uw.prototype;
Sn.copy = function() {
  var e = new Uw(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, n, i;
  if (!t)
    return e;
  if (!t.length)
    return e._root = uC(t), e;
  for (n = [{ source: t, target: e._root = new Array(4) }]; t = n.pop(); )
    for (var r = 0; r < 4; ++r)
      (i = t.source[r]) && (i.length ? n.push({ source: i, target: t.target[r] = new Array(4) }) : t.target[r] = uC(i));
  return e;
};
Sn.add = kY;
Sn.addAll = AY;
Sn.cover = CY;
Sn.data = $Y;
Sn.extent = MY;
Sn.find = FY;
Sn.remove = TY;
Sn.removeAll = OY;
Sn.root = NY;
Sn.size = DY;
Sn.visit = RY;
Sn.visitAfter = LY;
Sn.x = IY;
Sn.y = BY;
function yn(e) {
  return function() {
    return e;
  };
}
function no(e) {
  return (e() - 0.5) * 1e-6;
}
function jY(e) {
  return e.x + e.vx;
}
function UY(e) {
  return e.y + e.vy;
}
function qY(e) {
  var t, n, i, r = 1, s = 1;
  typeof e != "function" && (e = yn(e == null ? 1 : +e));
  function o() {
    for (var u, c = t.length, f, d, h, g, p, m, y = 0; y < s; ++y)
      for (f = jw(t, jY, UY).visitAfter(a), u = 0; u < c; ++u)
        d = t[u], p = n[d.index], m = p * p, h = d.x + d.vx, g = d.y + d.vy, f.visit(b);
    function b(v, w, _, S, E) {
      var C = v.data, $ = v.r, N = p + $;
      if (C) {
        if (C.index > d.index) {
          var T = h - C.x - C.vx, L = g - C.y - C.vy, O = T * T + L * L;
          O < N * N && (T === 0 && (T = no(i), O += T * T), L === 0 && (L = no(i), O += L * L), O = (N - (O = Math.sqrt(O))) / O * r, d.vx += (T *= O) * (N = ($ *= $) / (m + $)), d.vy += (L *= O) * N, C.vx -= T * (N = 1 - N), C.vy -= L * N);
        }
        return;
      }
      return w > h + N || S < h - N || _ > g + N || E < g - N;
    }
  }
  function a(u) {
    if (u.data)
      return u.r = n[u.data.index];
    for (var c = u.r = 0; c < 4; ++c)
      u[c] && u[c].r > u.r && (u.r = u[c].r);
  }
  function l() {
    if (t) {
      var u, c = t.length, f;
      for (n = new Array(c), u = 0; u < c; ++u)
        f = t[u], n[f.index] = +e(f, u, t);
    }
  }
  return o.initialize = function(u, c) {
    t = u, i = c, l();
  }, o.iterations = function(u) {
    return arguments.length ? (s = +u, o) : s;
  }, o.strength = function(u) {
    return arguments.length ? (r = +u, o) : r;
  }, o.radius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : yn(+u), l(), o) : e;
  }, o;
}
function WY(e) {
  return e.index;
}
function cC(e, t) {
  var n = e.get(t);
  if (!n)
    throw new Error("node not found: " + t);
  return n;
}
function HY(e) {
  var t = WY, n = f, i, r = yn(30), s, o, a, l, u, c = 1;
  e == null && (e = []);
  function f(m) {
    return 1 / Math.min(a[m.source.index], a[m.target.index]);
  }
  function d(m) {
    for (var y = 0, b = e.length; y < c; ++y)
      for (var v = 0, w, _, S, E, C, $, N; v < b; ++v)
        w = e[v], _ = w.source, S = w.target, E = S.x + S.vx - _.x - _.vx || no(u), C = S.y + S.vy - _.y - _.vy || no(u), $ = Math.sqrt(E * E + C * C), $ = ($ - s[v]) / $ * m * i[v], E *= $, C *= $, S.vx -= E * (N = l[v]), S.vy -= C * N, _.vx += E * (N = 1 - N), _.vy += C * N;
  }
  function h() {
    if (o) {
      var m, y = o.length, b = e.length, v = new Map(o.map((_, S) => [t(_, S, o), _])), w;
      for (m = 0, a = new Array(y); m < b; ++m)
        w = e[m], w.index = m, typeof w.source != "object" && (w.source = cC(v, w.source)), typeof w.target != "object" && (w.target = cC(v, w.target)), a[w.source.index] = (a[w.source.index] || 0) + 1, a[w.target.index] = (a[w.target.index] || 0) + 1;
      for (m = 0, l = new Array(b); m < b; ++m)
        w = e[m], l[m] = a[w.source.index] / (a[w.source.index] + a[w.target.index]);
      i = new Array(b), g(), s = new Array(b), p();
    }
  }
  function g() {
    if (o)
      for (var m = 0, y = e.length; m < y; ++m)
        i[m] = +n(e[m], m, e);
  }
  function p() {
    if (o)
      for (var m = 0, y = e.length; m < y; ++m)
        s[m] = +r(e[m], m, e);
  }
  return d.initialize = function(m, y) {
    o = m, u = y, h();
  }, d.links = function(m) {
    return arguments.length ? (e = m, h(), d) : e;
  }, d.id = function(m) {
    return arguments.length ? (t = m, d) : t;
  }, d.iterations = function(m) {
    return arguments.length ? (c = +m, d) : c;
  }, d.strength = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : yn(+m), g(), d) : n;
  }, d.distance = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : yn(+m), p(), d) : r;
  }, d;
}
var GY = { value: () => {
} };
function aR() {
  for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
    if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i))
      throw new Error("illegal type: " + i);
    n[i] = [];
  }
  return new qh(n);
}
function qh(e) {
  this._ = e;
}
function VY(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var i = "", r = n.indexOf(".");
    if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: i };
  });
}
qh.prototype = aR.prototype = {
  constructor: qh,
  on: function(e, t) {
    var n = this._, i = VY(e + "", n), r, s = -1, o = i.length;
    if (arguments.length < 2) {
      for (; ++s < o; )
        if ((r = (e = i[s]).type) && (r = YY(n[r], e.name)))
          return r;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < o; )
      if (r = (e = i[s]).type)
        n[r] = fC(n[r], e.name, t);
      else if (t == null)
        for (r in n)
          n[r] = fC(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new qh(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0)
      for (var n = new Array(r), i = 0, r, s; i < r; ++i)
        n[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], i = 0, r = s.length; i < r; ++i)
      s[i].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var i = this._[e], r = 0, s = i.length; r < s; ++r)
      i[r].value.apply(t, n);
  }
};
function YY(e, t) {
  for (var n = 0, i = e.length, r; n < i; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function fC(e, t, n) {
  for (var i = 0, r = e.length; i < r; ++i)
    if (e[i].name === t) {
      e[i] = GY, e = e.slice(0, i).concat(e.slice(i + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var mu = 0, Hc = 0, mc = 0, lR = 1e3, ap, Gc, lp = 0, Ra = 0, Im = 0, Lf = typeof performance == "object" && performance.now ? performance : Date, uR = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function qw() {
  return Ra || (uR(XY), Ra = Lf.now() + Im);
}
function XY() {
  Ra = 0;
}
function up() {
  this._call = this._time = this._next = null;
}
up.prototype = cR.prototype = {
  constructor: up,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? qw() : +n) + (t == null ? 0 : +t), !this._next && Gc !== this && (Gc ? Gc._next = this : ap = this, Gc = this), this._call = e, this._time = n, zb();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, zb());
  }
};
function cR(e, t, n) {
  var i = new up();
  return i.restart(e, t, n), i;
}
function KY() {
  qw(), ++mu;
  for (var e = ap, t; e; )
    (t = Ra - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --mu;
}
function dC() {
  Ra = (lp = Lf.now()) + Im, mu = Hc = 0;
  try {
    KY();
  } finally {
    mu = 0, QY(), Ra = 0;
  }
}
function JY() {
  var e = Lf.now(), t = e - lp;
  t > lR && (Im -= t, lp = e);
}
function QY() {
  for (var e, t = ap, n, i = 1 / 0; t; )
    t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : ap = n);
  Gc = e, zb(i);
}
function zb(e) {
  if (!mu) {
    Hc && (Hc = clearTimeout(Hc));
    var t = e - Ra;
    t > 24 ? (e < 1 / 0 && (Hc = setTimeout(dC, e - Lf.now() - Im)), mc && (mc = clearInterval(mc))) : (mc || (lp = Lf.now(), mc = setInterval(JY, lR)), mu = 1, uR(dC));
  }
}
function ZY(e, t, n) {
  var i = new up(), r = t;
  return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(s, o, a) {
    o = +o, a = a == null ? qw() : +a, i._restart(function l(u) {
      u += r, i._restart(l, r += o, a), s(u);
    }, o, a);
  }, i.restart(e, t, n), i);
}
const eX = 1664525, tX = 1013904223, hC = 4294967296;
function nX() {
  let e = 1;
  return () => (e = (eX * e + tX) % hC) / hC;
}
function iX(e) {
  return e.x;
}
function rX(e) {
  return e.y;
}
var sX = 10, oX = Math.PI * (3 - Math.sqrt(5));
function aX(e) {
  var t, n = 1, i = 1e-3, r = 1 - Math.pow(i, 1 / 300), s = 0, o = 0.6, a = /* @__PURE__ */ new Map(), l = cR(f), u = aR("tick", "end"), c = nX();
  e == null && (e = []);
  function f() {
    d(), u.call("tick", t), n < i && (l.stop(), u.call("end", t));
  }
  function d(p) {
    var m, y = e.length, b;
    p === void 0 && (p = 1);
    for (var v = 0; v < p; ++v)
      for (n += (s - n) * r, a.forEach(function(w) {
        w(n);
      }), m = 0; m < y; ++m)
        b = e[m], b.fx == null ? b.x += b.vx *= o : (b.x = b.fx, b.vx = 0), b.fy == null ? b.y += b.vy *= o : (b.y = b.fy, b.vy = 0);
    return t;
  }
  function h() {
    for (var p = 0, m = e.length, y; p < m; ++p) {
      if (y = e[p], y.index = p, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
        var b = sX * Math.sqrt(0.5 + p), v = p * oX;
        y.x = b * Math.cos(v), y.y = b * Math.sin(v);
      }
      (isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0);
    }
  }
  function g(p) {
    return p.initialize && p.initialize(e, c), p;
  }
  return h(), t = {
    tick: d,
    restart: function() {
      return l.restart(f), t;
    },
    stop: function() {
      return l.stop(), t;
    },
    nodes: function(p) {
      return arguments.length ? (e = p, h(), a.forEach(g), t) : e;
    },
    alpha: function(p) {
      return arguments.length ? (n = +p, t) : n;
    },
    alphaMin: function(p) {
      return arguments.length ? (i = +p, t) : i;
    },
    alphaDecay: function(p) {
      return arguments.length ? (r = +p, t) : +r;
    },
    alphaTarget: function(p) {
      return arguments.length ? (s = +p, t) : s;
    },
    velocityDecay: function(p) {
      return arguments.length ? (o = 1 - p, t) : 1 - o;
    },
    randomSource: function(p) {
      return arguments.length ? (c = p, a.forEach(g), t) : c;
    },
    force: function(p, m) {
      return arguments.length > 1 ? (m == null ? a.delete(p) : a.set(p, g(m)), t) : a.get(p);
    },
    find: function(p, m, y) {
      var b = 0, v = e.length, w, _, S, E, C;
      for (y == null ? y = 1 / 0 : y *= y, b = 0; b < v; ++b)
        E = e[b], w = p - E.x, _ = m - E.y, S = w * w + _ * _, S < y && (C = E, y = S);
      return C;
    },
    on: function(p, m) {
      return arguments.length > 1 ? (u.on(p, m), t) : u.on(p);
    }
  };
}
function lX() {
  var e, t, n, i, r = yn(-30), s, o = 1, a = 1 / 0, l = 0.81;
  function u(h) {
    var g, p = e.length, m = jw(e, iX, rX).visitAfter(f);
    for (i = h, g = 0; g < p; ++g)
      t = e[g], m.visit(d);
  }
  function c() {
    if (e) {
      var h, g = e.length, p;
      for (s = new Array(g), h = 0; h < g; ++h)
        p = e[h], s[p.index] = +r(p, h, e);
    }
  }
  function f(h) {
    var g = 0, p, m, y = 0, b, v, w;
    if (h.length) {
      for (b = v = w = 0; w < 4; ++w)
        (p = h[w]) && (m = Math.abs(p.value)) && (g += p.value, y += m, b += m * p.x, v += m * p.y);
      h.x = b / y, h.y = v / y;
    } else {
      p = h, p.x = p.data.x, p.y = p.data.y;
      do
        g += s[p.data.index];
      while (p = p.next);
    }
    h.value = g;
  }
  function d(h, g, p, m) {
    if (!h.value)
      return !0;
    var y = h.x - t.x, b = h.y - t.y, v = m - g, w = y * y + b * b;
    if (v * v / l < w)
      return w < a && (y === 0 && (y = no(n), w += y * y), b === 0 && (b = no(n), w += b * b), w < o && (w = Math.sqrt(o * w)), t.vx += y * h.value * i / w, t.vy += b * h.value * i / w), !0;
    if (h.length || w >= a)
      return;
    (h.data !== t || h.next) && (y === 0 && (y = no(n), w += y * y), b === 0 && (b = no(n), w += b * b), w < o && (w = Math.sqrt(o * w)));
    do
      h.data !== t && (v = s[h.data.index] * i / w, t.vx += y * v, t.vy += b * v);
    while (h = h.next);
  }
  return u.initialize = function(h, g) {
    e = h, n = g, c();
  }, u.strength = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : yn(+h), c(), u) : r;
  }, u.distanceMin = function(h) {
    return arguments.length ? (o = h * h, u) : Math.sqrt(o);
  }, u.distanceMax = function(h) {
    return arguments.length ? (a = h * h, u) : Math.sqrt(a);
  }, u.theta = function(h) {
    return arguments.length ? (l = h * h, u) : Math.sqrt(l);
  }, u;
}
function uX(e) {
  var t = yn(0.1), n, i, r;
  typeof e != "function" && (e = yn(e == null ? 0 : +e));
  function s(a) {
    for (var l = 0, u = n.length, c; l < u; ++l)
      c = n[l], c.vx += (r[l] - c.x) * i[l] * a;
  }
  function o() {
    if (n) {
      var a, l = n.length;
      for (i = new Array(l), r = new Array(l), a = 0; a < l; ++a)
        i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
    }
  }
  return s.initialize = function(a) {
    n = a, o();
  }, s.strength = function(a) {
    return arguments.length ? (t = typeof a == "function" ? a : yn(+a), o(), s) : t;
  }, s.x = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : yn(+a), o(), s) : e;
  }, s;
}
function cX(e) {
  var t = yn(0.1), n, i, r;
  typeof e != "function" && (e = yn(e == null ? 0 : +e));
  function s(a) {
    for (var l = 0, u = n.length, c; l < u; ++l)
      c = n[l], c.vy += (r[l] - c.y) * i[l] * a;
  }
  function o() {
    if (n) {
      var a, l = n.length;
      for (i = new Array(l), r = new Array(l), a = 0; a < l; ++a)
        i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
    }
  }
  return s.initialize = function(a) {
    n = a, o();
  }, s.strength = function(a) {
    return arguments.length ? (t = typeof a == "function" ? a : yn(+a), o(), s) : t;
  }, s.y = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : yn(+a), o(), s) : e;
  }, s;
}
const gC = {
  center: SY,
  collide: qY,
  nbody: lX,
  link: HY,
  x: uX,
  y: cX
}, Vc = "forces", Bb = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], fX = ["static", "iterations"], fR = ["x", "y", "vx", "vy"];
function Ww(e) {
  P.call(this, null, e);
}
Ww.Definition = {
  type: "Force",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "static",
    type: "boolean",
    default: !1
  }, {
    name: "restart",
    type: "boolean",
    default: !1
  }, {
    name: "iterations",
    type: "number",
    default: 300
  }, {
    name: "alpha",
    type: "number",
    default: 1
  }, {
    name: "alphaMin",
    type: "number",
    default: 1e-3
  }, {
    name: "alphaTarget",
    type: "number",
    default: 0
  }, {
    name: "velocityDecay",
    type: "number",
    default: 0.4
  }, {
    name: "forces",
    type: "param",
    array: !0,
    params: [{
      key: {
        force: "center"
      },
      params: [{
        name: "x",
        type: "number",
        default: 0
      }, {
        name: "y",
        type: "number",
        default: 0
      }]
    }, {
      key: {
        force: "collide"
      },
      params: [{
        name: "radius",
        type: "number",
        expr: !0
      }, {
        name: "strength",
        type: "number",
        default: 0.7
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "nbody"
      },
      params: [{
        name: "strength",
        type: "number",
        default: -30,
        expr: !0
      }, {
        name: "theta",
        type: "number",
        default: 0.9
      }, {
        name: "distanceMin",
        type: "number",
        default: 1
      }, {
        name: "distanceMax",
        type: "number"
      }]
    }, {
      key: {
        force: "link"
      },
      params: [{
        name: "links",
        type: "data"
      }, {
        name: "id",
        type: "field"
      }, {
        name: "distance",
        type: "number",
        default: 30,
        expr: !0
      }, {
        name: "strength",
        type: "number",
        expr: !0
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "x"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "x",
        type: "field"
      }]
    }, {
      key: {
        force: "y"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "y",
        type: "field"
      }]
    }]
  }, {
    name: "as",
    type: "string",
    array: !0,
    modify: !1,
    default: fR
  }]
};
Y(Ww, P, {
  transform(e, t) {
    var n = this.value, i = t.changed(t.ADD_REM), r = e.modified(Bb), s = e.iterations || 300;
    if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && dR(n, e, 0, t)) : (this.value = n = hX(t.source, e), n.on("tick", dX(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(fX) || t.changed() && e.restart) {
      if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / s)), e.static)
        for (n.stop(); --s >= 0; )
          n.tick();
      else if (n.stopped() && n.restart(), !i)
        return t.StopPropagation;
    }
    return this.finish(e, t);
  },
  finish(e, t) {
    const n = t.dataflow;
    for (let a = this._argops, l = 0, u = a.length, c; l < u; ++l)
      if (c = a[l], !(c.name !== Vc || c.op._argval.force !== "link")) {
        for (var i = c.op._argops, r = 0, s = i.length, o; r < s; ++r)
          if (i[r].name === "links" && (o = i[r].op.source)) {
            n.pulse(o, n.changeset().reflow());
            break;
          }
      }
    return t.reflow(e.modified()).modifies(fR);
  }
});
function dX(e, t) {
  return () => e.touch(t).run();
}
function hX(e, t) {
  const n = aX(e), i = n.stop, r = n.restart;
  let s = !1;
  return n.stopped = () => s, n.restart = () => (s = !1, r()), n.stop = () => (s = !0, i()), dR(n, t, !0).on("end", () => s = !0);
}
function dR(e, t, n, i) {
  var r = J(t.forces), s, o, a, l;
  for (s = 0, o = Bb.length; s < o; ++s)
    a = Bb[s], a !== Vc && t.modified(a) && e[a](t[a]);
  for (s = 0, o = r.length; s < o; ++s)
    l = Vc + s, a = n || t.modified(Vc, s) ? pX(r[s]) : i && gX(r[s], i) ? e.force(l) : null, a && e.force(l, a);
  for (o = e.numForces || 0; s < o; ++s)
    e.force(Vc + s, null);
  return e.numForces = r.length, e;
}
function gX(e, t) {
  var n, i;
  for (n in e)
    if (Ee(i = e[n]) && t.modified(tn(i)))
      return 1;
  return 0;
}
function pX(e) {
  var t, n;
  ce(gC, e.force) || B("Unrecognized force: " + e.force), t = gC[e.force]();
  for (n in e)
    Ee(t[n]) && mX(t[n], e[n], e);
  return t;
}
function mX(e, t, n) {
  e(Ee(t) ? (i) => t(i, n) : t);
}
const yX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  force: Ww
}, Symbol.toStringTag, { value: "Module" }));
function bX(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function vX(e) {
  return e.reduce(xX, 0) / e.length;
}
function xX(e, t) {
  return e + t.x;
}
function wX(e) {
  return 1 + e.reduce(_X, 0);
}
function _X(e, t) {
  return Math.max(e, t.y);
}
function EX(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function SX(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function kX() {
  var e = bX, t = 1, n = 1, i = !1;
  function r(s) {
    var o, a = 0;
    s.eachAfter(function(d) {
      var h = d.children;
      h ? (d.x = vX(h), d.y = wX(h)) : (d.x = o ? a += e(d, o) : 0, d.y = 0, o = d);
    });
    var l = EX(s), u = SX(s), c = l.x - e(l, u) / 2, f = u.x + e(u, l) / 2;
    return s.eachAfter(i ? function(d) {
      d.x = (d.x - s.x) * t, d.y = (s.y - d.y) * n;
    } : function(d) {
      d.x = (d.x - c) / (f - c) * t, d.y = (1 - (s.y ? d.y / s.y : 1)) * n;
    });
  }
  return r.separation = function(s) {
    return arguments.length ? (e = s, r) : e;
  }, r.size = function(s) {
    return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(s) {
    return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null;
  }, r;
}
function AX(e) {
  var t = 0, n = e.children, i = n && n.length;
  if (!i)
    t = 1;
  else
    for (; --i >= 0; )
      t += n[i].value;
  e.value = t;
}
function CX() {
  return this.eachAfter(AX);
}
function $X(e, t) {
  let n = -1;
  for (const i of this)
    e.call(t, i, ++n, this);
  return this;
}
function MX(e, t) {
  for (var n = this, i = [n], r, s, o = -1; n = i.pop(); )
    if (e.call(t, n, ++o, this), r = n.children)
      for (s = r.length - 1; s >= 0; --s)
        i.push(r[s]);
  return this;
}
function FX(e, t) {
  for (var n = this, i = [n], r = [], s, o, a, l = -1; n = i.pop(); )
    if (r.push(n), s = n.children)
      for (o = 0, a = s.length; o < a; ++o)
        i.push(s[o]);
  for (; n = r.pop(); )
    e.call(t, n, ++l, this);
  return this;
}
function TX(e, t) {
  let n = -1;
  for (const i of this)
    if (e.call(t, i, ++n, this))
      return i;
}
function OX(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0; )
      n += i[r].value;
    t.value = n;
  });
}
function NX(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function DX(e) {
  for (var t = this, n = RX(t, e), i = [t]; t !== n; )
    t = t.parent, i.push(t);
  for (var r = i.length; e !== n; )
    i.splice(r, 0, e), e = e.parent;
  return i;
}
function RX(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), i = t.ancestors(), r = null;
  for (e = n.pop(), t = i.pop(); e === t; )
    r = e, e = n.pop(), t = i.pop();
  return r;
}
function LX() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function PX() {
  return Array.from(this);
}
function IX() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function zX() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* BX() {
  var e = this, t, n = [e], i, r, s;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, i = e.children)
        for (r = 0, s = i.length; r < s; ++r)
          n.push(i[r]);
  while (n.length);
}
function Hw(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = qX)) : t === void 0 && (t = UX);
  for (var n = new yu(e), i, r = [n], s, o, a, l; i = r.pop(); )
    if ((o = t(i.data)) && (l = (o = Array.from(o)).length))
      for (i.children = o, a = l - 1; a >= 0; --a)
        r.push(s = o[a] = new yu(o[a])), s.parent = i, s.depth = i.depth + 1;
  return n.eachBefore(hR);
}
function jX() {
  return Hw(this).eachBefore(WX);
}
function UX(e) {
  return e.children;
}
function qX(e) {
  return Array.isArray(e) ? e[1] : null;
}
function WX(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function hR(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function yu(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
yu.prototype = Hw.prototype = {
  constructor: yu,
  count: CX,
  each: $X,
  eachAfter: FX,
  eachBefore: MX,
  find: TX,
  sum: OX,
  sort: NX,
  path: DX,
  ancestors: LX,
  descendants: PX,
  leaves: IX,
  links: zX,
  copy: jX,
  [Symbol.iterator]: BX
};
function Wh(e) {
  return e == null ? null : gR(e);
}
function gR(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function ca() {
  return 0;
}
function Tl(e) {
  return function() {
    return e;
  };
}
const HX = 1664525, GX = 1013904223, pC = 4294967296;
function VX() {
  let e = 1;
  return () => (e = (HX * e + GX) % pC) / pC;
}
function YX(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function XX(e, t) {
  let n = e.length, i, r;
  for (; n; )
    r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
  return e;
}
function KX(e, t) {
  for (var n = 0, i = (e = XX(Array.from(e), t)).length, r = [], s, o; n < i; )
    s = e[n], o && pR(o, s) ? ++n : (o = QX(r = JX(r, s)), n = 0);
  return o;
}
function JX(e, t) {
  var n, i;
  if ($1(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (uh(t, e[n]) && $1(Yc(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (i = n + 1; i < e.length; ++i)
      if (uh(Yc(e[n], e[i]), t) && uh(Yc(e[n], t), e[i]) && uh(Yc(e[i], t), e[n]) && $1(mR(e[n], e[i], t), e))
        return [e[n], e[i], t];
  throw new Error();
}
function uh(e, t) {
  var n = e.r - t.r, i = t.x - e.x, r = t.y - e.y;
  return n < 0 || n * n < i * i + r * r;
}
function pR(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function $1(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!pR(e, t[n]))
      return !1;
  return !0;
}
function QX(e) {
  switch (e.length) {
    case 1:
      return ZX(e[0]);
    case 2:
      return Yc(e[0], e[1]);
    case 3:
      return mR(e[0], e[1], e[2]);
  }
}
function ZX(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function Yc(e, t) {
  var n = e.x, i = e.y, r = e.r, s = t.x, o = t.y, a = t.r, l = s - n, u = o - i, c = a - r, f = Math.sqrt(l * l + u * u);
  return {
    x: (n + s + l / f * c) / 2,
    y: (i + o + u / f * c) / 2,
    r: (f + r + a) / 2
  };
}
function mR(e, t, n) {
  var i = e.x, r = e.y, s = e.r, o = t.x, a = t.y, l = t.r, u = n.x, c = n.y, f = n.r, d = i - o, h = i - u, g = r - a, p = r - c, m = l - s, y = f - s, b = i * i + r * r - s * s, v = b - o * o - a * a + l * l, w = b - u * u - c * c + f * f, _ = h * g - d * p, S = (g * w - p * v) / (_ * 2) - i, E = (p * m - g * y) / _, C = (h * v - d * w) / (_ * 2) - r, $ = (d * y - h * m) / _, N = E * E + $ * $ - 1, T = 2 * (s + S * E + C * $), L = S * S + C * C - s * s, O = -(Math.abs(N) > 1e-6 ? (T + Math.sqrt(T * T - 4 * N * L)) / (2 * N) : L / T);
  return {
    x: i + S + E * O,
    y: r + C + $ * O,
    r: O
  };
}
function mC(e, t, n) {
  var i = e.x - t.x, r, s, o = e.y - t.y, a, l, u = i * i + o * o;
  u ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (r = (u + l - s) / (2 * u), a = Math.sqrt(Math.max(0, l / u - r * r)), n.x = e.x - r * i - a * o, n.y = e.y - r * o + a * i) : (r = (u + s - l) / (2 * u), a = Math.sqrt(Math.max(0, s / u - r * r)), n.x = t.x + r * i - a * o, n.y = t.y + r * o + a * i)) : (n.x = t.x + n.r, n.y = t.y);
}
function yC(e, t) {
  var n = e.r + t.r - 1e-6, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function bC(e) {
  var t = e._, n = e.next._, i = t.r + n.r, r = (t.x * n.r + n.x * t.r) / i, s = (t.y * n.r + n.y * t.r) / i;
  return r * r + s * s;
}
function ch(e) {
  this._ = e, this.next = null, this.previous = null;
}
function eK(e, t) {
  if (!(s = (e = YX(e)).length))
    return 0;
  var n, i, r, s, o, a, l, u, c, f, d;
  if (n = e[0], n.x = 0, n.y = 0, !(s > 1))
    return n.r;
  if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(s > 2))
    return n.r + i.r;
  mC(i, n, r = e[2]), n = new ch(n), i = new ch(i), r = new ch(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
  e:
    for (l = 3; l < s; ++l) {
      mC(n._, i._, r = e[l]), r = new ch(r), u = i.next, c = n.previous, f = i._.r, d = n._.r;
      do
        if (f <= d) {
          if (yC(u._, r._)) {
            i = u, n.next = i, i.previous = n, --l;
            continue e;
          }
          f += u._.r, u = u.next;
        } else {
          if (yC(c._, r._)) {
            n = c, n.next = i, i.previous = n, --l;
            continue e;
          }
          d += c._.r, c = c.previous;
        }
      while (u !== c.next);
      for (r.previous = n, r.next = i, n.next = i.previous = i = r, o = bC(n); (r = r.next) !== i; )
        (a = bC(r)) < o && (n = r, o = a);
      i = n.next;
    }
  for (n = [i._], r = i; (r = r.next) !== i; )
    n.push(r._);
  for (r = KX(n, t), l = 0; l < s; ++l)
    n = e[l], n.x -= r.x, n.y -= r.y;
  return r.r;
}
function tK(e) {
  return Math.sqrt(e.value);
}
function nK() {
  var e = null, t = 1, n = 1, i = ca;
  function r(s) {
    const o = VX();
    return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(vC(e)).eachAfter(M1(i, 0.5, o)).eachBefore(xC(1)) : s.eachBefore(vC(tK)).eachAfter(M1(ca, 1, o)).eachAfter(M1(i, s.r / Math.min(t, n), o)).eachBefore(xC(Math.min(t, n) / (2 * s.r))), s;
  }
  return r.radius = function(s) {
    return arguments.length ? (e = Wh(s), r) : e;
  }, r.size = function(s) {
    return arguments.length ? (t = +s[0], n = +s[1], r) : [t, n];
  }, r.padding = function(s) {
    return arguments.length ? (i = typeof s == "function" ? s : Tl(+s), r) : i;
  }, r;
}
function vC(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function M1(e, t, n) {
  return function(i) {
    if (r = i.children) {
      var r, s, o = r.length, a = e(i) * t || 0, l;
      if (a)
        for (s = 0; s < o; ++s)
          r[s].r += a;
      if (l = eK(r, n), a)
        for (s = 0; s < o; ++s)
          r[s].r -= a;
      i.r = l + a;
    }
  };
}
function xC(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function yR(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function xd(e, t, n, i, r) {
  for (var s = e.children, o, a = -1, l = s.length, u = e.value && (i - t) / e.value; ++a < l; )
    o = s[a], o.y0 = n, o.y1 = r, o.x0 = t, o.x1 = t += o.value * u;
}
function iK() {
  var e = 1, t = 1, n = 0, i = !1;
  function r(o) {
    var a = o.height + 1;
    return o.x0 = o.y0 = n, o.x1 = e, o.y1 = t / a, o.eachBefore(s(t, a)), i && o.eachBefore(yR), o;
  }
  function s(o, a) {
    return function(l) {
      l.children && xd(l, l.x0, o * (l.depth + 1) / a, l.x1, o * (l.depth + 2) / a);
      var u = l.x0, c = l.y0, f = l.x1 - n, d = l.y1 - n;
      f < u && (u = f = (u + f) / 2), d < c && (c = d = (c + d) / 2), l.x0 = u, l.y0 = c, l.x1 = f, l.y1 = d;
    };
  }
  return r.round = function(o) {
    return arguments.length ? (i = !!o, r) : i;
  }, r.size = function(o) {
    return arguments.length ? (e = +o[0], t = +o[1], r) : [e, t];
  }, r.padding = function(o) {
    return arguments.length ? (n = +o, r) : n;
  }, r;
}
var rK = { depth: -1 }, wC = {}, F1 = {};
function sK(e) {
  return e.id;
}
function oK(e) {
  return e.parentId;
}
function _C() {
  var e = sK, t = oK, n;
  function i(r) {
    var s = Array.from(r), o = e, a = t, l, u, c, f, d, h, g, p, m = /* @__PURE__ */ new Map();
    if (n != null) {
      const y = s.map((w, _) => aK(n(w, _, r))), b = y.map(EC), v = new Set(y).add("");
      for (const w of b)
        v.has(w) || (v.add(w), y.push(w), b.push(EC(w)), s.push(F1));
      o = (w, _) => y[_], a = (w, _) => b[_];
    }
    for (c = 0, l = s.length; c < l; ++c)
      u = s[c], h = s[c] = new yu(u), (g = o(u, c, r)) != null && (g += "") && (p = h.id = g, m.set(p, m.has(p) ? wC : h)), (g = a(u, c, r)) != null && (g += "") && (h.parent = g);
    for (c = 0; c < l; ++c)
      if (h = s[c], g = h.parent) {
        if (d = m.get(g), !d)
          throw new Error("missing: " + g);
        if (d === wC)
          throw new Error("ambiguous: " + g);
        d.children ? d.children.push(h) : d.children = [h], h.parent = d;
      } else {
        if (f)
          throw new Error("multiple roots");
        f = h;
      }
    if (!f)
      throw new Error("no root");
    if (n != null) {
      for (; f.data === F1 && f.children.length === 1; )
        f = f.children[0], --l;
      for (let y = s.length - 1; y >= 0 && (h = s[y], h.data === F1); --y)
        h.data = null;
    }
    if (f.parent = rK, f.eachBefore(function(y) {
      y.depth = y.parent.depth + 1, --l;
    }).eachBefore(hR), f.parent = null, l > 0)
      throw new Error("cycle");
    return f;
  }
  return i.id = function(r) {
    return arguments.length ? (e = Wh(r), i) : e;
  }, i.parentId = function(r) {
    return arguments.length ? (t = Wh(r), i) : t;
  }, i.path = function(r) {
    return arguments.length ? (n = Wh(r), i) : n;
  }, i;
}
function aK(e) {
  e = `${e}`;
  let t = e.length;
  return jb(e, t - 1) && !jb(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
}
function EC(e) {
  let t = e.length;
  if (t < 2)
    return "";
  for (; --t > 1 && !jb(e, t); )
    ;
  return e.slice(0, t);
}
function jb(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
function lK(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function T1(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function O1(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function uK(e, t, n) {
  var i = n / (t.i - e.i);
  t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
}
function cK(e) {
  for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0; )
    s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c);
}
function fK(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function Hh(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
Hh.prototype = Object.create(yu.prototype);
function dK(e) {
  for (var t = new Hh(e, 0), n, i = [t], r, s, o, a; n = i.pop(); )
    if (s = n._.children)
      for (n.children = new Array(a = s.length), o = a - 1; o >= 0; --o)
        i.push(r = n.children[o] = new Hh(s[o], o)), r.parent = n;
  return (t.parent = new Hh(null, 0)).children = [t], t;
}
function hK() {
  var e = lK, t = 1, n = 1, i = null;
  function r(u) {
    var c = dK(u);
    if (c.eachAfter(s), c.parent.m = -c.z, c.eachBefore(o), i)
      u.eachBefore(l);
    else {
      var f = u, d = u, h = u;
      u.eachBefore(function(b) {
        b.x < f.x && (f = b), b.x > d.x && (d = b), b.depth > h.depth && (h = b);
      });
      var g = f === d ? 1 : e(f, d) / 2, p = g - f.x, m = t / (d.x + g + p), y = n / (h.depth || 1);
      u.eachBefore(function(b) {
        b.x = (b.x + p) * m, b.y = b.depth * y;
      });
    }
    return u;
  }
  function s(u) {
    var c = u.children, f = u.parent.children, d = u.i ? f[u.i - 1] : null;
    if (c) {
      cK(u);
      var h = (c[0].z + c[c.length - 1].z) / 2;
      d ? (u.z = d.z + e(u._, d._), u.m = u.z - h) : u.z = h;
    } else
      d && (u.z = d.z + e(u._, d._));
    u.parent.A = a(u, d, u.parent.A || f[0]);
  }
  function o(u) {
    u._.x = u.z + u.parent.m, u.m += u.parent.m;
  }
  function a(u, c, f) {
    if (c) {
      for (var d = u, h = u, g = c, p = d.parent.children[0], m = d.m, y = h.m, b = g.m, v = p.m, w; g = O1(g), d = T1(d), g && d; )
        p = T1(p), h = O1(h), h.a = u, w = g.z + b - d.z - m + e(g._, d._), w > 0 && (uK(fK(g, u, f), u, w), m += w, y += w), b += g.m, m += d.m, v += p.m, y += h.m;
      g && !O1(h) && (h.t = g, h.m += b - y), d && !T1(p) && (p.t = d, p.m += m - v, f = u);
    }
    return f;
  }
  function l(u) {
    u.x *= t, u.y = u.depth * n;
  }
  return r.separation = function(u) {
    return arguments.length ? (e = u, r) : e;
  }, r.size = function(u) {
    return arguments.length ? (i = !1, t = +u[0], n = +u[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(u) {
    return arguments.length ? (i = !0, t = +u[0], n = +u[1], r) : i ? [t, n] : null;
  }, r;
}
function zm(e, t, n, i, r) {
  for (var s = e.children, o, a = -1, l = s.length, u = e.value && (r - n) / e.value; ++a < l; )
    o = s[a], o.x0 = t, o.x1 = i, o.y0 = n, o.y1 = n += o.value * u;
}
var bR = (1 + Math.sqrt(5)) / 2;
function vR(e, t, n, i, r, s) {
  for (var o = [], a = t.children, l, u, c = 0, f = 0, d = a.length, h, g, p = t.value, m, y, b, v, w, _, S; c < d; ) {
    h = r - n, g = s - i;
    do
      m = a[f++].value;
    while (!m && f < d);
    for (y = b = m, _ = Math.max(g / h, h / g) / (p * e), S = m * m * _, w = Math.max(b / S, S / y); f < d; ++f) {
      if (m += u = a[f].value, u < y && (y = u), u > b && (b = u), S = m * m * _, v = Math.max(b / S, S / y), v > w) {
        m -= u;
        break;
      }
      w = v;
    }
    o.push(l = { value: m, dice: h < g, children: a.slice(c, f) }), l.dice ? xd(l, n, i, r, p ? i += g * m / p : s) : zm(l, n, i, p ? n += h * m / p : r, s), p -= m, c = f;
  }
  return o;
}
const xR = function e(t) {
  function n(i, r, s, o, a) {
    vR(t, i, r, s, o, a);
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(bR);
function gK() {
  var e = xR, t = !1, n = 1, i = 1, r = [0], s = ca, o = ca, a = ca, l = ca, u = ca;
  function c(d) {
    return d.x0 = d.y0 = 0, d.x1 = n, d.y1 = i, d.eachBefore(f), r = [0], t && d.eachBefore(yR), d;
  }
  function f(d) {
    var h = r[d.depth], g = d.x0 + h, p = d.y0 + h, m = d.x1 - h, y = d.y1 - h;
    m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), d.x0 = g, d.y0 = p, d.x1 = m, d.y1 = y, d.children && (h = r[d.depth + 1] = s(d) / 2, g += u(d) - h, p += o(d) - h, m -= a(d) - h, y -= l(d) - h, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(d, g, p, m, y));
  }
  return c.round = function(d) {
    return arguments.length ? (t = !!d, c) : t;
  }, c.size = function(d) {
    return arguments.length ? (n = +d[0], i = +d[1], c) : [n, i];
  }, c.tile = function(d) {
    return arguments.length ? (e = gR(d), c) : e;
  }, c.padding = function(d) {
    return arguments.length ? c.paddingInner(d).paddingOuter(d) : c.paddingInner();
  }, c.paddingInner = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : Tl(+d), c) : s;
  }, c.paddingOuter = function(d) {
    return arguments.length ? c.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : c.paddingTop();
  }, c.paddingTop = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : Tl(+d), c) : o;
  }, c.paddingRight = function(d) {
    return arguments.length ? (a = typeof d == "function" ? d : Tl(+d), c) : a;
  }, c.paddingBottom = function(d) {
    return arguments.length ? (l = typeof d == "function" ? d : Tl(+d), c) : l;
  }, c.paddingLeft = function(d) {
    return arguments.length ? (u = typeof d == "function" ? d : Tl(+d), c) : u;
  }, c;
}
function pK(e, t, n, i, r) {
  var s = e.children, o, a = s.length, l, u = new Array(a + 1);
  for (u[0] = l = o = 0; o < a; ++o)
    u[o + 1] = l += s[o].value;
  c(0, a, e.value, t, n, i, r);
  function c(f, d, h, g, p, m, y) {
    if (f >= d - 1) {
      var b = s[f];
      b.x0 = g, b.y0 = p, b.x1 = m, b.y1 = y;
      return;
    }
    for (var v = u[f], w = h / 2 + v, _ = f + 1, S = d - 1; _ < S; ) {
      var E = _ + S >>> 1;
      u[E] < w ? _ = E + 1 : S = E;
    }
    w - u[_ - 1] < u[_] - w && f + 1 < _ && --_;
    var C = u[_] - v, $ = h - C;
    if (m - g > y - p) {
      var N = h ? (g * $ + m * C) / h : m;
      c(f, _, C, g, p, N, y), c(_, d, $, N, p, m, y);
    } else {
      var T = h ? (p * $ + y * C) / h : y;
      c(f, _, C, g, p, m, T), c(_, d, $, g, T, m, y);
    }
  }
}
function mK(e, t, n, i, r) {
  (e.depth & 1 ? zm : xd)(e, t, n, i, r);
}
const yK = function e(t) {
  function n(i, r, s, o, a) {
    if ((l = i._squarify) && l.ratio === t)
      for (var l, u, c, f, d = -1, h, g = l.length, p = i.value; ++d < g; ) {
        for (u = l[d], c = u.children, f = u.value = 0, h = c.length; f < h; ++f)
          u.value += c[f].value;
        u.dice ? xd(u, r, s, o, p ? s += (a - s) * u.value / p : a) : zm(u, r, s, p ? r += (o - r) * u.value / p : o, a), p -= u.value;
      }
    else
      i._squarify = l = vR(t, i, r, s, o, a), l.ratio = t;
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(bR);
function Ub(e, t, n) {
  const i = {};
  return e.each((r) => {
    const s = r.data;
    n(s) && (i[t(s)] = r);
  }), e.lookup = i, e;
}
function Gw(e) {
  P.call(this, null, e);
}
Gw.Definition = {
  type: "Nest",
  metadata: {
    treesource: !0,
    changes: !0
  },
  params: [{
    name: "keys",
    type: "field",
    array: !0
  }, {
    name: "generate",
    type: "boolean"
  }]
};
const bK = (e) => e.values;
Y(Gw, P, {
  transform(e, t) {
    t.source || B("Nest transform requires an upstream data source.");
    var n = e.generate, i = e.modified(), r = t.clone(), s = this.value;
    return (!s || i || t.changed()) && (s && s.each((o) => {
      o.children && Qp(o.data) && r.rem.push(o.data);
    }), this.value = s = Hw({
      values: J(e.keys).reduce((o, a) => (o.key(a), o), vK()).entries(r.source)
    }, bK), n && s.each((o) => {
      o.children && (o = Be(o.data), r.add.push(o), r.source.push(o));
    }), Ub(s, le, le)), r.source.root = s, r;
  }
});
function vK() {
  const e = [], t = {
    entries: (r) => i(n(r, 0), 0),
    key: (r) => (e.push(r), t)
  };
  function n(r, s) {
    if (s >= e.length)
      return r;
    const o = r.length, a = e[s++], l = {}, u = {};
    let c = -1, f, d, h;
    for (; ++c < o; )
      f = a(d = r[c]) + "", (h = l[f]) ? h.push(d) : l[f] = [d];
    for (f in l)
      u[f] = n(l[f], s);
    return u;
  }
  function i(r, s) {
    if (++s > e.length)
      return r;
    const o = [];
    for (const a in r)
      o.push({
        key: a,
        values: i(r[a], s)
      });
    return o;
  }
  return t;
}
function Ts(e) {
  P.call(this, null, e);
}
const xK = (e, t) => e.parent === t.parent ? 1 : 2;
Y(Ts, P, {
  transform(e, t) {
    (!t.source || !t.source.root) && B(this.constructor.name + " transform requires a backing tree data source.");
    const n = this.layout(e.method), i = this.fields, r = t.source.root, s = e.as || i;
    e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(el(e.sort, (o) => o.data)), wK(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? xK : Nu);
    try {
      this.value = n(r);
    } catch (o) {
      B(o);
    }
    return r.each((o) => _K(o, i, s)), t.reflow(e.modified()).modifies(s).modifies("leaf");
  }
});
function wK(e, t, n) {
  for (let i, r = 0, s = t.length; r < s; ++r)
    i = t[r], i in n && e[i](n[i]);
}
function _K(e, t, n) {
  const i = e.data, r = t.length - 1;
  for (let s = 0; s < r; ++s)
    i[n[s]] = e[t[s]];
  i[n[r]] = e.children ? e.children.length : 0;
}
const qb = ["x", "y", "r", "depth", "children"];
function Vw(e) {
  Ts.call(this, e);
}
Vw.Definition = {
  type: "Pack",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "radius",
    type: "field",
    default: null
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: qb.length,
    default: qb
  }]
};
Y(Vw, Ts, {
  layout: nK,
  params: ["radius", "size", "padding"],
  fields: qb
});
const Wb = ["x0", "y0", "x1", "y1", "depth", "children"];
function Yw(e) {
  Ts.call(this, e);
}
Yw.Definition = {
  type: "Partition",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Wb.length,
    default: Wb
  }]
};
Y(Yw, Ts, {
  layout: iK,
  params: ["size", "round", "padding"],
  fields: Wb
});
function Xw(e) {
  P.call(this, null, e);
}
Xw.Definition = {
  type: "Stratify",
  metadata: {
    treesource: !0
  },
  params: [{
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "parentKey",
    type: "field",
    required: !0
  }]
};
Y(Xw, P, {
  transform(e, t) {
    t.source || B("Stratify transform requires an upstream data source.");
    let n = this.value;
    const i = e.modified(), r = t.fork(t.ALL).materialize(t.SOURCE), s = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
    return r.source = r.source.slice(), s && (n = r.source.length ? Ub(_C().id(e.key).parentId(e.parentKey)(r.source), e.key, Ei) : Ub(_C()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
  }
});
const SC = {
  tidy: hK,
  cluster: kX
}, Hb = ["x", "y", "depth", "children"];
function Kw(e) {
  Ts.call(this, e);
}
Kw.Definition = {
  type: "Tree",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "tidy",
    values: ["tidy", "cluster"]
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "nodeSize",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "separation",
    type: "boolean",
    default: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Hb.length,
    default: Hb
  }]
};
Y(Kw, Ts, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(e) {
    const t = e || "tidy";
    if (ce(SC, t))
      return SC[t]();
    B("Unrecognized Tree layout method: " + t);
  },
  params: ["size", "nodeSize"],
  fields: Hb
});
function Jw(e) {
  P.call(this, [], e);
}
Jw.Definition = {
  type: "TreeLinks",
  metadata: {
    tree: !0,
    generates: !0,
    changes: !0
  },
  params: []
};
Y(Jw, P, {
  transform(e, t) {
    const n = this.value, i = t.source && t.source.root, r = t.fork(t.NO_SOURCE), s = {};
    return i || B("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (o) => s[le(o)] = 1), i.each((o) => {
      const a = o.data, l = o.parent && o.parent.data;
      l && s[le(a)] && s[le(l)] && r.add.push(Be({
        source: l,
        target: a
      }));
    }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (o) => s[le(o)] = 1), n.forEach((o) => {
      (s[le(o.source)] || s[le(o.target)]) && r.mod.push(o);
    })), r;
  }
});
const kC = {
  binary: pK,
  dice: xd,
  slice: zm,
  slicedice: mK,
  squarify: xR,
  resquarify: yK
}, Gb = ["x0", "y0", "x1", "y1", "depth", "children"];
function Qw(e) {
  Ts.call(this, e);
}
Qw.Definition = {
  type: "Treemap",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "squarify",
    values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "paddingInner",
    type: "number",
    default: 0
  }, {
    name: "paddingOuter",
    type: "number",
    default: 0
  }, {
    name: "paddingTop",
    type: "number",
    default: 0
  }, {
    name: "paddingRight",
    type: "number",
    default: 0
  }, {
    name: "paddingBottom",
    type: "number",
    default: 0
  }, {
    name: "paddingLeft",
    type: "number",
    default: 0
  }, {
    name: "ratio",
    type: "number",
    default: 1.618033988749895
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Gb.length,
    default: Gb
  }]
};
Y(Qw, Ts, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const e = gK();
    return e.ratio = (t) => {
      const n = e.tile();
      n.ratio && e.tile(n.ratio(t));
    }, e.method = (t) => {
      ce(kC, t) ? e.tile(kC[t]) : B("Unrecognized Treemap layout method: " + t);
    }, e;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Gb
});
const EK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nest: Gw,
  pack: Vw,
  partition: Yw,
  stratify: Xw,
  tree: Kw,
  treelinks: Jw,
  treemap: Qw
}, Symbol.toStringTag, { value: "Module" })), N1 = 4278190080;
function SK(e, t) {
  const n = e.bitmap();
  return (t || []).forEach((i) => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0];
}
function kK(e, t, n, i, r) {
  const s = e.width, o = e.height, a = i || r, l = lo(s, o).getContext("2d"), u = lo(s, o).getContext("2d"), c = a && lo(s, o).getContext("2d");
  n.forEach((C) => Gh(l, C, !1)), Gh(u, t, !1), a && Gh(c, t, !0);
  const f = D1(l, s, o), d = D1(u, s, o), h = a && D1(c, s, o), g = e.bitmap(), p = a && e.bitmap();
  let m, y, b, v, w, _, S, E;
  for (y = 0; y < o; ++y)
    for (m = 0; m < s; ++m)
      w = y * s + m, _ = f[w] & N1, E = d[w] & N1, S = a && h[w] & N1, (_ || S || E) && (b = e(m), v = e(y), !r && (_ || E) && g.set(b, v), a && (_ || S) && p.set(b, v));
  return [g, p];
}
function D1(e, t, n) {
  return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
}
function Gh(e, t, n) {
  if (!t.length)
    return;
  const i = t[0].mark.marktype;
  i === "group" ? t.forEach((r) => {
    r.items.forEach((s) => Gh(e, s.items, n));
  }) : si[i].draw(e, {
    items: n ? t.map(AK) : t
  });
}
function AK(e) {
  const t = Zp(e, {});
  return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
    ...t,
    strokeOpacity: 1,
    stroke: "#000",
    fillOpacity: 0
  } : t;
}
const Qr = 5, un = 31, Pf = 32, Vs = new Uint32Array(Pf + 1), Bi = new Uint32Array(Pf + 1);
Bi[0] = 0;
Vs[0] = ~Bi[0];
for (let e = 1; e <= Pf; ++e)
  Bi[e] = Bi[e - 1] << 1 | 1, Vs[e] = ~Bi[e];
function CK(e, t) {
  const n = new Uint32Array(~~((e * t + Pf) / Pf));
  function i(s, o) {
    n[s] |= o;
  }
  function r(s, o) {
    n[s] &= o;
  }
  return {
    array: n,
    get: (s, o) => {
      const a = o * e + s;
      return n[a >>> Qr] & 1 << (a & un);
    },
    set: (s, o) => {
      const a = o * e + s;
      i(a >>> Qr, 1 << (a & un));
    },
    clear: (s, o) => {
      const a = o * e + s;
      r(a >>> Qr, ~(1 << (a & un)));
    },
    getRange: (s, o, a, l) => {
      let u = l, c, f, d, h;
      for (; u >= o; --u)
        if (c = u * e + s, f = u * e + a, d = c >>> Qr, h = f >>> Qr, d === h) {
          if (n[d] & Vs[c & un] & Bi[(f & un) + 1])
            return !0;
        } else {
          if (n[d] & Vs[c & un] || n[h] & Bi[(f & un) + 1])
            return !0;
          for (let g = d + 1; g < h; ++g)
            if (n[g])
              return !0;
        }
      return !1;
    },
    setRange: (s, o, a, l) => {
      let u, c, f, d, h;
      for (; o <= l; ++o)
        if (u = o * e + s, c = o * e + a, f = u >>> Qr, d = c >>> Qr, f === d)
          i(f, Vs[u & un] & Bi[(c & un) + 1]);
        else
          for (i(f, Vs[u & un]), i(d, Bi[(c & un) + 1]), h = f + 1; h < d; ++h)
            i(h, 4294967295);
    },
    clearRange: (s, o, a, l) => {
      let u, c, f, d, h;
      for (; o <= l; ++o)
        if (u = o * e + s, c = o * e + a, f = u >>> Qr, d = c >>> Qr, f === d)
          r(f, Bi[u & un] | Vs[(c & un) + 1]);
        else
          for (r(f, Bi[u & un]), r(d, Vs[(c & un) + 1]), h = f + 1; h < d; ++h)
            r(h, 0);
    },
    outOfBounds: (s, o, a, l) => s < 0 || o < 0 || l >= t || a >= e
  };
}
function $K(e, t, n) {
  const i = Math.max(1, Math.sqrt(e * t / 1e6)), r = ~~((e + 2 * n + i) / i), s = ~~((t + 2 * n + i) / i), o = (a) => ~~((a + n) / i);
  return o.invert = (a) => a * i - n, o.bitmap = () => CK(r, s), o.ratio = i, o.padding = n, o.width = e, o.height = t, o;
}
function MK(e, t, n, i) {
  const r = e.width, s = e.height;
  return function(o) {
    const a = o.datum.datum.items[i].items, l = a.length, u = o.datum.fontSize, c = Zn.width(o.datum, o.datum.text);
    let f = 0, d, h, g, p, m, y, b;
    for (let v = 0; v < l; ++v)
      d = a[v].x, g = a[v].y, h = a[v].x2 === void 0 ? d : a[v].x2, p = a[v].y2 === void 0 ? g : a[v].y2, m = (d + h) / 2, y = (g + p) / 2, b = Math.abs(h - d + p - g), b >= f && (f = b, o.x = m, o.y = y);
    return m = c / 2, y = u / 2, d = o.x - m, h = o.x + m, g = o.y - y, p = o.y + y, o.align = "center", d < 0 && h <= r ? o.align = "left" : 0 <= d && r < h && (o.align = "right"), o.baseline = "middle", g < 0 && p <= s ? o.baseline = "top" : 0 <= g && s < p && (o.baseline = "bottom"), !0;
  };
}
function cp(e, t, n, i, r, s) {
  let o = n / 2;
  return e - o < 0 || e + o > r || t - (o = i / 2) < 0 || t + o > s;
}
function io(e, t, n, i, r, s, o, a) {
  const l = r * s / (i * 2), u = e(t - l), c = e(t + l), f = e(n - (s = s / 2)), d = e(n + s);
  return o.outOfBounds(u, f, c, d) || o.getRange(u, f, c, d) || a && a.getRange(u, f, c, d);
}
function FK(e, t, n, i) {
  const r = e.width, s = e.height, o = t[0], a = t[1];
  function l(u, c, f, d, h) {
    const g = e.invert(u), p = e.invert(c);
    let m = f, y = s, b;
    if (!cp(g, p, d, h, r, s) && !io(e, g, p, h, d, m, o, a) && !io(e, g, p, h, d, h, o, null)) {
      for (; y - m >= 1; )
        b = (m + y) / 2, io(e, g, p, h, d, b, o, a) ? y = b : m = b;
      if (m > f)
        return [g, p, m, !0];
    }
  }
  return function(u) {
    const c = u.datum.datum.items[i].items, f = c.length, d = u.datum.fontSize, h = Zn.width(u.datum, u.datum.text);
    let g = n ? d : 0, p = !1, m = !1, y = 0, b, v, w, _, S, E, C, $, N, T, L, O, F, x, k, A, M;
    for (let D = 0; D < f; ++D) {
      for (b = c[D].x, w = c[D].y, v = c[D].x2 === void 0 ? b : c[D].x2, _ = c[D].y2 === void 0 ? w : c[D].y2, b > v && (M = b, b = v, v = M), w > _ && (M = w, w = _, _ = M), N = e(b), L = e(v), T = ~~((N + L) / 2), O = e(w), x = e(_), F = ~~((O + x) / 2), C = T; C >= N; --C)
        for ($ = F; $ >= O; --$)
          A = l(C, $, g, h, d), A && ([u.x, u.y, g, p] = A);
      for (C = T; C <= L; ++C)
        for ($ = F; $ <= x; ++$)
          A = l(C, $, g, h, d), A && ([u.x, u.y, g, p] = A);
      !p && !n && (k = Math.abs(v - b + _ - w), S = (b + v) / 2, E = (w + _) / 2, k >= y && !cp(S, E, h, d, r, s) && !io(e, S, E, d, h, d, o, null) && (y = k, u.x = S, u.y = E, m = !0));
    }
    return p || m ? (S = h / 2, E = d / 2, o.setRange(e(u.x - S), e(u.y - E), e(u.x + S), e(u.y + E)), u.align = "center", u.baseline = "middle", !0) : !1;
  };
}
const TK = [-1, -1, 1, 1], OK = [-1, 1, -1, 1];
function NK(e, t, n, i) {
  const r = e.width, s = e.height, o = t[0], a = t[1], l = e.bitmap();
  return function(u) {
    const c = u.datum.datum.items[i].items, f = c.length, d = u.datum.fontSize, h = Zn.width(u.datum, u.datum.text), g = [];
    let p = n ? d : 0, m = !1, y = !1, b = 0, v, w, _, S, E, C, $, N, T, L, O, F;
    for (let x = 0; x < f; ++x) {
      for (v = c[x].x, _ = c[x].y, w = c[x].x2 === void 0 ? v : c[x].x2, S = c[x].y2 === void 0 ? _ : c[x].y2, g.push([e((v + w) / 2), e((_ + S) / 2)]); g.length; )
        if ([$, N] = g.pop(), !(o.get($, N) || a.get($, N) || l.get($, N))) {
          l.set($, N);
          for (let k = 0; k < 4; ++k)
            E = $ + TK[k], C = N + OK[k], l.outOfBounds(E, C, E, C) || g.push([E, C]);
          if (E = e.invert($), C = e.invert(N), T = p, L = s, !cp(E, C, h, d, r, s) && !io(e, E, C, d, h, T, o, a) && !io(e, E, C, d, h, d, o, null)) {
            for (; L - T >= 1; )
              O = (T + L) / 2, io(e, E, C, d, h, O, o, a) ? L = O : T = O;
            T > p && (u.x = E, u.y = C, p = T, m = !0);
          }
        }
      !m && !n && (F = Math.abs(w - v + S - _), E = (v + w) / 2, C = (_ + S) / 2, F >= b && !cp(E, C, h, d, r, s) && !io(e, E, C, d, h, d, o, null) && (b = F, u.x = E, u.y = C, y = !0));
    }
    return m || y ? (E = h / 2, C = d / 2, o.setRange(e(u.x - E), e(u.y - C), e(u.x + E), e(u.y + C)), u.align = "center", u.baseline = "middle", !0) : !1;
  };
}
const DK = ["right", "center", "left"], RK = ["bottom", "middle", "top"];
function LK(e, t, n, i) {
  const r = e.width, s = e.height, o = t[0], a = t[1], l = i.length;
  return function(u) {
    const c = u.boundary, f = u.datum.fontSize;
    if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > s)
      return !1;
    let d = u.textWidth ?? 0, h, g, p, m, y, b, v, w, _, S, E, C, $, N, T;
    for (let L = 0; L < l; ++L) {
      if (h = (n[L] & 3) - 1, g = (n[L] >>> 2 & 3) - 1, p = h === 0 && g === 0 || i[L] < 0, m = h && g ? Math.SQRT1_2 : 1, y = i[L] < 0 ? -1 : 1, b = c[1 + h] + i[L] * h * m, E = c[4 + g] + y * f * g / 2 + i[L] * g * m, w = E - f / 2, _ = E + f / 2, C = e(b), N = e(w), T = e(_), !d)
        if (AC(C, C, N, T, o, a, b, b, w, _, c, p))
          d = Zn.width(u.datum, u.datum.text);
        else
          continue;
      if (S = b + y * d * h / 2, b = S - d / 2, v = S + d / 2, C = e(b), $ = e(v), AC(C, $, N, T, o, a, b, v, w, _, c, p))
        return u.x = h ? h * y < 0 ? v : b : S, u.y = g ? g * y < 0 ? _ : w : E, u.align = DK[h * y + 1], u.baseline = RK[g * y + 1], o.setRange(C, N, $, T), !0;
    }
    return !1;
  };
}
function AC(e, t, n, i, r, s, o, a, l, u, c, f) {
  return !(r.outOfBounds(e, n, t, i) || (f && s || r).getRange(e, n, t, i));
}
const R1 = 0, L1 = 4, P1 = 8, I1 = 0, z1 = 1, B1 = 2, PK = {
  "top-left": R1 + I1,
  top: R1 + z1,
  "top-right": R1 + B1,
  left: L1 + I1,
  middle: L1 + z1,
  right: L1 + B1,
  "bottom-left": P1 + I1,
  bottom: P1 + z1,
  "bottom-right": P1 + B1
}, IK = {
  naive: MK,
  "reduced-search": FK,
  floodfill: NK
};
function zK(e, t, n, i, r, s, o, a, l, u, c) {
  if (!e.length)
    return e;
  const f = Math.max(i.length, r.length), d = BK(i, f), h = jK(r, f), g = UK(e[0].datum), p = g === "group" && e[0].datum.items[l].marktype, m = p === "area", y = qK(g, p, a, l), b = u === null || u === 1 / 0, v = m && c === "naive";
  let w = -1, _ = -1;
  const S = e.map((N) => {
    const T = b ? Zn.width(N, N.text) : void 0;
    return w = Math.max(w, T), _ = Math.max(_, N.fontSize), {
      datum: N,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: y(N),
      textWidth: T
    };
  });
  u = u === null || u === 1 / 0 ? Math.max(w, _) + Math.max(...i) : u;
  const E = $K(t[0], t[1], u);
  let C;
  if (!v) {
    n && S.sort((L, O) => n(L.datum, O.datum));
    let N = !1;
    for (let L = 0; L < h.length && !N; ++L)
      N = h[L] === 5 || d[L] < 0;
    const T = (g && o || m) && e.map((L) => L.datum);
    C = s.length || T ? kK(E, T || [], s, N, m) : SK(E, o && S);
  }
  const $ = m ? IK[c](E, C, o, l) : LK(E, C, h, d);
  return S.forEach((N) => N.opacity = +$(N)), S;
}
function BK(e, t) {
  const n = new Float64Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] || 0;
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function jK(e, t) {
  const n = new Int8Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] |= PK[e[r]];
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function UK(e) {
  return e && e.mark && e.mark.marktype;
}
function qK(e, t, n, i) {
  const r = (s) => [s.x, s.x, s.x, s.y, s.y, s.y];
  return e ? e === "line" || e === "area" ? (s) => r(s.datum) : t === "line" ? (s) => {
    const o = s.datum.items[i].items;
    return r(o.length ? o[n === "start" ? 0 : o.length - 1] : {
      x: NaN,
      y: NaN
    });
  } : (s) => {
    const o = s.datum.bounds;
    return [o.x1, (o.x1 + o.x2) / 2, o.x2, o.y1, (o.y1 + o.y2) / 2, o.y2];
  } : r;
}
const Vb = ["x", "y", "opacity", "align", "baseline"], wR = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Zw(e) {
  P.call(this, null, e);
}
Zw.Definition = {
  type: "Label",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: !0,
    default: wR
  }, {
    name: "offset",
    type: "number",
    array: !0,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: !0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: !0
  }, {
    name: "avoidMarks",
    type: "data",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Vb.length,
    default: Vb
  }]
};
Y(Zw, P, {
  transform(e, t) {
    function n(s) {
      const o = e[s];
      return Ee(o) && t.modified(o.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || n("sort")))
      return;
    (!e.size || e.size.length !== 2) && B("Size parameter should be specified as a [width, height] array.");
    const r = e.as || Vb;
    return zK(t.materialize(t.SOURCE).source || [], e.size, e.sort, J(e.offset == null ? 1 : e.offset), J(e.anchor || wR), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((s) => {
      const o = s.datum;
      o[r[0]] = s.x, o[r[1]] = s.y, o[r[2]] = s.opacity, o[r[3]] = s.align, o[r[4]] = s.baseline;
    }), t.reflow(i).modifies(r);
  }
});
const WK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label: Zw
}, Symbol.toStringTag, { value: "Module" }));
function _R(e, t) {
  var n = [], i = function(c) {
    return c(a);
  }, r, s, o, a, l, u;
  if (t == null)
    n.push(e);
  else
    for (r = {}, s = 0, o = e.length; s < o; ++s)
      a = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(a);
  return n;
}
function e_(e) {
  P.call(this, null, e);
}
e_.Definition = {
  type: "Loess",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "bandwidth",
    type: "number",
    default: 0.3
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Y(e_, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = _R(i, e.groupby), s = (e.groupby || []).map(lt), o = s.length, a = e.as || [lt(e.x), lt(e.y)], l = [];
      r.forEach((u) => {
        NT(u, e.x, e.y, e.bandwidth || 0.3).forEach((c) => {
          const f = {};
          for (let d = 0; d < o; ++d)
            f[s[d]] = u.dims[d];
          f[a[0]] = c[0], f[a[1]] = c[1], l.push(Be(f));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
const Yb = {
  constant: Ox,
  linear: Nx,
  log: MT,
  exp: FT,
  pow: TT,
  quad: Dx,
  poly: OT
}, HK = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
function t_(e) {
  P.call(this, null, e);
}
t_.Definition = {
  type: "Regression",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "linear",
    values: Object.keys(Yb)
  }, {
    name: "order",
    type: "number",
    default: 3
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "params",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Y(t_, P, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = _R(i, e.groupby), s = (e.groupby || []).map(lt), o = e.method || "linear", a = e.order == null ? 3 : e.order, l = HK(o, a), u = e.as || [lt(e.x), lt(e.y)], c = Yb[o], f = [];
      let d = e.extent;
      ce(Yb, o) || B("Invalid regression method: " + o), d != null && o === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
        if (h.length <= l) {
          t.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const p = c(h, e.x, e.y, a);
        if (e.params) {
          f.push(Be({
            keys: h.dims,
            coef: p.coef,
            rSquared: p.rSquared
          }));
          return;
        }
        const m = d || $r(h, e.x), y = (b) => {
          const v = {};
          for (let w = 0; w < s.length; ++w)
            v[s[w]] = h.dims[w];
          v[u[0]] = b[0], v[u[1]] = b[1], f.push(Be(v));
        };
        o === "linear" || o === "constant" ? m.forEach((b) => y([b, p.predict(b)])) : om(p.predict, m, 25, 200).forEach(y);
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = f;
    }
    return n;
  }
});
const GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loess: e_,
  regression: t_
}, Symbol.toStringTag, { value: "Module" })), ps = 11102230246251565e-32, Vt = 134217729, VK = (3 + 8 * ps) * ps;
function j1(e, t, n, i, r) {
  let s, o, a, l, u = t[0], c = i[0], f = 0, d = 0;
  c > u == c > -u ? (s = u, u = t[++f]) : (s = c, c = i[++d]);
  let h = 0;
  if (f < e && d < n)
    for (c > u == c > -u ? (o = u + s, a = s - (o - u), u = t[++f]) : (o = c + s, a = s - (o - c), c = i[++d]), s = o, a !== 0 && (r[h++] = a); f < e && d < n; )
      c > u == c > -u ? (o = s + u, l = o - s, a = s - (o - l) + (u - l), u = t[++f]) : (o = s + c, l = o - s, a = s - (o - l) + (c - l), c = i[++d]), s = o, a !== 0 && (r[h++] = a);
  for (; f < e; )
    o = s + u, l = o - s, a = s - (o - l) + (u - l), u = t[++f], s = o, a !== 0 && (r[h++] = a);
  for (; d < n; )
    o = s + c, l = o - s, a = s - (o - l) + (c - l), c = i[++d], s = o, a !== 0 && (r[h++] = a);
  return (s !== 0 || h === 0) && (r[h++] = s), h;
}
function YK(e, t) {
  let n = t[0];
  for (let i = 1; i < e; i++)
    n += t[i];
  return n;
}
function wd(e) {
  return new Float64Array(e);
}
const XK = (3 + 16 * ps) * ps, KK = (2 + 12 * ps) * ps, JK = (9 + 64 * ps) * ps * ps, _l = wd(4), CC = wd(8), $C = wd(12), MC = wd(16), cn = wd(4);
function QK(e, t, n, i, r, s, o) {
  let a, l, u, c, f, d, h, g, p, m, y, b, v, w, _, S, E, C;
  const $ = e - r, N = n - r, T = t - s, L = i - s;
  w = $ * L, d = Vt * $, h = d - (d - $), g = $ - h, d = Vt * L, p = d - (d - L), m = L - p, _ = g * m - (w - h * p - g * p - h * m), S = T * N, d = Vt * T, h = d - (d - T), g = T - h, d = Vt * N, p = d - (d - N), m = N - p, E = g * m - (S - h * p - g * p - h * m), y = _ - E, f = _ - y, _l[0] = _ - (y + f) + (f - E), b = w + y, f = b - w, v = w - (b - f) + (y - f), y = v - S, f = v - y, _l[1] = v - (y + f) + (f - S), C = b + y, f = C - b, _l[2] = b - (C - f) + (y - f), _l[3] = C;
  let O = YK(4, _l), F = KK * o;
  if (O >= F || -O >= F || (f = e - $, a = e - ($ + f) + (f - r), f = n - N, u = n - (N + f) + (f - r), f = t - T, l = t - (T + f) + (f - s), f = i - L, c = i - (L + f) + (f - s), a === 0 && l === 0 && u === 0 && c === 0) || (F = JK * o + VK * Math.abs(O), O += $ * c + L * a - (T * u + N * l), O >= F || -O >= F))
    return O;
  w = a * L, d = Vt * a, h = d - (d - a), g = a - h, d = Vt * L, p = d - (d - L), m = L - p, _ = g * m - (w - h * p - g * p - h * m), S = l * N, d = Vt * l, h = d - (d - l), g = l - h, d = Vt * N, p = d - (d - N), m = N - p, E = g * m - (S - h * p - g * p - h * m), y = _ - E, f = _ - y, cn[0] = _ - (y + f) + (f - E), b = w + y, f = b - w, v = w - (b - f) + (y - f), y = v - S, f = v - y, cn[1] = v - (y + f) + (f - S), C = b + y, f = C - b, cn[2] = b - (C - f) + (y - f), cn[3] = C;
  const x = j1(4, _l, 4, cn, CC);
  w = $ * c, d = Vt * $, h = d - (d - $), g = $ - h, d = Vt * c, p = d - (d - c), m = c - p, _ = g * m - (w - h * p - g * p - h * m), S = T * u, d = Vt * T, h = d - (d - T), g = T - h, d = Vt * u, p = d - (d - u), m = u - p, E = g * m - (S - h * p - g * p - h * m), y = _ - E, f = _ - y, cn[0] = _ - (y + f) + (f - E), b = w + y, f = b - w, v = w - (b - f) + (y - f), y = v - S, f = v - y, cn[1] = v - (y + f) + (f - S), C = b + y, f = C - b, cn[2] = b - (C - f) + (y - f), cn[3] = C;
  const k = j1(x, CC, 4, cn, $C);
  w = a * c, d = Vt * a, h = d - (d - a), g = a - h, d = Vt * c, p = d - (d - c), m = c - p, _ = g * m - (w - h * p - g * p - h * m), S = l * u, d = Vt * l, h = d - (d - l), g = l - h, d = Vt * u, p = d - (d - u), m = u - p, E = g * m - (S - h * p - g * p - h * m), y = _ - E, f = _ - y, cn[0] = _ - (y + f) + (f - E), b = w + y, f = b - w, v = w - (b - f) + (y - f), y = v - S, f = v - y, cn[1] = v - (y + f) + (f - S), C = b + y, f = C - b, cn[2] = b - (C - f) + (y - f), cn[3] = C;
  const A = j1(k, $C, 4, cn, MC);
  return MC[A - 1];
}
function fh(e, t, n, i, r, s) {
  const o = (t - s) * (n - r), a = (e - r) * (i - s), l = o - a, u = Math.abs(o + a);
  return Math.abs(l) >= XK * u ? l : -QK(e, t, n, i, r, s, u);
}
const FC = Math.pow(2, -52), dh = new Uint32Array(512);
class fp {
  static from(t, n = iJ, i = rJ) {
    const r = t.length, s = new Float64Array(r * 2);
    for (let o = 0; o < r; o++) {
      const a = t[o];
      s[2 * o] = n(a), s[2 * o + 1] = i(a);
    }
    return new fp(s);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const i = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: i, _hullTri: r, _hullHash: s } = this, o = t.length >> 1;
    let a = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0;
    for (let $ = 0; $ < o; $++) {
      const N = t[2 * $], T = t[2 * $ + 1];
      N < a && (a = N), T < l && (l = T), N > u && (u = N), T > c && (c = T), this._ids[$] = $;
    }
    const f = (a + u) / 2, d = (l + c) / 2;
    let h, g, p;
    for (let $ = 0, N = 1 / 0; $ < o; $++) {
      const T = U1(f, d, t[2 * $], t[2 * $ + 1]);
      T < N && (h = $, N = T);
    }
    const m = t[2 * h], y = t[2 * h + 1];
    for (let $ = 0, N = 1 / 0; $ < o; $++) {
      if ($ === h)
        continue;
      const T = U1(m, y, t[2 * $], t[2 * $ + 1]);
      T < N && T > 0 && (g = $, N = T);
    }
    let b = t[2 * g], v = t[2 * g + 1], w = 1 / 0;
    for (let $ = 0; $ < o; $++) {
      if ($ === h || $ === g)
        continue;
      const N = tJ(m, y, b, v, t[2 * $], t[2 * $ + 1]);
      N < w && (p = $, w = N);
    }
    let _ = t[2 * p], S = t[2 * p + 1];
    if (w === 1 / 0) {
      for (let T = 0; T < o; T++)
        this._dists[T] = t[2 * T] - t[0] || t[2 * T + 1] - t[1];
      Il(this._ids, this._dists, 0, o - 1);
      const $ = new Uint32Array(o);
      let N = 0;
      for (let T = 0, L = -1 / 0; T < o; T++) {
        const O = this._ids[T], F = this._dists[O];
        F > L && ($[N++] = O, L = F);
      }
      this.hull = $.subarray(0, N), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (fh(m, y, b, v, _, S) < 0) {
      const $ = g, N = b, T = v;
      g = p, b = _, v = S, p = $, _ = N, S = T;
    }
    const E = nJ(m, y, b, v, _, S);
    this._cx = E.x, this._cy = E.y;
    for (let $ = 0; $ < o; $++)
      this._dists[$] = U1(t[2 * $], t[2 * $ + 1], E.x, E.y);
    Il(this._ids, this._dists, 0, o - 1), this._hullStart = h;
    let C = 3;
    i[h] = n[p] = g, i[g] = n[h] = p, i[p] = n[g] = h, r[h] = 0, r[g] = 1, r[p] = 2, s.fill(-1), s[this._hashKey(m, y)] = h, s[this._hashKey(b, v)] = g, s[this._hashKey(_, S)] = p, this.trianglesLen = 0, this._addTriangle(h, g, p, -1, -1, -1);
    for (let $ = 0, N, T; $ < this._ids.length; $++) {
      const L = this._ids[$], O = t[2 * L], F = t[2 * L + 1];
      if ($ > 0 && Math.abs(O - N) <= FC && Math.abs(F - T) <= FC || (N = O, T = F, L === h || L === g || L === p))
        continue;
      let x = 0;
      for (let R = 0, U = this._hashKey(O, F); R < this._hashSize && (x = s[(U + R) % this._hashSize], !(x !== -1 && x !== i[x])); R++)
        ;
      x = n[x];
      let k = x, A;
      for (; A = i[k], fh(O, F, t[2 * k], t[2 * k + 1], t[2 * A], t[2 * A + 1]) >= 0; )
        if (k = A, k === x) {
          k = -1;
          break;
        }
      if (k === -1)
        continue;
      let M = this._addTriangle(k, L, i[k], -1, -1, r[k]);
      r[L] = this._legalize(M + 2), r[k] = M, C++;
      let D = i[k];
      for (; A = i[D], fh(O, F, t[2 * D], t[2 * D + 1], t[2 * A], t[2 * A + 1]) < 0; )
        M = this._addTriangle(D, L, A, r[L], -1, r[D]), r[L] = this._legalize(M + 2), i[D] = D, C--, D = A;
      if (k === x)
        for (; A = n[k], fh(O, F, t[2 * A], t[2 * A + 1], t[2 * k], t[2 * k + 1]) < 0; )
          M = this._addTriangle(A, L, k, -1, r[k], r[A]), this._legalize(M + 2), r[A] = M, i[k] = k, C--, k = A;
      this._hullStart = n[L] = k, i[k] = n[D] = L, i[L] = D, s[this._hashKey(O, F)] = L, s[this._hashKey(t[2 * k], t[2 * k + 1])] = k;
    }
    this.hull = new Uint32Array(C);
    for (let $ = 0, N = this._hullStart; $ < C; $++)
      this.hull[$] = N, N = i[N];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, n) {
    return Math.floor(ZK(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: i, coords: r } = this;
    let s = 0, o = 0;
    for (; ; ) {
      const a = i[t], l = t - t % 3;
      if (o = l + (t + 2) % 3, a === -1) {
        if (s === 0)
          break;
        t = dh[--s];
        continue;
      }
      const u = a - a % 3, c = l + (t + 1) % 3, f = u + (a + 2) % 3, d = n[o], h = n[t], g = n[c], p = n[f];
      if (eJ(
        r[2 * d],
        r[2 * d + 1],
        r[2 * h],
        r[2 * h + 1],
        r[2 * g],
        r[2 * g + 1],
        r[2 * p],
        r[2 * p + 1]
      )) {
        n[t] = p, n[a] = d;
        const y = i[f];
        if (y === -1) {
          let v = this._hullStart;
          do {
            if (this._hullTri[v] === f) {
              this._hullTri[v] = t;
              break;
            }
            v = this._hullPrev[v];
          } while (v !== this._hullStart);
        }
        this._link(t, y), this._link(a, i[o]), this._link(o, f);
        const b = u + (a + 1) % 3;
        s < dh.length && (dh[s++] = b);
      } else {
        if (s === 0)
          break;
        t = dh[--s];
      }
    }
    return o;
  }
  _link(t, n) {
    this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, n, i, r, s, o) {
    const a = this.trianglesLen;
    return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = i, this._link(a, r), this._link(a + 1, s), this._link(a + 2, o), this.trianglesLen += 3, a;
  }
}
function ZK(e, t) {
  const n = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - n : 1 + n) / 4;
}
function U1(e, t, n, i) {
  const r = e - n, s = t - i;
  return r * r + s * s;
}
function eJ(e, t, n, i, r, s, o, a) {
  const l = e - o, u = t - a, c = n - o, f = i - a, d = r - o, h = s - a, g = l * l + u * u, p = c * c + f * f, m = d * d + h * h;
  return l * (f * m - p * h) - u * (c * m - p * d) + g * (c * h - f * d) < 0;
}
function tJ(e, t, n, i, r, s) {
  const o = n - e, a = i - t, l = r - e, u = s - t, c = o * o + a * a, f = l * l + u * u, d = 0.5 / (o * u - a * l), h = (u * c - a * f) * d, g = (o * f - l * c) * d;
  return h * h + g * g;
}
function nJ(e, t, n, i, r, s) {
  const o = n - e, a = i - t, l = r - e, u = s - t, c = o * o + a * a, f = l * l + u * u, d = 0.5 / (o * u - a * l), h = e + (u * c - a * f) * d, g = t + (o * f - l * c) * d;
  return { x: h, y: g };
}
function Il(e, t, n, i) {
  if (i - n <= 20)
    for (let r = n + 1; r <= i; r++) {
      const s = e[r], o = t[s];
      let a = r - 1;
      for (; a >= n && t[e[a]] > o; )
        e[a + 1] = e[a--];
      e[a + 1] = s;
    }
  else {
    const r = n + i >> 1;
    let s = n + 1, o = i;
    yc(e, r, s), t[e[n]] > t[e[i]] && yc(e, n, i), t[e[s]] > t[e[i]] && yc(e, s, i), t[e[n]] > t[e[s]] && yc(e, n, s);
    const a = e[s], l = t[a];
    for (; ; ) {
      do
        s++;
      while (t[e[s]] < l);
      do
        o--;
      while (t[e[o]] > l);
      if (o < s)
        break;
      yc(e, s, o);
    }
    e[n + 1] = e[o], e[o] = a, i - s + 1 >= o - n ? (Il(e, t, s, i), Il(e, t, n, o - 1)) : (Il(e, t, n, o - 1), Il(e, t, s, i));
  }
}
function yc(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function iJ(e) {
  return e[0];
}
function rJ(e) {
  return e[1];
}
const TC = 1e-6;
class ma {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, n) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, n) {
    this._ += `L${this._x1 = +t},${this._y1 = +n}`;
  }
  arc(t, n, i) {
    t = +t, n = +n, i = +i;
    const r = t + i, s = n;
    if (i < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > TC || Math.abs(this._y1 - s) > TC) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = s}`);
  }
  rect(t, n, i, r) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Xb {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let sJ = class {
  constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: n, triangles: i }, vectors: r } = this;
    let s, o;
    const a = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
    for (let p = 0, m = 0, y = i.length, b, v; p < y; p += 3, m += 2) {
      const w = i[p] * 2, _ = i[p + 1] * 2, S = i[p + 2] * 2, E = t[w], C = t[w + 1], $ = t[_], N = t[_ + 1], T = t[S], L = t[S + 1], O = $ - E, F = N - C, x = T - E, k = L - C, A = (O * k - F * x) * 2;
      if (Math.abs(A) < 1e-9) {
        if (s === void 0) {
          s = o = 0;
          for (const D of n)
            s += t[D * 2], o += t[D * 2 + 1];
          s /= n.length, o /= n.length;
        }
        const M = 1e9 * Math.sign((s - E) * k - (o - C) * x);
        b = (E + T) / 2 - M * k, v = (C + L) / 2 + M * x;
      } else {
        const M = 1 / A, D = O * O + F * F, R = x * x + k * k;
        b = E + (k * D - F * R) * M, v = C + (O * R - x * D) * M;
      }
      a[m] = b, a[m + 1] = v;
    }
    let l = n[n.length - 1], u, c = l * 4, f, d = t[2 * l], h, g = t[2 * l + 1];
    r.fill(0);
    for (let p = 0; p < n.length; ++p)
      l = n[p], u = c, f = d, h = g, c = l * 4, d = t[2 * l], g = t[2 * l + 1], r[u + 2] = r[c] = h - g, r[u + 3] = r[c + 1] = d - f;
  }
  render(t) {
    const n = t == null ? t = new ma() : void 0, { delaunay: { halfedges: i, inedges: r, hull: s }, circumcenters: o, vectors: a } = this;
    if (s.length <= 1)
      return null;
    for (let c = 0, f = i.length; c < f; ++c) {
      const d = i[c];
      if (d < c)
        continue;
      const h = Math.floor(c / 3) * 2, g = Math.floor(d / 3) * 2, p = o[h], m = o[h + 1], y = o[g], b = o[g + 1];
      this._renderSegment(p, m, y, b, t);
    }
    let l, u = s[s.length - 1];
    for (let c = 0; c < s.length; ++c) {
      l = u, u = s[c];
      const f = Math.floor(r[u] / 3) * 2, d = o[f], h = o[f + 1], g = l * 4, p = this._project(d, h, a[g + 2], a[g + 3]);
      p && this._renderSegment(d, h, p[0], p[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = t == null ? t = new ma() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const i = n == null ? n = new ma() : void 0, r = this._clip(t);
    if (r === null || !r.length)
      return;
    n.moveTo(r[0], r[1]);
    let s = r.length;
    for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1; )
      s -= 2;
    for (let o = 2; o < s; o += 2)
      (r[o] !== r[o - 2] || r[o + 1] !== r[o - 1]) && n.lineTo(r[o], r[o + 1]);
    return n.closePath(), i && i.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let n = 0, i = t.length / 2; n < i; ++n) {
      const r = this.cellPolygon(n);
      r && (r.index = n, yield r);
    }
  }
  cellPolygon(t) {
    const n = new Xb();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, i, r, s) {
    let o;
    const a = this._regioncode(t, n), l = this._regioncode(i, r);
    a === 0 && l === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (o = this._clipSegment(t, n, i, r, a, l)) && (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]));
  }
  contains(t, n, i) {
    return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const i of this.delaunay.neighbors(t)) {
        const r = this._clip(i);
        if (r) {
          e:
            for (let s = 0, o = n.length; s < o; s += 2)
              for (let a = 0, l = r.length; a < l; a += 2)
                if (n[s] === r[a] && n[s + 1] === r[a + 1] && n[(s + 2) % o] === r[(a + l - 2) % l] && n[(s + 3) % o] === r[(a + l - 1) % l]) {
                  yield i;
                  break e;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: n, delaunay: { inedges: i, halfedges: r, triangles: s } } = this, o = i[t];
    if (o === -1)
      return null;
    const a = [];
    let l = o;
    do {
      const u = Math.floor(l / 3);
      if (a.push(n[u * 2], n[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t)
        break;
      l = r[l];
    } while (l !== o && l !== -1);
    return a;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (n === null)
      return null;
    const { vectors: i } = this, r = t * 4;
    return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
  }
  _clipFinite(t, n) {
    const i = n.length;
    let r = null, s, o, a = n[i - 2], l = n[i - 1], u, c = this._regioncode(a, l), f, d = 0;
    for (let h = 0; h < i; h += 2)
      if (s = a, o = l, a = n[h], l = n[h + 1], u = c, c = this._regioncode(a, l), u === 0 && c === 0)
        f = d, d = 0, r ? r.push(a, l) : r = [a, l];
      else {
        let g, p, m, y, b;
        if (u === 0) {
          if ((g = this._clipSegment(s, o, a, l, u, c)) === null)
            continue;
          [p, m, y, b] = g;
        } else {
          if ((g = this._clipSegment(a, l, s, o, c, u)) === null)
            continue;
          [y, b, p, m] = g, f = d, d = this._edgecode(p, m), f && d && this._edge(t, f, d, r, r.length), r ? r.push(p, m) : r = [p, m];
        }
        f = d, d = this._edgecode(y, b), f && d && this._edge(t, f, d, r, r.length), r ? r.push(y, b) : r = [y, b];
      }
    if (r)
      f = d, d = this._edgecode(r[0], r[1]), f && d && this._edge(t, f, d, r, r.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return r;
  }
  _clipSegment(t, n, i, r, s, o) {
    const a = s < o;
    for (a && ([t, n, i, r, s, o] = [i, r, t, n, o, s]); ; ) {
      if (s === 0 && o === 0)
        return a ? [i, r, t, n] : [t, n, i, r];
      if (s & o)
        return null;
      let l, u, c = s || o;
      c & 8 ? (l = t + (i - t) * (this.ymax - n) / (r - n), u = this.ymax) : c & 4 ? (l = t + (i - t) * (this.ymin - n) / (r - n), u = this.ymin) : c & 2 ? (u = n + (r - n) * (this.xmax - t) / (i - t), l = this.xmax) : (u = n + (r - n) * (this.xmin - t) / (i - t), l = this.xmin), s ? (t = l, n = u, s = this._regioncode(t, n)) : (i = l, r = u, o = this._regioncode(i, r));
    }
  }
  _clipInfinite(t, n, i, r, s, o) {
    let a = Array.from(n), l;
    if ((l = this._project(a[0], a[1], i, r)) && a.unshift(l[0], l[1]), (l = this._project(a[a.length - 2], a[a.length - 1], s, o)) && a.push(l[0], l[1]), a = this._clipFinite(t, a))
      for (let u = 0, c = a.length, f, d = this._edgecode(a[c - 2], a[c - 1]); u < c; u += 2)
        f = d, d = this._edgecode(a[u], a[u + 1]), f && d && (u = this._edge(t, f, d, a, u), c = a.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return a;
  }
  _edge(t, n, i, r, s) {
    for (; n !== i; ) {
      let o, a;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          n = 6, o = this.xmax, a = this.ymin;
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          n = 10, o = this.xmax, a = this.ymax;
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          n = 9, o = this.xmin, a = this.ymax;
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          n = 5, o = this.xmin, a = this.ymin;
          break;
      }
      (r[s] !== o || r[s + 1] !== a) && this.contains(t, o, a) && (r.splice(s, 0, o, a), s += 2);
    }
    return s;
  }
  _project(t, n, i, r) {
    let s = 1 / 0, o, a, l;
    if (r < 0) {
      if (n <= this.ymin)
        return null;
      (o = (this.ymin - n) / r) < s && (l = this.ymin, a = t + (s = o) * i);
    } else if (r > 0) {
      if (n >= this.ymax)
        return null;
      (o = (this.ymax - n) / r) < s && (l = this.ymax, a = t + (s = o) * i);
    }
    if (i > 0) {
      if (t >= this.xmax)
        return null;
      (o = (this.xmax - t) / i) < s && (a = this.xmax, l = n + (s = o) * r);
    } else if (i < 0) {
      if (t <= this.xmin)
        return null;
      (o = (this.xmin - t) / i) < s && (a = this.xmin, l = n + (s = o) * r);
    }
    return [a, l];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let n = 0; n < t.length; n += 2) {
        const i = (n + 2) % t.length, r = (n + 4) % t.length;
        (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
};
const oJ = 2 * Math.PI, El = Math.pow;
function aJ(e) {
  return e[0];
}
function lJ(e) {
  return e[1];
}
function uJ(e) {
  const { triangles: t, coords: n } = e;
  for (let i = 0; i < t.length; i += 3) {
    const r = 2 * t[i], s = 2 * t[i + 1], o = 2 * t[i + 2];
    if ((n[o] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[o + 1] - n[r + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function cJ(e, t, n) {
  return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
}
class n_ {
  static from(t, n = aJ, i = lJ, r) {
    return new n_("length" in t ? fJ(t, n, i, r) : Float64Array.from(dJ(t, n, i, r)));
  }
  constructor(t) {
    this._delaunator = new fp(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, n = this.points;
    if (t.hull && t.hull.length > 2 && uJ(t)) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (d, h) => h).sort((d, h) => n[2 * d] - n[2 * h] || n[2 * d + 1] - n[2 * h + 1]);
      const l = this.collinear[0], u = this.collinear[this.collinear.length - 1], c = [n[2 * l], n[2 * l + 1], n[2 * u], n[2 * u + 1]], f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
      for (let d = 0, h = n.length / 2; d < h; ++d) {
        const g = cJ(n[2 * d], n[2 * d + 1], f);
        n[2 * d] = g[0], n[2 * d + 1] = g[1];
      }
      this._delaunator = new fp(n);
    } else
      delete this.collinear;
    const i = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, s = this.triangles = this._delaunator.triangles, o = this.inedges.fill(-1), a = this._hullIndex.fill(-1);
    for (let l = 0, u = i.length; l < u; ++l) {
      const c = s[l % 3 === 2 ? l - 2 : l + 1];
      (i[l] === -1 || o[c] === -1) && (o[c] = l);
    }
    for (let l = 0, u = r.length; l < u; ++l)
      a[r[l]] = l;
    r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, r.length === 2 && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
  }
  voronoi(t) {
    return new sJ(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: i, _hullIndex: r, halfedges: s, triangles: o, collinear: a } = this;
    if (a) {
      const f = a.indexOf(t);
      f > 0 && (yield a[f - 1]), f < a.length - 1 && (yield a[f + 1]);
      return;
    }
    const l = n[t];
    if (l === -1)
      return;
    let u = l, c = -1;
    do {
      if (yield c = o[u], u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== t)
        return;
      if (u = s[u], u === -1) {
        const f = i[(r[t] + 1) % i.length];
        f !== c && (yield f);
        return;
      }
    } while (u !== l);
  }
  find(t, n, i = 0) {
    if (t = +t, t !== t || (n = +n, n !== n))
      return -1;
    const r = i;
    let s;
    for (; (s = this._step(i, t, n)) >= 0 && s !== i && s !== r; )
      i = s;
    return s;
  }
  _step(t, n, i) {
    const { inedges: r, hull: s, _hullIndex: o, halfedges: a, triangles: l, points: u } = this;
    if (r[t] === -1 || !u.length)
      return (t + 1) % (u.length >> 1);
    let c = t, f = El(n - u[t * 2], 2) + El(i - u[t * 2 + 1], 2);
    const d = r[t];
    let h = d;
    do {
      let g = l[h];
      const p = El(n - u[g * 2], 2) + El(i - u[g * 2 + 1], 2);
      if (p < f && (f = p, c = g), h = h % 3 === 2 ? h - 2 : h + 1, l[h] !== t)
        break;
      if (h = a[h], h === -1) {
        if (h = s[(o[t] + 1) % s.length], h !== g && El(n - u[h * 2], 2) + El(i - u[h * 2 + 1], 2) < f)
          return h;
        break;
      }
    } while (h !== d);
    return c;
  }
  render(t) {
    const n = t == null ? t = new ma() : void 0, { points: i, halfedges: r, triangles: s } = this;
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o];
      if (l < o)
        continue;
      const u = s[o] * 2, c = s[l] * 2;
      t.moveTo(i[u], i[u + 1]), t.lineTo(i[c], i[c + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
    const i = t == null ? t = new ma() : void 0, { points: r } = this;
    for (let s = 0, o = r.length; s < o; s += 2) {
      const a = r[s], l = r[s + 1];
      t.moveTo(a + n, l), t.arc(a, l, n, 0, oJ);
    }
    return i && i.value();
  }
  renderHull(t) {
    const n = t == null ? t = new ma() : void 0, { hull: i, points: r } = this, s = i[0] * 2, o = i.length;
    t.moveTo(r[s], r[s + 1]);
    for (let a = 1; a < o; ++a) {
      const l = 2 * i[a];
      t.lineTo(r[l], r[l + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new Xb();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const i = n == null ? n = new ma() : void 0, { points: r, triangles: s } = this, o = s[t *= 3] * 2, a = s[t + 1] * 2, l = s[t + 2] * 2;
    return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[l], r[l + 1]), n.closePath(), i && i.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, i = t.length / 3; n < i; ++n)
      yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new Xb();
    return this.renderTriangle(t, n), n.value();
  }
}
function fJ(e, t, n, i) {
  const r = e.length, s = new Float64Array(r * 2);
  for (let o = 0; o < r; ++o) {
    const a = e[o];
    s[o * 2] = t.call(i, a, o, e), s[o * 2 + 1] = n.call(i, a, o, e);
  }
  return s;
}
function* dJ(e, t, n, i) {
  let r = 0;
  for (const s of e)
    yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r;
}
function i_(e) {
  P.call(this, null, e);
}
i_.Definition = {
  type: "Voronoi",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    default: [[-1e5, -1e5], [1e5, 1e5]],
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
const hJ = [-1e5, -1e5, 1e5, 1e5];
Y(i_, P, {
  transform(e, t) {
    const n = e.as || "path", i = t.source;
    if (!i || !i.length)
      return t;
    let r = e.size;
    r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : hJ;
    const s = this.value = n_.from(i, e.x, e.y).voronoi(r);
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = s.cellPolygon(o);
      i[o][n] = l && !pJ(l) ? gJ(l) : null;
    }
    return t.reflow(e.modified()).modifies(n);
  }
});
function gJ(e) {
  const t = e[0][0], n = e[0][1];
  let i = e.length - 1;
  for (; e[i][0] === t && e[i][1] === n; --i)
    ;
  return "M" + e.slice(0, i + 1).join("L") + "Z";
}
function pJ(e) {
  return e.length === 2 && e[0][0] === e[1][0] && e[0][1] === e[1][1];
}
const mJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  voronoi: i_
}, Symbol.toStringTag, { value: "Module" }));
var q1 = Math.PI / 180, Xc = 64, Vh = 2048;
function yJ() {
  var e = [256, 256], t, n, i, r, s, o, a, l = ER, u = [], c = Math.random, f = {};
  f.layout = function() {
    for (var g = d(lo()), p = EJ((e[0] >> 5) * e[1]), m = null, y = u.length, b = -1, v = [], w = u.map((S) => ({
      text: t(S),
      font: n(S),
      style: r(S),
      weight: s(S),
      rotate: o(S),
      size: ~~(i(S) + 1e-14),
      padding: a(S),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: !1,
      sprite: null,
      datum: S
    })).sort((S, E) => E.size - S.size); ++b < y; ) {
      var _ = w[b];
      _.x = e[0] * (c() + 0.5) >> 1, _.y = e[1] * (c() + 0.5) >> 1, bJ(g, _, w, b), _.hasText && h(p, _, m) && (v.push(_), m ? xJ(m, _) : m = [{
        x: _.x + _.x0,
        y: _.y + _.y0
      }, {
        x: _.x + _.x1,
        y: _.y + _.y1
      }], _.x -= e[0] >> 1, _.y -= e[1] >> 1);
    }
    return v;
  };
  function d(g) {
    g.width = g.height = 1;
    var p = Math.sqrt(g.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    g.width = (Xc << 5) / p, g.height = Vh / p;
    var m = g.getContext("2d");
    return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
      context: m,
      ratio: p
    };
  }
  function h(g, p, m) {
    for (var y = p.x, b = p.y, v = Math.sqrt(e[0] * e[0] + e[1] * e[1]), w = l(e), _ = c() < 0.5 ? 1 : -1, S = -_, E, C, $; (E = w(S += _)) && (C = ~~E[0], $ = ~~E[1], !(Math.min(Math.abs(C), Math.abs($)) >= v)); )
      if (p.x = y + C, p.y = b + $, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !vJ(p, g, e[0])) && (!m || wJ(p, m))) {
        for (var N = p.sprite, T = p.width >> 5, L = e[0] >> 5, O = p.x - (T << 4), F = O & 127, x = 32 - F, k = p.y1 - p.y0, A = (p.y + p.y0) * L + (O >> 5), M, D = 0; D < k; D++) {
          M = 0;
          for (var R = 0; R <= T; R++)
            g[A + R] |= M << x | (R < T ? (M = N[D * T + R]) >>> F : 0);
          A += L;
        }
        return p.sprite = null, !0;
      }
    return !1;
  }
  return f.words = function(g) {
    return arguments.length ? (u = g, f) : u;
  }, f.size = function(g) {
    return arguments.length ? (e = [+g[0], +g[1]], f) : e;
  }, f.font = function(g) {
    return arguments.length ? (n = Vo(g), f) : n;
  }, f.fontStyle = function(g) {
    return arguments.length ? (r = Vo(g), f) : r;
  }, f.fontWeight = function(g) {
    return arguments.length ? (s = Vo(g), f) : s;
  }, f.rotate = function(g) {
    return arguments.length ? (o = Vo(g), f) : o;
  }, f.text = function(g) {
    return arguments.length ? (t = Vo(g), f) : t;
  }, f.spiral = function(g) {
    return arguments.length ? (l = SJ[g] || g, f) : l;
  }, f.fontSize = function(g) {
    return arguments.length ? (i = Vo(g), f) : i;
  }, f.padding = function(g) {
    return arguments.length ? (a = Vo(g), f) : a;
  }, f.random = function(g) {
    return arguments.length ? (c = g, f) : c;
  }, f;
}
function bJ(e, t, n, i) {
  if (!t.sprite) {
    var r = e.context, s = e.ratio;
    r.clearRect(0, 0, (Xc << 5) / s, Vh / s);
    var o = 0, a = 0, l = 0, u = n.length, c, f, d, h, g;
    for (--i; ++i < u; ) {
      if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font, c = r.measureText(t.text + "m").width * s, d = t.size << 1, t.rotate) {
        var p = Math.sin(t.rotate * q1), m = Math.cos(t.rotate * q1), y = c * m, b = c * p, v = d * m, w = d * p;
        c = Math.max(Math.abs(y + w), Math.abs(y - w)) + 31 >> 5 << 5, d = ~~Math.max(Math.abs(b + v), Math.abs(b - v));
      } else
        c = c + 31 >> 5 << 5;
      if (d > l && (l = d), o + c >= Xc << 5 && (o = 0, a += l, l = 0), a + d >= Vh)
        break;
      r.translate((o + (c >> 1)) / s, (a + (d >> 1)) / s), t.rotate && r.rotate(t.rotate * q1), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = d, t.xoff = o, t.yoff = a, t.x1 = c >> 1, t.y1 = d >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, o += c;
    }
    for (var _ = r.getImageData(0, 0, (Xc << 5) / s, Vh / s).data, S = []; --i >= 0; )
      if (t = n[i], !!t.hasText) {
        for (c = t.width, f = c >> 5, d = t.y1 - t.y0, h = 0; h < d * f; h++)
          S[h] = 0;
        if (o = t.xoff, o == null)
          return;
        a = t.yoff;
        var E = 0, C = -1;
        for (g = 0; g < d; g++) {
          for (h = 0; h < c; h++) {
            var $ = f * g + (h >> 5), N = _[(a + g) * (Xc << 5) + (o + h) << 2] ? 1 << 31 - h % 32 : 0;
            S[$] |= N, E |= N;
          }
          E ? C = g : (t.y0++, d--, g--, a++);
        }
        t.y1 = t.y0 + C, t.sprite = S.slice(0, (t.y1 - t.y0) * f);
      }
  }
}
function vJ(e, t, n) {
  n >>= 5;
  for (var i = e.sprite, r = e.width >> 5, s = e.x - (r << 4), o = s & 127, a = 32 - o, l = e.y1 - e.y0, u = (e.y + e.y0) * n + (s >> 5), c, f = 0; f < l; f++) {
    c = 0;
    for (var d = 0; d <= r; d++)
      if ((c << a | (d < r ? (c = i[f * r + d]) >>> o : 0)) & t[u + d])
        return !0;
    u += n;
  }
  return !1;
}
function xJ(e, t) {
  var n = e[0], i = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1);
}
function wJ(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function ER(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function _J(e) {
  var t = 4, n = t * e[0] / e[1], i = 0, r = 0;
  return function(s) {
    var o = s < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * o * s) - o & 3) {
      case 0:
        i += n;
        break;
      case 1:
        r += t;
        break;
      case 2:
        i -= n;
        break;
      default:
        r -= t;
        break;
    }
    return [i, r];
  };
}
function EJ(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function Vo(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
var SJ = {
  archimedean: ER,
  rectangular: _J
};
const SR = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"], kJ = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function r_(e) {
  P.call(this, yJ(), e);
}
r_.Definition = {
  type: "Wordcloud",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "font",
    type: "string",
    expr: !0,
    default: "sans-serif"
  }, {
    name: "fontStyle",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontWeight",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontSize",
    type: "number",
    expr: !0,
    default: 14
  }, {
    name: "fontSizeRange",
    type: "number",
    array: "nullable",
    default: [10, 50]
  }, {
    name: "rotate",
    type: "number",
    expr: !0,
    default: 0
  }, {
    name: "text",
    type: "field"
  }, {
    name: "spiral",
    type: "string",
    values: ["archimedean", "rectangular"]
  }, {
    name: "padding",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 7,
    default: SR
  }]
};
Y(r_, P, {
  transform(e, t) {
    e.size && !(e.size[0] && e.size[1]) && B("Wordcloud size dimensions must be non-zero.");
    function n(g) {
      const p = e[g];
      return Ee(p) && t.modified(p.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || kJ.some(n)))
      return;
    const r = t.materialize(t.SOURCE).source, s = this.value, o = e.as || SR;
    let a = e.fontSize || 14, l;
    if (Ee(a) ? l = e.fontSizeRange : a = an(a), l) {
      const g = a, p = Ie("sqrt")().domain($r(r, g)).range(l);
      a = (m) => p(g(m));
    }
    r.forEach((g) => {
      g[o[0]] = NaN, g[o[1]] = NaN, g[o[3]] = 0;
    });
    const u = s.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(a).random(ki).layout(), c = s.size(), f = c[0] >> 1, d = c[1] >> 1, h = u.length;
    for (let g = 0, p, m; g < h; ++g)
      p = u[g], m = p.datum, m[o[0]] = p.x + f, m[o[1]] = p.y + d, m[o[2]] = p.font, m[o[3]] = p.size, m[o[4]] = p.style, m[o[5]] = p.weight, m[o[6]] = p.rotate;
    return t.reflow(i).modifies(o);
  }
});
const AJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  wordcloud: r_
}, Symbol.toStringTag, { value: "Module" })), CJ = (e) => new Uint8Array(e), $J = (e) => new Uint16Array(e), cf = (e) => new Uint32Array(e);
function MJ() {
  let e = 8, t = [], n = cf(0), i = hh(0, e), r = hh(0, e);
  return {
    data: () => t,
    seen: () => n = FJ(n, t.length),
    add(s) {
      for (let o = 0, a = t.length, l = s.length, u; o < l; ++o)
        u = s[o], u._index = a++, t.push(u);
    },
    remove(s, o) {
      const a = t.length, l = Array(a - s), u = t;
      let c, f, d;
      for (f = 0; !o[f] && f < a; ++f)
        l[f] = t[f], u[f] = f;
      for (d = f; f < a; ++f)
        c = t[f], o[f] ? u[f] = -1 : (u[f] = d, i[d] = i[f], r[d] = r[f], l[d] = c, c._index = d++), i[f] = 0;
      return t = l, u;
    },
    size: () => t.length,
    curr: () => i,
    prev: () => r,
    reset: (s) => r[s] = i[s],
    all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
    set(s, o) {
      i[s] |= o;
    },
    clear(s, o) {
      i[s] &= ~o;
    },
    resize(s, o) {
      const a = i.length;
      (s > a || o > e) && (e = Math.max(o, e), i = hh(s, e, i), r = hh(s, e));
    }
  };
}
function FJ(e, t, n) {
  return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n);
}
function hh(e, t, n) {
  const i = (t < 257 ? CJ : t < 65537 ? $J : cf)(e);
  return n && i.set(n), i;
}
function OC(e, t, n) {
  const i = 1 << t;
  return {
    one: i,
    zero: ~i,
    range: n.slice(),
    bisect: e.bisect,
    index: e.index,
    size: e.size,
    onAdd(r, s) {
      const o = this, a = o.bisect(o.range, r.value), l = r.index, u = a[0], c = a[1], f = l.length;
      let d;
      for (d = 0; d < u; ++d)
        s[l[d]] |= i;
      for (d = c; d < f; ++d)
        s[l[d]] |= i;
      return o;
    }
  };
}
function NC() {
  let e = cf(0), t = [], n = 0;
  function i(a, l, u) {
    if (!l.length)
      return [];
    const c = n, f = l.length, d = cf(f);
    let h = Array(f), g, p, m;
    for (m = 0; m < f; ++m)
      h[m] = a(l[m]), d[m] = m;
    if (h = TJ(h, d), c)
      g = t, p = e, t = Array(c + f), e = cf(c + f), OJ(u, g, p, c, h, d, f, t, e);
    else {
      if (u > 0)
        for (m = 0; m < f; ++m)
          d[m] += u;
      t = h, e = d;
    }
    return n = c + f, {
      index: d,
      value: h
    };
  }
  function r(a, l) {
    const u = n;
    let c, f, d;
    for (f = 0; !l[e[f]] && f < u; ++f)
      ;
    for (d = f; f < u; ++f)
      l[c = e[f]] || (e[d] = c, t[d] = t[f], ++d);
    n = u - a;
  }
  function s(a) {
    for (let l = 0, u = n; l < u; ++l)
      e[l] = a[e[l]];
  }
  function o(a, l) {
    let u;
    return l ? u = l.length : (l = t, u = n), [GI(l, a[0], 0, u), fo(l, a[1], 0, u)];
  }
  return {
    insert: i,
    remove: r,
    bisect: o,
    reindex: s,
    index: () => e,
    size: () => n
  };
}
function TJ(e, t) {
  return e.sort.call(t, (n, i) => {
    const r = e[n], s = e[i];
    return r < s ? -1 : r > s ? 1 : 0;
  }), XI(e, t);
}
function OJ(e, t, n, i, r, s, o, a, l) {
  let u = 0, c = 0, f;
  for (f = 0; u < i && c < o; ++f)
    t[u] < r[c] ? (a[f] = t[u], l[f] = n[u++]) : (a[f] = r[c], l[f] = s[c++] + e);
  for (; u < i; ++u, ++f)
    a[f] = t[u], l[f] = n[u];
  for (; c < o; ++c, ++f)
    a[f] = r[c], l[f] = s[c] + e;
}
function s_(e) {
  P.call(this, MJ(), e), this._indices = null, this._dims = null;
}
s_.Definition = {
  type: "CrossFilter",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "query",
    type: "array",
    array: !0,
    required: !0,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }]
};
Y(s_, P, {
  transform(e, t) {
    if (this._dims) {
      var n = e.modified("fields") || e.fields.some((i) => t.modified(i.fields));
      return n ? this.reinit(e, t) : this.eval(e, t);
    } else
      return this.init(e, t);
  },
  init(e, t) {
    const n = e.fields, i = e.query, r = this._indices = {}, s = this._dims = [], o = i.length;
    let a = 0, l, u;
    for (; a < o; ++a)
      l = n[a].fname, u = r[l] || (r[l] = NC()), s.push(OC(u, a, i[a]));
    return this.eval(e, t);
  },
  reinit(e, t) {
    const n = t.materialize().fork(), i = e.fields, r = e.query, s = this._indices, o = this._dims, a = this.value, l = a.curr(), u = a.prev(), c = a.all(), f = n.rem = n.add, d = n.mod, h = r.length, g = {};
    let p, m, y, b, v, w, _, S, E;
    if (u.set(l), t.rem.length && (v = this.remove(e, t, n)), t.add.length && a.add(t.add), t.mod.length)
      for (w = {}, b = t.mod, _ = 0, S = b.length; _ < S; ++_)
        w[b[_]._index] = 1;
    for (_ = 0; _ < h; ++_)
      E = i[_], (!o[_] || e.modified("fields", _) || t.modified(E.fields)) && (y = E.fname, (p = g[y]) || (s[y] = m = NC(), g[y] = p = m.insert(E, t.source, 0)), o[_] = OC(m, _, r[_]).onAdd(p, l));
    for (_ = 0, S = a.data().length; _ < S; ++_)
      v[_] || (u[_] !== l[_] ? f.push(_) : w[_] && l[_] !== c && d.push(_));
    return a.mask = (1 << h) - 1, n;
  },
  eval(e, t) {
    const n = t.materialize().fork(), i = this._dims.length;
    let r = 0;
    return t.rem.length && (this.remove(e, t, n), r |= (1 << i) - 1), e.modified("query") && !e.modified("fields") && (r |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), r |= (1 << i) - 1), t.mod.length && (this.modify(t, n), r |= (1 << i) - 1), this.value.mask = r, n;
  },
  insert(e, t, n) {
    const i = t.add, r = this.value, s = this._dims, o = this._indices, a = e.fields, l = {}, u = n.add, c = r.size() + i.length, f = s.length;
    let d = r.size(), h, g, p;
    r.resize(c, f), r.add(i);
    const m = r.curr(), y = r.prev(), b = r.all();
    for (h = 0; h < f; ++h)
      g = a[h].fname, p = l[g] || (l[g] = o[g].insert(a[h], i, d)), s[h].onAdd(p, m);
    for (; d < c; ++d)
      y[d] = b, m[d] !== b && u.push(d);
  },
  modify(e, t) {
    const n = t.mod, i = this.value, r = i.curr(), s = i.all(), o = e.mod;
    let a, l, u;
    for (a = 0, l = o.length; a < l; ++a)
      u = o[a]._index, r[u] !== s && n.push(u);
  },
  remove(e, t, n) {
    const i = this._indices, r = this.value, s = r.curr(), o = r.prev(), a = r.all(), l = {}, u = n.rem, c = t.rem;
    let f, d, h, g;
    for (f = 0, d = c.length; f < d; ++f)
      h = c[f]._index, l[h] = 1, o[h] = g = s[h], s[h] = a, g !== a && u.push(h);
    for (h in i)
      i[h].remove(d, l);
    return this.reindex(t, d, l), l;
  },
  // reindex filters and indices after propagation completes
  reindex(e, t, n) {
    const i = this._indices, r = this.value;
    e.runAfter(() => {
      const s = r.remove(t, n);
      for (const o in i)
        i[o].reindex(s);
    });
  },
  update(e, t, n) {
    const i = this._dims, r = e.query, s = t.stamp, o = i.length;
    let a = 0, l, u;
    for (n.filters = 0, u = 0; u < o; ++u)
      e.modified("query", u) && (l = u, ++a);
    if (a === 1)
      a = i[l].one, this.incrementOne(i[l], r[l], n.add, n.rem);
    else
      for (u = 0, a = 0; u < o; ++u)
        e.modified("query", u) && (a |= i[u].one, this.incrementAll(i[u], r[u], s, n.add), n.rem = n.add);
    return a;
  },
  incrementAll(e, t, n, i) {
    const r = this.value, s = r.seen(), o = r.curr(), a = r.prev(), l = e.index(), u = e.bisect(e.range), c = e.bisect(t), f = c[0], d = c[1], h = u[0], g = u[1], p = e.one;
    let m, y, b;
    if (f < h)
      for (m = f, y = Math.min(h, d); m < y; ++m)
        b = l[m], s[b] !== n && (a[b] = o[b], s[b] = n, i.push(b)), o[b] ^= p;
    else if (f > h)
      for (m = h, y = Math.min(f, g); m < y; ++m)
        b = l[m], s[b] !== n && (a[b] = o[b], s[b] = n, i.push(b)), o[b] ^= p;
    if (d > g)
      for (m = Math.max(f, g), y = d; m < y; ++m)
        b = l[m], s[b] !== n && (a[b] = o[b], s[b] = n, i.push(b)), o[b] ^= p;
    else if (d < g)
      for (m = Math.max(h, d), y = g; m < y; ++m)
        b = l[m], s[b] !== n && (a[b] = o[b], s[b] = n, i.push(b)), o[b] ^= p;
    e.range = t.slice();
  },
  incrementOne(e, t, n, i) {
    const r = this.value, s = r.curr(), o = e.index(), a = e.bisect(e.range), l = e.bisect(t), u = l[0], c = l[1], f = a[0], d = a[1], h = e.one;
    let g, p, m;
    if (u < f)
      for (g = u, p = Math.min(f, c); g < p; ++g)
        m = o[g], s[m] ^= h, n.push(m);
    else if (u > f)
      for (g = f, p = Math.min(u, d); g < p; ++g)
        m = o[g], s[m] ^= h, i.push(m);
    if (c > d)
      for (g = Math.max(u, d), p = c; g < p; ++g)
        m = o[g], s[m] ^= h, n.push(m);
    else if (c < d)
      for (g = Math.max(f, c), p = d; g < p; ++g)
        m = o[g], s[m] ^= h, i.push(m);
    e.range = t.slice();
  }
});
function o_(e) {
  P.call(this, null, e);
}
o_.Definition = {
  type: "ResolveFilter",
  metadata: {},
  params: [{
    name: "ignore",
    type: "number",
    required: !0,
    description: "A bit mask indicating which filters to ignore."
  }, {
    name: "filter",
    type: "object",
    required: !0,
    description: "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
Y(o_, P, {
  transform(e, t) {
    const n = ~(e.ignore || 0), i = e.filter, r = i.mask;
    if (!(r & n))
      return t.StopPropagation;
    const s = t.fork(t.ALL), o = i.data(), a = i.curr(), l = i.prev(), u = (c) => a[c] & n ? null : o[c];
    return s.filter(s.MOD, u), r & r - 1 ? (s.filter(s.ADD, (c) => {
      const f = a[c] & n;
      return !f && f ^ l[c] & n ? o[c] : null;
    }), s.filter(s.REM, (c) => {
      const f = a[c] & n;
      return f && !(f ^ (f ^ l[c] & n)) ? o[c] : null;
    })) : (s.filter(s.ADD, u), s.filter(s.REM, (c) => (a[c] & n) === r ? o[c] : null)), s.filter(s.SOURCE, (c) => u(c._index));
  }
});
const NJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crossfilter: s_,
  resolvefilter: o_
}, Symbol.toStringTag, { value: "Module" })), DJ = "RawCode", La = "Literal", RJ = "Property", LJ = "Identifier", PJ = "ArrayExpression", IJ = "BinaryExpression", kR = "CallExpression", zJ = "ConditionalExpression", BJ = "LogicalExpression", jJ = "MemberExpression", UJ = "ObjectExpression", qJ = "UnaryExpression";
function nr(e) {
  this.type = e;
}
nr.prototype.visit = function(e) {
  let t, n, i;
  if (e(this))
    return 1;
  for (t = WJ(this), n = 0, i = t.length; n < i; ++n)
    if (t[n].visit(e))
      return 1;
};
function WJ(e) {
  switch (e.type) {
    case PJ:
      return e.elements;
    case IJ:
    case BJ:
      return [e.left, e.right];
    case kR:
      return [e.callee].concat(e.arguments);
    case zJ:
      return [e.test, e.consequent, e.alternate];
    case jJ:
      return [e.object, e.property];
    case UJ:
      return e.properties;
    case RJ:
      return [e.key, e.value];
    case qJ:
      return [e.argument];
    case LJ:
    case La:
    case DJ:
    default:
      return [];
  }
}
var jr, se, z, rn, qe, Bm = 1, _d = 2, Pa = 3, Lo = 4, jm = 5, rl = 6, $n = 7, Ed = 8, HJ = 9;
jr = {};
jr[Bm] = "Boolean";
jr[_d] = "<end>";
jr[Pa] = "Identifier";
jr[Lo] = "Keyword";
jr[jm] = "Null";
jr[rl] = "Numeric";
jr[$n] = "Punctuator";
jr[Ed] = "String";
jr[HJ] = "RegularExpression";
var GJ = "ArrayExpression", VJ = "BinaryExpression", YJ = "CallExpression", XJ = "ConditionalExpression", AR = "Identifier", KJ = "Literal", JJ = "LogicalExpression", QJ = "MemberExpression", ZJ = "ObjectExpression", eQ = "Property", tQ = "UnaryExpression", Ft = "Unexpected token %0", nQ = "Unexpected number", iQ = "Unexpected string", rQ = "Unexpected identifier", sQ = "Unexpected reserved word", oQ = "Unexpected end of input", Kb = "Invalid regular expression", W1 = "Invalid regular expression: missing /", CR = "Octal literals are not allowed in strict mode.", aQ = "Duplicate data property in object literal not allowed in strict mode", jt = "ILLEGAL", If = "Disabled.", lQ = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), uQ = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function Um(e, t) {
  if (!e)
    throw new Error("ASSERT: " + t);
}
function is(e) {
  return e >= 48 && e <= 57;
}
function a_(e) {
  return "0123456789abcdefABCDEF".indexOf(e) >= 0;
}
function ff(e) {
  return "01234567".indexOf(e) >= 0;
}
function cQ(e) {
  return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0;
}
function zf(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function Sd(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e === 92 || // \ (backslash)
  e >= 128 && lQ.test(String.fromCharCode(e));
}
function dp(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e >= 48 && e <= 57 || // 0..9
  e === 92 || // \ (backslash)
  e >= 128 && uQ.test(String.fromCharCode(e));
}
const fQ = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function $R() {
  for (; z < rn; ) {
    const e = se.charCodeAt(z);
    if (cQ(e) || zf(e))
      ++z;
    else
      break;
  }
}
function Jb(e) {
  var t, n, i, r = 0;
  for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
    z < rn && a_(se[z]) ? (i = se[z++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Le({}, Ft, jt);
  return String.fromCharCode(r);
}
function dQ() {
  var e, t, n, i;
  for (e = se[z], t = 0, e === "}" && Le({}, Ft, jt); z < rn && (e = se[z++], !!a_(e)); )
    t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
  return (t > 1114111 || e !== "}") && Le({}, Ft, jt), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
}
function MR() {
  var e, t;
  for (e = se.charCodeAt(z++), t = String.fromCharCode(e), e === 92 && (se.charCodeAt(z) !== 117 && Le({}, Ft, jt), ++z, e = Jb("u"), (!e || e === "\\" || !Sd(e.charCodeAt(0))) && Le({}, Ft, jt), t = e); z < rn && (e = se.charCodeAt(z), !!dp(e)); )
    ++z, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), se.charCodeAt(z) !== 117 && Le({}, Ft, jt), ++z, e = Jb("u"), (!e || e === "\\" || !dp(e.charCodeAt(0))) && Le({}, Ft, jt), t += e);
  return t;
}
function hQ() {
  var e, t;
  for (e = z++; z < rn; ) {
    if (t = se.charCodeAt(z), t === 92)
      return z = e, MR();
    if (dp(t))
      ++z;
    else
      break;
  }
  return se.slice(e, z);
}
function gQ() {
  var e, t, n;
  return e = z, t = se.charCodeAt(z) === 92 ? MR() : hQ(), t.length === 1 ? n = Pa : fQ.hasOwnProperty(t) ? n = Lo : t === "null" ? n = jm : t === "true" || t === "false" ? n = Bm : n = Pa, {
    type: n,
    value: t,
    start: e,
    end: z
  };
}
function H1() {
  var e = z, t = se.charCodeAt(z), n, i = se[z], r, s, o;
  switch (t) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      return ++z, {
        type: $n,
        value: String.fromCharCode(t),
        start: e,
        end: z
      };
    default:
      if (n = se.charCodeAt(z + 1), n === 61)
        switch (t) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            return z += 2, {
              type: $n,
              value: String.fromCharCode(t) + String.fromCharCode(n),
              start: e,
              end: z
            };
          case 33:
          case 61:
            return z += 2, se.charCodeAt(z) === 61 && ++z, {
              type: $n,
              value: se.slice(e, z),
              start: e,
              end: z
            };
        }
  }
  if (o = se.substr(z, 4), o === ">>>=")
    return z += 4, {
      type: $n,
      value: o,
      start: e,
      end: z
    };
  if (s = o.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=")
    return z += 3, {
      type: $n,
      value: s,
      start: e,
      end: z
    };
  if (r = s.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>")
    return z += 2, {
      type: $n,
      value: r,
      start: e,
      end: z
    };
  if (r === "//" && Le({}, Ft, jt), "<>=!+-*%&|^/".indexOf(i) >= 0)
    return ++z, {
      type: $n,
      value: i,
      start: e,
      end: z
    };
  Le({}, Ft, jt);
}
function pQ(e) {
  let t = "";
  for (; z < rn && a_(se[z]); )
    t += se[z++];
  return t.length === 0 && Le({}, Ft, jt), Sd(se.charCodeAt(z)) && Le({}, Ft, jt), {
    type: rl,
    value: parseInt("0x" + t, 16),
    start: e,
    end: z
  };
}
function mQ(e) {
  let t = "0" + se[z++];
  for (; z < rn && ff(se[z]); )
    t += se[z++];
  return (Sd(se.charCodeAt(z)) || is(se.charCodeAt(z))) && Le({}, Ft, jt), {
    type: rl,
    value: parseInt(t, 8),
    octal: !0,
    start: e,
    end: z
  };
}
function DC() {
  var e, t, n;
  if (n = se[z], Um(is(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = z, e = "", n !== ".") {
    if (e = se[z++], n = se[z], e === "0") {
      if (n === "x" || n === "X")
        return ++z, pQ(t);
      if (ff(n))
        return mQ(t);
      n && is(n.charCodeAt(0)) && Le({}, Ft, jt);
    }
    for (; is(se.charCodeAt(z)); )
      e += se[z++];
    n = se[z];
  }
  if (n === ".") {
    for (e += se[z++]; is(se.charCodeAt(z)); )
      e += se[z++];
    n = se[z];
  }
  if (n === "e" || n === "E")
    if (e += se[z++], n = se[z], (n === "+" || n === "-") && (e += se[z++]), is(se.charCodeAt(z)))
      for (; is(se.charCodeAt(z)); )
        e += se[z++];
    else
      Le({}, Ft, jt);
  return Sd(se.charCodeAt(z)) && Le({}, Ft, jt), {
    type: rl,
    value: parseFloat(e),
    start: t,
    end: z
  };
}
function yQ() {
  var e = "", t, n, i, r, s = !1;
  for (t = se[z], Um(t === "'" || t === '"', "String literal must starts with a quote"), n = z, ++z; z < rn; )
    if (i = se[z++], i === t) {
      t = "";
      break;
    } else if (i === "\\")
      if (i = se[z++], !i || !zf(i.charCodeAt(0)))
        switch (i) {
          case "u":
          case "x":
            se[z] === "{" ? (++z, e += dQ()) : e += Jb(i);
            break;
          case "n":
            e += `
`;
            break;
          case "r":
            e += "\r";
            break;
          case "t":
            e += "	";
            break;
          case "b":
            e += "\b";
            break;
          case "f":
            e += "\f";
            break;
          case "v":
            e += "\v";
            break;
          default:
            ff(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), z < rn && ff(se[z]) && (s = !0, r = r * 8 + "01234567".indexOf(se[z++]), "0123".indexOf(i) >= 0 && z < rn && ff(se[z]) && (r = r * 8 + "01234567".indexOf(se[z++]))), e += String.fromCharCode(r)) : e += i;
            break;
        }
      else
        i === "\r" && se[z] === `
` && ++z;
    else {
      if (zf(i.charCodeAt(0)))
        break;
      e += i;
    }
  return t !== "" && Le({}, Ft, jt), {
    type: Ed,
    value: e,
    octal: s,
    start: n,
    end: z
  };
}
function bQ(e, t) {
  let n = e;
  t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
    if (parseInt(r, 16) <= 1114111)
      return "x";
    Le({}, Kb);
  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
  try {
    new RegExp(n);
  } catch {
    Le({}, Kb);
  }
  try {
    return new RegExp(e, t);
  } catch {
    return null;
  }
}
function vQ() {
  var e, t, n, i, r;
  for (e = se[z], Um(e === "/", "Regular expression literal must start with a slash"), t = se[z++], n = !1, i = !1; z < rn; )
    if (e = se[z++], t += e, e === "\\")
      e = se[z++], zf(e.charCodeAt(0)) && Le({}, W1), t += e;
    else if (zf(e.charCodeAt(0)))
      Le({}, W1);
    else if (n)
      e === "]" && (n = !1);
    else if (e === "/") {
      i = !0;
      break;
    } else
      e === "[" && (n = !0);
  return i || Le({}, W1), r = t.substr(1, t.length - 2), {
    value: r,
    literal: t
  };
}
function xQ() {
  var e, t, n;
  for (t = "", n = ""; z < rn && (e = se[z], !!dp(e.charCodeAt(0))); )
    ++z, e === "\\" && z < rn ? Le({}, Ft, jt) : (n += e, t += e);
  return n.search(/[^gimuy]/g) >= 0 && Le({}, Kb, n), {
    value: n,
    literal: t
  };
}
function wQ() {
  var e, t, n, i;
  return qe = null, $R(), e = z, t = vQ(), n = xQ(), i = bQ(t.value, n.value), {
    literal: t.literal + n.literal,
    value: i,
    regex: {
      pattern: t.value,
      flags: n.value
    },
    start: e,
    end: z
  };
}
function _Q(e) {
  return e.type === Pa || e.type === Lo || e.type === Bm || e.type === jm;
}
function FR() {
  if ($R(), z >= rn)
    return {
      type: _d,
      start: z,
      end: z
    };
  const e = se.charCodeAt(z);
  return Sd(e) ? gQ() : e === 40 || e === 41 || e === 59 ? H1() : e === 39 || e === 34 ? yQ() : e === 46 ? is(se.charCodeAt(z + 1)) ? DC() : H1() : is(e) ? DC() : H1();
}
function Tn() {
  const e = qe;
  return z = e.end, qe = FR(), z = e.end, e;
}
function TR() {
  const e = z;
  qe = FR(), z = e;
}
function EQ(e) {
  const t = new nr(GJ);
  return t.elements = e, t;
}
function RC(e, t, n) {
  const i = new nr(e === "||" || e === "&&" ? JJ : VJ);
  return i.operator = e, i.left = t, i.right = n, i;
}
function SQ(e, t) {
  const n = new nr(YJ);
  return n.callee = e, n.arguments = t, n;
}
function kQ(e, t, n) {
  const i = new nr(XJ);
  return i.test = e, i.consequent = t, i.alternate = n, i;
}
function l_(e) {
  const t = new nr(AR);
  return t.name = e, t;
}
function Kc(e) {
  const t = new nr(KJ);
  return t.value = e.value, t.raw = se.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
}
function LC(e, t, n) {
  const i = new nr(QJ);
  return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i;
}
function AQ(e) {
  const t = new nr(ZJ);
  return t.properties = e, t;
}
function PC(e, t, n) {
  const i = new nr(eQ);
  return i.key = t, i.value = n, i.kind = e, i;
}
function CQ(e, t) {
  const n = new nr(tQ);
  return n.operator = e, n.argument = t, n.prefix = !0, n;
}
function Le(e, t) {
  var n, i = Array.prototype.slice.call(arguments, 2), r = t.replace(/%(\d)/g, (s, o) => (Um(o < i.length, "Message reference must be in range"), i[o]));
  throw n = new Error(r), n.index = z, n.description = r, n;
}
function qm(e) {
  e.type === _d && Le(e, oQ), e.type === rl && Le(e, nQ), e.type === Ed && Le(e, iQ), e.type === Pa && Le(e, rQ), e.type === Lo && Le(e, sQ), Le(e, Ft, e.value);
}
function sn(e) {
  const t = Tn();
  (t.type !== $n || t.value !== e) && qm(t);
}
function Je(e) {
  return qe.type === $n && qe.value === e;
}
function G1(e) {
  return qe.type === Lo && qe.value === e;
}
function $Q() {
  const e = [];
  for (z = qe.start, sn("["); !Je("]"); )
    Je(",") ? (Tn(), e.push(null)) : (e.push(Ia()), Je("]") || sn(","));
  return Tn(), EQ(e);
}
function IC() {
  z = qe.start;
  const e = Tn();
  return e.type === Ed || e.type === rl ? (e.octal && Le(e, CR), Kc(e)) : l_(e.value);
}
function MQ() {
  var e, t, n, i;
  if (z = qe.start, e = qe, e.type === Pa)
    return n = IC(), sn(":"), i = Ia(), PC("init", n, i);
  if (e.type === _d || e.type === $n)
    qm(e);
  else
    return t = IC(), sn(":"), i = Ia(), PC("init", t, i);
}
function FQ() {
  var e = [], t, n, i, r = {}, s = String;
  for (z = qe.start, sn("{"); !Je("}"); )
    t = MQ(), t.key.type === AR ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Le({}, aQ) : r[i] = !0, e.push(t), Je("}") || sn(",");
  return sn("}"), AQ(e);
}
function TQ() {
  sn("(");
  const e = u_();
  return sn(")"), e;
}
const OQ = {
  if: 1
};
function NQ() {
  var e, t, n;
  if (Je("("))
    return TQ();
  if (Je("["))
    return $Q();
  if (Je("{"))
    return FQ();
  if (e = qe.type, z = qe.start, e === Pa || OQ[qe.value])
    n = l_(Tn().value);
  else if (e === Ed || e === rl)
    qe.octal && Le(qe, CR), n = Kc(Tn());
  else {
    if (e === Lo)
      throw new Error(If);
    e === Bm ? (t = Tn(), t.value = t.value === "true", n = Kc(t)) : e === jm ? (t = Tn(), t.value = null, n = Kc(t)) : Je("/") || Je("/=") ? (n = Kc(wQ()), TR()) : qm(Tn());
  }
  return n;
}
function DQ() {
  const e = [];
  if (sn("("), !Je(")"))
    for (; z < rn && (e.push(Ia()), !Je(")")); )
      sn(",");
  return sn(")"), e;
}
function RQ() {
  z = qe.start;
  const e = Tn();
  return _Q(e) || qm(e), l_(e.value);
}
function LQ() {
  return sn("."), RQ();
}
function PQ() {
  sn("[");
  const e = u_();
  return sn("]"), e;
}
function IQ() {
  var e, t, n;
  for (e = NQ(); ; )
    if (Je("."))
      n = LQ(), e = LC(".", e, n);
    else if (Je("("))
      t = DQ(), e = SQ(e, t);
    else if (Je("["))
      n = PQ(), e = LC("[", e, n);
    else
      break;
  return e;
}
function zC() {
  const e = IQ();
  if (qe.type === $n && (Je("++") || Je("--")))
    throw new Error(If);
  return e;
}
function Yh() {
  var e, t;
  if (qe.type !== $n && qe.type !== Lo)
    t = zC();
  else {
    if (Je("++") || Je("--"))
      throw new Error(If);
    if (Je("+") || Je("-") || Je("~") || Je("!"))
      e = Tn(), t = Yh(), t = CQ(e.value, t);
    else {
      if (G1("delete") || G1("void") || G1("typeof"))
        throw new Error(If);
      t = zC();
    }
  }
  return t;
}
function BC(e) {
  let t = 0;
  if (e.type !== $n && e.type !== Lo)
    return 0;
  switch (e.value) {
    case "||":
      t = 1;
      break;
    case "&&":
      t = 2;
      break;
    case "|":
      t = 3;
      break;
    case "^":
      t = 4;
      break;
    case "&":
      t = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      t = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      t = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      t = 8;
      break;
    case "+":
    case "-":
      t = 9;
      break;
    case "*":
    case "/":
    case "%":
      t = 11;
      break;
  }
  return t;
}
function zQ() {
  var e, t, n, i, r, s, o, a, l, u;
  if (e = qe, l = Yh(), i = qe, r = BC(i), r === 0)
    return l;
  for (i.prec = r, Tn(), t = [e, qe], o = Yh(), s = [l, i, o]; (r = BC(qe)) > 0; ) {
    for (; s.length > 2 && r <= s[s.length - 2].prec; )
      o = s.pop(), a = s.pop().value, l = s.pop(), t.pop(), n = RC(a, l, o), s.push(n);
    i = Tn(), i.prec = r, s.push(i), t.push(qe), n = Yh(), s.push(n);
  }
  for (u = s.length - 1, n = s[u], t.pop(); u > 1; )
    t.pop(), n = RC(s[u - 1].value, s[u - 2], n), u -= 2;
  return n;
}
function Ia() {
  var e, t, n;
  return e = zQ(), Je("?") && (Tn(), t = Ia(), sn(":"), n = Ia(), e = kQ(e, t, n)), e;
}
function u_() {
  const e = Ia();
  if (Je(","))
    throw new Error(If);
  return e;
}
function c_(e) {
  se = e, z = 0, rn = se.length, qe = null, TR();
  const t = u_();
  if (qe.type !== _d)
    throw new Error("Unexpect token after expression.");
  return t;
}
var OR = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function NR(e) {
  function t(o, a, l, u) {
    let c = e(a[0]);
    return l && (c = l + "(" + c + ")", l.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + o + (u < 0 ? "" : u === 0 ? "()" : "(" + a.slice(1).map(e).join(",") + ")");
  }
  function n(o, a, l) {
    return (u) => t(o, u, a, l);
  }
  const i = "new Date", r = "String", s = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(o) {
      o.length < 3 && B("Missing arguments to clamp function."), o.length > 3 && B("Too many arguments to clamp function.");
      const a = o.map(e);
      return "Math.max(" + a[1] + ", Math.min(" + a[2] + "," + a[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: i,
    date: n("getDate", i, 0),
    day: n("getDay", i, 0),
    year: n("getFullYear", i, 0),
    month: n("getMonth", i, 0),
    hours: n("getHours", i, 0),
    minutes: n("getMinutes", i, 0),
    seconds: n("getSeconds", i, 0),
    milliseconds: n("getMilliseconds", i, 0),
    time: n("getTime", i, 0),
    timezoneoffset: n("getTimezoneOffset", i, 0),
    utcdate: n("getUTCDate", i, 0),
    utcday: n("getUTCDay", i, 0),
    utcyear: n("getUTCFullYear", i, 0),
    utcmonth: n("getUTCMonth", i, 0),
    utchours: n("getUTCHours", i, 0),
    utcminutes: n("getUTCMinutes", i, 0),
    utcseconds: n("getUTCSeconds", i, 0),
    utcmilliseconds: n("getUTCMilliseconds", i, 0),
    // sequence functions
    length: n("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: n("toUpperCase", r, 0),
    lower: n("toLowerCase", r, 0),
    substring: n("substring", r),
    split: n("split", r),
    trim: n("trim", r, 0),
    // REGEXP functions
    regexp: s,
    test: n("test", s),
    // Control Flow functions
    if: function(o) {
      o.length < 3 && B("Missing arguments to if function."), o.length > 3 && B("Too many arguments to if function.");
      const a = o.map(e);
      return "(" + a[0] + "?" + a[1] + ":" + a[2] + ")";
    }
  };
}
function BQ(e) {
  const t = e && e.length - 1;
  return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e;
}
function DR(e) {
  e = e || {};
  const t = e.allowed ? Ji(e.allowed) : {}, n = e.forbidden ? Ji(e.forbidden) : {}, i = e.constants || OR, r = (e.functions || NR)(f), s = e.globalvar, o = e.fieldvar, a = Ee(s) ? s : (g) => `${s}["${g}"]`;
  let l = {}, u = {}, c = 0;
  function f(g) {
    if (Q(g))
      return g;
    const p = d[g.type];
    return p == null && B("Unsupported type: " + g.type), p(g);
  }
  const d = {
    Literal: (g) => g.raw,
    Identifier: (g) => {
      const p = g.name;
      return c > 0 ? p : ce(n, p) ? B("Illegal identifier: " + p) : ce(i, p) ? i[p] : ce(t, p) ? p : (l[p] = 1, a(p));
    },
    MemberExpression: (g) => {
      const p = !g.computed, m = f(g.object);
      p && (c += 1);
      const y = f(g.property);
      return m === o && (u[BQ(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]");
    },
    CallExpression: (g) => {
      g.callee.type !== "Identifier" && B("Illegal callee type: " + g.callee.type);
      const p = g.callee.name, m = g.arguments, y = ce(r, p) && r[p];
      return y || B("Unrecognized function: " + p), Ee(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
    },
    ArrayExpression: (g) => "[" + g.elements.map(f).join(",") + "]",
    BinaryExpression: (g) => "(" + f(g.left) + " " + g.operator + " " + f(g.right) + ")",
    UnaryExpression: (g) => "(" + g.operator + f(g.argument) + ")",
    ConditionalExpression: (g) => "(" + f(g.test) + "?" + f(g.consequent) + ":" + f(g.alternate) + ")",
    LogicalExpression: (g) => "(" + f(g.left) + g.operator + f(g.right) + ")",
    ObjectExpression: (g) => "{" + g.properties.map(f).join(",") + "}",
    Property: (g) => {
      c += 1;
      const p = f(g.key);
      return c -= 1, p + ":" + f(g.value);
    }
  };
  function h(g) {
    const p = {
      code: f(g),
      globals: Object.keys(l),
      fields: Object.keys(u)
    };
    return l = {}, u = {}, p;
  }
  return h.functions = r, h.constants = i, h;
}
const jC = Symbol("vega_selection_getter");
function RR(e) {
  return (!e.getter || !e.getter[jC]) && (e.getter = _i(e.field), e.getter[jC] = !0), e.getter;
}
const f_ = "intersect", UC = "union", jQ = "vlMulti", UQ = "vlPoint", qC = "or", qQ = "and", mr = "_vgsid_", Bf = _i(mr), WQ = "E", HQ = "R", GQ = "R-E", VQ = "R-LE", YQ = "R-RE", hp = "index:unit";
function WC(e, t) {
  for (var n = t.fields, i = t.values, r = n.length, s = 0, o, a; s < r; ++s)
    if (a = n[s], o = RR(a)(e), so(o) && (o = Qt(o)), so(i[s]) && (i[s] = Qt(i[s])), j(i[s]) && so(i[s][0]) && (i[s] = i[s].map(Qt)), a.type === WQ) {
      if (j(i[s]) ? i[s].indexOf(o) < 0 : o !== i[s])
        return !1;
    } else if (a.type === HQ) {
      if (!Dl(o, i[s]))
        return !1;
    } else if (a.type === YQ) {
      if (!Dl(o, i[s], !0, !1))
        return !1;
    } else if (a.type === GQ) {
      if (!Dl(o, i[s], !1, !1))
        return !1;
    } else if (a.type === VQ && !Dl(o, i[s], !1, !0))
      return !1;
  return !0;
}
function XQ(e, t, n) {
  for (var i = this.context.data[e], r = i ? i.values.value : [], s = i ? i[hp] && i[hp].value : void 0, o = n === f_, a = r.length, l = 0, u, c, f, d, h; l < a; ++l)
    if (u = r[l], s && o) {
      if (c = c || {}, f = c[d = u.unit] || 0, f === -1)
        continue;
      if (h = WC(t, u), c[d] = h ? -1 : ++f, h && s.size === 1)
        return !0;
      if (!h && f === s.get(d).count)
        return !1;
    } else if (h = WC(t, u), o ^ h)
      return h;
  return a && o;
}
const LR = Pu(Bf), KQ = LR.left, JQ = LR.right;
function QQ(e, t, n) {
  const i = this.context.data[e], r = i ? i.values.value : [], s = i ? i[hp] && i[hp].value : void 0, o = n === f_, a = Bf(t), l = KQ(r, a);
  if (l === r.length || Bf(r[l]) !== a)
    return !1;
  if (s && o) {
    if (s.size === 1)
      return !0;
    if (JQ(r, a) - l < s.size)
      return !1;
  }
  return !0;
}
function ZQ(e, t) {
  return e.map((n) => we(t.fields ? {
    values: t.fields.map((i) => RR(i)(n.datum))
  } : {
    [mr]: Bf(n.datum)
  }, t));
}
function eZ(e, t, n, i) {
  for (var r = this.context.data[e], s = r ? r.values.value : [], o = {}, a = {}, l = {}, u, c, f, d, h, g, p, m, y, b, v = s.length, w = 0, _, S; w < v; ++w)
    if (u = s[w], d = u.unit, c = u.fields, f = u.values, c && f) {
      for (_ = 0, S = c.length; _ < S; ++_)
        h = c[_], p = o[h.field] || (o[h.field] = {}), m = p[d] || (p[d] = []), l[h.field] = y = h.type.charAt(0), b = V1[`${y}_union`], p[d] = b(m, J(f[_]));
      n && (m = a[d] || (a[d] = []), m.push(J(f).reduce((E, C, $) => (E[c[$].field] = C, E), {})));
    } else
      h = mr, g = Bf(u), p = o[h] || (o[h] = {}), m = p[d] || (p[d] = []), m.push(g), n && (m = a[d] || (a[d] = []), m.push({
        [mr]: g
      }));
  if (t = t || UC, o[mr] ? o[mr] = V1[`${mr}_${t}`](...Object.values(o[mr])) : Object.keys(o).forEach((E) => {
    o[E] = Object.keys(o[E]).map((C) => o[E][C]).reduce((C, $) => C === void 0 ? $ : V1[`${l[E]}_${t}`](C, $));
  }), s = Object.keys(a), n && s.length) {
    const E = i ? UQ : jQ;
    o[E] = t === UC ? {
      [qC]: s.reduce((C, $) => (C.push(...a[$]), C), [])
    } : {
      [qQ]: s.map((C) => ({
        [qC]: a[C]
      }))
    };
  }
  return o;
}
var V1 = {
  [`${mr}_union`]: r9,
  [`${mr}_intersect`]: n9,
  E_union: function(e, t) {
    if (!e.length)
      return t;
    for (var n = 0, i = t.length; n < i; ++n)
      e.indexOf(t[n]) < 0 && e.push(t[n]);
    return e;
  },
  E_intersect: function(e, t) {
    return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
  },
  R_union: function(e, t) {
    var n = Qt(t[0]), i = Qt(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
  },
  R_intersect: function(e, t) {
    var n = Qt(t[0]), i = Qt(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
  }
};
const tZ = ":", nZ = "@";
function d_(e, t, n, i) {
  t[0].type !== La && B("First argument to selection functions must be a string literal.");
  const r = t[0].value, s = t.length >= 2 && Oe(t).value, o = "unit", a = nZ + o, l = tZ + r;
  s === f_ && !ce(i, a) && (i[a] = n.getData(r).indataRef(n, o)), ce(i, l) || (i[l] = n.getData(r).tuplesRef());
}
function PR(e) {
  const t = this.context.data[e];
  return t ? t.values.value : [];
}
function iZ(e, t, n) {
  const i = this.context.data[e]["index:" + t], r = i ? i.value.get(n) : void 0;
  return r && r.count;
}
function rZ(e, t) {
  const n = this.context.dataflow, i = this.context.data[e], r = i.input;
  return n.pulse(r, n.changeset().remove(Ei).insert(t)), 1;
}
function sZ(e, t, n) {
  if (e) {
    const i = this.context.dataflow, r = e.mark.source;
    i.pulse(r, i.changeset().encode(e, t));
  }
  return n !== void 0 ? n : e;
}
const kd = (e) => function(t, n) {
  return this.context.dataflow.locale()[e](n)(t);
}, oZ = kd("format"), IR = kd("timeFormat"), aZ = kd("utcFormat"), lZ = kd("timeParse"), uZ = kd("utcParse"), gh = new Date(2e3, 0, 1);
function Wm(e, t, n) {
  return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (gh.setYear(2e3), gh.setMonth(e), gh.setDate(t), IR.call(this, gh, n));
}
function cZ(e) {
  return Wm.call(this, e, 1, "%B");
}
function fZ(e) {
  return Wm.call(this, e, 1, "%b");
}
function dZ(e) {
  return Wm.call(this, 0, 2 + e, "%A");
}
function hZ(e) {
  return Wm.call(this, 0, 2 + e, "%a");
}
const gZ = ":", pZ = "@", Qb = "%", zR = "$";
function h_(e, t, n, i) {
  t[0].type !== La && B("First argument to data functions must be a string literal.");
  const r = t[0].value, s = gZ + r;
  if (!ce(s, i))
    try {
      i[s] = n.getData(r).tuplesRef();
    } catch {
    }
}
function mZ(e, t, n, i) {
  t[0].type !== La && B("First argument to indata must be a string literal."), t[1].type !== La && B("Second argument to indata must be a string literal.");
  const r = t[0].value, s = t[1].value, o = pZ + s;
  ce(o, i) || (i[o] = n.getData(r).indataRef(n, s));
}
function vn(e, t, n, i) {
  if (t[0].type === La)
    HC(n, i, t[0].value);
  else
    for (e in n.scales)
      HC(n, i, e);
}
function HC(e, t, n) {
  const i = Qb + n;
  if (!ce(t, i))
    try {
      t[i] = e.scaleRef(n);
    } catch {
    }
}
function Ur(e, t) {
  if (Ee(e))
    return e;
  if (Q(e)) {
    const n = t.scales[e];
    return n && CU(n.value) ? n.value : void 0;
  }
}
function yZ(e, t, n) {
  t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = vn, n._range = vn, n._scale = vn;
  const i = (r) => "_[" + (r.type === La ? X(Qb + r.value) : X(Qb) + "+" + e(r)) + "]";
  return {
    _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
    _range: (r) => `${i(r[0])}.range()`,
    _scale: (r) => `${i(r[0])}(${e(r[1])})`
  };
}
function g_(e, t) {
  return function(n, i, r) {
    if (n) {
      const s = Ur(n, (r || this).context);
      return s && s.path[e](i);
    } else
      return t(i);
  };
}
const bZ = g_("area", UG), vZ = g_("bounds", GG), xZ = g_("centroid", QG);
function wZ(e, t) {
  const n = Ur(e, (t || this).context);
  return n && n.scale();
}
function _Z(e) {
  const t = this.context.group;
  let n = !1;
  if (t)
    for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
  return n;
}
function p_(e, t, n) {
  try {
    e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
  } catch (i) {
    e.warn(i);
  }
  return n[n.length - 1];
}
function EZ() {
  return p_(this.context.dataflow, "warn", arguments);
}
function SZ() {
  return p_(this.context.dataflow, "info", arguments);
}
function kZ() {
  return p_(this.context.dataflow, "debug", arguments);
}
function Y1(e) {
  const t = e / 255;
  return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function Zb(e) {
  const t = mo(e), n = Y1(t.r), i = Y1(t.g), r = Y1(t.b);
  return 0.2126 * n + 0.7152 * i + 0.0722 * r;
}
function AZ(e, t) {
  const n = Zb(e), i = Zb(t), r = Math.max(n, i), s = Math.min(n, i);
  return (r + 0.05) / (s + 0.05);
}
function CZ() {
  const e = [].slice.call(arguments);
  return e.unshift({}), we(...e);
}
function BR(e, t) {
  return e === t || e !== e && t !== t ? !0 : j(e) ? j(t) && e.length === t.length ? $Z(e, t) : !1 : ee(e) && ee(t) ? jR(e, t) : !1;
}
function $Z(e, t) {
  for (let n = 0, i = e.length; n < i; ++n)
    if (!BR(e[n], t[n]))
      return !1;
  return !0;
}
function jR(e, t) {
  for (const n in e)
    if (!BR(e[n], t[n]))
      return !1;
  return !0;
}
function GC(e) {
  return (t) => jR(e, t);
}
function MZ(e, t, n, i, r, s) {
  const o = this.context.dataflow, a = this.context.data[e], l = a.input, u = o.stamp();
  let c = a.changes, f, d;
  if (o._trigger === !1 || !(l.value.length || t || i))
    return 0;
  if ((!c || c.stamp < u) && (a.changes = c = o.changeset(), c.stamp = u, o.runAfter(() => {
    a.modified = !0, o.pulse(l, c).run();
  }, !0, 1)), n && (f = n === !0 ? Ei : j(n) || Qp(n) ? n : GC(n), c.remove(f)), t && c.insert(t), i && (f = GC(i), l.value.some(f) ? c.remove(f) : c.insert(i)), r)
    for (d in s)
      c.modify(r, d, s[d]);
  return 1;
}
function FZ(e) {
  const t = e.touches, n = t[0].clientX - t[1].clientX, i = t[0].clientY - t[1].clientY;
  return Math.hypot(n, i);
}
function TZ(e) {
  const t = e.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
const VC = {};
function OZ(e, t) {
  const n = VC[t] || (VC[t] = _i(t));
  return j(e) ? e.map(n) : n(e);
}
function m_(e) {
  return j(e) || ArrayBuffer.isView(e) ? e : null;
}
function y_(e) {
  return m_(e) || (Q(e) ? e : null);
}
function NZ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return m_(e).join(...n);
}
function DZ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return y_(e).indexOf(...n);
}
function RZ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return y_(e).lastIndexOf(...n);
}
function LZ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return y_(e).slice(...n);
}
function PZ(e, t, n) {
  return Ee(n) && B("Function argument passed to replace."), String(e).replace(t, n);
}
function IZ(e) {
  return m_(e).slice().reverse();
}
function zZ(e, t, n) {
  return A2(e || 0, t || 0, n || 0);
}
function BZ(e, t) {
  const n = Ur(e, (t || this).context);
  return n && n.bandwidth ? n.bandwidth() : 0;
}
function jZ(e, t) {
  const n = Ur(e, (t || this).context);
  return n ? n.copy() : void 0;
}
function UZ(e, t) {
  const n = Ur(e, (t || this).context);
  return n ? n.domain() : [];
}
function qZ(e, t, n) {
  const i = Ur(e, (n || this).context);
  return i ? j(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
}
function WZ(e, t) {
  const n = Ur(e, (t || this).context);
  return n && n.range ? n.range() : [];
}
function HZ(e, t, n) {
  const i = Ur(e, (n || this).context);
  return i ? i(t) : void 0;
}
function GZ(e, t, n, i, r) {
  e = Ur(e, (r || this).context);
  const s = RO(t, n);
  let o = e.domain(), a = o[0], l = Oe(o), u = on;
  return l - a ? u = EO(e, a, l) : e = (e.interpolator ? Ie("sequential")().interpolator(e.interpolator()) : Ie("linear")().interpolate(e.interpolate()).range(e.range())).domain([a = 0, l = 1]), e.ticks && (o = e.ticks(+i || 15), a !== o[0] && o.unshift(a), l !== Oe(o) && o.push(l)), o.forEach((c) => s.stop(u(c), e(c))), s;
}
function VZ(e, t, n) {
  const i = Ur(e, (n || this).context);
  return function(r) {
    return i ? i.path.context(r)(t) : "";
  };
}
function YZ(e) {
  let t = null;
  return function(n) {
    return n ? $f(n, t = t || cu(e)) : e;
  };
}
const UR = (e) => e.data;
function qR(e, t) {
  const n = PR.call(t, e);
  return n.root && n.root.lookup || {};
}
function XZ(e, t, n) {
  const i = qR(e, this), r = i[t], s = i[n];
  return r && s ? r.path(s).map(UR) : void 0;
}
function KZ(e, t) {
  const n = qR(e, this)[t];
  return n ? n.ancestors().map(UR) : void 0;
}
const WR = () => typeof window < "u" && window || null;
function JZ() {
  const e = WR();
  return e ? e.screen : {};
}
function QZ() {
  const e = WR();
  return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
}
function ZZ() {
  const e = this.context.dataflow, t = e.container && e.container();
  return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
}
function HR(e, t, n) {
  if (!e)
    return [];
  const [i, r] = e, s = new ht().set(i[0], i[1], r[0], r[1]), o = n || this.context.dataflow.scenegraph().root;
  return $N(o, s, eee(t));
}
function eee(e) {
  let t = null;
  if (e) {
    const n = J(e.marktype), i = J(e.markname);
    t = (r) => (!n.length || n.some((s) => r.marktype === s)) && (!i.length || i.some((s) => r.name === s));
  }
  return t;
}
function tee(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  e = J(e);
  const r = e[e.length - 1];
  return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
}
function nee(e) {
  return J(e).reduce((t, n, i) => {
    let [r, s] = n;
    return t += i == 0 ? `M ${r},${s} ` : i === e.length - 1 ? " Z" : `L ${r},${s} `;
  }, "");
}
function iee(e, t, n) {
  const {
    x: i,
    y: r,
    mark: s
  } = n, o = new ht().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [l, u] of t)
    l < o.x1 && (o.x1 = l), l > o.x2 && (o.x2 = l), u < o.y1 && (o.y1 = u), u > o.y2 && (o.y2 = u);
  return o.translate(i, r), HR([[o.x1, o.y1], [o.x2, o.y2]], e, s).filter((l) => ree(l.x, l.y, t));
}
function ree(e, t, n) {
  let i = 0;
  for (let r = 0, s = n.length - 1; r < n.length; s = r++) {
    const [o, a] = n[s], [l, u] = n[r];
    u > t != a > t && e < (o - l) * (t - u) / (a - u) + l && i++;
  }
  return i & 1;
}
const jf = {
  random() {
    return ki();
  },
  // override default
  cumulativeNormal: im,
  cumulativeLogNormal: Ax,
  cumulativeUniform: Fx,
  densityNormal: wx,
  densityLogNormal: kx,
  densityUniform: Mx,
  quantileNormal: rm,
  quantileLogNormal: Cx,
  quantileUniform: Tx,
  sampleNormal: nm,
  sampleLogNormal: Sx,
  sampleUniform: $x,
  isArray: j,
  isBoolean: To,
  isDate: so,
  isDefined(e) {
    return e !== void 0;
  },
  isNumber: Re,
  isObject: ee,
  isRegExp: nF,
  isString: Q,
  isTuple: Qp,
  isValid(e) {
    return e != null && e === e;
  },
  toBoolean: ex,
  toDate(e) {
    return tx(e);
  },
  // suppress extra arguments
  toNumber: Qt,
  toString: nx,
  indexof: DZ,
  join: NZ,
  lastindexof: RZ,
  replace: PZ,
  reverse: IZ,
  slice: LZ,
  flush: eF,
  lerp: iF,
  merge: CZ,
  pad: oF,
  peek: Oe,
  pluck: OZ,
  span: ed,
  inrange: Dl,
  truncate: aF,
  rgb: mo,
  lab: xg,
  hcl: wg,
  hsl: bg,
  luminance: Zb,
  contrast: AZ,
  sequence: Xn,
  format: oZ,
  utcFormat: aZ,
  utcParse: uZ,
  utcOffset: BF,
  utcSequence: qF,
  timeFormat: IR,
  timeParse: lZ,
  timeOffset: zF,
  timeSequence: UF,
  timeUnitSpecifier: $F,
  monthFormat: cZ,
  monthAbbrevFormat: fZ,
  dayFormat: dZ,
  dayAbbrevFormat: hZ,
  quarter: K3,
  utcquarter: J3,
  week: FF,
  utcweek: NF,
  dayofyear: MF,
  utcdayofyear: OF,
  warn: EZ,
  info: SZ,
  debug: kZ,
  extent(e) {
    return $r(e);
  },
  // suppress extra arguments
  inScope: _Z,
  intersect: HR,
  clampRange: Q3,
  pinchDistance: FZ,
  pinchAngle: TZ,
  screen: JZ,
  containerSize: ZZ,
  windowSize: QZ,
  bandspace: zZ,
  setdata: rZ,
  pathShape: YZ,
  panLinear: G3,
  panLog: V3,
  panPow: Y3,
  panSymlog: X3,
  zoomLinear: Yv,
  zoomLog: Xv,
  zoomPow: sg,
  zoomSymlog: Kv,
  encode: sZ,
  modify: MZ,
  lassoAppend: tee,
  lassoPath: nee,
  intersectLasso: iee
}, see = ["view", "item", "group", "xy", "x", "y"], oee = "event.vega.", GR = "this.", b_ = {}, VR = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (e) => `_[${X(zR + e)}]`,
  functions: aee,
  constants: OR,
  visitors: b_
}, ev = DR(VR);
function aee(e) {
  const t = NR(e);
  see.forEach((n) => t[n] = oee + n);
  for (const n in jf)
    t[n] = GR + n;
  return we(t, yZ(e, jf, b_)), t;
}
function dt(e, t, n) {
  return arguments.length === 1 ? jf[e] : (jf[e] = t, n && (b_[e] = n), ev && (ev.functions[e] = GR + e), this);
}
dt("bandwidth", BZ, vn);
dt("copy", jZ, vn);
dt("domain", UZ, vn);
dt("range", WZ, vn);
dt("invert", qZ, vn);
dt("scale", HZ, vn);
dt("gradient", GZ, vn);
dt("geoArea", bZ, vn);
dt("geoBounds", vZ, vn);
dt("geoCentroid", xZ, vn);
dt("geoShape", VZ, vn);
dt("geoScale", wZ, vn);
dt("indata", iZ, mZ);
dt("data", PR, h_);
dt("treePath", XZ, h_);
dt("treeAncestors", KZ, h_);
dt("vlSelectionTest", XQ, d_);
dt("vlSelectionIdTest", QQ, d_);
dt("vlSelectionResolve", eZ, d_);
dt("vlSelectionTuples", ZQ);
function Nr(e, t) {
  const n = {};
  let i;
  try {
    e = Q(e) ? e : X(e) + "", i = c_(e);
  } catch {
    B("Expression parse error: " + e);
  }
  i.visit((s) => {
    if (s.type !== kR)
      return;
    const o = s.callee.name, a = VR.visitors[o];
    a && a(o, s.arguments, t, n);
  });
  const r = ev(i);
  return r.globals.forEach((s) => {
    const o = zR + s;
    !ce(n, o) && t.getSignal(s) && (n[o] = t.signalRef(s));
  }), {
    $expr: we({
      code: r.code
    }, t.options.ast ? {
      ast: i
    } : null),
    $fields: r.fields,
    $params: n
  };
}
function lee(e) {
  const t = this, n = e.operators || [];
  return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach((i) => t.parseOperator(i)), n.forEach((i) => t.parseOperatorParameters(i)), (e.streams || []).forEach((i) => t.parseStream(i)), (e.updates || []).forEach((i) => t.parseUpdate(i)), t.resolve();
}
const uee = Ji(["rule"]), YC = Ji(["group", "image", "rect"]);
function cee(e, t) {
  let n = "";
  return uee[t] || (e.x2 && (e.x ? (YC[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (YC[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n;
}
function v_(e) {
  return (e + "").toLowerCase();
}
function fee(e) {
  return v_(e) === "operator";
}
function dee(e) {
  return v_(e) === "collect";
}
function bc(e, t, n) {
  n.endsWith(";") || (n = "return(" + n + ");");
  const i = Function(...t.concat(n));
  return e && e.functions ? i.bind(e.functions) : i;
}
function hee(e, t, n, i) {
  return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
  : (u > v || v == null) && u != null ? ${i}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
  : v !== v && u === u ? ${i} : `;
}
var gee = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (e, t) => bc(e, ["_"], t.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (e, t) => bc(e, ["datum", "_"], t.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (e, t) => bc(e, ["event"], t.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (e, t) => {
    const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
    return bc(e, ["_", "event"], n);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (e, t) => {
    const {
      marktype: n,
      channels: i
    } = t;
    let r = "var o=item,datum=o.datum,m=0,$;";
    for (const s in i) {
      const o = "o[" + X(s) + "]";
      r += `$=${i[s].code};if(${o}!==$)${o}=$,m=1;`;
    }
    return r += cee(i, n), r += "return m;", bc(e, ["item", "_"], r);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(e) {
      const t = `[${e.map(X).join("][")}]`, n = Function("_", `return _${t};`);
      return n.path = t, n;
    },
    comparator(e, t) {
      let n;
      const i = (s, o) => {
        const a = t[o];
        let l, u;
        return s.path ? (l = `a${s.path}`, u = `b${s.path}`) : ((n = n || {})["f" + o] = s, l = `this.f${o}(a)`, u = `this.f${o}(b)`), hee(l, u, -a, a);
      }, r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
      return n ? r.bind(n) : r;
    }
  }
};
function pee(e) {
  const t = this;
  fee(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
}
function mee(e) {
  const t = this;
  if (e.params) {
    const n = t.get(e.id);
    n || B("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
  }
}
function yee(e, t) {
  t = t || {};
  const n = this;
  for (const i in e) {
    const r = e[i];
    t[i] = j(r) ? r.map((s) => XC(s, n, t)) : XC(r, n, t);
  }
  return t;
}
function XC(e, t, n) {
  if (!e || !ee(e))
    return e;
  for (let i = 0, r = KC.length, s; i < r; ++i)
    if (s = KC[i], ce(e, s.key))
      return s.parse(e, t, n);
  return e;
}
var KC = [{
  key: "$ref",
  parse: bee
}, {
  key: "$key",
  parse: xee
}, {
  key: "$expr",
  parse: vee
}, {
  key: "$field",
  parse: wee
}, {
  key: "$encode",
  parse: Eee
}, {
  key: "$compare",
  parse: _ee
}, {
  key: "$context",
  parse: See
}, {
  key: "$subflow",
  parse: kee
}, {
  key: "$tupleid",
  parse: Aee
}];
function bee(e, t) {
  return t.get(e.$ref) || B("Operator not defined: " + e.$ref);
}
function vee(e, t, n) {
  e.$params && t.parseParameters(e.$params, n);
  const i = "e:" + e.$expr.code;
  return t.fn[i] || (t.fn[i] = Un(t.parameterExpression(e.$expr), e.$fields));
}
function xee(e, t) {
  const n = "k:" + e.$key + "_" + !!e.$flat;
  return t.fn[n] || (t.fn[n] = Zv(e.$key, e.$flat, t.expr.codegen));
}
function wee(e, t) {
  if (!e.$field)
    return null;
  const n = "f:" + e.$field + "_" + e.$name;
  return t.fn[n] || (t.fn[n] = _i(e.$field, e.$name, t.expr.codegen));
}
function _ee(e, t) {
  const n = "c:" + e.$compare + "_" + e.$order, i = J(e.$compare).map((r) => r && r.$tupleid ? le : r);
  return t.fn[n] || (t.fn[n] = Jv(i, e.$order, t.expr.codegen));
}
function Eee(e, t) {
  const n = e.$encode, i = {};
  for (const r in n) {
    const s = n[r];
    i[r] = Un(t.encodeExpression(s.$expr), s.$fields), i[r].output = s.$output;
  }
  return i;
}
function See(e, t) {
  return t;
}
function kee(e, t) {
  const n = e.$subflow;
  return function(i, r, s) {
    const o = t.fork().parse(n), a = o.get(n.operators[0].id), l = o.signals.parent;
    return l && l.set(s), a.detachSubflow = () => t.detach(o), a;
  };
}
function Aee() {
  return le;
}
function Cee(e) {
  var t = this, n = e.filter != null ? t.eventExpression(e.filter) : void 0, i = e.stream != null ? t.get(e.stream) : void 0, r;
  e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((s) => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((s) => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && B("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
}
function $ee(e) {
  var t = this, n = ee(n = e.source) ? n.$ref : n, i = t.get(n), r = null, s = e.update, o = void 0;
  i || B("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (o = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, o);
}
const Mee = {
  skip: !0
};
function Fee(e) {
  var t = this, n = {};
  if (e.signals) {
    var i = n.signals = {};
    Object.keys(t.signals).forEach((s) => {
      const o = t.signals[s];
      e.signals(s, o) && (i[s] = o.value);
    });
  }
  if (e.data) {
    var r = n.data = {};
    Object.keys(t.data).forEach((s) => {
      const o = t.data[s];
      e.data(s, o) && (r[s] = o.input.value);
    });
  }
  return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map((s) => s.getState(e))), n;
}
function Tee(e) {
  var t = this, n = t.dataflow, i = e.data, r = e.signals;
  Object.keys(r || {}).forEach((s) => {
    n.update(t.signals[s], r[s], Mee);
  }), Object.keys(i || {}).forEach((s) => {
    n.pulse(t.data[s].input, n.changeset().remove(Ei).insert(i[s]));
  }), (e.subcontext || []).forEach((s, o) => {
    const a = t.subcontext[o];
    a && a.setState(s);
  });
}
function YR(e, t, n, i) {
  return new XR(e, t, n, i);
}
function XR(e, t, n, i) {
  this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || gee, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this);
}
function JC(e) {
  this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this);
}
XR.prototype = JC.prototype = {
  fork() {
    const e = new JC(this);
    return (this.subcontext || (this.subcontext = [])).push(e), e;
  },
  detach(e) {
    this.subcontext = this.subcontext.filter((n) => n !== e);
    const t = Object.keys(e.nodes);
    for (const n of t)
      e.nodes[n]._targets = null;
    for (const n of t)
      e.nodes[n].detach();
    e.nodes = null;
  },
  get(e) {
    return this.nodes[e];
  },
  set(e, t) {
    return this.nodes[e] = t;
  },
  add(e, t) {
    const n = this, i = n.dataflow, r = e.value;
    if (n.set(e.id, t), dee(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
      let s = n.get(e.parent.$ref);
      s ? (i.connect(s, [t]), t.targets().add(s)) : (n.unresolved = n.unresolved || []).push(() => {
        s = n.get(e.parent.$ref), i.connect(s, [t]), t.targets().add(s);
      });
    }
    if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
      for (const s in e.data) {
        const o = n.data[s] || (n.data[s] = {});
        e.data[s].forEach((a) => o[a] = t);
      }
  },
  resolve() {
    return (this.unresolved || []).forEach((e) => e()), delete this.unresolved, this;
  },
  operator(e, t) {
    this.add(e, this.dataflow.add(e.value, t));
  },
  transform(e, t) {
    this.add(e, this.dataflow.add(this.transforms[v_(t)]));
  },
  stream(e, t) {
    this.set(e.id, t);
  },
  update(e, t, n, i, r) {
    this.dataflow.on(t, n, i, r, e.options);
  },
  // expression parsing
  operatorExpression(e) {
    return this.expr.operator(this, e);
  },
  parameterExpression(e) {
    return this.expr.parameter(this, e);
  },
  eventExpression(e) {
    return this.expr.event(this, e);
  },
  handlerExpression(e) {
    return this.expr.handler(this, e);
  },
  encodeExpression(e) {
    return this.expr.encode(this, e);
  },
  // parse methods
  parse: lee,
  parseOperator: pee,
  parseOperatorParameters: mee,
  parseParameters: yee,
  parseStream: Cee,
  parseUpdate: $ee,
  // state methods
  getState: Fee,
  setState: Tee
};
function Oee(e) {
  const t = e.container();
  t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), KR(t, e.description()));
}
function KR(e, t) {
  e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t));
}
function Nee(e) {
  e.add(null, (t) => (e._background = t.bg, e._resize = 1, t.bg), {
    bg: e._signals.background
  });
}
const X1 = "default";
function Dee(e) {
  const t = e._signals.cursor || (e._signals.cursor = e.add({
    user: X1,
    item: null
  }));
  e.on(e.events("view", "pointermove"), t, (n, i) => {
    const r = t.value, s = r ? Q(r) ? r : r.user : X1, o = i.item && i.item.cursor || null;
    return r && s === r.user && o == r.item ? r : {
      user: s,
      item: o
    };
  }), e.add(null, function(n) {
    let i = n.cursor, r = this.value;
    return Q(i) || (r = i.item, i = i.user), tv(e, i && i !== X1 ? i : r || i), r;
  }, {
    cursor: t
  });
}
function tv(e, t) {
  const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
  if (n)
    return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
}
function gp(e, t) {
  var n = e._runtime.data;
  return ce(n, t) || B("Unrecognized data set: " + t), n[t];
}
function Ree(e, t) {
  return arguments.length < 2 ? gp(this, e).values.value : Hm.call(this, e, tl().remove(Ei).insert(t));
}
function Hm(e, t) {
  mT(t) || B("Second argument to changes must be a changeset.");
  const n = gp(this, e);
  return n.modified = !0, this.pulse(n.input, t);
}
function Lee(e, t) {
  return Hm.call(this, e, tl().insert(t));
}
function Pee(e, t) {
  return Hm.call(this, e, tl().remove(t));
}
function JR(e) {
  var t = e.padding();
  return Math.max(0, e._viewWidth + t.left + t.right);
}
function QR(e) {
  var t = e.padding();
  return Math.max(0, e._viewHeight + t.top + t.bottom);
}
function Gm(e) {
  var t = e.padding(), n = e._origin;
  return [t.left + n[0], t.top + n[1]];
}
function Iee(e) {
  var t = Gm(e), n = JR(e), i = QR(e);
  e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach((r) => {
    try {
      r(n, i);
    } catch (s) {
      e.error(s);
    }
  });
}
function zee(e, t, n) {
  var i = e._renderer, r = i && i.canvas(), s, o, a;
  return r && (a = Gm(e), o = t.changedTouches ? t.changedTouches[0] : t, s = Tm(o, r), s[0] -= a[0], s[1] -= a[1]), t.dataflow = e, t.item = n, t.vega = Bee(e, n, s), t;
}
function Bee(e, t, n) {
  const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
  function r(o) {
    var a = i, l;
    if (o) {
      for (l = t; l; l = l.mark.group)
        if (l.mark.name === o) {
          a = l;
          break;
        }
    }
    return a && a.mark && a.mark.interactive ? a : {};
  }
  function s(o) {
    if (!o)
      return n;
    Q(o) && (o = r(o));
    const a = n.slice();
    for (; o; )
      a[0] -= o.x || 0, a[1] -= o.y || 0, o = o.mark && o.mark.group;
    return a;
  }
  return {
    view: an(e),
    item: an(t || {}),
    group: r,
    xy: s,
    x: (o) => s(o)[0],
    y: (o) => s(o)[1]
  };
}
const QC = "view", jee = "timer", Uee = "window", qee = {
  trap: !1
};
function Wee(e) {
  const t = we({
    defaults: {}
  }, e), n = (i, r) => {
    r.forEach((s) => {
      j(i[s]) && (i[s] = Ji(i[s]));
    });
  };
  return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
}
function ZR(e, t, n, i) {
  e._eventListeners.push({
    type: n,
    sources: J(t),
    handler: i
  });
}
function Hee(e, t) {
  var n = e._eventConfig.defaults, i = n.prevent, r = n.allow;
  return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault();
}
function ph(e, t, n) {
  const i = e._eventConfig && e._eventConfig[t];
  return i === !1 || ee(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
}
function Gee(e, t, n) {
  var i = this, r = new tm(n), s = function(u, c) {
    i.runAsync(null, () => {
      e === QC && Hee(i, t) && u.preventDefault(), r.receive(zee(i, u, c));
    });
  }, o;
  if (e === jee)
    ph(i, "timer", t) && i.timer(s, t);
  else if (e === QC)
    ph(i, "view", t) && i.addEventListener(t, s, qee);
  else if (e === Uee ? ph(i, "window", t) && typeof window < "u" && (o = [window]) : typeof document < "u" && ph(i, "selector", t) && (o = Array.from(document.querySelectorAll(e))), !o)
    i.warn("Can not resolve event source: " + e);
  else {
    for (var a = 0, l = o.length; a < l; ++a)
      o[a].addEventListener(t, s);
    ZR(i, o, t, s);
  }
  return r;
}
function ZC(e) {
  return e.item;
}
function e$(e) {
  return e.item.mark.source;
}
function t$(e) {
  return function(t, n) {
    return n.vega.view().changeset().encode(n.item, e);
  };
}
function Vee(e, t) {
  return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "pointerover", ZC), e$, t$(e)), this.on(this.events("view", "pointerout", ZC), e$, t$(t)), this;
}
function Yee() {
  var e = this._tooltip, t = this._timers, n = this._eventListeners, i, r, s;
  for (i = t.length; --i >= 0; )
    t[i].stop();
  for (i = n.length; --i >= 0; )
    for (s = n[i], r = s.sources.length; --r >= 0; )
      s.sources[r].removeEventListener(s.type, s.handler);
  return e && e.call(this, this._handler, null, null, null), this;
}
function ei(e, t, n) {
  const i = document.createElement(e);
  for (const r in t)
    i.setAttribute(r, t[r]);
  return n != null && (i.textContent = n), i;
}
const Xee = "vega-bind", Kee = "vega-bind-name", Jee = "vega-bind-radio";
function Qee(e, t, n) {
  if (!t)
    return;
  const i = n.param;
  let r = n.state;
  return r || (r = n.state = {
    elements: null,
    active: !1,
    set: null,
    update: (o) => {
      o != e.signal(i.signal) && e.runAsync(null, () => {
        r.source = !0, e.signal(i.signal, o);
      });
    }
  }, i.debounce && (r.update = Qv(i.debounce, r.update))), (i.input == null && i.element ? Zee : tte)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
    r.source ? r.source = !1 : r.set(e.signal(i.signal));
  }), r.active = !0), r;
}
function Zee(e, t, n, i) {
  const r = n.event || "input", s = () => e.update(t.value);
  i.signal(n.signal, t.value), t.addEventListener(r, s), ZR(i, t, r, s), e.set = (o) => {
    t.value = o, t.dispatchEvent(ete(r));
  };
}
function ete(e) {
  return typeof Event < "u" ? new Event(e) : {
    type: e
  };
}
function tte(e, t, n, i) {
  const r = i.signal(n.signal), s = ei("div", {
    class: Xee
  }), o = n.input === "radio" ? s : s.appendChild(ei("label"));
  o.appendChild(ei("span", {
    class: Kee
  }, n.name || n.signal)), t.appendChild(s);
  let a = nte;
  switch (n.input) {
    case "checkbox":
      a = ite;
      break;
    case "select":
      a = rte;
      break;
    case "radio":
      a = ste;
      break;
    case "range":
      a = ote;
      break;
  }
  a(e, o, n, r);
}
function nte(e, t, n, i) {
  const r = ei("input");
  for (const s in n)
    s !== "signal" && s !== "element" && r.setAttribute(s === "input" ? "type" : s, n[s]);
  r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = (s) => r.value = s;
}
function ite(e, t, n, i) {
  const r = {
    type: "checkbox",
    name: n.signal
  };
  i && (r.checked = !0);
  const s = ei("input", r);
  t.appendChild(s), s.addEventListener("change", () => e.update(s.checked)), e.elements = [s], e.set = (o) => s.checked = !!o || null;
}
function rte(e, t, n, i) {
  const r = ei("select", {
    name: n.signal
  }), s = n.labels || [];
  n.options.forEach((o, a) => {
    const l = {
      value: o
    };
    pp(o, i) && (l.selected = !0), r.appendChild(ei("option", l, (s[a] || o) + ""));
  }), t.appendChild(r), r.addEventListener("change", () => {
    e.update(n.options[r.selectedIndex]);
  }), e.elements = [r], e.set = (o) => {
    for (let a = 0, l = n.options.length; a < l; ++a)
      if (pp(n.options[a], o)) {
        r.selectedIndex = a;
        return;
      }
  };
}
function ste(e, t, n, i) {
  const r = ei("span", {
    class: Jee
  }), s = n.labels || [];
  t.appendChild(r), e.elements = n.options.map((o, a) => {
    const l = {
      type: "radio",
      name: n.signal,
      value: o
    };
    pp(o, i) && (l.checked = !0);
    const u = ei("input", l);
    u.addEventListener("change", () => e.update(o));
    const c = ei("label", {}, (s[a] || o) + "");
    return c.prepend(u), r.appendChild(c), u;
  }), e.set = (o) => {
    const a = e.elements, l = a.length;
    for (let u = 0; u < l; ++u)
      pp(a[u].value, o) && (a[u].checked = !0);
  };
}
function ote(e, t, n, i) {
  i = i !== void 0 ? i : (+n.max + +n.min) / 2;
  const r = n.max != null ? n.max : Math.max(100, +i) || 100, s = n.min || Math.min(0, r, +i) || 0, o = n.step || ho(s, r, 100), a = ei("input", {
    type: "range",
    name: n.signal,
    min: s,
    max: r,
    step: o
  });
  a.value = i;
  const l = ei("span", {}, +i);
  t.appendChild(a), t.appendChild(l);
  const u = () => {
    l.textContent = a.value, e.update(+a.value);
  };
  a.addEventListener("input", u), a.addEventListener("change", u), e.elements = [a], e.set = (c) => {
    a.value = c, l.textContent = c;
  };
}
function pp(e, t) {
  return e === t || e + "" == t + "";
}
function e6(e, t, n, i, r, s) {
  return t = t || new i(e.loader()), t.initialize(n, JR(e), QR(e), Gm(e), r, s).background(e.background());
}
function x_(e, t) {
  return t ? function() {
    try {
      t.apply(this, arguments);
    } catch (n) {
      e.error(n);
    }
  } : null;
}
function ate(e, t, n, i) {
  const r = new i(e.loader(), x_(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, Gm(e), e);
  return t && t.handlers().forEach((s) => {
    r.on(s.type, s.handler);
  }), r;
}
function lte(e, t) {
  const n = this, i = n._renderType, r = n._eventConfig.bind, s = Nm(i);
  e = n._el = e ? K1(n, e, !0) : null, Oee(n), s || n.error("Unrecognized renderer type: " + i);
  const o = s.handler || wo, a = e ? s.renderer : s.headless;
  return n._renderer = a ? e6(n, n._renderer, e, a) : null, n._handler = ate(n, n._handler, e, o), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = K1(n, t, !0) : e.appendChild(ei("form", {
    class: "vega-bindings"
  })), n._bind.forEach((l) => {
    l.param.element && r !== "container" && (l.element = K1(n, l.param.element, !!l.param.input));
  }), n._bind.forEach((l) => {
    Qee(n, l.element || t, l);
  })), n;
}
function K1(e, t, n) {
  if (typeof t == "string")
    if (typeof document < "u") {
      if (t = document.querySelector(t), !t)
        return e.error("Signal bind element not found: " + t), null;
    } else
      return e.error("DOM document instance not found."), null;
  if (t && n)
    try {
      t.textContent = "";
    } catch (i) {
      t = null, e.error(i);
    }
  return t;
}
const vc = (e) => +e || 0, ute = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function n$(e) {
  return ee(e) ? {
    top: vc(e.top),
    bottom: vc(e.bottom),
    left: vc(e.left),
    right: vc(e.right)
  } : ute(vc(e));
}
async function w_(e, t, n, i) {
  const r = Nm(t), s = r && r.headless;
  return s || B("Unrecognized renderer type: " + t), await e.runAsync(), e6(e, null, null, s, n, i).renderAsync(e._scenegraph.root);
}
async function cte(e, t) {
  e !== Zs.Canvas && e !== Zs.SVG && e !== Zs.PNG && B("Unrecognized image type: " + e);
  const n = await w_(this, e, t);
  return e === Zs.SVG ? fte(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
}
function fte(e, t) {
  const n = new Blob([e], {
    type: t
  });
  return window.URL.createObjectURL(n);
}
async function dte(e, t) {
  return (await w_(this, Zs.Canvas, e, t)).canvas();
}
async function hte(e) {
  return (await w_(this, Zs.SVG, e)).svg();
}
function gte(e, t, n) {
  return YR(e, ru, jf, n).parse(t);
}
function pte(e) {
  var t = this._runtime.scales;
  return ce(t, e) || B("Unrecognized scale or projection: " + e), t[e].value;
}
var t6 = "width", n6 = "height", __ = "padding", i$ = {
  skip: !0
};
function i6(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === __ ? i.left + i.right : 0);
}
function r6(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === __ ? i.top + i.bottom : 0);
}
function mte(e) {
  var t = e._signals, n = t[t6], i = t[n6], r = t[__];
  function s() {
    e._autosize = e._resize = 1;
  }
  e._resizeWidth = e.add(null, (a) => {
    e._width = a.size, e._viewWidth = i6(e, a.size), s();
  }, {
    size: n
  }), e._resizeHeight = e.add(null, (a) => {
    e._height = a.size, e._viewHeight = r6(e, a.size), s();
  }, {
    size: i
  });
  const o = e.add(null, s, {
    pad: r
  });
  e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, o.rank = r.rank + 1;
}
function yte(e, t, n, i, r, s) {
  this.runAfter((o) => {
    let a = 0;
    o._autosize = 0, o.width() !== n && (a = 1, o.signal(t6, n, i$), o._resizeWidth.skip(!0)), o.height() !== i && (a = 1, o.signal(n6, i, i$), o._resizeHeight.skip(!0)), o._viewWidth !== e && (o._resize = 1, o._viewWidth = e), o._viewHeight !== t && (o._resize = 1, o._viewHeight = t), (o._origin[0] !== r[0] || o._origin[1] !== r[1]) && (o._resize = 1, o._origin = r), a && o.run("enter"), s && o.runAfter((l) => l.resize());
  }, !1, 1);
}
function bte(e) {
  return this._runtime.getState(e || {
    data: vte,
    signals: xte,
    recurse: !0
  });
}
function vte(e, t) {
  return t.modified && j(t.input.value) && !e.startsWith("_:vega:_");
}
function xte(e, t) {
  return !(e === "parent" || t instanceof ru.proxy);
}
function wte(e) {
  return this.runAsync(null, (t) => {
    t._trigger = !1, t._runtime.setState(e);
  }, (t) => {
    t._trigger = !0;
  }), this;
}
function _te(e, t) {
  function n(i) {
    e({
      timestamp: Date.now(),
      elapsed: i
    });
  }
  this._timers.push(ZY(n, t));
}
function Ete(e, t, n, i) {
  const r = e.element();
  r && r.setAttribute("title", Ste(i));
}
function Ste(e) {
  return e == null ? "" : j(e) ? s6(e) : ee(e) && !so(e) ? kte(e) : e + "";
}
function kte(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return t + ": " + (j(n) ? s6(n) : o6(n));
  }).join(`
`);
}
function s6(e) {
  return "[" + e.map(o6).join(", ") + "]";
}
function o6(e) {
  return j(e) ? "[]" : ee(e) && !so(e) ? "{}" : e;
}
function Ate() {
  if (this.renderer() === "canvas" && this._renderer._canvas) {
    let e = null;
    const t = () => {
      e != null && e();
      const n = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      n.addEventListener("change", t), e = () => {
        n.removeEventListener("change", t);
      }, this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1, this._redraw = !0, this._resize = 1, this.resize().runAsync();
    };
    t();
  }
}
function a6(e, t) {
  const n = this;
  if (t = t || {}, jl.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
    const s = we({}, e.locale, t.locale);
    n.locale(oT(s.number, s.time));
  }
  n._el = null, n._elBind = null, n._renderType = t.renderer || Zs.Canvas, n._scenegraph = new nw();
  const i = n._scenegraph.root;
  n._renderer = null, n._tooltip = t.tooltip || Ete, n._redraw = !0, n._handler = new wo().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Wee(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
  const r = gte(n, e, t.expr);
  n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map((s) => ({
    state: null,
    param: we({}, s)
  })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = i6(n, n._width), n._viewHeight = r6(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, mte(n), Nee(n), Dee(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind), t.watchPixelRatio && n._watchPixelRatio();
}
function mh(e, t) {
  return ce(e._signals, t) ? e._signals[t] : B("Unrecognized signal name: " + X(t));
}
function l6(e, t) {
  const n = (e._targets || []).filter((i) => i._update && i._update.handler === t);
  return n.length ? n[0] : null;
}
function r$(e, t, n, i) {
  let r = l6(n, i);
  return r || (r = x_(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e;
}
function s$(e, t, n) {
  const i = l6(t, n);
  return i && t._targets.remove(i), e;
}
Y(a6, jl, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(e, t, n) {
    if (await jl.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
      try {
        this._renderer && (this._resize && (this._resize = 0, Iee(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
      } catch (i) {
        this.error(i);
      }
    return n && Oh(this, n), this;
  },
  dirty(e) {
    this._redraw = !0, this._renderer && this._renderer.dirty(e);
  },
  // -- GET / SET ----
  description(e) {
    if (arguments.length) {
      const t = e != null ? e + "" : null;
      return t !== this._desc && KR(this._el, this._desc = t), this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(e, t, n) {
    const i = mh(this, e);
    return arguments.length === 1 ? i.value : this.update(i, t, n);
  },
  width(e) {
    return arguments.length ? this.signal("width", e) : this.signal("width");
  },
  height(e) {
    return arguments.length ? this.signal("height", e) : this.signal("height");
  },
  padding(e) {
    return arguments.length ? this.signal("padding", n$(e)) : n$(this.signal("padding"));
  },
  autosize(e) {
    return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
  },
  background(e) {
    return arguments.length ? this.signal("background", e) : this.signal("background");
  },
  renderer(e) {
    return arguments.length ? (Nm(e) || B("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
  },
  tooltip(e) {
    return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
  },
  loader(e) {
    return arguments.length ? (e !== this._loader && (jl.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
  },
  resize() {
    return this._autosize = 1, this.touch(mh(this, "autosize"));
  },
  _resetRenderer() {
    this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
  },
  // -- SIZING ----
  _resizeView: yte,
  // -- EVENT HANDLING ----
  addEventListener(e, t, n) {
    let i = t;
    return n && n.trap === !1 || (i = x_(this, t), i.raw = t), this._handler.on(e, i), this;
  },
  removeEventListener(e, t) {
    for (var n = this._handler.handlers(e), i = n.length, r, s; --i >= 0; )
      if (s = n[i].type, r = n[i].handler, e === s && (t === r || t === r.raw)) {
        this._handler.off(s, r);
        break;
      }
    return this;
  },
  addResizeListener(e) {
    const t = this._resizeListeners;
    return t.includes(e) || t.push(e), this;
  },
  removeResizeListener(e) {
    var t = this._resizeListeners, n = t.indexOf(e);
    return n >= 0 && t.splice(n, 1), this;
  },
  addSignalListener(e, t) {
    return r$(this, e, mh(this, e), t);
  },
  removeSignalListener(e, t) {
    return s$(this, mh(this, e), t);
  },
  addDataListener(e, t) {
    return r$(this, e, gp(this, e).values, t);
  },
  removeDataListener(e, t) {
    return s$(this, gp(this, e).values, t);
  },
  globalCursor(e) {
    if (arguments.length) {
      if (this._globalCursor !== !!e) {
        const t = tv(this, null);
        this._globalCursor = !!e, t && tv(this, t);
      }
      return this;
    } else
      return this._globalCursor;
  },
  preventDefault(e) {
    return arguments.length ? (this._preventDefault = e, this) : this._preventDefault;
  },
  timer: _te,
  events: Gee,
  finalize: Yee,
  hover: Vee,
  // -- DATA ----
  data: Ree,
  change: Hm,
  insert: Lee,
  remove: Pee,
  // -- SCALES --
  scale: pte,
  // -- INITIALIZATION ----
  initialize: lte,
  // -- HEADLESS RENDERING ----
  toImageURL: cte,
  toCanvas: dte,
  toSVG: hte,
  // -- SAVE / RESTORE STATE ----
  getState: bte,
  setState: wte,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: Ate
});
const Cte = "view", mp = "[", yp = "]", u6 = "{", c6 = "}", $te = ":", f6 = ",", Mte = "@", Fte = ">", Tte = /[[\]{}]/, Ote = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let d6, h6;
function Po(e, t, n) {
  return d6 = t || Cte, h6 = n || Ote, g6(e.trim()).map(nv);
}
function Nte(e) {
  return h6[e];
}
function df(e, t, n, i, r) {
  const s = e.length;
  let o = 0, a;
  for (; t < s; ++t) {
    if (a = e[t], !o && a === n)
      return t;
    r && r.indexOf(a) >= 0 ? --o : i && i.indexOf(a) >= 0 && ++o;
  }
  return t;
}
function g6(e) {
  const t = [], n = e.length;
  let i = 0, r = 0;
  for (; r < n; )
    r = df(e, r, f6, mp + u6, yp + c6), t.push(e.substring(i, r).trim()), i = ++r;
  if (t.length === 0)
    throw "Empty event selector: " + e;
  return t;
}
function nv(e) {
  return e[0] === "[" ? Dte(e) : Rte(e);
}
function Dte(e) {
  const t = e.length;
  let n = 1, i;
  if (n = df(e, n, yp, mp, yp), n === t)
    throw "Empty between selector: " + e;
  if (i = g6(e.substring(1, n)), i.length !== 2)
    throw "Between selector must have two elements: " + e;
  if (e = e.slice(n + 1).trim(), e[0] !== Fte)
    throw "Expected '>' after between selector: " + e;
  i = i.map(nv);
  const r = nv(e.slice(1).trim());
  return r.between ? {
    between: i,
    stream: r
  } : (r.between = i, r);
}
function Rte(e) {
  const t = {
    source: d6
  }, n = [];
  let i = [0, 0], r = 0, s = 0, o = e.length, a = 0, l, u;
  if (e[o - 1] === c6) {
    if (a = e.lastIndexOf(u6), a >= 0) {
      try {
        i = Lte(e.substring(a + 1, o - 1));
      } catch {
        throw "Invalid throttle specification: " + e;
      }
      e = e.slice(0, a).trim(), o = e.length;
    } else
      throw "Unmatched right brace: " + e;
    a = 0;
  }
  if (!o)
    throw e;
  if (e[0] === Mte && (r = ++a), l = df(e, a, $te), l < o && (n.push(e.substring(s, l).trim()), s = a = ++l), a = df(e, a, mp), a === o)
    n.push(e.substring(s, o).trim());
  else if (n.push(e.substring(s, a).trim()), u = [], s = ++a, s === o)
    throw "Unmatched left bracket: " + e;
  for (; a < o; ) {
    if (a = df(e, a, yp), a === o)
      throw "Unmatched left bracket: " + e;
    if (u.push(e.substring(s, a).trim()), a < o - 1 && e[++a] !== mp)
      throw "Expected left bracket: " + e;
    s = ++a;
  }
  if (!(o = n.length) || Tte.test(n[o - 1]))
    throw "Invalid event selector: " + e;
  return o > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : Nte(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), u != null && (t.filter = u), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t;
}
function Lte(e) {
  const t = e.split(f6);
  if (!e.length || t.length > 2)
    throw e;
  return t.map((n) => {
    const i = +n;
    if (i !== i)
      throw e;
    return i;
  });
}
function Pte(e) {
  return ee(e) ? e : {
    type: e || "pad"
  };
}
const xc = (e) => +e || 0, Ite = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function zte(e) {
  return ee(e) ? e.signal ? e : {
    top: xc(e.top),
    bottom: xc(e.bottom),
    left: xc(e.left),
    right: xc(e.right)
  } : Ite(xc(e));
}
const Tt = (e) => ee(e) && !j(e) ? we({}, e) : {
  value: e
};
function o$(e, t, n, i) {
  return n != null ? (ee(n) && !j(n) || j(n) && n.length && ee(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
    value: n
  }, 1) : 0;
}
function Wt(e, t, n) {
  for (const i in t)
    o$(e, i, t[i]);
  for (const i in n)
    o$(e, i, n[i], "update");
}
function Vu(e, t, n) {
  for (const i in t)
    n && ce(n, i) || (e[i] = we(e[i] || {}, t[i]));
  return e;
}
function Ol(e, t) {
  return t && (t.enter && t.enter[e] || t.update && t.update[e]);
}
const E_ = "mark", S_ = "frame", k_ = "scope", Bte = "axis", jte = "axis-domain", Ute = "axis-grid", qte = "axis-label", Wte = "axis-tick", Hte = "axis-title", Gte = "legend", Vte = "legend-band", Yte = "legend-entry", Xte = "legend-gradient", p6 = "legend-label", Kte = "legend-symbol", Jte = "legend-title", Qte = "title", Zte = "title-text", ene = "title-subtitle";
function tne(e, t, n, i, r) {
  const s = {}, o = {};
  let a, l, u, c;
  l = "lineBreak", t === "text" && r[l] != null && !Ol(l, e) && J1(s, l, r[l]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === S_ ? r.group : n === E_ ? we({}, r.mark, r[t]) : null;
  for (l in c)
    u = Ol(l, e) || (l === "fill" || l === "stroke") && (Ol("fill", e) || Ol("stroke", e)), u || J1(s, l, c[l]);
  J(i).forEach((f) => {
    const d = r.style && r.style[f];
    for (const h in d)
      Ol(h, e) || J1(s, h, d[h]);
  }), e = we({}, e);
  for (l in s)
    c = s[l], c.signal ? (a = a || {})[l] = c : o[l] = c;
  return e.enter = we(o, e.enter), a && (e.update = we(a, e.update)), e;
}
function J1(e, t, n) {
  e[t] = n && n.signal ? {
    signal: n.signal
  } : {
    value: n
  };
}
const m6 = (e) => Q(e) ? X(e) : e.signal ? `(${e.signal})` : y6(e);
function Vm(e) {
  if (e.gradient != null)
    return ine(e);
  let t = e.signal ? `(${e.signal})` : e.color ? nne(e.color) : e.field != null ? y6(e.field) : e.value !== void 0 ? X(e.value) : void 0;
  return e.scale != null && (t = rne(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${Xh(e.exponent)})`), e.mult != null && (t += `*${Xh(e.mult)}`), e.offset != null && (t += `+${Xh(e.offset)}`), e.round && (t = `round(${t})`), t;
}
const yh = (e, t, n, i) => `(${e}(${[t, n, i].map(Vm).join(",")})+'')`;
function nne(e) {
  return e.c ? yh("hcl", e.h, e.c, e.l) : e.h || e.s ? yh("hsl", e.h, e.s, e.l) : e.l || e.a ? yh("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? yh("rgb", e.r, e.g, e.b) : null;
}
function ine(e) {
  const t = [e.start, e.stop, e.count].map((n) => n == null ? null : X(n));
  for (; t.length && Oe(t) == null; )
    t.pop();
  return t.unshift(m6(e.gradient)), `gradient(${t.join(",")})`;
}
function Xh(e) {
  return ee(e) ? "(" + Vm(e) + ")" : e;
}
function y6(e) {
  return b6(ee(e) ? e : {
    datum: e
  });
}
function b6(e) {
  let t, n, i;
  if (e.signal)
    t = "datum", i = e.signal;
  else if (e.group || e.parent) {
    for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0; )
      t += ".mark.group";
    e.parent ? (i = e.parent, t += ".datum") : i = e.group;
  } else
    e.datum ? (t = "datum", i = e.datum) : B("Invalid field reference: " + X(e));
  return e.signal || (i = Q(i) ? Pr(i).map(X).join("][") : b6(i)), t + "[" + i + "]";
}
function rne(e, t) {
  const n = m6(e.scale);
  return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + Xh(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
}
function sne(e) {
  let t = "";
  return e.forEach((n) => {
    const i = Vm(n);
    t += n.test ? `(${n.test})?${i}:` : i;
  }), Oe(t) === ":" && (t += "null"), t;
}
function v6(e, t, n, i, r, s) {
  const o = {};
  s = s || {}, s.encoders = {
    $encode: o
  }, e = tne(e, t, n, i, r.config);
  for (const a in e)
    o[a] = one(e[a], t, s, r);
  return s;
}
function one(e, t, n, i) {
  const r = {}, s = {};
  for (const o in e)
    e[o] != null && (r[o] = lne(ane(e[o]), i, n, s));
  return {
    $expr: {
      marktype: t,
      channels: r
    },
    $fields: Object.keys(s),
    $output: Object.keys(e)
  };
}
function ane(e) {
  return j(e) ? sne(e) : Vm(e);
}
function lne(e, t, n, i) {
  const r = Nr(e, t);
  return r.$fields.forEach((s) => i[s] = 1), we(n, r.$params), r.$expr;
}
const une = "outer", cne = ["value", "update", "init", "react", "bind"];
function a$(e, t) {
  B(e + ' for "outer" push: ' + X(t));
}
function x6(e, t) {
  const n = e.name;
  if (e.push === une)
    t.signals[n] || a$("No prior signal definition", n), cne.forEach((i) => {
      e[i] !== void 0 && a$("Invalid property ", i);
    });
  else {
    const i = t.addSignal(n, e.value);
    e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind);
  }
}
function iv(e, t, n, i) {
  this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i);
}
function Ym(e, t, n, i) {
  return new iv(e, t, n, i);
}
function bp(e, t) {
  return Ym("operator", e, t);
}
function ae(e) {
  const t = {
    $ref: e.id
  };
  return e.id < 0 && (e.refs = e.refs || []).push(t), t;
}
function Uf(e, t) {
  return t ? {
    $field: e,
    $name: t
  } : {
    $field: e
  };
}
const rv = Uf("key");
function l$(e, t) {
  return {
    $compare: e,
    $order: t
  };
}
function fne(e, t) {
  const n = {
    $key: e
  };
  return t && (n.$flat = !0), n;
}
const dne = "ascending", hne = "descending";
function gne(e) {
  return ee(e) ? (e.order === hne ? "-" : "+") + Xm(e.op, e.field) : "";
}
function Xm(e, t) {
  return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
}
const A_ = "scope", sv = "view";
function xt(e) {
  return e && e.signal;
}
function pne(e) {
  return e && e.expr;
}
function Kh(e) {
  if (xt(e))
    return !0;
  if (ee(e)) {
    for (const t in e)
      if (Kh(e[t]))
        return !0;
  }
  return !1;
}
function Ii(e, t) {
  return e ?? t;
}
function Ea(e) {
  return e && e.signal || e;
}
const u$ = "timer";
function qf(e, t) {
  return (e.merge ? yne : e.stream ? bne : e.type ? vne : B("Invalid stream specification: " + X(e)))(e, t);
}
function mne(e) {
  return e === A_ ? sv : e || sv;
}
function yne(e, t) {
  const n = e.merge.map((r) => qf(r, t)), i = C_({
    merge: n
  }, e, t);
  return t.addStream(i).id;
}
function bne(e, t) {
  const n = qf(e.stream, t), i = C_({
    stream: n
  }, e, t);
  return t.addStream(i).id;
}
function vne(e, t) {
  let n;
  e.type === u$ ? (n = t.event(u$, e.throttle), e = {
    between: e.between,
    filter: e.filter
  }) : n = t.event(mne(e.source), e.type);
  const i = C_({
    stream: n
  }, e, t);
  return Object.keys(i).length === 1 ? n : t.addStream(i).id;
}
function C_(e, t, n) {
  let i = t.between;
  return i && (i.length !== 2 && B('Stream "between" parameter must have 2 entries: ' + X(t)), e.between = [qf(i[0], n), qf(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(xne(t.marktype, t.markname, t.markrole)), t.source === A_ && i.push("inScope(event.item)"), i.length && (e.filter = Nr("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
}
function xne(e, t, n) {
  const i = "event.item";
  return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "");
}
const wne = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function _ne(e, t, n) {
  const i = e.encode, r = {
    target: n
  };
  let s = e.events, o = e.update, a = [];
  s || B("Signal update missing events specification."), Q(s) && (s = Po(s, t.isSubscope() ? A_ : sv)), s = J(s).filter((l) => l.signal || l.scale ? (a.push(l), 0) : 1), a.length > 1 && (a = [Sne(a)]), s.length && a.push(s.length > 1 ? {
    merge: s
  } : s[0]), i != null && (o && B("Signal encode and update are mutually exclusive."), o = "encode(item()," + X(i) + ")"), r.update = Q(o) ? Nr(o, t) : o.expr != null ? Nr(o.expr, t) : o.value != null ? o.value : o.signal != null ? {
    $expr: wne,
    $params: {
      $value: t.signalRef(o.signal)
    }
  } : B("Invalid signal update specification."), e.force && (r.options = {
    force: !0
  }), a.forEach((l) => t.addUpdate(we(Ene(l, t), r)));
}
function Ene(e, t) {
  return {
    source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : qf(e, t)
  };
}
function Sne(e) {
  return {
    signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
  };
}
function kne(e, t) {
  const n = t.getSignal(e.name);
  let i = e.update;
  e.init && (i ? B("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = Nr(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => _ne(r, t, n.id));
}
const Ve = (e) => (t, n, i) => Ym(e, n, t || void 0, i), w6 = Ve("aggregate"), Ane = Ve("axisticks"), _6 = Ve("bound"), ir = Ve("collect"), c$ = Ve("compare"), Cne = Ve("datajoin"), E6 = Ve("encode"), $ne = Ve("expression"), Mne = Ve("facet"), Fne = Ve("field"), Tne = Ve("key"), One = Ve("legendentries"), Nne = Ve("load"), Dne = Ve("mark"), Rne = Ve("multiextent"), Lne = Ve("multivalues"), Pne = Ve("overlap"), Ine = Ve("params"), S6 = Ve("prefacet"), zne = Ve("projection"), Bne = Ve("proxy"), jne = Ve("relay"), k6 = Ve("render"), Une = Ve("scale"), sl = Ve("sieve"), qne = Ve("sortitems"), A6 = Ve("viewlayout"), Wne = Ve("values");
let Hne = 0;
const C6 = {
  min: "min",
  max: "max",
  count: "sum"
};
function Gne(e, t) {
  const n = e.type || "linear";
  yO(n) || B("Unrecognized scale type: " + X(n)), t.addScale(e.name, {
    type: n,
    domain: void 0
  });
}
function Vne(e, t) {
  const n = t.getScale(e.name).params;
  let i;
  n.domain = $6(e.domain, e, t), e.range != null && (n.range = F6(e, t, n)), e.interpolate != null && iie(e.interpolate, n), e.nice != null && (n.nice = nie(e.nice)), e.bins != null && (n.bins = tie(e.bins, t));
  for (i in e)
    ce(n, i) || i === "name" || (n[i] = pi(e[i], t));
}
function pi(e, t) {
  return ee(e) ? e.signal ? t.signalRef(e.signal) : B("Unsupported object: " + X(e)) : e;
}
function Jh(e, t) {
  return e.signal ? t.signalRef(e.signal) : e.map((n) => pi(n, t));
}
function Km(e) {
  B("Can not find data set: " + X(e));
}
function $6(e, t, n) {
  if (!e) {
    (t.domainMin != null || t.domainMax != null) && B("No scale domain defined for domainMin/domainMax to override.");
    return;
  }
  return e.signal ? n.signalRef(e.signal) : (j(e) ? Yne : e.fields ? Kne : Xne)(e, t, n);
}
function Yne(e, t, n) {
  return e.map((i) => pi(i, n));
}
function Xne(e, t, n) {
  const i = n.getData(e.data);
  return i || Km(e.data), uu(t.type) ? i.valuesRef(n, e.field, M6(e.sort, !1)) : xO(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
}
function Kne(e, t, n) {
  const i = e.data, r = e.fields.reduce((s, o) => (o = Q(o) ? {
    data: i,
    field: o
  } : j(o) || o.signal ? Jne(o, n) : o, s.push(o), s), []);
  return (uu(t.type) ? Qne : xO(t.type) ? Zne : eie)(e, n, r);
}
function Jne(e, t) {
  const n = "_:vega:_" + Hne++, i = ir({});
  if (j(e))
    i.value = {
      $ingest: e
    };
  else if (e.signal) {
    const r = "setdata(" + X(n) + "," + e.signal + ")";
    i.params.input = t.signalRef(r);
  }
  return t.addDataPipeline(n, [i, sl({})]), {
    data: n,
    field: "data"
  };
}
function Qne(e, t, n) {
  const i = M6(e.sort, !0);
  let r, s;
  const o = n.map((u) => {
    const c = t.getData(u.data);
    return c || Km(u.data), c.countsRef(t, u.field, i);
  }), a = {
    groupby: rv,
    pulse: o
  };
  i && (r = i.op || "count", s = i.field ? Xm(r, i.field) : "count", a.ops = [C6[r]], a.fields = [t.fieldRef(s)], a.as = [s]), r = t.add(w6(a));
  const l = t.add(ir({
    pulse: ae(r)
  }));
  return s = t.add(Wne({
    field: rv,
    sort: t.sortRef(i),
    pulse: ae(l)
  })), ae(s);
}
function M6(e, t) {
  return e && (!e.field && !e.op ? ee(e) ? e.field = "key" : e = {
    field: "key"
  } : !e.field && e.op !== "count" ? B("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !C6[e.op] && B("Multiple domain scales can not be sorted using " + e.op)), e;
}
function Zne(e, t, n) {
  const i = n.map((r) => {
    const s = t.getData(r.data);
    return s || Km(r.data), s.domainRef(t, r.field);
  });
  return ae(t.add(Lne({
    values: i
  })));
}
function eie(e, t, n) {
  const i = n.map((r) => {
    const s = t.getData(r.data);
    return s || Km(r.data), s.extentRef(t, r.field);
  });
  return ae(t.add(Rne({
    extents: i
  })));
}
function tie(e, t) {
  return e.signal || j(e) ? Jh(e, t) : t.objectProperty(e);
}
function nie(e) {
  return ee(e) ? {
    interval: pi(e.interval),
    step: pi(e.step)
  } : pi(e);
}
function iie(e, t) {
  t.interpolate = pi(e.type || e), e.gamma != null && (t.interpolateGamma = pi(e.gamma));
}
function F6(e, t, n) {
  const i = t.config.range;
  let r = e.range;
  if (r.signal)
    return t.signalRef(r.signal);
  if (Q(r)) {
    if (i && ce(i, r))
      return e = we({}, e, {
        range: i[r]
      }), F6(e, t, n);
    r === "width" ? r = [0, {
      signal: "width"
    }] : r === "height" ? r = uu(e.type) ? [0, {
      signal: "height"
    }] : [{
      signal: "height"
    }, 0] : B("Unrecognized scale range value: " + X(r));
  } else if (r.scheme) {
    n.scheme = j(r.scheme) ? Jh(r.scheme, t) : pi(r.scheme, t), r.extent && (n.schemeExtent = Jh(r.extent, t)), r.count && (n.schemeCount = pi(r.count, t));
    return;
  } else if (r.step) {
    n.rangeStep = pi(r.step, t);
    return;
  } else {
    if (uu(e.type) && !j(r))
      return $6(r, e, t);
    j(r) || B("Unsupported range type: " + X(r));
  }
  return r.map((s) => (j(s) ? Jh : pi)(s, t));
}
function rie(e, t) {
  const n = t.config.projection || {}, i = {};
  for (const r in e)
    r !== "name" && (i[r] = ov(e[r], r, t));
  for (const r in n)
    i[r] == null && (i[r] = ov(n[r], r, t));
  t.addProjection(e.name, i);
}
function ov(e, t, n) {
  return j(e) ? e.map((i) => ov(i, t, n)) : ee(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : B("Unsupported parameter object: " + X(e)) : e;
}
const rr = "top", Yu = "left", Xu = "right", Eo = "bottom", T6 = "center", sie = "vertical", oie = "start", aie = "middle", lie = "end", av = "index", $_ = "label", uie = "offset", bu = "perc", cie = "perc2", yi = "value", Ad = "guide-label", M_ = "guide-title", fie = "group-title", die = "group-subtitle", f$ = "symbol", Qh = "gradient", lv = "discrete", uv = "size", hie = "shape", gie = "fill", pie = "stroke", mie = "strokeWidth", yie = "strokeDash", bie = "opacity", F_ = [uv, hie, gie, pie, mie, yie, bie], Cd = {
  name: 1,
  style: 1,
  interactive: 1
}, Ne = {
  value: 0
}, bi = {
  value: 1
}, Jm = "group", O6 = "rect", T_ = "rule", vie = "symbol", ol = "text";
function Wf(e) {
  return e.type = Jm, e.interactive = e.interactive || !1, e;
}
function qn(e, t) {
  const n = (i, r) => Ii(e[i], Ii(t[i], r));
  return n.isVertical = (i) => sie === Ii(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => Ii(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => Ii(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => Ii(e.columns, Ii(t.columns, +n.isVertical(!0))), n;
}
function N6(e, t) {
  const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
  return n && n.signal ? n : n ? n.value : null;
}
function xie(e, t, n) {
  const i = t.config.style[n];
  return i && i[e];
}
function Qm(e, t, n) {
  return `item.anchor === '${oie}' ? ${e} : item.anchor === '${lie}' ? ${t} : ${n}`;
}
const O_ = Qm(X(Yu), X(Xu), X(T6));
function wie(e) {
  const t = e("tickBand");
  let n = e("tickOffset"), i, r;
  return t ? t.signal ? (i = {
    signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
  }, r = {
    signal: `(${t.signal}) === 'extent'`
  }, ee(n) || (n = {
    signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
  })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = 0.5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
    extra: r,
    band: i,
    offset: n
  };
}
function D6(e, t) {
  return t ? e ? ee(e) ? Object.assign({}, e, {
    offset: D6(e.offset, t)
  }) : {
    value: e,
    offset: t
  } : t : e;
}
function oi(e, t) {
  return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = Vu(e.encode, t, Cd)) : e.interactive = !1, e;
}
function _ie(e, t, n, i) {
  const r = qn(e, n), s = r.isVertical(), o = r.gradientThickness(), a = r.gradientLength();
  let l, u, c, f, d;
  s ? (u = [0, 1], c = [0, 0], f = o, d = a) : (u = [0, 0], c = [1, 0], f = a, d = o);
  const h = {
    enter: l = {
      opacity: Ne,
      x: Ne,
      y: Ne,
      width: Tt(f),
      height: Tt(d)
    },
    update: we({}, l, {
      opacity: bi,
      fill: {
        gradient: t,
        start: u,
        stop: c
      }
    }),
    exit: {
      opacity: Ne
    }
  };
  return Wt(h, {
    stroke: r("gradientStrokeColor"),
    strokeWidth: r("gradientStrokeWidth")
  }, {
    // update
    opacity: r("gradientOpacity")
  }), oi({
    type: O6,
    role: Xte,
    encode: h
  }, i);
}
function Eie(e, t, n, i, r) {
  const s = qn(e, n), o = s.isVertical(), a = s.gradientThickness(), l = s.gradientLength();
  let u, c, f, d, h = "";
  o ? (u = "y", f = "y2", c = "x", d = "width", h = "1-") : (u = "x", f = "x2", c = "y", d = "height");
  const g = {
    opacity: Ne,
    fill: {
      scale: t,
      field: yi
    }
  };
  g[u] = {
    signal: h + "datum." + bu,
    mult: l
  }, g[c] = Ne, g[f] = {
    signal: h + "datum." + cie,
    mult: l
  }, g[d] = Tt(a);
  const p = {
    enter: g,
    update: we({}, g, {
      opacity: bi
    }),
    exit: {
      opacity: Ne
    }
  };
  return Wt(p, {
    stroke: s("gradientStrokeColor"),
    strokeWidth: s("gradientStrokeWidth")
  }, {
    // update
    opacity: s("gradientOpacity")
  }), oi({
    type: O6,
    role: Vte,
    key: yi,
    from: r,
    encode: p
  }, i);
}
const Sie = `datum.${bu}<=0?"${Yu}":datum.${bu}>=1?"${Xu}":"${T6}"`, kie = `datum.${bu}<=0?"${Eo}":datum.${bu}>=1?"${rr}":"${aie}"`;
function d$(e, t, n, i) {
  const r = qn(e, t), s = r.isVertical(), o = Tt(r.gradientThickness()), a = r.gradientLength();
  let l = r("labelOverlap"), u, c, f, d, h = "";
  const g = {
    enter: u = {
      opacity: Ne
    },
    update: c = {
      opacity: bi,
      text: {
        field: $_
      }
    },
    exit: {
      opacity: Ne
    }
  };
  return Wt(g, {
    fill: r("labelColor"),
    fillOpacity: r("labelOpacity"),
    font: r("labelFont"),
    fontSize: r("labelFontSize"),
    fontStyle: r("labelFontStyle"),
    fontWeight: r("labelFontWeight"),
    limit: Ii(e.labelLimit, t.gradientLabelLimit)
  }), s ? (u.align = {
    value: "left"
  }, u.baseline = c.baseline = {
    signal: kie
  }, f = "y", d = "x", h = "1-") : (u.align = c.align = {
    signal: Sie
  }, u.baseline = {
    value: "top"
  }, f = "x", d = "y"), u[f] = c[f] = {
    signal: h + "datum." + bu,
    mult: a
  }, u[d] = c[d] = o, o.offset = Ii(e.labelOffset, t.gradientLabelOffset) || 0, l = l ? {
    separation: r("labelSeparation"),
    method: l,
    order: "datum." + av
  } : void 0, oi({
    type: ol,
    role: p6,
    style: Ad,
    key: yi,
    from: i,
    encode: g,
    overlap: l
  }, n);
}
function Aie(e, t, n, i, r) {
  const s = qn(e, t), o = n.entries, a = !!(o && o.interactive), l = o ? o.name : void 0, u = s("clipHeight"), c = s("symbolOffset"), f = {
    data: "value"
  }, d = `(${r}) ? datum.${uie} : datum.${uv}`, h = u ? Tt(u) : {
    field: uv
  }, g = `datum.${av}`, p = `max(1, ${r})`;
  let m, y, b, v, w;
  h.mult = 0.5, m = {
    enter: y = {
      opacity: Ne,
      x: {
        signal: d,
        mult: 0.5,
        offset: c
      },
      y: h
    },
    update: b = {
      opacity: bi,
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: Ne
    }
  };
  let _ = null, S = null;
  e.fill || (_ = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), Wt(m, {
    fill: s("symbolFillColor", _),
    shape: s("symbolType"),
    size: s("symbolSize"),
    stroke: s("symbolStrokeColor", S),
    strokeDash: s("symbolDash"),
    strokeDashOffset: s("symbolDashOffset"),
    strokeWidth: s("symbolStrokeWidth")
  }, {
    // update
    opacity: s("symbolOpacity")
  }), F_.forEach((N) => {
    e[N] && (b[N] = y[N] = {
      scale: e[N],
      field: yi
    });
  });
  const E = oi({
    type: vie,
    role: Kte,
    key: yi,
    from: f,
    clip: u ? !0 : void 0,
    encode: m
  }, n.symbols), C = Tt(c);
  C.offset = s("labelOffset"), m = {
    enter: y = {
      opacity: Ne,
      x: {
        signal: d,
        offset: C
      },
      y: h
    },
    update: b = {
      opacity: bi,
      text: {
        field: $_
      },
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: Ne
    }
  }, Wt(m, {
    align: s("labelAlign"),
    baseline: s("labelBaseline"),
    fill: s("labelColor"),
    fillOpacity: s("labelOpacity"),
    font: s("labelFont"),
    fontSize: s("labelFontSize"),
    fontStyle: s("labelFontStyle"),
    fontWeight: s("labelFontWeight"),
    limit: s("labelLimit")
  });
  const $ = oi({
    type: ol,
    role: p6,
    style: Ad,
    key: yi,
    from: f,
    encode: m
  }, n.labels);
  return m = {
    enter: {
      noBound: {
        value: !u
      },
      // ignore width/height in bounds calc
      width: Ne,
      height: u ? Tt(u) : Ne,
      opacity: Ne
    },
    exit: {
      opacity: Ne
    },
    update: b = {
      opacity: bi,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }, s.isVertical(!0) ? (v = `ceil(item.mark.items.length / ${p})`, b.row.signal = `${g}%${v}`, b.column.signal = `floor(${g} / ${v})`, w = {
    field: ["row", g]
  }) : (b.row.signal = `floor(${g} / ${p})`, b.column.signal = `${g} % ${p}`, w = {
    field: g
  }), b.column.signal = `(${r})?${b.column.signal}:${g}`, i = {
    facet: {
      data: i,
      name: "value",
      groupby: av
    }
  }, Wf({
    role: k_,
    from: i,
    encode: Vu(m, o, Cd),
    marks: [E, $],
    name: l,
    interactive: a,
    sort: w
  });
}
function Cie(e, t) {
  const n = qn(e, t);
  return {
    align: n("gridAlign"),
    columns: n.entryColumns(),
    center: {
      row: !0,
      column: !1
    },
    padding: {
      row: n("rowPadding"),
      column: n("columnPadding")
    }
  };
}
const N_ = 'item.orient === "left"', D_ = 'item.orient === "right"', Zm = `(${N_} || ${D_})`, $ie = `datum.vgrad && ${Zm}`, Mie = Qm('"top"', '"bottom"', '"middle"'), Fie = Qm('"right"', '"left"', '"center"'), Tie = `datum.vgrad && ${D_} ? (${Fie}) : (${Zm} && !(datum.vgrad && ${N_})) ? "left" : ${O_}`, Oie = `item._anchor || (${Zm} ? "middle" : "start")`, Nie = `${$ie} ? (${N_} ? -90 : 90) : 0`, Die = `${Zm} ? (datum.vgrad ? (${D_} ? "bottom" : "top") : ${Mie}) : "top"`;
function Rie(e, t, n, i) {
  const r = qn(e, t), s = {
    enter: {
      opacity: Ne
    },
    update: {
      opacity: bi,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: Ne
    }
  };
  return Wt(s, {
    orient: r("titleOrient"),
    _anchor: r("titleAnchor"),
    anchor: {
      signal: Oie
    },
    angle: {
      signal: Nie
    },
    align: {
      signal: Tie
    },
    baseline: {
      signal: Die
    },
    text: e.title,
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    // require update
    align: r("titleAlign"),
    baseline: r("titleBaseline")
  }), oi({
    type: ol,
    role: Jte,
    style: M_,
    from: i,
    encode: s
  }, n);
}
function Lie(e, t) {
  let n;
  return ee(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + h$(e.path) + ")" : e.sphere && (n = "geoShape(" + h$(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
}
function h$(e) {
  return ee(e) && e.signal ? e.signal : X(e);
}
function R6(e) {
  const t = e.role || "";
  return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === Jm ? k_ : t || E_;
}
function Pie(e) {
  return {
    marktype: e.type,
    name: e.name || void 0,
    role: e.role || R6(e),
    zindex: +e.zindex || void 0,
    aria: e.aria,
    description: e.description
  };
}
function Iie(e, t) {
  return e && e.signal ? t.signalRef(e.signal) : e !== !1;
}
function R_(e, t) {
  const n = vT(e.type);
  n || B("Unrecognized transform type: " + X(e.type));
  const i = Ym(n.type.toLowerCase(), null, L6(n, e, t));
  return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i;
}
function L6(e, t, n) {
  const i = {}, r = e.params.length;
  for (let s = 0; s < r; ++s) {
    const o = e.params[s];
    i[o.name] = zie(o, t, n);
  }
  return i;
}
function zie(e, t, n) {
  const i = e.type, r = t[e.name];
  if (i === "index")
    return Bie(e, t, n);
  if (r === void 0) {
    e.required && B("Missing required " + X(t.type) + " parameter: " + X(e.name));
    return;
  } else {
    if (i === "param")
      return jie(e, t, n);
    if (i === "projection")
      return n.projectionRef(t[e.name]);
  }
  return e.array && !xt(r) ? r.map((s) => g$(e, s, n)) : g$(e, r, n);
}
function g$(e, t, n) {
  const i = e.type;
  if (xt(t))
    return m$(i) ? B("Expression references can not be signals.") : Q1(i) ? n.fieldRef(t) : y$(i) ? n.compareRef(t) : n.signalRef(t.signal);
  {
    const r = e.expr || Q1(i);
    return r && Uie(t) ? n.exprRef(t.expr, t.as) : r && qie(t) ? Uf(t.field, t.as) : m$(i) ? Nr(t, n) : Wie(i) ? ae(n.getData(t).values) : Q1(i) ? Uf(t) : y$(i) ? n.compareRef(t) : t;
  }
}
function Bie(e, t, n) {
  return Q(t.from) || B('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
}
function jie(e, t, n) {
  const i = t[e.name];
  return e.array ? (j(i) || B("Expected an array of sub-parameters. Instead: " + X(i)), i.map((r) => p$(e, r, n))) : p$(e, i, n);
}
function p$(e, t, n) {
  const i = e.params.length;
  let r;
  for (let o = 0; o < i; ++o) {
    r = e.params[o];
    for (const a in r.key)
      if (r.key[a] !== t[a]) {
        r = null;
        break;
      }
    if (r)
      break;
  }
  r || B("Unsupported parameter: " + X(t));
  const s = we(L6(r, t, n), r.key);
  return ae(n.add(Ine(s)));
}
const Uie = (e) => e && e.expr, qie = (e) => e && e.field, Wie = (e) => e === "data", m$ = (e) => e === "expr", Q1 = (e) => e === "field", y$ = (e) => e === "compare";
function Hie(e, t, n) {
  let i, r, s, o, a;
  return e ? (i = e.facet) && (t || B("Only group marks can be faceted."), i.field != null ? o = a = Zh(i, n) : (e.data ? a = ae(n.getData(e.data).aggregate) : (s = R_(we({
    type: "aggregate",
    groupby: J(i.groupby)
  }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = Zh(i, n), o = a = ae(n.add(s))), r = n.keyRef(i.groupby, !0))) : o = ae(n.add(ir(null, [{}]))), o || (o = Zh(e, n)), {
    key: r,
    pulse: o,
    parent: a
  };
}
function Zh(e, t) {
  return e.$ref ? e : e.data && e.data.$ref ? e.data : ae(t.getData(e.data).output);
}
function za(e, t, n, i, r) {
  this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {};
}
za.fromEntries = function(e, t) {
  const n = t.length, i = t[n - 1], r = t[n - 2];
  let s = t[0], o = null, a = 1;
  for (s && s.type === "load" && (s = t[1]), e.add(t[0]); a < n; ++a)
    t[a].params.pulse = ae(t[a - 1]), e.add(t[a]), t[a].type === "aggregate" && (o = t[a]);
  return new za(e, s, r, i, o);
};
function P6(e) {
  return Q(e) ? e : null;
}
function b$(e, t, n) {
  const i = Xm(n.op, n.field);
  let r;
  if (t.ops) {
    for (let s = 0, o = t.as.length; s < o; ++s)
      if (t.as[s] === i)
        return;
  } else
    t.ops = ["count"], t.fields = [null], t.as = ["count"];
  n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i));
}
function wc(e, t, n, i, r, s, o) {
  const a = t[n] || (t[n] = {}), l = gne(s);
  let u = P6(r), c, f;
  if (u != null && (e = t.scope, u = u + (l ? "|" + l : ""), c = a[u]), !c) {
    const d = s ? {
      field: rv,
      pulse: t.countsRef(e, r, s)
    } : {
      field: e.fieldRef(r),
      pulse: ae(t.output)
    };
    l && (d.sort = e.sortRef(s)), f = e.add(Ym(i, void 0, d)), o && (t.index[r] = f), c = ae(f), u != null && (a[u] = c);
  }
  return c;
}
za.prototype = {
  countsRef(e, t, n) {
    const i = this, r = i.counts || (i.counts = {}), s = P6(t);
    let o, a, l;
    return s != null && (e = i.scope, o = r[s]), o ? n && n.field && b$(e, o.agg.params, n) : (l = {
      groupby: e.fieldRef(t, "key"),
      pulse: ae(i.output)
    }, n && n.field && b$(e, l, n), a = e.add(w6(l)), o = e.add(ir({
      pulse: ae(a)
    })), o = {
      agg: a,
      ref: ae(o)
    }, s != null && (r[s] = o)), o.ref;
  },
  tuplesRef() {
    return ae(this.values);
  },
  extentRef(e, t) {
    return wc(e, this, "extent", "extent", t, !1);
  },
  domainRef(e, t) {
    return wc(e, this, "domain", "values", t, !1);
  },
  valuesRef(e, t, n) {
    return wc(e, this, "vals", "values", t, n || !0);
  },
  lookupRef(e, t) {
    return wc(e, this, "lookup", "tupleindex", t, !1);
  },
  indataRef(e, t) {
    return wc(e, this, "indata", "tupleindex", t, !0, !0);
  }
};
function Gie(e, t, n) {
  const i = e.from.facet, r = i.name, s = Zh(i, t);
  let o;
  i.name || B("Facet must have a name: " + X(i)), i.data || B("Facet must reference a data set: " + X(i)), i.field ? o = t.add(S6({
    field: t.fieldRef(i.field),
    pulse: s
  })) : i.groupby ? o = t.add(Mne({
    key: t.keyRef(i.groupby),
    group: ae(t.proxy(n.parent)),
    pulse: s
  })) : B("Facet must specify groupby or field: " + X(i));
  const a = t.fork(), l = a.add(ir()), u = a.add(sl({
    pulse: ae(l)
  }));
  a.addData(r, new za(a, l, l, u)), a.addSignal("parent", null), o.params.subflow = {
    $subflow: a.parse(e).toRuntime()
  };
}
function Vie(e, t, n) {
  const i = t.add(S6({
    pulse: n.pulse
  })), r = t.fork();
  r.add(sl()), r.addSignal("parent", null), i.params.subflow = {
    $subflow: r.parse(e).toRuntime()
  };
}
function I6(e, t, n) {
  const i = e.remove, r = e.insert, s = e.toggle, o = e.modify, a = e.values, l = t.add(bp()), u = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, s, o, a].map((f) => f ?? "null").join(",") + "),0)", c = Nr(u, t);
  l.update = c.$expr, l.params = c.$params;
}
function e0(e, t) {
  const n = R6(e), i = e.type === Jm, r = e.from && e.from.facet, s = e.overlap;
  let o = e.layout || n === k_ || n === S_, a, l, u, c, f, d, h;
  const g = n === E_ || o || r, p = Hie(e.from, i, t);
  l = t.add(Cne({
    key: p.key || (e.key ? Uf(e.key) : void 0),
    pulse: p.pulse,
    clean: !i
  }));
  const m = ae(l);
  l = u = t.add(ir({
    pulse: m
  })), l = t.add(Dne({
    markdef: Pie(e),
    interactive: Iie(e.interactive, t),
    clip: Lie(e.clip, t),
    context: {
      $context: !0
    },
    groups: t.lookup(),
    parent: t.signals.parent ? t.signalRef("parent") : null,
    index: t.markpath(),
    pulse: ae(l)
  }));
  const y = ae(l);
  l = c = t.add(E6(v6(e.encode, e.type, n, e.style, t, {
    mod: !1,
    pulse: y
  }))), l.params.parent = t.encode(), e.transform && e.transform.forEach((S) => {
    const E = R_(S, t), C = E.metadata;
    (C.generates || C.changes) && B("Mark transforms should not generate new data."), C.nomod || (c.params.mod = !0), E.params.pulse = ae(l), t.add(l = E);
  }), e.sort && (l = t.add(qne({
    sort: t.compareRef(e.sort),
    pulse: ae(l)
  })));
  const b = ae(l);
  (r || o) && (o = t.add(A6({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    mark: y,
    pulse: b
  })), d = ae(o));
  const v = t.add(_6({
    mark: y,
    pulse: d || b
  }));
  h = ae(v), i && (g && (a = t.operators, a.pop(), o && a.pop()), t.pushState(b, d || h, m), r ? Gie(e, t, p) : g ? Vie(e, t, p) : t.parse(e), t.popState(), g && (o && a.push(o), a.push(v))), s && (h = Yie(s, h, t));
  const w = t.add(k6({
    pulse: h
  })), _ = t.add(sl({
    pulse: ae(w)
  }, void 0, t.parent()));
  e.name != null && (f = e.name, t.addData(f, new za(t, u, w, _)), e.on && e.on.forEach((S) => {
    (S.insert || S.remove || S.toggle) && B("Marks only support modify triggers."), I6(S, t, f);
  }));
}
function Yie(e, t, n) {
  const i = e.method, r = e.bound, s = e.separation, o = {
    separation: xt(s) ? n.signalRef(s.signal) : s,
    method: xt(i) ? n.signalRef(i.signal) : i,
    pulse: t
  };
  if (e.order && (o.sort = n.compareRef({
    field: e.order
  })), r) {
    const a = r.tolerance;
    o.boundTolerance = xt(a) ? n.signalRef(a.signal) : +a, o.boundScale = n.scaleRef(r.scale), o.boundOrient = r.orient;
  }
  return ae(n.add(Pne(o)));
}
function Xie(e, t) {
  const n = t.config.legend, i = e.encode || {}, r = qn(e, n), s = i.legend || {}, o = s.name || void 0, a = s.interactive, l = s.style, u = {};
  let c = 0, f, d, h;
  F_.forEach((v) => e[v] ? (u[v] = e[v], c = c || e[v]) : 0), c || B("Missing valid scale for legend.");
  const g = Kie(e, t.scaleType(c)), p = {
    title: e.title != null,
    scales: u,
    type: g,
    vgrad: g !== "symbol" && r.isVertical()
  }, m = ae(t.add(ir(null, [p]))), y = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }, b = ae(t.add(One(d = {
    type: g,
    scale: t.scaleRef(c),
    count: t.objectProperty(r("tickCount")),
    limit: t.property(r("symbolLimit")),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  })));
  return g === Qh ? (h = [_ie(e, c, n, i.gradient), d$(e, n, i.labels, b)], d.count = d.count || t.signalRef(`max(2,2*floor((${Ea(r.gradientLength())})/100))`)) : g === lv ? h = [Eie(e, c, n, i.gradient, b), d$(e, n, i.labels, b)] : (f = Cie(e, n), h = [Aie(e, n, i, b, Ea(f.columns))], d.size = Zie(e, t, h[0].marks)), h = [Wf({
    role: Yte,
    from: m,
    encode: y,
    marks: h,
    layout: f,
    interactive: a
  })], p.title && h.push(Rie(e, n, i.title, m)), e0(Wf({
    role: Gte,
    from: m,
    encode: Vu(Qie(r, e, n), s, Cd),
    marks: h,
    aria: r("aria"),
    description: r("description"),
    zindex: r("zindex"),
    name: o,
    interactive: a,
    style: l
  }), t);
}
function Kie(e, t) {
  let n = e.type || f$;
  return !e.type && Jie(e) === 1 && (e.fill || e.stroke) && (n = T2(t) ? Qh : Zy(t) ? lv : f$), n !== Qh ? n : Zy(t) ? lv : Qh;
}
function Jie(e) {
  return F_.reduce((t, n) => t + (e[n] ? 1 : 0), 0);
}
function Qie(e, t, n) {
  const i = {
    enter: {},
    update: {}
  };
  return Wt(i, {
    orient: e("orient"),
    offset: e("offset"),
    padding: e("padding"),
    titlePadding: e("titlePadding"),
    cornerRadius: e("cornerRadius"),
    fill: e("fillColor"),
    stroke: e("strokeColor"),
    strokeWidth: n.strokeWidth,
    strokeDash: n.strokeDash,
    x: e("legendX"),
    y: e("legendY"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), i;
}
function Zie(e, t, n) {
  const i = Ea(v$("size", e, n)), r = Ea(v$("strokeWidth", e, n)), s = Ea(ere(n[1].encode, t, Ad));
  return Nr(`max(ceil(sqrt(${i})+${r}),${s})`, t);
}
function v$(e, t, n) {
  return t[e] ? `scale("${t[e]}",datum)` : N6(e, n[0].encode);
}
function ere(e, t, n) {
  return N6("fontSize", e) || xie("fontSize", t, n);
}
const tre = `item.orient==="${Yu}"?-90:item.orient==="${Xu}"?90:0`;
function nre(e, t) {
  e = Q(e) ? {
    text: e
  } : e;
  const n = qn(e, t.config.title), i = e.encode || {}, r = i.group || {}, s = r.name || void 0, o = r.interactive, a = r.style, l = [], u = {}, c = ae(t.add(ir(null, [u])));
  return l.push(sre(e, n, ire(e), c)), e.subtitle && l.push(ore(e, n, i.subtitle, c)), e0(Wf({
    role: Qte,
    from: c,
    encode: rre(n, r),
    marks: l,
    aria: n("aria"),
    description: n("description"),
    zindex: n("zindex"),
    name: s,
    interactive: o,
    style: a
  }), t);
}
function ire(e) {
  const t = e.encode;
  return t && t.title || we({
    name: e.name,
    interactive: e.interactive,
    style: e.style
  }, t);
}
function rre(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Wt(n, {
    orient: e("orient"),
    anchor: e("anchor"),
    align: {
      signal: O_
    },
    angle: {
      signal: tre
    },
    limit: e("limit"),
    frame: e("frame"),
    offset: e("offset") || 0,
    padding: e("subtitlePadding")
  }), Vu(n, t, Cd);
}
function sre(e, t, n, i) {
  const r = {
    value: 0
  }, s = e.text, o = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Wt(o, {
    text: s,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("color"),
    font: t("font"),
    fontSize: t("fontSize"),
    fontStyle: t("fontStyle"),
    fontWeight: t("fontWeight"),
    lineHeight: t("lineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), oi({
    type: ol,
    role: Zte,
    style: fie,
    from: i,
    encode: o
  }, n);
}
function ore(e, t, n, i) {
  const r = {
    value: 0
  }, s = e.subtitle, o = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Wt(o, {
    text: s,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("subtitleColor"),
    font: t("subtitleFont"),
    fontSize: t("subtitleFontSize"),
    fontStyle: t("subtitleFontStyle"),
    fontWeight: t("subtitleFontWeight"),
    lineHeight: t("subtitleLineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), oi({
    type: ol,
    role: ene,
    style: die,
    from: i,
    encode: o
  }, n);
}
function are(e, t) {
  const n = [];
  e.transform && e.transform.forEach((i) => {
    n.push(R_(i, t));
  }), e.on && e.on.forEach((i) => {
    I6(i, t, e.name);
  }), t.addDataPipeline(e.name, lre(e, t, n));
}
function lre(e, t, n) {
  const i = [];
  let r = null, s = !1, o = !1, a, l, u, c, f;
  for (e.values ? xt(e.values) || Kh(e.format) ? (i.push(x$(t, e)), i.push(r = Yo())) : i.push(r = Yo({
    $ingest: e.values,
    $format: e.format
  })) : e.url ? Kh(e.url) || Kh(e.format) ? (i.push(x$(t, e)), i.push(r = Yo())) : i.push(r = Yo({
    $request: e.url,
    $format: e.format
  })) : e.source && (r = a = J(e.source).map((d) => ae(t.getData(d).output)), i.push(null)), l = 0, u = n.length; l < u; ++l)
    c = n[l], f = c.metadata, !r && !f.source && i.push(r = Yo()), i.push(c), f.generates && (o = !0), f.modifies && !o && (s = !0), f.source ? r = c : f.changes && (r = null);
  return a && (u = a.length - 1, i[0] = jne({
    derive: s,
    pulse: u ? a : a[0]
  }), (s || u) && i.splice(1, 0, Yo())), r || i.push(Yo()), i.push(sl({})), i;
}
function Yo(e) {
  const t = ir({}, e);
  return t.metadata = {
    source: !0
  }, t;
}
function x$(e, t) {
  return Nne({
    url: t.url ? e.property(t.url) : void 0,
    async: t.async ? e.property(t.async) : void 0,
    values: t.values ? e.property(t.values) : void 0,
    format: e.objectProperty(t.format)
  });
}
const z6 = (e) => e === Eo || e === rr, t0 = (e, t, n) => xt(e) ? dre(e.signal, t, n) : e === Yu || e === rr ? t : n, Ot = (e, t, n) => xt(e) ? cre(e.signal, t, n) : z6(e) ? t : n, Yi = (e, t, n) => xt(e) ? fre(e.signal, t, n) : z6(e) ? n : t, B6 = (e, t, n) => xt(e) ? hre(e.signal, t, n) : e === rr ? {
  value: t
} : {
  value: n
}, ure = (e, t, n) => xt(e) ? gre(e.signal, t, n) : e === Xu ? {
  value: t
} : {
  value: n
}, cre = (e, t, n) => j6(`${e} === '${rr}' || ${e} === '${Eo}'`, t, n), fre = (e, t, n) => j6(`${e} !== '${rr}' && ${e} !== '${Eo}'`, t, n), dre = (e, t, n) => L_(`${e} === '${Yu}' || ${e} === '${rr}'`, t, n), hre = (e, t, n) => L_(`${e} === '${rr}'`, t, n), gre = (e, t, n) => L_(`${e} === '${Xu}'`, t, n), j6 = (e, t, n) => (t = t != null ? Tt(t) : t, n = n != null ? Tt(n) : n, w$(t) && w$(n) ? (t = t ? t.signal || X(t.value) : null, n = n ? n.signal || X(n.value) : null, {
  signal: `${e} ? (${t}) : (${n})`
}) : [we({
  test: e
}, t)].concat(n || [])), w$ = (e) => e == null || Object.keys(e).length === 1, L_ = (e, t, n) => ({
  signal: `${e} ? (${zl(t)}) : (${zl(n)})`
}), pre = (e, t, n, i, r) => ({
  signal: (i != null ? `${e} === '${Yu}' ? (${zl(i)}) : ` : "") + (n != null ? `${e} === '${Eo}' ? (${zl(n)}) : ` : "") + (r != null ? `${e} === '${Xu}' ? (${zl(r)}) : ` : "") + (t != null ? `${e} === '${rr}' ? (${zl(t)}) : ` : "") + "(null)"
}), zl = (e) => xt(e) ? e.signal : e == null ? null : X(e), mre = (e, t) => t === 0 ? 0 : xt(e) ? {
  signal: `(${e.signal}) * ${t}`
} : {
  value: e * t
}, Hl = (e, t) => {
  const n = e.signal;
  return n && n.endsWith("(null)") ? {
    signal: n.slice(0, -6) + t.signal
  } : e;
};
function Sl(e, t, n, i) {
  let r;
  if (t && ce(t, e))
    return t[e];
  if (ce(n, e))
    return n[e];
  if (e.startsWith("title")) {
    switch (e) {
      case "titleColor":
        r = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[M_][r];
  } else if (e.startsWith("label")) {
    switch (e) {
      case "labelColor":
        r = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[Ad][r];
  }
  return null;
}
function _$(e) {
  const t = {};
  for (const n of e)
    if (n)
      for (const i in n)
        t[i] = 1;
  return Object.keys(t);
}
function yre(e, t) {
  var n = t.config, i = n.style, r = n.axis, s = t.scaleType(e.scale) === "band" && n.axisBand, o = e.orient, a, l, u;
  if (xt(o)) {
    const f = _$([n.axisX, n.axisY]), d = _$([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
    a = {};
    for (u of f)
      a[u] = Ot(o, Sl(u, n.axisX, r, i), Sl(u, n.axisY, r, i));
    l = {};
    for (u of d)
      l[u] = pre(o.signal, Sl(u, n.axisTop, r, i), Sl(u, n.axisBottom, r, i), Sl(u, n.axisLeft, r, i), Sl(u, n.axisRight, r, i));
  } else
    a = o === rr || o === Eo ? n.axisX : n.axisY, l = n["axis" + o[0].toUpperCase() + o.slice(1)];
  return a || l || s ? we({}, r, a, l, s) : r;
}
function bre(e, t, n, i) {
  const r = qn(e, t), s = e.orient;
  let o, a;
  const l = {
    enter: o = {
      opacity: Ne
    },
    update: a = {
      opacity: bi
    },
    exit: {
      opacity: Ne
    }
  };
  Wt(l, {
    stroke: r("domainColor"),
    strokeCap: r("domainCap"),
    strokeDash: r("domainDash"),
    strokeDashOffset: r("domainDashOffset"),
    strokeWidth: r("domainWidth"),
    strokeOpacity: r("domainOpacity")
  });
  const u = E$(e, 0), c = E$(e, 1);
  return o.x = a.x = Ot(s, u, Ne), o.x2 = a.x2 = Ot(s, c), o.y = a.y = Yi(s, u, Ne), o.y2 = a.y2 = Yi(s, c), oi({
    type: T_,
    role: jte,
    from: i,
    encode: l
  }, n);
}
function E$(e, t) {
  return {
    scale: e.scale,
    range: t
  };
}
function vre(e, t, n, i, r) {
  const s = qn(e, t), o = e.orient, a = e.gridScale, l = t0(o, 1, -1), u = xre(e.offset, l);
  let c, f, d;
  const h = {
    enter: c = {
      opacity: Ne
    },
    update: d = {
      opacity: bi
    },
    exit: f = {
      opacity: Ne
    }
  };
  Wt(h, {
    stroke: s("gridColor"),
    strokeCap: s("gridCap"),
    strokeDash: s("gridDash"),
    strokeDashOffset: s("gridDashOffset"),
    strokeOpacity: s("gridOpacity"),
    strokeWidth: s("gridWidth")
  });
  const g = {
    scale: e.scale,
    field: yi,
    band: r.band,
    extra: r.extra,
    offset: r.offset,
    round: s("tickRound")
  }, p = Ot(o, {
    signal: "height"
  }, {
    signal: "width"
  }), m = a ? {
    scale: a,
    range: 0,
    mult: l,
    offset: u
  } : {
    value: 0,
    offset: u
  }, y = a ? {
    scale: a,
    range: 1,
    mult: l,
    offset: u
  } : we(p, {
    mult: l,
    offset: u
  });
  return c.x = d.x = Ot(o, g, m), c.y = d.y = Yi(o, g, m), c.x2 = d.x2 = Yi(o, y), c.y2 = d.y2 = Ot(o, y), f.x = Ot(o, g), f.y = Yi(o, g), oi({
    type: T_,
    role: Ute,
    key: yi,
    from: i,
    encode: h
  }, n);
}
function xre(e, t) {
  if (t !== 1)
    if (!ee(e))
      e = xt(t) ? {
        signal: `(${t.signal}) * (${e || 0})`
      } : t * (e || 0);
    else {
      let n = e = we({}, e);
      for (; n.mult != null; )
        if (ee(n.mult))
          n = n.mult = we({}, n.mult);
        else
          return n.mult = xt(t) ? {
            signal: `(${n.mult}) * (${t.signal})`
          } : n.mult * t, e;
      n.mult = t;
    }
  return e;
}
function wre(e, t, n, i, r, s) {
  const o = qn(e, t), a = e.orient, l = t0(a, -1, 1);
  let u, c, f;
  const d = {
    enter: u = {
      opacity: Ne
    },
    update: f = {
      opacity: bi
    },
    exit: c = {
      opacity: Ne
    }
  };
  Wt(d, {
    stroke: o("tickColor"),
    strokeCap: o("tickCap"),
    strokeDash: o("tickDash"),
    strokeDashOffset: o("tickDashOffset"),
    strokeOpacity: o("tickOpacity"),
    strokeWidth: o("tickWidth")
  });
  const h = Tt(r);
  h.mult = l;
  const g = {
    scale: e.scale,
    field: yi,
    band: s.band,
    extra: s.extra,
    offset: s.offset,
    round: o("tickRound")
  };
  return f.y = u.y = Ot(a, Ne, g), f.y2 = u.y2 = Ot(a, h), c.x = Ot(a, g), f.x = u.x = Yi(a, Ne, g), f.x2 = u.x2 = Yi(a, h), c.y = Yi(a, g), oi({
    type: T_,
    role: Wte,
    key: yi,
    from: i,
    encode: d
  }, n);
}
function Z1(e, t, n, i, r) {
  return {
    signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
  };
}
function _re(e, t, n, i, r, s) {
  const o = qn(e, t), a = e.orient, l = e.scale, u = t0(a, -1, 1), c = Ea(o("labelFlush")), f = Ea(o("labelFlushOffset")), d = o("labelAlign"), h = o("labelBaseline");
  let g = c === 0 || !!c, p;
  const m = Tt(r);
  m.mult = u, m.offset = Tt(o("labelPadding") || 0), m.offset.mult = u;
  const y = {
    scale: l,
    field: yi,
    band: 0.5,
    offset: D6(s.offset, o("labelOffset"))
  }, b = Ot(a, g ? Z1(l, c, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ure(a, "left", "right")), v = Ot(a, B6(a, "bottom", "top"), g ? Z1(l, c, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  }), w = Z1(l, c, `-(${f})`, f, 0);
  g = g && f;
  const _ = {
    opacity: Ne,
    x: Ot(a, y, m),
    y: Yi(a, y, m)
  }, S = {
    enter: _,
    update: p = {
      opacity: bi,
      text: {
        field: $_
      },
      x: _.x,
      y: _.y,
      align: b,
      baseline: v
    },
    exit: {
      opacity: Ne,
      x: _.x,
      y: _.y
    }
  };
  Wt(S, {
    dx: !d && g ? Ot(a, w) : null,
    dy: !h && g ? Yi(a, w) : null
  }), Wt(S, {
    angle: o("labelAngle"),
    fill: o("labelColor"),
    fillOpacity: o("labelOpacity"),
    font: o("labelFont"),
    fontSize: o("labelFontSize"),
    fontWeight: o("labelFontWeight"),
    fontStyle: o("labelFontStyle"),
    limit: o("labelLimit"),
    lineHeight: o("labelLineHeight")
  }, {
    align: d,
    baseline: h
  });
  const E = o("labelBound");
  let C = o("labelOverlap");
  return C = C || E ? {
    separation: o("labelSeparation"),
    method: C,
    order: "datum.index",
    bound: E ? {
      scale: l,
      orient: a,
      tolerance: E
    } : null
  } : void 0, p.align !== b && (p.align = Hl(p.align, b)), p.baseline !== v && (p.baseline = Hl(p.baseline, v)), oi({
    type: ol,
    role: qte,
    style: Ad,
    key: yi,
    from: i,
    encode: S,
    overlap: C
  }, n);
}
function Ere(e, t, n, i) {
  const r = qn(e, t), s = e.orient, o = t0(s, -1, 1);
  let a, l;
  const u = {
    enter: a = {
      opacity: Ne,
      anchor: Tt(r("titleAnchor", null)),
      align: {
        signal: O_
      }
    },
    update: l = we({}, a, {
      opacity: bi,
      text: Tt(e.title)
    }),
    exit: {
      opacity: Ne
    }
  }, c = {
    signal: `lerp(range("${e.scale}"), ${Qm(0, 1, 0.5)})`
  };
  return l.x = Ot(s, c), l.y = Yi(s, c), a.angle = Ot(s, Ne, mre(o, 90)), a.baseline = Ot(s, B6(s, Eo, rr), {
    value: Eo
  }), l.angle = a.angle, l.baseline = a.baseline, Wt(u, {
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    // require update
    align: r("titleAlign"),
    angle: r("titleAngle"),
    baseline: r("titleBaseline")
  }), Sre(r, s, u, n), u.update.align = Hl(u.update.align, a.align), u.update.angle = Hl(u.update.angle, a.angle), u.update.baseline = Hl(u.update.baseline, a.baseline), oi({
    type: ol,
    role: Hte,
    style: M_,
    from: i,
    encode: u
  }, n);
}
function Sre(e, t, n, i) {
  const r = (a, l) => a != null ? (n.update[l] = Hl(Tt(a), n.update[l]), !1) : !Ol(l, i), s = r(e("titleX"), "x"), o = r(e("titleY"), "y");
  n.enter.auto = o === s ? Tt(o) : Ot(t, Tt(o), Tt(s));
}
function kre(e, t) {
  const n = yre(e, t), i = e.encode || {}, r = i.axis || {}, s = r.name || void 0, o = r.interactive, a = r.style, l = qn(e, n), u = wie(l), c = {
    scale: e.scale,
    ticks: !!l("ticks"),
    labels: !!l("labels"),
    grid: !!l("grid"),
    domain: !!l("domain"),
    title: e.title != null
  }, f = ae(t.add(ir({}, [c]))), d = ae(t.add(Ane({
    scale: t.scaleRef(e.scale),
    extra: t.property(u.extra),
    count: t.objectProperty(e.tickCount),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  }))), h = [];
  let g;
  return c.grid && h.push(vre(e, n, i.grid, d, u)), c.ticks && (g = l("tickSize"), h.push(wre(e, n, i.ticks, d, g, u))), c.labels && (g = c.ticks ? g : 0, h.push(_re(e, n, i.labels, d, g, u))), c.domain && h.push(bre(e, n, i.domain, f)), c.title && h.push(Ere(e, n, i.title, f)), e0(Wf({
    role: Bte,
    from: f,
    encode: Vu(Are(l, e), r, Cd),
    marks: h,
    aria: l("aria"),
    description: l("description"),
    zindex: l("zindex"),
    name: s,
    interactive: o,
    style: a
  }), t);
}
function Are(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Wt(n, {
    orient: e("orient"),
    offset: e("offset") || 0,
    position: Ii(t.position, 0),
    titlePadding: e("titlePadding"),
    minExtent: e("minExtent"),
    maxExtent: e("maxExtent"),
    range: {
      signal: `abs(span(range("${t.scale}")))`
    },
    translate: e("translate"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), n;
}
function U6(e, t, n) {
  const i = J(e.signals), r = J(e.scales);
  return n || i.forEach((s) => x6(s, t)), J(e.projections).forEach((s) => rie(s, t)), r.forEach((s) => Gne(s, t)), J(e.data).forEach((s) => are(s, t)), r.forEach((s) => Vne(s, t)), (n || i).forEach((s) => kne(s, t)), J(e.axes).forEach((s) => kre(s, t)), J(e.marks).forEach((s) => e0(s, t)), J(e.legends).forEach((s) => Xie(s, t)), e.title && nre(e.title, t), t.parseLambdas(), t;
}
const Cre = (e) => Vu({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, e);
function $re(e, t) {
  const n = t.config, i = ae(t.root = t.add(bp())), r = Mre(e, n);
  r.forEach((u) => x6(u, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
  const s = t.add(ir()), o = t.add(E6(v6(Cre(e.encode), Jm, S_, e.style, t, {
    pulse: ae(s)
  }))), a = t.add(A6({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    autosize: t.signalRef("autosize"),
    mark: i,
    pulse: ae(o)
  }));
  t.operators.pop(), t.pushState(ae(o), ae(a), null), U6(e, t, r), t.operators.push(a);
  let l = t.add(_6({
    mark: i,
    pulse: ae(a)
  }));
  return l = t.add(k6({
    pulse: ae(l)
  })), l = t.add(sl({
    pulse: ae(l)
  })), t.addData("root", new za(t, s, s, l)), t;
}
function _c(e, t) {
  return t && t.signal ? {
    name: e,
    update: t.signal
  } : {
    name: e,
    value: t
  };
}
function Mre(e, t) {
  const n = (o) => Ii(e[o], t[o]), i = [_c("background", n("background")), _c("autosize", Pte(n("autosize"))), _c("padding", zte(n("padding"))), _c("width", n("width") || 0), _c("height", n("height") || 0)], r = i.reduce((o, a) => (o[a.name] = a, o), {}), s = {};
  return J(e.signals).forEach((o) => {
    ce(r, o.name) ? o = we(r[o.name], o) : i.push(o), s[o.name] = o;
  }), J(t.signals).forEach((o) => {
    !ce(s, o.name) && !ce(r, o.name) && i.push(o);
  }), i;
}
function q6(e, t) {
  this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
}
function S$(e) {
  this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath;
}
q6.prototype = S$.prototype = {
  parse(e) {
    return U6(e, this);
  },
  fork() {
    return new S$(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    return this.finish(), {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(e) {
    return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
      t.$ref = e.id;
    }), e.refs = null), e;
  },
  proxy(e) {
    const t = e instanceof iv ? ae(e) : e;
    return this.add(Bne({
      value: t
    }));
  },
  addStream(e) {
    return this.streams.push(e), e.id = this.id(), e;
  },
  addUpdate(e) {
    return this.updates.push(e), e;
  },
  // Apply metadata
  finish() {
    let e, t;
    this.root && (this.root.root = !0);
    for (e in this.signals)
      this.signals[e].signal = e;
    for (e in this.scales)
      this.scales[e].scale = e;
    function n(i, r, s) {
      let o, a;
      i && (o = i.data || (i.data = {}), a = o[r] || (o[r] = []), a.push(s));
    }
    for (e in this.data) {
      t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
      for (const i in t.index)
        n(t.index[i], e, "index:" + i);
    }
    return this;
  },
  // ----
  pushState(e, t, n) {
    this._encode.push(ae(this.add(sl({
      pulse: e
    })))), this._parent.push(t), this._lookup.push(n ? ae(this.proxy(n)) : null), this._markpath.push(-1);
  },
  popState() {
    this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
  },
  parent() {
    return Oe(this._parent);
  },
  encode() {
    return Oe(this._encode);
  },
  lookup() {
    return Oe(this._lookup);
  },
  markpath() {
    const e = this._markpath;
    return ++e[e.length - 1];
  },
  // ----
  fieldRef(e, t) {
    if (Q(e))
      return Uf(e, t);
    e.signal || B("Unsupported field reference: " + X(e));
    const n = e.signal;
    let i = this.field[n];
    if (!i) {
      const r = {
        name: this.signalRef(n)
      };
      t && (r.as = t), this.field[n] = i = ae(this.add(Fne(r)));
    }
    return i;
  },
  compareRef(e) {
    let t = !1;
    const n = (s) => xt(s) ? (t = !0, this.signalRef(s.signal)) : pne(s) ? (t = !0, this.exprRef(s.expr)) : s, i = J(e.field).map(n), r = J(e.order).map(n);
    return t ? ae(this.add(c$({
      fields: i,
      orders: r
    }))) : l$(i, r);
  },
  keyRef(e, t) {
    let n = !1;
    const i = (s) => xt(s) ? (n = !0, ae(r[s.signal])) : s, r = this.signals;
    return e = J(e).map(i), n ? ae(this.add(Tne({
      fields: e,
      flat: t
    }))) : fne(e, t);
  },
  sortRef(e) {
    if (!e)
      return e;
    const t = Xm(e.op, e.field), n = e.order || dne;
    return n.signal ? ae(this.add(c$({
      fields: t,
      orders: this.signalRef(n.signal)
    }))) : l$(t, n);
  },
  // ----
  event(e, t) {
    const n = e + ":" + t;
    if (!this.events[n]) {
      const i = this.id();
      this.streams.push({
        id: i,
        source: e,
        type: t
      }), this.events[n] = i;
    }
    return this.events[n];
  },
  // ----
  hasOwnSignal(e) {
    return ce(this.signals, e);
  },
  addSignal(e, t) {
    this.hasOwnSignal(e) && B("Duplicate signal name: " + X(e));
    const n = t instanceof iv ? t : this.add(bp(t));
    return this.signals[e] = n;
  },
  getSignal(e) {
    return this.signals[e] || B("Unrecognized signal name: " + X(e)), this.signals[e];
  },
  signalRef(e) {
    return this.signals[e] ? ae(this.signals[e]) : (ce(this.lambdas, e) || (this.lambdas[e] = this.add(bp(null))), ae(this.lambdas[e]));
  },
  parseLambdas() {
    const e = Object.keys(this.lambdas);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t], r = Nr(i, this), s = this.lambdas[i];
      s.params = r.$params, s.update = r.$expr;
    }
  },
  property(e) {
    return e && e.signal ? this.signalRef(e.signal) : e;
  },
  objectProperty(e) {
    return !e || !ee(e) ? e : this.signalRef(e.signal || P_(e));
  },
  exprRef(e, t) {
    const n = {
      expr: Nr(e, this)
    };
    return t && (n.expr.$name = t), ae(this.add($ne(n)));
  },
  addBinding(e, t) {
    this.bindings || B("Nested signals do not support binding: " + X(e)), this.bindings.push(we({
      signal: e
    }, t));
  },
  // ----
  addScaleProj(e, t) {
    ce(this.scales, e) && B("Duplicate scale or projection name: " + X(e)), this.scales[e] = this.add(t);
  },
  addScale(e, t) {
    this.addScaleProj(e, Une(t));
  },
  addProjection(e, t) {
    this.addScaleProj(e, zne(t));
  },
  getScale(e) {
    return this.scales[e] || B("Unrecognized scale name: " + X(e)), this.scales[e];
  },
  scaleRef(e) {
    return ae(this.getScale(e));
  },
  scaleType(e) {
    return this.getScale(e).params.type;
  },
  projectionRef(e) {
    return this.scaleRef(e);
  },
  projectionType(e) {
    return this.scaleType(e);
  },
  // ----
  addData(e, t) {
    return ce(this.data, e) && B("Duplicate data set name: " + X(e)), this.data[e] = t;
  },
  getData(e) {
    return this.data[e] || B("Undefined data set name: " + X(e)), this.data[e];
  },
  addDataPipeline(e, t) {
    return ce(this.data, e) && B("Duplicate data set name: " + X(e)), this.addData(e, za.fromEntries(this, t));
  }
};
function P_(e) {
  return (j(e) ? Fre : Tre)(e);
}
function Fre(e) {
  const t = e.length;
  let n = "[";
  for (let i = 0; i < t; ++i) {
    const r = e[i];
    n += (i > 0 ? "," : "") + (ee(r) ? r.signal || P_(r) : X(r));
  }
  return n + "]";
}
function Tre(e) {
  let t = "{", n = 0, i, r;
  for (i in e)
    r = e[i], t += (++n > 1 ? "," : "") + X(i) + ":" + (ee(r) ? r.signal || P_(r) : X(r));
  return t + "}";
}
function Ore() {
  const e = "sans-serif", i = "#4c78a8", r = "#000", s = "#888", o = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: i
    },
    area: {
      fill: i
    },
    image: null,
    line: {
      stroke: i,
      strokeWidth: 2
    },
    path: {
      stroke: i
    },
    rect: {
      fill: i
    },
    rule: {
      stroke: r
    },
    shape: {
      stroke: i
    },
    symbol: {
      fill: i,
      size: 64
    },
    text: {
      fill: r,
      font: e,
      fontSize: 11
    },
    trail: {
      fill: i,
      size: 2
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: r,
        font: e,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: r,
        font: e,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: r,
        font: e,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: r,
        font: e,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: 30,
        strokeWidth: 2,
        shape: "circle"
      },
      circle: {
        size: 30,
        strokeWidth: 2
      },
      square: {
        size: 30,
        strokeWidth: 2,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: o
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: !0,
      domainWidth: 1,
      domainColor: s,
      grid: !1,
      gridWidth: 1,
      gridColor: o,
      labels: !0,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: !0,
      tickColor: s,
      tickOffset: 0,
      tickRound: !0,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: o,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: !0,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: s,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function Nre(e, t, n) {
  return ee(e) || B("Input Vega specification must be an object."), t = Du(Ore(), t, e.config), $re(e, new q6(t, n)).toRuntime();
}
var Dre = "5.27.0";
we(ru, zB, oG, IG, EY, yX, WK, EK, GK, mJ, AJ, NJ);
const Rre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bounds: ht,
  CanvasHandler: wo,
  CanvasRenderer: Of,
  DATE: Pn,
  DAY: Jt,
  DAYOFYEAR: Tr,
  Dataflow: jl,
  Debug: j3,
  Error: Hv,
  EventStream: tm,
  Gradient: RO,
  GroupItem: Sm,
  HOURS: ii,
  Handler: xo,
  HybridHandler: fw,
  HybridRenderer: Dg,
  Info: B3,
  Item: Em,
  MILLISECONDS: Qi,
  MINUTES: ri,
  MONTH: nn,
  Marks: si,
  MultiPulse: mx,
  None: z3,
  Operator: Ye,
  Parameters: em,
  Pulse: ao,
  QUARTER: Ln,
  RenderType: Zs,
  Renderer: li,
  ResourceLoader: B2,
  SECONDS: Si,
  SVGHandler: rw,
  SVGRenderer: Om,
  SVGStringRenderer: cw,
  Scenegraph: nw,
  TIME_UNITS: ox,
  Transform: P,
  View: a6,
  WEEK: yt,
  Warn: Gv,
  YEAR: Ut,
  accessor: Un,
  accessorFields: tn,
  accessorName: lt,
  array: J,
  ascending: qp,
  bandwidthNRD: xx,
  bin: _T,
  bootstrapCI: ET,
  boundClip: ON,
  boundContext: gd,
  boundItem: sb,
  boundMark: eN,
  boundStroke: Fs,
  changeset: tl,
  clampRange: Q3,
  codegenExpression: DR,
  compare: Jv,
  constant: an,
  cumulativeLogNormal: Ax,
  cumulativeNormal: im,
  cumulativeUniform: Fx,
  dayofyear: MF,
  debounce: Qv,
  defaultLocale: fx,
  definition: vT,
  densityLogNormal: kx,
  densityNormal: wx,
  densityUniform: Mx,
  domChild: mt,
  domClear: fi,
  domCreate: Js,
  domFind: iw,
  dotbin: ST,
  error: B,
  expressionFunction: dt,
  extend: we,
  extent: $r,
  extentIndex: Z3,
  falsy: js,
  fastmap: Lu,
  field: _i,
  flush: eF,
  font: Mm,
  fontFamily: yd,
  fontSize: zr,
  format: Th,
  formatLocale: fg,
  formats: gx,
  hasOwnProperty: ce,
  id: Zf,
  identity: on,
  inferType: lT,
  inferTypes: uT,
  ingest: Be,
  inherits: Y,
  inrange: Dl,
  interpolate: O2,
  interpolateColors: wm,
  interpolateRange: wO,
  intersect: $N,
  intersectBoxLine: Rl,
  intersectPath: j2,
  intersectPoint: U2,
  intersectRule: qO,
  isArray: j,
  isBoolean: To,
  isDate: so,
  isFunction: Ee,
  isIterable: tF,
  isNumber: Re,
  isObject: ee,
  isRegExp: nF,
  isString: Q,
  isTuple: Qp,
  key: Zv,
  lerp: iF,
  lineHeight: bo,
  loader: Kp,
  locale: oT,
  logger: Vv,
  lruCache: rF,
  markup: uw,
  merge: sF,
  mergeConfig: Du,
  multiLineOffset: Z2,
  one: Nu,
  pad: oF,
  panLinear: G3,
  panLog: V3,
  panPow: Y3,
  panSymlog: X3,
  parse: Nre,
  parseExpression: c_,
  parseSelector: Po,
  path: lm,
  pathCurves: P2,
  pathEqual: NN,
  pathParse: cu,
  pathRectangle: IO,
  pathRender: $f,
  pathSymbols: PO,
  pathTrail: zO,
  peek: Oe,
  point: Tm,
  projection: Fw,
  quantileLogNormal: Cx,
  quantileNormal: rm,
  quantileUniform: Tx,
  quantiles: bx,
  quantizeInterpolator: _O,
  quarter: K3,
  quartiles: vx,
  get random() {
    return ki;
  },
  randomInteger: q7,
  randomKDE: Ex,
  randomLCG: U7,
  randomLogNormal: AT,
  randomMixture: CT,
  randomNormal: _x,
  randomUniform: $T,
  read: dT,
  regressionConstant: Ox,
  regressionExp: FT,
  regressionLinear: Nx,
  regressionLoess: NT,
  regressionLog: MT,
  regressionPoly: OT,
  regressionPow: TT,
  regressionQuad: Dx,
  renderModule: Nm,
  repeat: Fc,
  resetDefaultLocale: zz,
  resetSVGClipId: jO,
  resetSVGDefIds: SH,
  responseType: fT,
  runtimeContext: YR,
  sampleCurve: om,
  sampleLogNormal: Sx,
  sampleNormal: nm,
  sampleUniform: $x,
  scale: Ie,
  sceneEqual: dw,
  sceneFromJSON: nN,
  scenePickVisit: kg,
  sceneToJSON: tN,
  sceneVisit: Zi,
  sceneZOrder: q2,
  scheme: N2,
  serializeXML: vN,
  setHybridRendererOptions: xH,
  setRandom: B7,
  span: ed,
  splitAccessPath: Pr,
  stringValue: X,
  textMetrics: Zn,
  timeBin: GF,
  timeFloor: LF,
  timeFormatLocale: _f,
  timeInterval: Bu,
  timeOffset: zF,
  timeSequence: UF,
  timeUnitSpecifier: $F,
  timeUnits: ax,
  toBoolean: ex,
  toDate: tx,
  toNumber: Qt,
  toSet: Ji,
  toString: nx,
  transform: xT,
  transforms: ru,
  truncate: aF,
  truthy: Ei,
  tupleid: le,
  typeParsers: jy,
  utcFloor: PF,
  utcInterval: ju,
  utcOffset: BF,
  utcSequence: qF,
  utcdayofyear: OF,
  utcquarter: J3,
  utcweek: NF,
  version: Dre,
  visitArray: Ws,
  week: FF,
  writeConfig: Ru,
  zero: Xs,
  zoomLinear: Yv,
  zoomLog: Xv,
  zoomPow: sg,
  zoomSymlog: Kv
}, Symbol.toStringTag, { value: "Module" }));
function Lre(e, t, n) {
  let i;
  t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2);
}
var Pre = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
}, Ire = {
  "*": (e, t) => e * t,
  "+": (e, t) => e + t,
  "-": (e, t) => e - t,
  "/": (e, t) => e / t,
  "%": (e, t) => e % t,
  ">": (e, t) => e > t,
  "<": (e, t) => e < t,
  "<=": (e, t) => e <= t,
  ">=": (e, t) => e >= t,
  "==": (e, t) => e == t,
  "!=": (e, t) => e != t,
  "===": (e, t) => e === t,
  "!==": (e, t) => e !== t,
  "&": (e, t) => e & t,
  "|": (e, t) => e | t,
  "^": (e, t) => e ^ t,
  "<<": (e, t) => e << t,
  ">>": (e, t) => e >> t,
  ">>>": (e, t) => e >>> t
}, zre = {
  "+": (e) => +e,
  "-": (e) => -e,
  "~": (e) => ~e,
  "!": (e) => !e
};
const Bre = Array.prototype.slice, Xo = (e, t, n) => {
  const i = n ? n(t[0]) : t[0];
  return i[e].apply(i, Bre.call(t, 1));
}, jre = (e, t, n, i, r, s, o) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, o || 0);
var Ure = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime: jre,
  date: (e) => new Date(e).getDate(),
  day: (e) => new Date(e).getDay(),
  year: (e) => new Date(e).getFullYear(),
  month: (e) => new Date(e).getMonth(),
  hours: (e) => new Date(e).getHours(),
  minutes: (e) => new Date(e).getMinutes(),
  seconds: (e) => new Date(e).getSeconds(),
  milliseconds: (e) => new Date(e).getMilliseconds(),
  time: (e) => new Date(e).getTime(),
  timezoneoffset: (e) => new Date(e).getTimezoneOffset(),
  utcdate: (e) => new Date(e).getUTCDate(),
  utcday: (e) => new Date(e).getUTCDay(),
  utcyear: (e) => new Date(e).getUTCFullYear(),
  utcmonth: (e) => new Date(e).getUTCMonth(),
  utchours: (e) => new Date(e).getUTCHours(),
  utcminutes: (e) => new Date(e).getUTCMinutes(),
  utcseconds: (e) => new Date(e).getUTCSeconds(),
  utcmilliseconds: (e) => new Date(e).getUTCMilliseconds(),
  // sequence functions
  length: (e) => e.length,
  join: function() {
    return Xo("join", arguments);
  },
  indexof: function() {
    return Xo("indexOf", arguments);
  },
  lastindexof: function() {
    return Xo("lastIndexOf", arguments);
  },
  slice: function() {
    return Xo("slice", arguments);
  },
  reverse: (e) => e.slice().reverse(),
  // string functions
  parseFloat,
  parseInt,
  upper: (e) => String(e).toUpperCase(),
  lower: (e) => String(e).toLowerCase(),
  substring: function() {
    return Xo("substring", arguments, String);
  },
  split: function() {
    return Xo("split", arguments, String);
  },
  replace: function() {
    return Xo("replace", arguments, String);
  },
  trim: (e) => String(e).trim(),
  // regexp functions
  regexp: RegExp,
  test: (e, t) => RegExp(e).test(t)
};
const qre = ["view", "item", "group", "xy", "x", "y"], cv = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
typeof setImmediate == "function" && cv.add(setImmediate);
const Wre = {
  Literal: (e, t) => t.value,
  Identifier: (e, t) => {
    const n = t.name;
    return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Pre[n] || e.params["$" + n];
  },
  MemberExpression: (e, t) => {
    const n = !t.computed, i = e(t.object);
    n && (e.memberDepth += 1);
    const r = e(t.property);
    if (n && (e.memberDepth -= 1), cv.has(i[r])) {
      console.error(`Prevented interpretation of member "${r}" which could lead to insecure code execution`);
      return;
    }
    return i[r];
  },
  CallExpression: (e, t) => {
    const n = t.arguments;
    let i = t.callee.name;
    return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Ure[i]).apply(e.fn, n.map(e));
  },
  ArrayExpression: (e, t) => t.elements.map(e),
  BinaryExpression: (e, t) => Ire[t.operator](e(t.left), e(t.right)),
  UnaryExpression: (e, t) => zre[t.operator](e(t.argument)),
  ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
  LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
  ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
    e.memberDepth += 1;
    const r = e(i.key);
    return e.memberDepth -= 1, cv.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n;
  }, {})
};
function Ec(e, t, n, i, r, s) {
  const o = (a) => Wre[a.type](o, a);
  return o.memberDepth = 0, o.fn = Object.create(t), o.params = n, o.datum = i, o.event = r, o.item = s, qre.forEach((a) => o.fn[a] = function() {
    return r.vega[a](...arguments);
  }), o(e);
}
var Hre = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => Ec(n, i, r);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(e, t) {
    const n = t.ast, i = e.functions;
    return (r, s) => Ec(n, i, s, r);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => Ec(n, i, void 0, void 0, r);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(e, t) {
    const n = t.ast, i = e.functions;
    return (r, s) => {
      const o = s.item && s.item.datum;
      return Ec(n, i, r, o, s);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(e, t) {
    const {
      marktype: n,
      channels: i
    } = t, r = e.functions, s = n === "group" || n === "image" || n === "rect";
    return (o, a) => {
      const l = o.datum;
      let u = 0, c;
      for (const f in i)
        c = Ec(i[f].ast, r, a, l, void 0, o), o[f] !== c && (o[f] = c, u = 1);
      return n !== "rule" && Lre(o, i, s), u;
    };
  }
};
const Gre = "vega-lite", Vre = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer', Yre = "5.16.3", Xre = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
], Kre = "https://vega.github.io/vega-lite/", Jre = "Vega-Lite is a concise high-level language for interactive visualization.", Qre = [
  "vega",
  "chart",
  "visualization"
], Zre = "build/vega-lite.js", ese = "build/vega-lite.min.js", tse = "build/vega-lite.min.js", nse = "build/src/index", ise = "build/src/index.d.ts", rse = {
  vl2pdf: "./bin/vl2pdf",
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2vg: "./bin/vl2vg"
}, sse = [
  "bin",
  "build",
  "src",
  "vega-lite*",
  "tsconfig.json"
], ose = {
  changelog: "conventional-changelog -p angular -r 2",
  prebuild: "yarn clean:build",
  build: "yarn build:only",
  "build:only": "tsc -p tsconfig.build.json && rollup -c",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "rollup -c site/rollup.config.mjs",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "yarn site:only",
  "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  format: "eslint . --fix && yarn prettierbase --write",
  lint: "eslint . && yarn prettierbase --check",
  jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
  test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
  "test:cover": "yarn jest --collectCoverage test/",
  "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
  "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  watch: "tsc -p tsconfig.build.json -w",
  "watch:site": "yarn build:site -w",
  "watch:test": "yarn jest --watch test/",
  "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
  release: "release-it"
}, ase = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
}, lse = "BSD-3-Clause", use = {
  url: "https://github.com/vega/vega-lite/issues"
}, cse = {
  "@babel/core": "^7.22.10",
  "@babel/plugin-proposal-class-properties": "^7.18.6",
  "@babel/preset-env": "^7.22.10",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-alias": "^5.0.0",
  "@rollup/plugin-babel": "^6.0.3",
  "@rollup/plugin-commonjs": "^25.0.4",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.2.1",
  "@rollup/plugin-terser": "^0.4.3",
  "@types/chai": "^4.3.5",
  "@types/d3": "^7.4.0",
  "@types/jest": "^29.5.4",
  "@types/pako": "^2.0.0",
  "@typescript-eslint/eslint-plugin": "^6.4.1",
  "@typescript-eslint/parser": "^6.4.1",
  ajv: "^8.12.0",
  "ajv-formats": "^2.1.1",
  chai: "^4.3.7",
  cheerio: "^1.0.0-rc.12",
  "conventional-changelog-cli": "^4.0.0",
  d3: "^7.8.5",
  "del-cli": "^5.0.0",
  eslint: "^8.47.0",
  "eslint-config-prettier": "^9.0.0",
  "eslint-plugin-jest": "^27.2.3",
  "eslint-plugin-prettier": "^5.0.0",
  "fast-json-stable-stringify": "~2.1.0",
  "highlight.js": "^11.8.0",
  jest: "^29.6.3",
  "jest-dev-server": "^9.0.0",
  mkdirp: "^3.0.1",
  pako: "^2.1.0",
  prettier: "^3.0.2",
  puppeteer: "^15.0.0",
  "release-it": "^16.1.5",
  rollup: "^3.28.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-sourcemaps": "^0.6.3",
  serve: "^14.2.1",
  terser: "^5.19.2",
  "ts-jest": "^29.1.1",
  "ts-json-schema-generator": "^1.3.0",
  typescript: "~5.2.2",
  "vega-cli": "^5.25.0",
  "vega-datasets": "^2.7.0",
  "vega-embed": "^6.22.2",
  "vega-tooltip": "^0.33.0",
  "yaml-front-matter": "^4.1.1"
}, fse = {
  "json-stringify-pretty-compact": "~3.0.0",
  tslib: "~2.6.2",
  "vega-event-selector": "~3.0.1",
  "vega-expression": "~5.1.0",
  "vega-util": "~1.17.2",
  yargs: "~17.7.2"
}, dse = {
  vega: "^5.24.0"
}, hse = {
  node: ">=18"
}, gse = {
  name: Gre,
  author: Vre,
  version: Yre,
  collaborators: Xre,
  homepage: Kre,
  description: Jre,
  keywords: Qre,
  main: Zre,
  unpkg: ese,
  jsdelivr: tse,
  module: nse,
  types: ise,
  bin: rse,
  files: sse,
  scripts: ose,
  repository: ase,
  license: lse,
  bugs: use,
  devDependencies: cse,
  dependencies: fse,
  peerDependencies: dse,
  engines: hse
};
function I_(e) {
  return !!e.or;
}
function z_(e) {
  return !!e.and;
}
function B_(e) {
  return !!e.not;
}
function eg(e, t) {
  if (B_(e))
    eg(e.not, t);
  else if (z_(e))
    for (const n of e.and)
      eg(n, t);
  else if (I_(e))
    for (const n of e.or)
      eg(n, t);
  else
    t(e);
}
function Gl(e, t) {
  return B_(e) ? { not: Gl(e.not, t) } : z_(e) ? { and: e.and.map((n) => Gl(n, t)) } : I_(e) ? { or: e.or.map((n) => Gl(n, t)) } : t(e);
}
const me = structuredClone;
function W6(e) {
  throw new Error(e);
}
function vu(e, t) {
  const n = {};
  for (const i of t)
    ce(e, i) && (n[i] = e[i]);
  return n;
}
function Nn(e, t) {
  const n = { ...e };
  for (const i of t)
    delete n[i];
  return n;
}
Set.prototype.toJSON = function() {
  return `Set(${[...this].map((e) => Ge(e)).join(",")})`;
};
function Me(e) {
  if (Re(e))
    return e;
  const t = Q(e) ? e : Ge(e);
  if (t.length < 250)
    return t;
  let n = 0;
  for (let i = 0; i < t.length; i++) {
    const r = t.charCodeAt(i);
    n = (n << 5) - n + r, n = n & n;
  }
  return n;
}
function fv(e) {
  return e === !1 || e === null;
}
function Fe(e, t) {
  return e.includes(t);
}
function Ba(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (t(r, i, n++))
      return !0;
  return !1;
}
function j_(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (!t(r, i, n++))
      return !1;
  return !0;
}
function H6(e, ...t) {
  for (const n of t)
    pse(e, n ?? {});
  return e;
}
function pse(e, t) {
  for (const n of q(t))
    Ru(e, n, t[n], !0);
}
function xr(e, t) {
  const n = [], i = {};
  let r;
  for (const s of e)
    r = t(s), !(r in i) && (i[r] = 1, n.push(s));
  return n;
}
function mse(e, t) {
  const n = q(e), i = q(t);
  if (n.length !== i.length)
    return !1;
  for (const r of n)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function G6(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function U_(e, t) {
  for (const n of e)
    if (t.has(n))
      return !0;
  return !1;
}
function dv(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e) {
    const r = Pr(n).map((o, a) => a === 0 ? o : `[${o}]`), s = r.map((o, a) => r.slice(0, a + 1).join(""));
    for (const o of s)
      t.add(o);
  }
  return t;
}
function q_(e, t) {
  return e === void 0 || t === void 0 ? !0 : U_(dv(e), dv(t));
}
function He(e) {
  return q(e).length === 0;
}
const q = Object.keys, qt = Object.values, So = Object.entries;
function Hf(e) {
  return e === !0 || e === !1;
}
function et(e) {
  const t = e.replace(/\W/g, "_");
  return (e.match(/^\d+/) ? "_" : "") + t;
}
function hf(e, t) {
  return B_(e) ? `!(${hf(e.not, t)})` : z_(e) ? `(${e.and.map((n) => hf(n, t)).join(") && (")})` : I_(e) ? `(${e.or.map((n) => hf(n, t)).join(") || (")})` : t(e);
}
function vp(e, t) {
  if (t.length === 0)
    return !0;
  const n = t.shift();
  return n in e && vp(e[n], t) && delete e[n], He(e);
}
function $d(e) {
  return e.charAt(0).toUpperCase() + e.substr(1);
}
function W_(e, t = "datum") {
  const n = Pr(e), i = [];
  for (let r = 1; r <= n.length; r++) {
    const s = `[${n.slice(0, r).map(X).join("][")}]`;
    i.push(`${t}${s}`);
  }
  return i.join(" && ");
}
function V6(e, t = "datum") {
  return `${t}[${X(Pr(e).join("."))}]`;
}
function yse(e) {
  return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function Ci(e) {
  return `${Pr(e).map(yse).join("\\.")}`;
}
function ja(e, t, n) {
  return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);
}
function H_(e) {
  return `${Pr(e).join(".")}`;
}
function xu(e) {
  return e ? Pr(e).length : 0;
}
function ct(...e) {
  for (const t of e)
    if (t !== void 0)
      return t;
}
let Y6 = 42;
function X6(e) {
  const t = ++Y6;
  return e ? String(e) + t : t;
}
function bse() {
  Y6 = 42;
}
function K6(e) {
  return J6(e) ? e : `__${e}`;
}
function J6(e) {
  return e.startsWith("__");
}
function Gf(e) {
  if (e !== void 0)
    return (e % 360 + 360) % 360;
}
function n0(e) {
  return Re(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e));
}
const k$ = Object.getPrototypeOf(structuredClone({}));
function Kn(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor.name !== t.constructor.name)
      return !1;
    let n, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!Kn(e[i], t[i]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      for (i of e.entries())
        if (!Kn(i[1], t.get(i[0])))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (e[i] !== t[i])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf && e.valueOf !== k$.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString && e.toString !== k$.toString)
      return e.toString() === t.toString();
    const r = Object.keys(e);
    if (n = r.length, n !== Object.keys(t).length)
      return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[i]))
        return !1;
    for (i = n; i-- !== 0; ) {
      const s = r[i];
      if (!Kn(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Ge(e) {
  const t = [];
  return function n(i) {
    if (i && i.toJSON && typeof i.toJSON == "function" && (i = i.toJSON()), i === void 0)
      return;
    if (typeof i == "number")
      return isFinite(i) ? "" + i : "null";
    if (typeof i != "object")
      return JSON.stringify(i);
    let r, s;
    if (Array.isArray(i)) {
      for (s = "[", r = 0; r < i.length; r++)
        r && (s += ","), s += n(i[r]) || "null";
      return s + "]";
    }
    if (i === null)
      return "null";
    if (t.includes(i))
      throw new TypeError("Converting circular structure to JSON");
    const o = t.push(i) - 1, a = Object.keys(i).sort();
    for (s = "", r = 0; r < a.length; r++) {
      const l = a[r], u = n(i[l]);
      u && (s && (s += ","), s += JSON.stringify(l) + ":" + u);
    }
    return t.splice(o, 1), `{${s}}`;
  }(e);
}
const ms = "row", ys = "column", i0 = "facet", tt = "x", Lt = "y", sr = "x2", qr = "y2", Io = "xOffset", Ku = "yOffset", or = "radius", Os = "radius2", Fi = "theta", Ns = "theta2", ar = "latitude", lr = "longitude", ur = "latitude2", $i = "longitude2", zn = "color", Wr = "fill", Hr = "stroke", Bn = "shape", Ds = "size", al = "angle", Rs = "opacity", zo = "fillOpacity", Bo = "strokeOpacity", jo = "strokeWidth", Uo = "strokeDash", Md = "text", wu = "order", Fd = "detail", r0 = "key", Ua = "tooltip", s0 = "href", o0 = "url", a0 = "description", vse = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
}, Q6 = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function Z6(e) {
  return e in Q6;
}
const G_ = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function e4(e) {
  switch (e) {
    case ar:
      return "y";
    case ur:
      return "y2";
    case lr:
      return "x";
    case $i:
      return "x2";
  }
}
function t4(e) {
  return e in G_;
}
const xse = q(G_), V_ = {
  ...vse,
  ...Q6,
  ...G_,
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
};
function Vl(e) {
  return e === zn || e === Wr || e === Hr;
}
const n4 = {
  row: 1,
  column: 1,
  facet: 1
}, mi = q(n4), Y_ = {
  ...V_,
  ...n4
}, wse = q(Y_), { order: Bme, detail: jme, tooltip: Ume, ..._se } = Y_, { row: qme, column: Wme, facet: Hme, ...Ese } = _se;
function Sse(e) {
  return !!Ese[e];
}
function i4(e) {
  return !!Y_[e];
}
const kse = [sr, qr, ur, $i, Ns, Os];
function r4(e) {
  return ll(e) !== e;
}
function ll(e) {
  switch (e) {
    case sr:
      return tt;
    case qr:
      return Lt;
    case ur:
      return ar;
    case $i:
      return lr;
    case Ns:
      return Fi;
    case Os:
      return or;
  }
  return e;
}
function ko(e) {
  if (Z6(e))
    switch (e) {
      case Fi:
        return "startAngle";
      case Ns:
        return "endAngle";
      case or:
        return "outerRadius";
      case Os:
        return "innerRadius";
    }
  return e;
}
function Gr(e) {
  switch (e) {
    case tt:
      return sr;
    case Lt:
      return qr;
    case ar:
      return ur;
    case lr:
      return $i;
    case Fi:
      return Ns;
    case or:
      return Os;
  }
}
function jn(e) {
  switch (e) {
    case tt:
    case sr:
      return "width";
    case Lt:
    case qr:
      return "height";
  }
}
function s4(e) {
  switch (e) {
    case tt:
      return "xOffset";
    case Lt:
      return "yOffset";
    case sr:
      return "x2Offset";
    case qr:
      return "y2Offset";
    case Fi:
      return "thetaOffset";
    case or:
      return "radiusOffset";
    case Ns:
      return "theta2Offset";
    case Os:
      return "radius2Offset";
  }
}
function X_(e) {
  switch (e) {
    case tt:
      return "xOffset";
    case Lt:
      return "yOffset";
  }
}
function Ase(e) {
  switch (e) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
const Cse = q(V_), {
  x: Gme,
  y: Vme,
  // x2 and y2 share the same scale as x and y
  x2: Yme,
  y2: Xme,
  //
  xOffset: Kme,
  yOffset: Jme,
  latitude: Qme,
  longitude: Zme,
  latitude2: e0e,
  longitude2: t0e,
  theta: n0e,
  theta2: i0e,
  radius: r0e,
  radius2: s0e,
  // The rest of unit channels then have scale
  ...K_
} = V_, $se = q(K_), J_ = {
  x: 1,
  y: 1
}, Vr = q(J_);
function ft(e) {
  return e in J_;
}
const Q_ = {
  theta: 1,
  radius: 1
}, Mse = q(Q_);
function l0(e) {
  return e === "width" ? tt : Lt;
}
const o4 = { xOffset: 1, yOffset: 1 };
function Td(e) {
  return e in o4;
}
const {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: o0e,
  tooltip: a0e,
  href: l0e,
  url: u0e,
  description: c0e,
  // detail and order have no scale
  detail: f0e,
  key: d0e,
  order: h0e,
  ...a4
} = K_, Fse = q(a4);
function Tse(e) {
  return !!K_[e];
}
function Ose(e) {
  switch (e) {
    case zn:
    case Wr:
    case Hr:
    case Ds:
    case Bn:
    case Rs:
    case jo:
    case Uo:
      return !0;
    case zo:
    case Bo:
    case al:
      return !1;
  }
}
const l4 = {
  ...J_,
  ...Q_,
  ...o4,
  ...a4
}, u0 = q(l4);
function Ls(e) {
  return !!l4[e];
}
function Nse(e, t) {
  return Rse(e)[t];
}
const u4 = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
}, { geoshape: g0e, ...Dse } = u4;
function Rse(e) {
  switch (e) {
    case zn:
    case Wr:
    case Hr:
    case a0:
    case Fd:
    case r0:
    case Ua:
    case s0:
    case wu:
    case Rs:
    case zo:
    case Bo:
    case jo:
    case i0:
    case ms:
    case ys:
      return u4;
    case tt:
    case Lt:
    case Io:
    case Ku:
    case ar:
    case lr:
      return Dse;
    case sr:
    case qr:
    case ur:
    case $i:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case Ds:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case Uo:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case Bn:
      return { point: "always", geoshape: "always" };
    case Md:
      return { text: "always" };
    case al:
      return { point: "always", square: "always", text: "always" };
    case o0:
      return { image: "always" };
    case Fi:
      return { text: "always", arc: "always" };
    case or:
      return { text: "always", arc: "always" };
    case Ns:
    case Os:
      return { arc: "always" };
  }
}
function ey(e) {
  switch (e) {
    case tt:
    case Lt:
    case Fi:
    case or:
    case Io:
    case Ku:
    case Ds:
    case al:
    case jo:
    case Rs:
    case zo:
    case Bo:
    case sr:
    case qr:
    case Ns:
    case Os:
      return;
    case i0:
    case ms:
    case ys:
    case Bn:
    case Uo:
    case Md:
    case Ua:
    case s0:
    case o0:
    case a0:
      return "discrete";
    case zn:
    case Wr:
    case Hr:
      return "flexible";
    case ar:
    case lr:
    case ur:
    case $i:
    case Fd:
    case r0:
    case wu:
      return;
  }
}
const Lse = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
}, Pse = {
  count: 1,
  min: 1,
  max: 1
};
function Ss(e) {
  return !!e && !!e.argmin;
}
function qo(e) {
  return !!e && !!e.argmax;
}
function Z_(e) {
  return Q(e) && !!Lse[e];
}
const Ise = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function c4(e) {
  return Q(e) && Ise.has(e);
}
function zse(e) {
  return Q(e) && Fe(["min", "max"], e);
}
const Bse = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]), jse = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function f4(e) {
  return To(e) && (e = w0(e, void 0)), "bin" + q(e).map((t) => c0(e[t]) ? et(`_${t}_${So(e[t])}`) : et(`_${t}_${e[t]}`)).join("");
}
function Ke(e) {
  return e === !0 || ul(e) && !e.binned;
}
function zt(e) {
  return e === "binned" || ul(e) && e.binned === !0;
}
function ul(e) {
  return ee(e);
}
function c0(e) {
  return e == null ? void 0 : e.param;
}
function A$(e) {
  switch (e) {
    case ms:
    case ys:
    case Ds:
    case zn:
    case Wr:
    case Hr:
    case jo:
    case Rs:
    case zo:
    case Bo:
    case Bn:
      return 6;
    case Uo:
      return 4;
    default:
      return 10;
  }
}
function Od(e) {
  return !!(e != null && e.expr);
}
function Fn(e) {
  const t = q(e || {}), n = {};
  for (const i of t)
    n[i] = Vn(e[i]);
  return n;
}
function d4(e) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor: t,
    frame: n,
    offset: i,
    orient: r,
    angle: s,
    limit: o,
    // color needs to be redirect to fill
    color: a,
    // subtitle properties
    subtitleColor: l,
    subtitleFont: u,
    subtitleFontSize: c,
    subtitleFontStyle: f,
    subtitleFontWeight: d,
    subtitleLineHeight: h,
    subtitlePadding: g,
    // The rest are mark config.
    ...p
  } = e, m = {
    ...p,
    ...a ? { fill: a } : {}
  }, y = {
    ...t ? { anchor: t } : {},
    ...n ? { frame: n } : {},
    ...i ? { offset: i } : {},
    ...r ? { orient: r } : {},
    ...s !== void 0 ? { angle: s } : {},
    ...o !== void 0 ? { limit: o } : {}
  }, b = {
    ...l ? { subtitleColor: l } : {},
    ...u ? { subtitleFont: u } : {},
    ...c ? { subtitleFontSize: c } : {},
    ...f ? { subtitleFontStyle: f } : {},
    ...d ? { subtitleFontWeight: d } : {},
    ...h ? { subtitleLineHeight: h } : {},
    ...g ? { subtitlePadding: g } : {}
  }, v = vu(e, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig: m, subtitleMarkConfig: v, nonMarkTitleProperties: y, subtitle: b };
}
function Ys(e) {
  return Q(e) || j(e) && Q(e[0]);
}
function oe(e) {
  return !!(e != null && e.signal);
}
function Wo(e) {
  return !!e.step;
}
function Use(e) {
  return j(e) ? !1 : "fields" in e && !("data" in e);
}
function qse(e) {
  return j(e) ? !1 : "fields" in e && "data" in e;
}
function ds(e) {
  return j(e) ? !1 : "field" in e && "data" in e;
}
const Wse = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
}, Hse = q(Wse), Gse = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
}, hv = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
function h4(e) {
  const t = j(e.condition) ? e.condition.map(C$) : C$(e.condition);
  return {
    ...Vn(e),
    condition: t
  };
}
function Vn(e) {
  if (Od(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function C$(e) {
  if (Od(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function Qe(e) {
  if (Od(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return oe(e) ? e : e !== void 0 ? { value: e } : void 0;
}
function Vse(e) {
  return oe(e) ? e.signal : X(e);
}
function $$(e) {
  return oe(e) ? e.signal : X(e.value);
}
function Hi(e) {
  return oe(e) ? e.signal : e == null ? null : X(e);
}
function Yse(e, t, n) {
  for (const i of n) {
    const r = ks(i, t.markDef, t.config);
    r !== void 0 && (e[i] = Qe(r));
  }
  return e;
}
function g4(e) {
  return [].concat(e.type, e.style ?? []);
}
function Ue(e, t, n, i = {}) {
  const { vgChannel: r, ignoreVgConfig: s } = i;
  return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : s && (!r || r === e) ? void 0 : ks(e, t, n, i);
}
function ks(e, t, n, { vgChannel: i } = {}) {
  return ct(
    // style config has highest precedence
    i ? xp(e, t, n.style) : void 0,
    xp(e, t, n.style),
    // then mark-specific config
    i ? n[t.type][i] : void 0,
    n[t.type][e],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    i ? n.mark[i] : n.mark[e]
    // Need to cast for the same reason as above
  );
}
function xp(e, t, n) {
  return p4(e, g4(t), n);
}
function p4(e, t, n) {
  t = J(t);
  let i;
  for (const r of t) {
    const s = n[r];
    s && s[e] !== void 0 && (i = s[e]);
  }
  return i;
}
function m4(e, t) {
  return J(e).reduce((n, i) => (n.field.push(K(i, t)), n.order.push(i.sort ?? "ascending"), n), { field: [], order: [] });
}
function y4(e, t) {
  const n = [...e];
  return t.forEach((i) => {
    for (const r of n)
      if (Kn(r, i))
        return;
    n.push(i);
  }), n;
}
function b4(e, t) {
  return Kn(e, t) || !t ? e : e ? [...J(e), ...J(t)].join(", ") : t;
}
function v4(e, t) {
  const n = e.value, i = t.value;
  if (n == null || i === null)
    return {
      explicit: e.explicit,
      value: null
    };
  if ((Ys(n) || oe(n)) && (Ys(i) || oe(i)))
    return {
      explicit: e.explicit,
      value: b4(n, i)
    };
  if (Ys(n) || oe(n))
    return {
      explicit: e.explicit,
      value: n
    };
  if (Ys(i) || oe(i))
    return {
      explicit: e.explicit,
      value: i
    };
  if (!Ys(n) && !oe(n) && !Ys(i) && !oe(i))
    return {
      explicit: e.explicit,
      value: y4(n, i)
    };
  throw new Error("It should never reach here");
}
function eE(e) {
  return `Invalid specification ${Ge(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
const Xse = 'Autosize "fit" only works for single views and layered views.';
function M$(e) {
  return `${e == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
}
function F$(e) {
  const t = e == "width" ? "Width" : "Height", n = e == "width" ? "x" : "y";
  return `${t} "container" only works well with autosize "fit" or "fit-${n}".`;
}
function T$(e) {
  return e ? `Dropping "fit-${e}" because spec has discrete ${jn(e)}.` : 'Dropping "fit" because spec has discrete size.';
}
function tE(e) {
  return `Unknown field for ${e}. Cannot calculate view size.`;
}
function O$(e) {
  return `Cannot project a selection on encoding channel "${e}", which has no field.`;
}
function Kse(e, t) {
  return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`;
}
function Jse(e) {
  return `The "nearest" transform is not supported for ${e} marks.`;
}
function x4(e) {
  return `Selection not supported for ${e} yet.`;
}
function Qse(e) {
  return `Cannot find a selection named "${e}".`;
}
const Zse = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", eoe = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function toe(e) {
  return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`;
}
function noe(e) {
  return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
const ioe = "The same selection must be used to override scale domains in a layered view.", roe = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
function soe(e) {
  return `Unknown repeated value "${e}".`;
}
function N$(e) {
  return `The "columns" property cannot be used when "${e}" has nested row/column.`;
}
const ooe = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function aoe(e) {
  return `Unrecognized parse "${e}".`;
}
function D$(e, t, n) {
  return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`;
}
const loe = "Attempt to add the same child twice.";
function uoe(e) {
  return `Ignoring an invalid transform: ${Ge(e)}.`;
}
const coe = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function R$(e) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`;
}
function foe(e) {
  const { parentProjection: t, projection: n } = e;
  return `Layer's shared projection ${Ge(t)} is overridden by a child projection ${Ge(n)}.`;
}
const doe = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function hoe(e) {
  return `${e}Offset dropped because ${e} is continuous`;
}
function goe(e, t, n) {
  return `Channel ${e} is a ${t}. Converted to {value: ${Ge(n)}}.`;
}
function w4(e) {
  return `Invalid field type "${e}".`;
}
function poe(e, t) {
  return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`;
}
function moe(e) {
  return `Invalid aggregation operator "${e}".`;
}
function _4(e, t) {
  const { fill: n, stroke: i } = t;
  return `Dropping color ${e} as the plot also has ${n && i ? "fill and stroke" : n ? "fill" : "stroke"}.`;
}
function yoe(e) {
  return `Position range does not support relative band size for ${e}.`;
}
function gv(e, t) {
  return `Dropping ${Ge(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`;
}
const boe = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function f0(e, t, n) {
  return `${e} dropped as it is incompatible with "${t}"${n ? ` when ${n}` : ""}.`;
}
function voe(e) {
  return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`;
}
function xoe(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned).`;
}
function woe(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function _oe(e) {
  return `Facet encoding dropped as ${e.join(" and ")} ${e.length > 1 ? "are" : "is"} also specified.`;
}
function ty(e, t) {
  return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t === "ordinal" ? "order" : "magnitude"}.`;
}
function Eoe(e) {
  return `The ${e} for range marks cannot be an expression`;
}
function Soe(e, t) {
  return `Line mark is for continuous lines and thus cannot be used with ${e && t ? "x2 and y2" : e ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
}
function koe(e, t) {
  return `Specified orient "${e}" overridden with "${t}".`;
}
function Aoe(e) {
  return `Cannot use the scale property "${e}" with non-color channel.`;
}
function Coe(e) {
  return `Cannot use the relative band size with ${e} scale.`;
}
function $oe(e) {
  return `Using unaggregated domain with raw field has no effect (${Ge(e)}).`;
}
function Moe(e) {
  return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`;
}
function Foe(e) {
  return `Unaggregated domain is currently unsupported for log scale (${Ge(e)}).`;
}
function Toe(e) {
  return `Cannot apply size to non-oriented mark "${e}".`;
}
function Ooe(e, t, n) {
  return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`;
}
function Noe(e, t) {
  return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`;
}
function E4(e, t, n) {
  return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`;
}
function S4(e) {
  return `The step for "${e}" is dropped because the ${e === "width" ? "x" : "y"} is continuous.`;
}
function Doe(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Ge(n)} and ${Ge(i)}). Using ${Ge(n)}.`;
}
function Roe(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Ge(n)} and ${Ge(i)}). Using the union of the two domains.`;
}
function Loe(e) {
  return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`;
}
function Poe(e) {
  return `Dropping sort property ${Ge(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
const L$ = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", Ioe = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", zoe = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", Boe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function joe(e) {
  return `Cannot stack "${e}" if there is already "${e}2".`;
}
function Uoe(e) {
  return `Cannot stack non-linear scale (${e}).`;
}
function qoe(e) {
  return `Stacking is applied even though the aggregate function is non-summative ("${e}").`;
}
function wp(e, t) {
  return `Invalid ${e}: ${Ge(t)}.`;
}
function Woe(e) {
  return `Dropping day from datetime ${Ge(e)} as day cannot be combined with other units.`;
}
function Hoe(e, t) {
  return `${t ? "extent " : ""}${t && e ? "and " : ""}${e ? "center " : ""}${t && e ? "are " : "is "}not needed when data are aggregated.`;
}
function Goe(e, t, n) {
  return `${e} is not usually used with ${t} for ${n}.`;
}
function Voe(e, t) {
  return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`;
}
function P$(e) {
  return `1D error band does not support ${e}.`;
}
function k4(e) {
  return `Channel ${e} is required for "binned" bin.`;
}
function Yoe(e) {
  return `Channel ${e} should not be used with "binned" bin.`;
}
function Xoe(e) {
  return `Domain for ${e} is required for threshold scale.`;
}
const A4 = Vv(Gv);
let _u = A4;
function Koe(e) {
  return _u = e, _u;
}
function Joe() {
  return _u = A4, _u;
}
function V(...e) {
  _u.warn(...e);
}
function Qoe(...e) {
  _u.debug(...e);
}
function cl(e) {
  if (e && ee(e)) {
    for (const t of iE)
      if (t in e)
        return !0;
  }
  return !1;
}
const C4 = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], Zoe = C4.map((e) => e.substr(0, 3)), $4 = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"], eae = $4.map((e) => e.substr(0, 3));
function tae(e) {
  if (n0(e) && (e = +e), Re(e))
    return e > 4 && V(wp("quarter", e)), e - 1;
  throw new Error(wp("quarter", e));
}
function nae(e) {
  if (n0(e) && (e = +e), Re(e))
    return e - 1;
  {
    const t = e.toLowerCase(), n = C4.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = Zoe.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error(wp("month", e));
  }
}
function iae(e) {
  if (n0(e) && (e = +e), Re(e))
    return e % 7;
  {
    const t = e.toLowerCase(), n = $4.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = eae.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error(wp("day", e));
  }
}
function nE(e, t) {
  const n = [];
  if (t && e.day !== void 0 && q(e).length > 1 && (V(Woe(e)), e = me(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
    const i = t ? nae(e.month) : e.month;
    n.push(i);
  } else if (e.quarter !== void 0) {
    const i = t ? tae(e.quarter) : e.quarter;
    n.push(Re(i) ? i * 3 : `${i}*3`);
  } else
    n.push(0);
  if (e.date !== void 0)
    n.push(e.date);
  else if (e.day !== void 0) {
    const i = t ? iae(e.day) : e.day;
    n.push(Re(i) ? i + 1 : `${i}+1`);
  } else
    n.push(1);
  for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
    const r = e[i];
    n.push(typeof r > "u" ? 0 : r);
  }
  return n;
}
function qa(e) {
  const n = nE(e, !0).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function rae(e) {
  const n = nE(e, !1).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function sae(e) {
  const t = nE(e, !0);
  return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);
}
const M4 = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
}, iE = q(M4);
function oae(e) {
  return !!M4[e];
}
function fl(e) {
  return ee(e) ? e.binned : F4(e);
}
function F4(e) {
  return e && e.startsWith("binned");
}
function rE(e) {
  return e.startsWith("utc");
}
function aae(e) {
  return e.substring(3);
}
const lae = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function d0(e) {
  return iE.filter((t) => O4(e, t));
}
function T4(e) {
  const t = d0(e);
  return t[t.length - 1];
}
function O4(e, t) {
  const n = e.indexOf(t);
  return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f");
}
function uae(e, t, { end: n } = { end: !1 }) {
  const i = W_(t), r = rE(e) ? "utc" : "";
  function s(l) {
    return l === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${l}(${i})`;
  }
  let o;
  const a = {};
  for (const l of iE)
    O4(e, l) && (a[l] = s(l), o = l);
  return n && (a[o] += "+1"), rae(a);
}
function N4(e) {
  if (!e)
    return;
  const t = d0(e);
  return `timeUnitSpecifier(${Ge(t)}, ${Ge(lae)})`;
}
function cae(e, t, n) {
  if (!e)
    return;
  const i = N4(e);
  return `${n || rE(e) ? "utc" : "time"}Format(${t}, ${i})`;
}
function Nt(e) {
  if (!e)
    return;
  let t;
  return Q(e) ? F4(e) ? t = {
    unit: e.substring(6),
    binned: !0
  } : t = {
    unit: e
  } : ee(e) && (t = {
    ...e,
    ...e.unit ? { unit: e.unit } : {}
  }), rE(t.unit) && (t.utc = !0, t.unit = aae(t.unit)), t;
}
function fae(e) {
  const { utc: t, ...n } = Nt(e);
  return n.unit ? (t ? "utc" : "") + q(n).map((i) => et(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + q(n).map((i) => et(`_${i}_${n[i]}`)).join("");
}
function D4(e, t = (n) => n) {
  const n = Nt(e), i = T4(n.unit);
  if (i && i !== "day") {
    const r = {
      year: 2001,
      month: 1,
      date: 1,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    }, { step: s, part: o } = R4(i, n.step), a = {
      ...r,
      [o]: +r[o] + s
    };
    return `${t(qa(a))} - ${t(qa(r))}`;
  }
}
const dae = {
  year: 1,
  month: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
function hae(e) {
  return !!dae[e];
}
function R4(e, t = 1) {
  if (hae(e))
    return { part: e, step: t };
  switch (e) {
    case "day":
    case "dayofyear":
      return { part: "date", step: t };
    case "quarter":
      return { part: "month", step: t * 3 };
    case "week":
      return { part: "date", step: t * 7 };
  }
}
function gae(e) {
  return e == null ? void 0 : e.param;
}
function sE(e) {
  return !!(e != null && e.field) && e.equal !== void 0;
}
function oE(e) {
  return !!(e != null && e.field) && e.lt !== void 0;
}
function aE(e) {
  return !!(e != null && e.field) && e.lte !== void 0;
}
function lE(e) {
  return !!(e != null && e.field) && e.gt !== void 0;
}
function uE(e) {
  return !!(e != null && e.field) && e.gte !== void 0;
}
function cE(e) {
  if (e != null && e.field) {
    if (j(e.range) && e.range.length === 2)
      return !0;
    if (oe(e.range))
      return !0;
  }
  return !1;
}
function fE(e) {
  return !!(e != null && e.field) && (j(e.oneOf) || j(e.in));
}
function pae(e) {
  return !!(e != null && e.field) && e.valid !== void 0;
}
function L4(e) {
  return fE(e) || sE(e) || cE(e) || oE(e) || lE(e) || aE(e) || uE(e);
}
function dr(e, t) {
  return _0(e, { timeUnit: t, wrapTime: !0 });
}
function mae(e, t) {
  return e.map((n) => dr(n, t));
}
function P4(e, t = !0) {
  const { field: n } = e, i = Nt(e.timeUnit), { unit: r, binned: s } = i || {}, o = K(e, { expr: "datum" }), a = r ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${s ? o : uae(r, n)})`
  ) : o;
  if (sE(e))
    return `${a}===${dr(e.equal, r)}`;
  if (oE(e)) {
    const l = e.lt;
    return `${a}<${dr(l, r)}`;
  } else if (lE(e)) {
    const l = e.gt;
    return `${a}>${dr(l, r)}`;
  } else if (aE(e)) {
    const l = e.lte;
    return `${a}<=${dr(l, r)}`;
  } else if (uE(e)) {
    const l = e.gte;
    return `${a}>=${dr(l, r)}`;
  } else {
    if (fE(e))
      return `indexof([${mae(e.oneOf, r).join(",")}], ${a}) !== -1`;
    if (pae(e))
      return dE(a, e.valid);
    if (cE(e)) {
      const { range: l } = e, u = oe(l) ? { signal: `${l.signal}[0]` } : l[0], c = oe(l) ? { signal: `${l.signal}[1]` } : l[1];
      if (u !== null && c !== null && t)
        return "inrange(" + a + ", [" + dr(u, r) + ", " + dr(c, r) + "])";
      const f = [];
      return u !== null && f.push(`${a} >= ${dr(u, r)}`), c !== null && f.push(`${a} <= ${dr(c, r)}`), f.length > 0 ? f.join(" && ") : "true";
    }
  }
  throw new Error(`Invalid field predicate: ${Ge(e)}`);
}
function dE(e, t = !0) {
  return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
}
function yae(e) {
  return L4(e) && e.timeUnit ? {
    ...e,
    timeUnit: Nt(e.timeUnit)
  } : e;
}
const Nd = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function bae(e) {
  return e === "quantitative" || e === "temporal";
}
function I4(e) {
  return e === "ordinal" || e === "nominal";
}
const Wa = Nd.quantitative, hE = Nd.ordinal, Eu = Nd.temporal, gE = Nd.nominal, Ju = Nd.geojson;
function vae(e) {
  if (e)
    switch (e = e.toLowerCase(), e) {
      case "q":
      case Wa:
        return "quantitative";
      case "t":
      case Eu:
        return "temporal";
      case "o":
      case hE:
        return "ordinal";
      case "n":
      case gE:
        return "nominal";
      case Ju:
        return "geojson";
    }
}
const Dn = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  // Discretizing scales
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  // Discrete scales
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
}, pv = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function xae(e, t) {
  const n = pv[e], i = pv[t];
  return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time";
}
const wae = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function I$(e) {
  return wae[e];
}
const z4 = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]), B4 = /* @__PURE__ */ new Set([
  ...z4,
  "time",
  "utc"
]);
function j4(e) {
  return z4.has(e);
}
const U4 = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]), _ae = /* @__PURE__ */ new Set([
  ...B4,
  ...U4,
  "sequential",
  "identity"
]), Eae = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function Dt(e) {
  return Eae.has(e);
}
function ai(e) {
  return _ae.has(e);
}
function Gi(e) {
  return B4.has(e);
}
function Su(e) {
  return U4.has(e);
}
const Sae = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4,
  zero: !0
};
function kae(e) {
  return !Q(e) && !!e.name;
}
function q4(e) {
  return e == null ? void 0 : e.param;
}
function Aae(e) {
  return e == null ? void 0 : e.unionWith;
}
function Cae(e) {
  return ee(e) && "field" in e;
}
const $ae = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  domainRaw: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
}, { type: p0e, domain: m0e, range: y0e, rangeMax: b0e, rangeMin: v0e, scheme: x0e, ...Mae } = $ae, Fae = q(Mae);
function mv(e, t) {
  switch (t) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return !0;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(e);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(e);
    case "round":
      return Gi(e) || e === "band" || e === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return Gi(e) || ["point", "band"].includes(e);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(e);
    case "paddingInner":
      return e === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "domainRaw":
    case "clamp":
      return Gi(e);
    case "nice":
      return Gi(e) || e === "quantize" || e === "threshold";
    case "exponent":
      return e === "pow";
    case "base":
      return e === "log";
    case "constant":
      return e === "symlog";
    case "zero":
      return ai(e) && !Fe([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], e);
  }
}
function W4(e, t) {
  switch (t) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      return Vl(e) ? void 0 : Aoe(t);
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "domainRaw":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return;
  }
}
function Tae(e, t) {
  return Fe([hE, gE], t) ? e === void 0 || Dt(e) : t === Eu ? Fe([Dn.TIME, Dn.UTC, void 0], e) : t === Wa ? j4(e) || Su(e) || e === void 0 : !0;
}
function Oae(e, t, n = !1) {
  if (!Ls(e))
    return !1;
  switch (e) {
    case tt:
    case Lt:
    case Io:
    case Ku:
    case Fi:
    case or:
      return Gi(t) || t === "band" ? !0 : t === "point" ? !n : !1;
    case Ds:
    case jo:
    case Rs:
    case zo:
    case Bo:
    case al:
      return Gi(t) || Su(t) || Fe(["band", "point", "ordinal"], t);
    case zn:
    case Wr:
    case Hr:
      return t !== "band";
    case Uo:
    case Bn:
      return t === "ordinal" || Su(t);
  }
}
const kn = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
}, H4 = kn.arc, h0 = kn.area, g0 = kn.bar, Nae = kn.image, p0 = kn.line, m0 = kn.point, Dae = kn.rect, _p = kn.rule, G4 = kn.text, pE = kn.tick, Rae = kn.trail, mE = kn.circle, yE = kn.square, V4 = kn.geoshape;
function Ho(e) {
  return ["line", "area", "trail"].includes(e);
}
function Vf(e) {
  return [
    "rect",
    "bar",
    "image",
    "arc"
    /* arc is rect/interval in polar coordinate */
  ].includes(e);
}
const Lae = new Set(q(kn));
function Dr(e) {
  return e.type;
}
const Pae = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
], Iae = ["fill", "fillOpacity"], zae = [...Pae, ...Iae], Bae = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
}, z$ = q(Bae), jae = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
}, Uae = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
}, qae = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
}, Y4 = q(qae);
function Ha(e) {
  return e && e.band != null;
}
const Wae = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
}, X4 = 5, Hae = {
  binSpacing: 1,
  continuousBandSize: X4,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, Gae = {
  binSpacing: 0,
  continuousBandSize: X4,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, Vae = {
  thickness: 1
};
function Yae(e) {
  return Dr(e) ? e.type : e;
}
function bE(e) {
  const { channel: t, channelDef: n, markDef: i, scale: r, config: s } = e, o = xE(e);
  return (
    // Only this for field def without counting aggregate (as count wouldn't be null)
    G(n) && !c4(n.aggregate) && // and only for continuous scale
    r && Gi(r.get("type")) ? Xae({
      fieldDef: n,
      channel: t,
      markDef: i,
      ref: o,
      config: s
    }) : o
  );
}
function Xae({ fieldDef: e, channel: t, markDef: n, ref: i, config: r }) {
  return Ho(n.type) ? i : Ue("invalid", n, r) === null ? [Kae(e, t), i] : i;
}
function Kae(e, t) {
  const n = vE(e, !0), r = ll(t) === "y" ? { field: { group: "height" } } : (
    // x / angle / radius can all use 0
    { value: 0 }
  );
  return { test: n, ...r };
}
function vE(e, t = !0) {
  return dE(Q(e) ? e : K(e, { expr: "datum" }), !t);
}
function Jae(e) {
  const { datum: t } = e;
  return cl(t) ? qa(t) : `${Ge(t)}`;
}
function Sa(e, t, n, i) {
  const r = {};
  if (t && (r.scale = t), Yr(e)) {
    const { datum: s } = e;
    cl(s) ? r.signal = qa(s) : oe(s) ? r.signal = s.signal : Od(s) ? r.signal = s.expr : r.value = s;
  } else
    r.field = K(e, n);
  if (i) {
    const { offset: s, band: o } = i;
    s && (r.offset = s), o && (r.band = o);
  }
  return r;
}
function Ep({ scaleName: e, fieldOrDatumDef: t, fieldOrDatumDef2: n, offset: i, startSuffix: r, endSuffix: s = "end", bandPosition: o = 0.5 }) {
  const a = !oe(o) && 0 < o && o < 1 ? "datum" : void 0, l = K(t, { expr: a, suffix: r }), u = n !== void 0 ? K(n, { expr: a }) : K(t, { suffix: s, expr: a }), c = {};
  if (o === 0 || o === 1) {
    c.scale = e;
    const f = o === 0 ? l : u;
    c.field = f;
  } else {
    const f = oe(o) ? `(1-${o.signal}) * ${l} + ${o.signal} * ${u}` : `${1 - o} * ${l} + ${o} * ${u}`;
    c.signal = `scale("${e}", ${f})`;
  }
  return i && (c.offset = i), c;
}
function Qae({ scaleName: e, fieldDef: t }) {
  const n = K(t, { expr: "datum" }), i = K(t, { expr: "datum", suffix: "end" });
  return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`;
}
function xE({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: s, scale: o, stack: a, offset: l, defaultRef: u, bandPosition: c }) {
  if (t) {
    if (be(t)) {
      const f = o == null ? void 0 : o.get("type");
      if (En(t)) {
        c ?? (c = Ao({
          fieldDef: t,
          fieldDef2: n,
          markDef: i,
          config: r
        }));
        const { bin: d, timeUnit: h, type: g } = t;
        if (Ke(d) || c && h && g === Eu)
          return a != null && a.impute ? Sa(t, s, { binSuffix: "mid" }, { offset: l }) : c && !Dt(f) ? Ep({ scaleName: s, fieldOrDatumDef: t, bandPosition: c, offset: l }) : Sa(t, s, Pd(t, e) ? { binSuffix: "range" } : {}, {
            offset: l
          });
        if (zt(d)) {
          if (G(n))
            return Ep({
              scaleName: s,
              fieldOrDatumDef: t,
              fieldOrDatumDef2: n,
              bandPosition: c,
              offset: l
            });
          V(k4(e === tt ? sr : qr));
        }
      }
      return Sa(
        t,
        s,
        Dt(f) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: l,
          // For band, to get mid point, need to offset by half of the band
          band: f === "band" ? c ?? t.bandPosition ?? 0.5 : void 0
        }
      );
    } else if (er(t)) {
      const f = t.value, d = l ? { offset: l } : {};
      return { ...gf(e, f), ...d };
    }
  }
  return Ee(u) && (u = u()), u && {
    ...u,
    // only include offset when it is non-zero (zero = no offset)
    ...l ? { offset: l } : {}
  };
}
function gf(e, t) {
  return Fe(["x", "x2"], e) && t === "width" ? { field: { group: "width" } } : Fe(["y", "y2"], e) && t === "height" ? { field: { group: "height" } } : Qe(t);
}
function Ga(e) {
  return e && e !== "number" && e !== "time";
}
function K4(e, t, n) {
  return `${e}(${t}${n ? `, ${Ge(n)}` : ""})`;
}
const Zae = "  ";
function wE({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: s }) {
  var l, u;
  if (Ga(n))
    return Vi({
      fieldOrDatumDef: e,
      format: t,
      formatType: n,
      expr: i,
      config: s
    });
  const o = J4(e, i, r), a = ku(e);
  if (t === void 0 && n === void 0 && s.customFormatTypes) {
    if (a === "quantitative") {
      if (r && s.normalizedNumberFormatType)
        return Vi({
          fieldOrDatumDef: e,
          format: s.normalizedNumberFormat,
          formatType: s.normalizedNumberFormatType,
          expr: i,
          config: s
        });
      if (s.numberFormatType)
        return Vi({
          fieldOrDatumDef: e,
          format: s.numberFormat,
          formatType: s.numberFormatType,
          expr: i,
          config: s
        });
    }
    if (a === "temporal" && s.timeFormatType && G(e) && e.timeUnit === void 0)
      return Vi({
        fieldOrDatumDef: e,
        format: s.timeFormat,
        formatType: s.timeFormatType,
        expr: i,
        config: s
      });
  }
  if (Cu(e)) {
    const c = tle({
      field: o,
      timeUnit: G(e) ? (l = Nt(e.timeUnit)) == null ? void 0 : l.unit : void 0,
      format: t,
      formatType: s.timeFormatType,
      rawTimeFormat: s.timeFormat,
      isUTCScale: dl(e) && ((u = e.scale) == null ? void 0 : u.type) === Dn.UTC
    });
    return c ? { signal: c } : void 0;
  }
  if (t = yv({ type: a, specifiedFormat: t, config: s, normalizeStack: r }), G(e) && Ke(e.bin)) {
    const c = K(e, { expr: i, binSuffix: "end" });
    return {
      signal: Dd(o, c, t, n, s)
    };
  } else
    return t || ku(e) === "quantitative" ? {
      signal: `${eL(o, t)}`
    } : { signal: `isValid(${o}) ? ${o} : ""+${o}` };
}
function J4(e, t, n) {
  return G(e) ? n ? `${K(e, { expr: t, suffix: "end" })}-${K(e, {
    expr: t,
    suffix: "start"
  })}` : K(e, { expr: t }) : Jae(e);
}
function Vi({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: s, field: o }) {
  if (o ?? (o = J4(e, i, r)), o !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  G(e) && Ke(e.bin)) {
    const a = K(e, { expr: i, binSuffix: "end" });
    return {
      signal: Dd(o, a, t, n, s)
    };
  }
  return { signal: K4(n, o, t) };
}
function Q4(e, t, n, i, r, s) {
  var o;
  if (!(Q(i) && Ga(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && ku(e) === "quantitative" && (r.normalizedNumberFormatType && Au(e) && e.stack === "normalize" || r.numberFormatType))) {
    if (Au(e) && e.stack === "normalize" && r.normalizedNumberFormat)
      return yv({
        type: "quantitative",
        config: r,
        normalizeStack: !0
      });
    if (Cu(e)) {
      const a = G(e) ? (o = Nt(e.timeUnit)) == null ? void 0 : o.unit : void 0;
      return a === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : ele({ specifiedFormat: n, timeUnit: a, config: r, omitTimeFormatConfig: s });
    }
    return yv({ type: t, specifiedFormat: n, config: r });
  }
}
function Z4(e, t, n) {
  var i;
  if (e && (oe(e) || e === "number" || e === "time"))
    return e;
  if (Cu(t) && n !== "time" && n !== "utc")
    return G(t) && ((i = Nt(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time";
}
function yv({ type: e, specifiedFormat: t, config: n, normalizeStack: i }) {
  if (Q(t))
    return t;
  if (e === Wa)
    return i ? n.normalizedNumberFormat : n.numberFormat;
}
function ele({ specifiedFormat: e, timeUnit: t, config: n, omitTimeFormatConfig: i }) {
  return e || (t ? {
    signal: N4(t)
  } : i ? void 0 : n.timeFormat);
}
function eL(e, t) {
  return `format(${e}, "${t || ""}")`;
}
function B$(e, t, n, i) {
  return Ga(n) ? K4(n, e, t) : eL(e, (Q(t) ? t : void 0) ?? i.numberFormat);
}
function Dd(e, t, n, i, r) {
  if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType)
    return Dd(e, t, r.numberFormat, r.numberFormatType, r);
  const s = B$(e, n, i, r), o = B$(t, n, i, r);
  return `${dE(e, !1)} ? "null" : ${s} + "${Zae}" + ${o}`;
}
function tle({ field: e, timeUnit: t, format: n, formatType: i, rawTimeFormat: r, isUTCScale: s }) {
  return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = Q(n) ? n : r, `${s ? "utc" : "time"}Format(${e}, '${n}')`) : cae(t, e, s);
}
const y0 = "min", nle = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function j$(e) {
  return e in nle;
}
function tL(e) {
  return !!(e != null && e.encoding);
}
function Sr(e) {
  return e && (e.op === "count" || !!e.field);
}
function nL(e) {
  return e && j(e);
}
function Rd(e) {
  return "row" in e || "column" in e;
}
function _E(e) {
  return !!e && "header" in e;
}
function b0(e) {
  return "facet" in e;
}
function ile(e) {
  return e.param;
}
function rle(e) {
  return e && !Q(e) && "repeat" in e;
}
function U$(e) {
  const { field: t, timeUnit: n, bin: i, aggregate: r } = e;
  return {
    ...n ? { timeUnit: n } : {},
    ...i ? { bin: i } : {},
    ...r ? { aggregate: r } : {},
    field: t
  };
}
function EE(e) {
  return "sort" in e;
}
function Ao({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) {
  if (be(e) && e.bandPosition !== void 0)
    return e.bandPosition;
  if (G(e)) {
    const { timeUnit: r, bin: s } = e;
    if (r && !t)
      return ks("timeUnitBandPosition", n, i);
    if (Ke(s))
      return 0.5;
  }
}
function iL({ channel: e, fieldDef: t, fieldDef2: n, markDef: i, config: r, scaleType: s, useVlSizeChannel: o }) {
  var u, c, f;
  const a = jn(e), l = Ue(o ? "size" : a, i, r, {
    vgChannel: a
  });
  if (l !== void 0)
    return l;
  if (G(t)) {
    const { timeUnit: d, bin: h } = t;
    if (d && !n)
      return { band: ks("timeUnitBandSize", i, r) };
    if (Ke(h) && !Dt(s))
      return { band: 1 };
  }
  if (Vf(i.type))
    return s ? Dt(s) ? ((u = r[i.type]) == null ? void 0 : u.discreteBandSize) || { band: 1 } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize;
}
function rL(e, t, n, i) {
  return Ke(e.bin) || e.timeUnit && En(e) && e.type === "temporal" ? Ao({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) !== void 0 : !1;
}
function sL(e) {
  return e && !!e.sort && !e.field;
}
function v0(e) {
  return e && "condition" in e;
}
function x0(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !j(t) && G(t);
}
function Ld(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !j(t) && be(t);
}
function sle(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && (j(t) || er(t));
}
function G(e) {
  return e && (!!e.field || e.aggregate === "count");
}
function ku(e) {
  return e == null ? void 0 : e.type;
}
function Yr(e) {
  return e && "datum" in e;
}
function ro(e) {
  return En(e) && !kp(e) || Sp(e);
}
function q$(e) {
  return En(e) && e.type === "quantitative" && !e.bin || Sp(e);
}
function Sp(e) {
  return Yr(e) && Re(e.datum);
}
function be(e) {
  return G(e) || Yr(e);
}
function En(e) {
  return e && ("field" in e || e.aggregate === "count") && "type" in e;
}
function er(e) {
  return e && "value" in e && "value" in e;
}
function dl(e) {
  return e && ("scale" in e || "sort" in e);
}
function Au(e) {
  return e && ("axis" in e || "stack" in e || "impute" in e);
}
function oL(e) {
  return e && "legend" in e;
}
function aL(e) {
  return e && ("format" in e || "formatType" in e);
}
function ole(e) {
  return Nn(e, ["legend", "axis", "header", "scale"]);
}
function ale(e) {
  return "op" in e;
}
function K(e, t = {}) {
  let n = e.field;
  const i = t.prefix;
  let r = t.suffix, s = "";
  if (ule(e))
    n = K6("count");
  else {
    let o;
    if (!t.nofn)
      if (ale(e))
        o = e.op;
      else {
        const { bin: a, aggregate: l, timeUnit: u } = e;
        Ke(a) ? (o = f4(a), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : l ? qo(l) ? (s = `["${n}"]`, n = `argmax_${l.argmax}`) : Ss(l) ? (s = `["${n}"]`, n = `argmin_${l.argmin}`) : o = String(l) : u && !fl(u) && (o = fae(u), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
      }
    o && (n = n ? `${o}_${n}` : o);
  }
  return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? H_(n) : t.expr ? V6(n, t.expr) + s : Ci(n) + s;
}
function kp(e) {
  switch (e.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return !0;
    case "quantitative":
      return G(e) && !!e.bin;
    case "temporal":
      return !1;
  }
  throw new Error(w4(e.type));
}
function lle(e) {
  var t;
  return dl(e) && Su((t = e.scale) == null ? void 0 : t.type);
}
function ule(e) {
  return e.aggregate === "count";
}
function cle(e, t) {
  var o;
  const { field: n, bin: i, timeUnit: r, aggregate: s } = e;
  if (s === "count")
    return t.countTitle;
  if (Ke(i))
    return `${n} (binned)`;
  if (r && !fl(r)) {
    const a = (o = Nt(r)) == null ? void 0 : o.unit;
    if (a)
      return `${n} (${d0(a).join("-")})`;
  } else if (s)
    return qo(s) ? `${n} for max ${s.argmax}` : Ss(s) ? `${n} for min ${s.argmin}` : `${$d(s)} of ${n}`;
  return n;
}
function fle(e) {
  const { aggregate: t, bin: n, timeUnit: i, field: r } = e;
  if (qo(t))
    return `${r} for argmax(${t.argmax})`;
  if (Ss(t))
    return `${r} for argmin(${t.argmin})`;
  const s = i && !fl(i) ? Nt(i) : void 0, o = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || Ke(n) && "bin";
  return o ? `${o.toUpperCase()}(${r})` : r;
}
const lL = (e, t) => {
  switch (t.fieldTitle) {
    case "plain":
      return e.field;
    case "functional":
      return fle(e);
    default:
      return cle(e, t);
  }
};
let uL = lL;
function cL(e) {
  uL = e;
}
function dle() {
  cL(lL);
}
function Yl(e, t, { allowDisabling: n, includeDefault: i = !0 }) {
  var a;
  const r = (a = SE(e)) == null ? void 0 : a.title;
  if (!G(e))
    return r ?? e.title;
  const s = e, o = i ? kE(s, t) : void 0;
  return n ? ct(r, s.title, o) : r ?? s.title ?? o;
}
function SE(e) {
  if (Au(e) && e.axis)
    return e.axis;
  if (oL(e) && e.legend)
    return e.legend;
  if (_E(e) && e.header)
    return e.header;
}
function kE(e, t) {
  return uL(e, t);
}
function Ap(e) {
  if (aL(e)) {
    const { format: t, formatType: n } = e;
    return { format: t, formatType: n };
  } else {
    const t = SE(e) ?? {}, { format: n, formatType: i } = t;
    return { format: n, formatType: i };
  }
}
function hle(e, t) {
  var s;
  switch (t) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (EE(e) && j(e.sort))
    return "ordinal";
  const { aggregate: n, bin: i, timeUnit: r } = e;
  if (r)
    return "temporal";
  if (i || n && !qo(n) && !Ss(n))
    return "quantitative";
  if (dl(e) && ((s = e.scale) != null && s.type))
    switch (pv[e.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  return "nominal";
}
function Rr(e) {
  if (G(e))
    return e;
  if (x0(e))
    return e.condition;
}
function bt(e) {
  if (be(e))
    return e;
  if (Ld(e))
    return e.condition;
}
function fL(e, t, n, i = {}) {
  if (Q(e) || Re(e) || To(e)) {
    const r = Q(e) ? "string" : Re(e) ? "number" : "boolean";
    return V(goe(t, r, e)), { value: e };
  }
  return be(e) ? Cp(e, t, n, i) : Ld(e) ? {
    ...e,
    // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
    condition: Cp(e.condition, t, n, i)
  } : e;
}
function Cp(e, t, n, i) {
  if (aL(e)) {
    const { format: r, formatType: s, ...o } = e;
    if (Ga(s) && !n.customFormatTypes)
      return V(R$(t)), Cp(o, t, n, i);
  } else {
    const r = Au(e) ? "axis" : oL(e) ? "legend" : _E(e) ? "header" : null;
    if (r && e[r]) {
      const { format: s, formatType: o, ...a } = e[r];
      if (Ga(o) && !n.customFormatTypes)
        return V(R$(t)), Cp({ ...e, [r]: a }, t, n, i);
    }
  }
  return G(e) ? AE(e, t, i) : gle(e);
}
function gle(e) {
  let t = e.type;
  if (t)
    return e;
  const { datum: n } = e;
  return t = Re(n) ? "quantitative" : Q(n) ? "nominal" : cl(n) ? "temporal" : void 0, { ...e, type: t };
}
function AE(e, t, { compositeMark: n = !1 } = {}) {
  const { aggregate: i, timeUnit: r, bin: s, field: o } = e, a = { ...e };
  if (!n && i && !Z_(i) && !qo(i) && !Ss(i) && (V(moe(i)), delete a.aggregate), r && (a.timeUnit = Nt(r)), o && (a.field = `${o}`), Ke(s) && (a.bin = w0(s, t)), zt(s) && !ft(t) && V(Yoe(t)), En(a)) {
    const { type: l } = a, u = vae(l);
    l !== u && (a.type = u), l !== "quantitative" && c4(i) && (V(poe(l, i)), a.type = "quantitative");
  } else if (!r4(t)) {
    const l = hle(a, t);
    a.type = l;
  }
  if (En(a)) {
    const { compatible: l, warning: u } = ple(a, t) || {};
    l === !1 && V(u);
  }
  if (EE(a) && Q(a.sort)) {
    const { sort: l } = a;
    if (j$(l))
      return {
        ...a,
        sort: { encoding: l }
      };
    const u = l.substr(1);
    if (l.charAt(0) === "-" && j$(u))
      return {
        ...a,
        sort: { encoding: u, order: "descending" }
      };
  }
  if (_E(a)) {
    const { header: l } = a;
    if (l) {
      const { orient: u, ...c } = l;
      if (u)
        return {
          ...a,
          header: {
            ...c,
            labelOrient: l.labelOrient || u,
            titleOrient: l.titleOrient || u
          }
        };
    }
  }
  return a;
}
function w0(e, t) {
  return To(e) ? { maxbins: A$(t) } : e === "binned" ? {
    binned: !0
  } : !e.maxbins && !e.step ? { ...e, maxbins: A$(t) } : e;
}
const kl = { compatible: !0 };
function ple(e, t) {
  const n = e.type;
  if (n === "geojson" && t !== "shape")
    return {
      compatible: !1,
      warning: `Channel ${t} should not be used with a geojson data.`
    };
  switch (t) {
    case ms:
    case ys:
    case i0:
      return kp(e) ? kl : {
        compatible: !1,
        warning: xoe(t)
      };
    case tt:
    case Lt:
    case Io:
    case Ku:
    case zn:
    case Wr:
    case Hr:
    case Md:
    case Fd:
    case r0:
    case Ua:
    case s0:
    case o0:
    case al:
    case Fi:
    case or:
    case a0:
      return kl;
    case lr:
    case $i:
    case ar:
    case ur:
      return n !== Wa ? {
        compatible: !1,
        warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
      } : kl;
    case Rs:
    case zo:
    case Bo:
    case jo:
    case Ds:
    case Ns:
    case Os:
    case sr:
    case qr:
      return n === "nominal" && !e.sort ? {
        compatible: !1,
        warning: `Channel ${t} should not be used with an unsorted discrete field.`
      } : kl;
    case Bn:
    case Uo:
      return !kp(e) && !lle(e) ? {
        compatible: !1,
        warning: woe(t)
      } : kl;
    case wu:
      return e.type === "nominal" && !("sort" in e) ? {
        compatible: !1,
        warning: "Channel order is inappropriate for nominal field, which has no inherent order."
      } : kl;
  }
}
function Cu(e) {
  const { formatType: t } = Ap(e);
  return t === "time" || !t && mle(e);
}
function mle(e) {
  return e && (e.type === "temporal" || G(e) && !!e.timeUnit);
}
function _0(e, { timeUnit: t, type: n, wrapTime: i, undefinedIfExprNotRequired: r }) {
  var l;
  const s = t && ((l = Nt(t)) == null ? void 0 : l.unit);
  let o = s || n === "temporal", a;
  return Od(e) ? a = e.expr : oe(e) ? a = e.signal : cl(e) ? (o = !0, a = qa(e)) : (Q(e) || Re(e)) && o && (a = `datetime(${Ge(e)})`, oae(s) && (Re(e) && e < 1e4 || Q(e) && isNaN(Date.parse(e))) && (a = qa({ [s]: e }))), a ? i && o ? `time(${a})` : a : r ? void 0 : Ge(e);
}
function dL(e, t) {
  const { type: n } = e;
  return t.map((i) => {
    const r = G(e) && !fl(e.timeUnit) ? e.timeUnit : void 0, s = _0(i, {
      timeUnit: r,
      type: n,
      undefinedIfExprNotRequired: !0
    });
    return s !== void 0 ? { signal: s } : i;
  });
}
function Pd(e, t) {
  return Ke(e.bin) ? Ls(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
}
const W$ = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function Id(e) {
  return e == null ? void 0 : e.condition;
}
const hL = ["domain", "grid", "labels", "ticks", "title"], yle = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
}, gL = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
}, ble = {
  ...gL,
  style: 1,
  labelExpr: 1,
  encoding: 1
};
function H$(e) {
  return !!ble[e];
}
const vle = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
}, pL = q(vle);
function Ps(e) {
  return "mark" in e;
}
class E0 {
  constructor(t, n) {
    this.name = t, this.run = n;
  }
  hasMatchingType(t) {
    return Ps(t) ? Yae(t.mark) === this.name : !1;
  }
}
function ka(e, t) {
  const n = e && e[t];
  return n ? j(n) ? Ba(n, (i) => !!i.field) : G(n) || x0(n) : !1;
}
function mL(e, t) {
  const n = e && e[t];
  return n ? j(n) ? Ba(n, (i) => !!i.field) : G(n) || Yr(n) || Ld(n) : !1;
}
function yL(e, t) {
  if (ft(t)) {
    const n = e[t];
    if ((G(n) || Yr(n)) && (I4(n.type) || G(n) && n.timeUnit)) {
      const i = X_(t);
      return mL(e, i);
    }
  }
  return !1;
}
function CE(e) {
  return Ba(wse, (t) => {
    if (ka(e, t)) {
      const n = e[t];
      if (j(n))
        return Ba(n, (i) => !!i.aggregate);
      {
        const i = Rr(n);
        return i && !!i.aggregate;
      }
    }
    return !1;
  });
}
function bL(e, t) {
  const n = [], i = [], r = [], s = [], o = {};
  return $E(e, (a, l) => {
    if (G(a)) {
      const { field: u, aggregate: c, bin: f, timeUnit: d, ...h } = a;
      if (c || d || f) {
        const g = SE(a), p = g == null ? void 0 : g.title;
        let m = K(a, { forAs: !0 });
        const y = {
          // Only add title if it doesn't exist
          ...p ? [] : { title: Yl(a, t, { allowDisabling: !0 }) },
          ...h,
          // Always overwrite field
          field: m
        };
        if (c) {
          let b;
          if (qo(c) ? (b = "argmax", m = K({ op: "argmax", field: c.argmax }, { forAs: !0 }), y.field = `${m}.${u}`) : Ss(c) ? (b = "argmin", m = K({ op: "argmin", field: c.argmin }, { forAs: !0 }), y.field = `${m}.${u}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (b = c), b) {
            const v = {
              op: b,
              as: m
            };
            u && (v.field = u), s.push(v);
          }
        } else if (n.push(m), En(a) && Ke(f)) {
          if (i.push({ bin: f, field: u, as: m }), n.push(K(a, { binSuffix: "end" })), Pd(a, l) && n.push(K(a, { binSuffix: "range" })), ft(l)) {
            const b = {
              field: `${m}_end`
            };
            o[`${l}2`] = b;
          }
          y.bin = "binned", r4(l) || (y.type = Wa);
        } else if (d && !fl(d)) {
          r.push({
            timeUnit: d,
            field: u,
            as: m
          });
          const b = En(a) && a.type !== Eu && "time";
          b && (l === Md || l === Ua ? y.formatType = b : Tse(l) ? y.legend = {
            formatType: b,
            ...y.legend
          } : ft(l) && (y.axis = {
            formatType: b,
            ...y.axis
          }));
        }
        o[l] = y;
      } else
        n.push(u), o[l] = e[l];
    } else
      o[l] = e[l];
  }), {
    bins: i,
    timeUnits: r,
    aggregate: s,
    groupby: n,
    encoding: o
  };
}
function xle(e, t, n) {
  const i = Nse(t, n);
  if (i) {
    if (i === "binned") {
      const r = e[t === sr ? tt : Lt];
      return !!(G(r) && G(e[t]) && zt(r.bin));
    }
  } else
    return !1;
  return !0;
}
function wle(e, t, n, i) {
  const r = {};
  for (const s of q(e))
    i4(s) || V(voe(s));
  for (let s of Cse) {
    if (!e[s])
      continue;
    const o = e[s];
    if (Td(s)) {
      const a = Ase(s), l = r[a];
      if (G(l) && bae(l.type) && G(o) && !l.timeUnit) {
        V(hoe(a));
        continue;
      }
    }
    if (s === "angle" && t === "arc" && !e.theta && (V(doe), s = Fi), !xle(e, s, t)) {
      V(f0(s, t));
      continue;
    }
    if (s === Ds && t === "line") {
      const a = Rr(e[s]);
      if (a != null && a.aggregate) {
        V(boe);
        continue;
      }
    }
    if (s === zn && (n ? "fill" in e : "stroke" in e)) {
      V(_4("encoding", { fill: "fill" in e, stroke: "stroke" in e }));
      continue;
    }
    if (s === Fd || s === wu && !j(o) && !er(o) || s === Ua && j(o)) {
      if (o) {
        if (s === wu) {
          const a = e[s];
          if (sL(a)) {
            r[s] = a;
            continue;
          }
        }
        r[s] = J(o).reduce((a, l) => (G(l) ? a.push(AE(l, s)) : V(gv(l, s)), a), []);
      }
    } else {
      if (s === Ua && o === null)
        r[s] = null;
      else if (!G(o) && !Yr(o) && !er(o) && !v0(o) && !oe(o)) {
        V(gv(o, s));
        continue;
      }
      r[s] = fL(o, s, i);
    }
  }
  return r;
}
function S0(e, t) {
  const n = {};
  for (const i of q(e)) {
    const r = fL(e[i], i, t, { compositeMark: !0 });
    n[i] = r;
  }
  return n;
}
function _le(e) {
  const t = [];
  for (const n of q(e))
    if (ka(e, n)) {
      const i = e[n], r = J(i);
      for (const s of r)
        G(s) ? t.push(s) : x0(s) && t.push(s.condition);
    }
  return t;
}
function $E(e, t, n) {
  if (e)
    for (const i of q(e)) {
      const r = e[i];
      if (j(r))
        for (const s of r)
          t.call(n, s, i);
      else
        t.call(n, r, i);
    }
}
function Ele(e, t, n, i) {
  return e ? q(e).reduce((r, s) => {
    const o = e[s];
    return j(o) ? o.reduce((a, l) => t.call(i, a, l, s), r) : t.call(i, r, o, s);
  }, n) : n;
}
function vL(e, t) {
  return q(t).reduce((n, i) => {
    switch (i) {
      case tt:
      case Lt:
      case s0:
      case a0:
      case o0:
      case sr:
      case qr:
      case Io:
      case Ku:
      case Fi:
      case Ns:
      case or:
      case Os:
      case ar:
      case lr:
      case ur:
      case $i:
      case Md:
      case Bn:
      case al:
      case Ua:
        return n;
      case wu:
        if (e === "line" || e === "trail")
          return n;
      case Fd:
      case r0: {
        const r = t[i];
        if (j(r) || G(r))
          for (const s of J(r))
            s.aggregate || n.push(K(s, {}));
        return n;
      }
      case Ds:
        if (e === "trail")
          return n;
      case zn:
      case Wr:
      case Hr:
      case Rs:
      case zo:
      case Bo:
      case Uo:
      case jo: {
        const r = Rr(t[i]);
        return r && !r.aggregate && n.push(K(r, {})), n;
      }
    }
  }, []);
}
function Sle(e) {
  const { tooltip: t, ...n } = e;
  if (!t)
    return { filteredEncoding: n };
  let i, r;
  if (j(t)) {
    for (const s of t)
      s.aggregate ? (i || (i = []), i.push(s)) : (r || (r = []), r.push(s));
    i && (n.tooltip = i);
  } else
    t.aggregate ? n.tooltip = t : r = t;
  return j(r) && r.length === 1 && (r = r[0]), { customTooltipWithoutAggregatedField: r, filteredEncoding: n };
}
function bv(e, t, n, i = !0) {
  if ("tooltip" in n)
    return { tooltip: n.tooltip };
  const r = e.map(({ fieldPrefix: o, titlePrefix: a }) => {
    const l = i ? ` of ${ME(t)}` : "";
    return {
      field: o + t.field,
      type: t.type,
      title: oe(a) ? { signal: `${a}"${escape(l)}"` } : a + l
    };
  }), s = _le(n).map(ole);
  return {
    tooltip: [
      ...r,
      // need to cast because TextFieldDef supports fewer types of bin
      ...xr(s, Me)
    ]
  };
}
function ME(e) {
  const { title: t, field: n } = e;
  return ct(t, n);
}
function FE(e, t, n, i, r) {
  const { scale: s, axis: o } = n;
  return ({ partName: a, mark: l, positionPrefix: u, endPositionPrefix: c = void 0, extraEncoding: f = {} }) => {
    const d = ME(n);
    return xL(e, a, r, {
      mark: l,
      encoding: {
        [t]: {
          field: `${u}_${n.field}`,
          type: n.type,
          ...d !== void 0 ? { title: d } : {},
          ...s !== void 0 ? { scale: s } : {},
          ...o !== void 0 ? { axis: o } : {}
        },
        ...Q(c) ? {
          [`${t}2`]: {
            field: `${c}_${n.field}`
          }
        } : {},
        ...i,
        ...f
      }
    });
  };
}
function xL(e, t, n, i) {
  const { clip: r, color: s, opacity: o } = e, a = e.type;
  return e[t] || e[t] === void 0 && n[t] ? [
    {
      ...i,
      mark: {
        ...n[t],
        ...r ? { clip: r } : {},
        ...s ? { color: s } : {},
        ...o ? { opacity: o } : {},
        ...Dr(i.mark) ? i.mark : { type: i.mark },
        style: `${a}-${String(t)}`,
        ...To(e[t]) ? {} : e[t]
      }
    }
  ] : [];
}
function wL(e, t, n) {
  const { encoding: i } = e, r = t === "vertical" ? "y" : "x", s = i[r], o = i[`${r}2`], a = i[`${r}Error`], l = i[`${r}Error2`];
  return {
    continuousAxisChannelDef: bh(s, n),
    continuousAxisChannelDef2: bh(o, n),
    continuousAxisChannelDefError: bh(a, n),
    continuousAxisChannelDefError2: bh(l, n),
    continuousAxis: r
  };
}
function bh(e, t) {
  if (e != null && e.aggregate) {
    const { aggregate: n, ...i } = e;
    return n !== t && V(Voe(n, t)), i;
  } else
    return e;
}
function _L(e, t) {
  const { mark: n, encoding: i } = e, { x: r, y: s } = i;
  if (Dr(n) && n.orient)
    return n.orient;
  if (ro(r)) {
    if (ro(s)) {
      const o = G(r) && r.aggregate, a = G(s) && s.aggregate;
      if (!o && a === t)
        return "vertical";
      if (!a && o === t)
        return "horizontal";
      if (o === t && a === t)
        throw new Error("Both x and y cannot have aggregate");
      return Cu(s) && !Cu(r) ? "horizontal" : "vertical";
    }
    return "horizontal";
  } else {
    if (ro(s))
      return "vertical";
    throw new Error(`Need a valid continuous axis for ${t}s`);
  }
}
const $p = "boxplot", kle = ["box", "median", "outliers", "rule", "ticks"], Ale = new E0($p, SL);
function EL(e) {
  return Re(e) ? "tukey" : e;
}
function SL(e, { config: t }) {
  e = {
    ...e,
    encoding: S0(e.encoding, t)
  };
  const { mark: n, encoding: i, params: r, projection: s, ...o } = e, a = Dr(n) ? n : { type: n };
  r && V(x4("boxplot"));
  const l = a.extent ?? t.boxplot.extent, u = Ue(
    "size",
    a,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    t
  ), c = a.invalid, f = EL(l), { bins: d, timeUnits: h, transform: g, continuousAxisChannelDef: p, continuousAxis: m, groupby: y, aggregate: b, encodingWithoutContinuousAxis: v, ticksOrient: w, boxOrient: _, customTooltipWithoutAggregatedField: S } = Cle(e, l, t), { color: E, size: C, ...$ } = v, N = (Pt) => FE(a, m, p, Pt, t.boxplot), T = N($), L = N(v), O = N({ ...$, ...C ? { size: C } : {} }), F = bv([
    { fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], p, v), x = { type: "tick", color: "black", opacity: 1, orient: w, invalid: c, aria: !1 }, k = f === "min-max" ? F : (
    // for tukey / k-IQR, just show upper/lower-whisker
    bv([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], p, v)
  ), A = [
    ...T({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: k
    }),
    ...T({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: k
    }),
    ...T({
      partName: "ticks",
      mark: x,
      positionPrefix: "lower_whisker",
      extraEncoding: k
    }),
    ...T({
      partName: "ticks",
      mark: x,
      positionPrefix: "upper_whisker",
      extraEncoding: k
    })
  ], M = [
    ...f !== "tukey" ? A : [],
    ...L({
      partName: "box",
      mark: {
        type: "bar",
        ...u ? { size: u } : {},
        orient: _,
        invalid: c,
        ariaRoleDescription: "box"
      },
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: F
    }),
    ...O({
      partName: "median",
      mark: {
        type: "tick",
        invalid: c,
        ...ee(t.boxplot.median) && t.boxplot.median.color ? { color: t.boxplot.median.color } : {},
        ...u ? { size: u } : {},
        orient: w,
        aria: !1
      },
      positionPrefix: "mid_box",
      extraEncoding: F
    })
  ];
  if (f === "min-max")
    return {
      ...o,
      transform: (o.transform ?? []).concat(g),
      layer: M
    };
  const D = `datum["lower_box_${p.field}"]`, R = `datum["upper_box_${p.field}"]`, U = `(${R} - ${D})`, W = `${D} - ${l} * ${U}`, ne = `${R} + ${l} * ${U}`, Z = `datum["${p.field}"]`, re = {
    joinaggregate: kL(p.field),
    groupby: y
  }, Ce = {
    transform: [
      {
        filter: `(${W} <= ${Z}) && (${Z} <= ${ne})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: p.field,
            as: `lower_whisker_${p.field}`
          },
          {
            op: "max",
            field: p.field,
            as: `upper_whisker_${p.field}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${p.field}`,
            as: `lower_box_${p.field}`
          },
          {
            op: "max",
            field: `upper_box_${p.field}`,
            as: `upper_box_${p.field}`
          },
          ...b
        ],
        groupby: y
      }
    ],
    layer: A
  }, { tooltip: Et, ...ln } = $, { scale: te, axis: ye } = p, ve = ME(p), H = Nn(ye, ["title"]), gt = xL(a, "outliers", t.boxplot, {
    transform: [{ filter: `(${Z} < ${W}) || (${Z} > ${ne})` }],
    mark: "point",
    encoding: {
      [m]: {
        field: p.field,
        type: p.type,
        ...ve !== void 0 ? { title: ve } : {},
        ...te !== void 0 ? { scale: te } : {},
        // add axis without title since we already added the title above
        ...He(H) ? {} : { axis: H }
      },
      ...ln,
      ...E ? { color: E } : {},
      ...S ? { tooltip: S } : {}
    }
  })[0];
  let De;
  const St = [...d, ...h, re];
  return gt ? De = {
    transform: St,
    layer: [gt, Ce]
  } : (De = Ce, De.transform.unshift(...St)), {
    ...o,
    layer: [
      De,
      {
        // boxplot
        transform: g,
        layer: M
      }
    ]
  };
}
function kL(e) {
  return [
    {
      op: "q1",
      field: e,
      as: `lower_box_${e}`
    },
    {
      op: "q3",
      field: e,
      as: `upper_box_${e}`
    }
  ];
}
function Cle(e, t, n) {
  const i = _L(e, $p), { continuousAxisChannelDef: r, continuousAxis: s } = wL(e, i, $p), o = r.field, a = EL(t), l = [
    ...kL(o),
    {
      op: "median",
      field: o,
      as: `mid_box_${o}`
    },
    {
      op: "min",
      field: o,
      as: (a === "min-max" ? "lower_whisker_" : "min_") + o
    },
    {
      op: "max",
      field: o,
      as: (a === "min-max" ? "upper_whisker_" : "max_") + o
    }
  ], u = a === "min-max" || a === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `datum["upper_box_${o}"] - datum["lower_box_${o}"]`,
      as: `iqr_${o}`
    },
    {
      calculate: `min(datum["upper_box_${o}"] + datum["iqr_${o}"] * ${t}, datum["max_${o}"])`,
      as: `upper_whisker_${o}`
    },
    {
      calculate: `max(datum["lower_box_${o}"] - datum["iqr_${o}"] * ${t}, datum["min_${o}"])`,
      as: `lower_whisker_${o}`
    }
  ], { [s]: c, ...f } = e.encoding, { customTooltipWithoutAggregatedField: d, filteredEncoding: h } = Sle(f), { bins: g, timeUnits: p, aggregate: m, groupby: y, encoding: b } = bL(h, n), v = i === "vertical" ? "horizontal" : "vertical", w = i, _ = [
    ...g,
    ...p,
    {
      aggregate: [...m, ...l],
      groupby: y
    },
    ...u
  ];
  return {
    bins: g,
    timeUnits: p,
    transform: _,
    groupby: y,
    aggregate: m,
    continuousAxisChannelDef: r,
    continuousAxis: s,
    encodingWithoutContinuousAxis: b,
    ticksOrient: v,
    boxOrient: w,
    customTooltipWithoutAggregatedField: d
  };
}
const TE = "errorbar", $le = ["ticks", "rule"], Mle = new E0(TE, AL);
function AL(e, { config: t }) {
  e = {
    ...e,
    encoding: S0(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: s, ticksOrient: o, markDef: a, outerSpec: l, tooltipEncoding: u } = CL(e, TE, t);
  delete s.size;
  const c = FE(a, r, i, s, t.errorbar), f = a.thickness, d = a.size, h = {
    type: "tick",
    orient: o,
    aria: !1,
    ...f !== void 0 ? { thickness: f } : {},
    ...d !== void 0 ? { size: d } : {}
  }, g = [
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "lower",
      extraEncoding: u
    }),
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "upper",
      extraEncoding: u
    }),
    ...c({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar",
        ...f !== void 0 ? { size: f } : {}
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: u
    })
  ];
  return {
    ...l,
    transform: n,
    ...g.length > 1 ? { layer: g } : { ...g[0] }
  };
}
function Fle(e, t) {
  const { encoding: n } = e;
  if (Tle(n))
    return {
      orient: _L(e, t),
      inputType: "raw"
    };
  const i = Ole(n), r = Nle(n), s = n.x, o = n.y;
  if (i) {
    if (r)
      throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
    const a = n.x2, l = n.y2;
    if (be(a) && be(l))
      throw new Error(`${t} cannot have both x2 and y2`);
    if (be(a)) {
      if (ro(s))
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      throw new Error(`Both x and x2 have to be quantitative in ${t}`);
    } else if (be(l)) {
      if (ro(o))
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      throw new Error(`Both y and y2 have to be quantitative in ${t}`);
    }
    throw new Error("No ranged axis");
  } else {
    const a = n.xError, l = n.xError2, u = n.yError, c = n.yError2;
    if (be(l) && !be(a))
      throw new Error(`${t} cannot have xError2 without xError`);
    if (be(c) && !be(u))
      throw new Error(`${t} cannot have yError2 without yError`);
    if (be(a) && be(u))
      throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
    if (be(a)) {
      if (ro(s))
        return { orient: "horizontal", inputType: "aggregated-error" };
      throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
    } else if (be(u)) {
      if (ro(o))
        return { orient: "vertical", inputType: "aggregated-error" };
      throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
    }
    throw new Error("No ranged axis");
  }
}
function Tle(e) {
  return (be(e.x) || be(e.y)) && !be(e.x2) && !be(e.y2) && !be(e.xError) && !be(e.xError2) && !be(e.yError) && !be(e.yError2);
}
function Ole(e) {
  return be(e.x2) || be(e.y2);
}
function Nle(e) {
  return be(e.xError) || be(e.xError2) || be(e.yError) || be(e.yError2);
}
function CL(e, t, n) {
  const { mark: i, encoding: r, params: s, projection: o, ...a } = e, l = Dr(i) ? i : { type: i };
  s && V(x4(t));
  const { orient: u, inputType: c } = Fle(e, t), { continuousAxisChannelDef: f, continuousAxisChannelDef2: d, continuousAxisChannelDefError: h, continuousAxisChannelDefError2: g, continuousAxis: p } = wL(e, u, t), { errorBarSpecificAggregate: m, postAggregateCalculates: y, tooltipSummary: b, tooltipTitleWithFieldName: v } = Dle(l, f, d, h, g, c, t, n), { [p]: w, [p === "x" ? "x2" : "y2"]: _, [p === "x" ? "xError" : "yError"]: S, [p === "x" ? "xError2" : "yError2"]: E, ...C } = r, { bins: $, timeUnits: N, aggregate: T, groupby: L, encoding: O } = bL(C, n), F = [...T, ...m], x = c !== "raw" ? [] : L, k = bv(b, f, O, v);
  return {
    transform: [
      ...a.transform ?? [],
      ...$,
      ...N,
      ...F.length === 0 ? [] : [{ aggregate: F, groupby: x }],
      ...y
    ],
    groupby: x,
    continuousAxisChannelDef: f,
    continuousAxis: p,
    encodingWithoutContinuousAxis: O,
    ticksOrient: u === "vertical" ? "horizontal" : "vertical",
    markDef: l,
    outerSpec: a,
    tooltipEncoding: k
  };
}
function Dle(e, t, n, i, r, s, o, a) {
  let l = [], u = [];
  const c = t.field;
  let f, d = !1;
  if (s === "raw") {
    const h = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : a.errorbar.center, g = e.extent ? e.extent : h === "mean" ? "stderr" : "iqr";
    if (h === "median" != (g === "iqr") && V(Goe(h, g, o)), g === "stderr" || g === "stdev")
      l = [
        { op: g, field: c, as: `extent_${c}` },
        { op: h, field: c, as: `center_${c}` }
      ], u = [
        {
          calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
          as: `upper_${c}`
        },
        {
          calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
          as: `lower_${c}`
        }
      ], f = [
        { fieldPrefix: "center_", titlePrefix: $d(h) },
        { fieldPrefix: "upper_", titlePrefix: G$(h, g, "+") },
        { fieldPrefix: "lower_", titlePrefix: G$(h, g, "-") }
      ], d = !0;
    else {
      let p, m, y;
      g === "ci" ? (p = "mean", m = "ci0", y = "ci1") : (p = "median", m = "q1", y = "q3"), l = [
        { op: m, field: c, as: `lower_${c}` },
        { op: y, field: c, as: `upper_${c}` },
        { op: p, field: c, as: `center_${c}` }
      ], f = [
        {
          fieldPrefix: "upper_",
          titlePrefix: Yl({ field: c, aggregate: y, type: "quantitative" }, a, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: Yl({ field: c, aggregate: m, type: "quantitative" }, a, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: Yl({ field: c, aggregate: p, type: "quantitative" }, a, {
            allowDisabling: !1
          })
        }
      ];
    }
  } else {
    (e.center || e.extent) && V(Hoe(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], u = [
      { calculate: `datum["${n.field}"]`, as: `upper_${c}` },
      { calculate: `datum["${c}"]`, as: `lower_${c}` }
    ]) : s === "aggregated-error" && (f = [{ fieldPrefix: "", titlePrefix: c }], u = [
      {
        calculate: `datum["${c}"] + datum["${i.field}"]`,
        as: `upper_${c}`
      }
    ], r ? u.push({
      calculate: `datum["${c}"] + datum["${r.field}"]`,
      as: `lower_${c}`
    }) : u.push({
      calculate: `datum["${c}"] - datum["${i.field}"]`,
      as: `lower_${c}`
    }));
    for (const h of u)
      f.push({
        fieldPrefix: h.as.substring(0, 6),
        titlePrefix: ja(ja(h.calculate, 'datum["', ""), '"]', "")
      });
  }
  return { postAggregateCalculates: u, errorBarSpecificAggregate: l, tooltipSummary: f, tooltipTitleWithFieldName: d };
}
function G$(e, t, n) {
  return `${$d(e)} ${n} ${t}`;
}
const OE = "errorband", Rle = ["band", "borders"], Lle = new E0(OE, $L);
function $L(e, { config: t }) {
  e = {
    ...e,
    encoding: S0(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: s, markDef: o, outerSpec: a, tooltipEncoding: l } = CL(e, OE, t), u = o, c = FE(u, r, i, s, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
  let d = { type: f ? "area" : "rect" }, h = { type: f ? "line" : "rule" };
  const g = {
    ...u.interpolate ? { interpolate: u.interpolate } : {},
    ...u.tension && u.interpolate ? { tension: u.tension } : {}
  };
  return f ? (d = {
    ...d,
    ...g,
    ariaRoleDescription: "errorband"
  }, h = {
    ...h,
    ...g,
    aria: !1
  }) : u.interpolate ? V(P$("interpolate")) : u.tension && V(P$("tension")), {
    ...a,
    transform: n,
    layer: [
      ...c({
        partName: "band",
        mark: d,
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: l
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "lower",
        extraEncoding: l
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "upper",
        extraEncoding: l
      })
    ]
  };
}
const ML = {};
function NE(e, t, n) {
  const i = new E0(e, t);
  ML[e] = { normalizer: i, parts: n };
}
function Ple() {
  return q(ML);
}
NE($p, SL, kle);
NE(TE, AL, $le);
NE(OE, $L, Rle);
const Ile = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
], FL = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
}, TL = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
}, zle = q(FL), Ble = q(TL), jle = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
}, OL = q(jle), NL = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
], Ule = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
}, qle = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
}, tr = "_vgsid_", Wle = {
  point: {
    on: "click",
    fields: [tr],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[pointerdown, window:pointerup] > window:pointermove!",
    encodings: ["x", "y"],
    translate: "[pointerdown, window:pointerup] > window:pointermove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function DE(e) {
  return e === "legend" || !!(e != null && e.legend);
}
function ny(e) {
  return DE(e) && ee(e);
}
function RE(e) {
  return !!(e != null && e.select);
}
function DL(e) {
  const t = [];
  for (const n of e || []) {
    if (RE(n))
      continue;
    const { expr: i, bind: r, ...s } = n;
    if (r && i) {
      const o = {
        ...s,
        bind: r,
        init: i
      };
      t.push(o);
    } else {
      const o = {
        ...s,
        ...i ? { update: i } : {},
        ...r ? { bind: r } : {}
      };
      t.push(o);
    }
  }
  return t;
}
function Hle(e) {
  return k0(e) || PE(e) || LE(e);
}
function LE(e) {
  return "concat" in e;
}
function k0(e) {
  return "vconcat" in e;
}
function PE(e) {
  return "hconcat" in e;
}
function RL({ step: e, offsetIsDiscrete: t }) {
  return t ? e.for ?? "offset" : "position";
}
function Lr(e) {
  return ee(e) && e.step !== void 0;
}
function V$(e) {
  return e.view || e.width || e.height;
}
const Y$ = 20, Gle = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
}, Vle = q(Gle);
function Yle(e, t, n) {
  const i = n[t], r = {}, { spacing: s, columns: o } = i;
  s !== void 0 && (r.spacing = s), o !== void 0 && (b0(e) && !Rd(e.facet) || LE(e)) && (r.columns = o), k0(e) && (r.columns = 1);
  for (const a of Vle)
    if (e[a] !== void 0)
      if (a === "spacing") {
        const l = e[a];
        r[a] = Re(l) ? l : {
          row: l.row ?? s,
          column: l.column ?? s
        };
      } else
        r[a] = e[a];
  return r;
}
function vv(e, t) {
  return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"];
}
function Mp(e, t) {
  const n = Fp(e, t);
  return Lr(n) ? n.step : LL;
}
function Fp(e, t) {
  const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
  return ct(n, { step: e.step });
}
const LL = 20, Xle = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: LL
}, Kle = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: Xle,
  mark: Uae,
  arc: {},
  area: {},
  bar: Hae,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: Gae,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: Vae,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: !0,
    ticks: !1
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: !1
  },
  scale: Sae,
  projection: {},
  legend: Ule,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: Wle,
  style: {},
  title: {},
  facet: { spacing: Y$ },
  concat: { spacing: Y$ },
  normalizedNumberFormat: ".0%"
}, Zr = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
], X$ = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
}, K$ = {
  blue: Zr[0],
  orange: Zr[1],
  red: Zr[2],
  teal: Zr[3],
  green: Zr[4],
  yellow: Zr[5],
  purple: Zr[6],
  pink: Zr[7],
  brown: Zr[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function Jle(e = {}) {
  return {
    signals: [
      {
        name: "color",
        value: ee(e) ? { ...K$, ...e } : K$
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function Qle(e) {
  return {
    signals: [
      {
        name: "fontSize",
        value: ee(e) ? { ...X$, ...e } : X$
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function Zle(e) {
  return {
    text: { font: e },
    style: {
      "guide-label": { font: e },
      "guide-title": { font: e },
      "group-title": { font: e },
      "group-subtitle": { font: e }
    }
  };
}
function PL(e) {
  const t = q(e || {}), n = {};
  for (const i of t) {
    const r = e[i];
    n[i] = Id(r) ? h4(r) : Vn(r);
  }
  return n;
}
function eue(e) {
  const t = q(e), n = {};
  for (const i of t)
    n[i] = PL(e[i]);
  return n;
}
const tue = [
  ...Y4,
  ...pL,
  ...OL,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function IL(e = {}) {
  const { color: t, font: n, fontSize: i, selection: r, ...s } = e, o = Du({}, me(Kle), n ? Zle(n) : {}, t ? Jle(t) : {}, i ? Qle(i) : {}, s || {});
  r && Ru(o, "selection", r, !0);
  const a = Nn(o, tue);
  for (const l of ["background", "lineBreak", "padding"])
    o[l] && (a[l] = Vn(o[l]));
  for (const l of Y4)
    o[l] && (a[l] = Fn(o[l]));
  for (const l of pL)
    o[l] && (a[l] = PL(o[l]));
  for (const l of OL)
    o[l] && (a[l] = Fn(o[l]));
  return o.legend && (a.legend = Fn(o.legend)), o.scale && (a.scale = Fn(o.scale)), o.style && (a.style = eue(o.style)), o.title && (a.title = Fn(o.title)), o.view && (a.view = Fn(o.view)), a;
}
const nue = /* @__PURE__ */ new Set(["view", ...Lae]), iue = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
  // FIXME: Redesign and unhide this
], rue = {
  view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
  ...jae
};
function sue(e) {
  e = me(e);
  for (const t of iue)
    delete e[t];
  if (e.axis)
    for (const t in e.axis)
      Id(e.axis[t]) && delete e.axis[t];
  if (e.legend)
    for (const t of Ile)
      delete e.legend[t];
  if (e.mark) {
    for (const t of z$)
      delete e.mark[t];
    e.mark.tooltip && ee(e.mark.tooltip) && delete e.mark.tooltip;
  }
  e.params && (e.signals = (e.signals || []).concat(DL(e.params)), delete e.params);
  for (const t of nue) {
    for (const i of z$)
      delete e[t][i];
    const n = rue[t];
    if (n)
      for (const i of n)
        delete e[t][i];
    aue(e, t);
  }
  for (const t of Ple())
    delete e[t];
  oue(e);
  for (const t in e)
    ee(e[t]) && He(e[t]) && delete e[t];
  return He(e) ? void 0 : e;
}
function oue(e) {
  const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: i } = d4(e.title);
  He(t) || (e.style["group-title"] = {
    ...e.style["group-title"],
    ...t
    // config.title has higher precedence than config.style.group-title in Vega
  }), He(n) || (e.style["group-subtitle"] = {
    ...e.style["group-subtitle"],
    ...n
  }), He(i) ? delete e.title : e.title = i;
}
function aue(e, t, n, i) {
  const r = i ? e[t][i] : e[t];
  t === "view" && (n = "cell");
  const s = {
    ...r,
    ...e.style[n ?? t]
  };
  He(s) || (e.style[n ?? t] = s), i || delete e[t];
}
function A0(e) {
  return "layer" in e;
}
function lue(e) {
  return "repeat" in e;
}
function uue(e) {
  return !j(e.repeat) && e.repeat.layer;
}
class IE {
  map(t, n) {
    return b0(t) ? this.mapFacet(t, n) : lue(t) ? this.mapRepeat(t, n) : PE(t) ? this.mapHConcat(t, n) : k0(t) ? this.mapVConcat(t, n) : LE(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (A0(t))
      return this.mapLayer(t, n);
    if (Ps(t))
      return this.mapUnit(t, n);
    throw new Error(eE(t));
  }
  mapLayer(t, n) {
    return {
      ...t,
      layer: t.layer.map((i) => this.mapLayerOrUnit(i, n))
    };
  }
  mapHConcat(t, n) {
    return {
      ...t,
      hconcat: t.hconcat.map((i) => this.map(i, n))
    };
  }
  mapVConcat(t, n) {
    return {
      ...t,
      vconcat: t.vconcat.map((i) => this.map(i, n))
    };
  }
  mapConcat(t, n) {
    const { concat: i, ...r } = t;
    return {
      ...r,
      concat: i.map((s) => this.map(s, n))
    };
  }
  mapFacet(t, n) {
    return {
      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
      ...t,
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(t.spec, n)
    };
  }
  mapRepeat(t, n) {
    return {
      ...t,
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(t.spec, n)
    };
  }
}
const cue = {
  zero: 1,
  center: 1,
  normalize: 1
};
function fue(e) {
  return e in cue;
}
const due = /* @__PURE__ */ new Set([H4, g0, h0, _p, m0, mE, yE, p0, G4, pE]), hue = /* @__PURE__ */ new Set([g0, h0, H4]);
function Al(e) {
  return G(e) && ku(e) === "quantitative" && !e.bin;
}
function J$(e, t, { orient: n, type: i }) {
  const r = t === "x" ? "y" : "radius", s = t === "x" && ["bar", "area"].includes(i), o = e[t], a = e[r];
  if (G(o) && G(a))
    if (Al(o) && Al(a)) {
      if (o.stack)
        return t;
      if (a.stack)
        return r;
      const l = G(o) && !!o.aggregate, u = G(a) && !!a.aggregate;
      if (l !== u)
        return l ? t : r;
      if (s) {
        if (n === "vertical")
          return r;
        if (n === "horizontal")
          return t;
      }
    } else {
      if (Al(o))
        return t;
      if (Al(a))
        return r;
    }
  else {
    if (Al(o))
      return s && n === "vertical" ? void 0 : t;
    if (Al(a))
      return s && n === "horizontal" ? void 0 : r;
  }
}
function gue(e) {
  switch (e) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function zL(e, t) {
  var p, m;
  const n = Dr(e) ? e : { type: e }, i = n.type;
  if (!due.has(i))
    return null;
  const r = J$(t, "x", n) || J$(t, "theta", n);
  if (!r)
    return null;
  const s = t[r], o = G(s) ? K(s, {}) : void 0, a = gue(r), l = [], u = /* @__PURE__ */ new Set();
  if (t[a]) {
    const y = t[a], b = G(y) ? K(y, {}) : void 0;
    b && b !== o && (l.push(a), u.add(b));
  }
  const c = a === "x" ? "xOffset" : "yOffset", f = t[c], d = G(f) ? K(f, {}) : void 0;
  d && d !== o && (l.push(c), u.add(d));
  const h = $se.reduce((y, b) => {
    if (b !== "tooltip" && ka(t, b)) {
      const v = t[b];
      for (const w of J(v)) {
        const _ = Rr(w);
        if (_.aggregate)
          continue;
        const S = K(_, {});
        // if fielddef is a repeat, just include it in the stack by
        (!S || // otherwise, the field must be different from the groupBy fields.
        !u.has(S)) && y.push({ channel: b, fieldDef: _ });
      }
    }
    return y;
  }, []);
  let g;
  return s.stack !== void 0 ? To(s.stack) ? g = s.stack ? "zero" : null : g = s.stack : hue.has(i) && (g = "zero"), !g || !fue(g) || CE(t) && h.length === 0 ? null : (p = s == null ? void 0 : s.scale) != null && p.type && ((m = s == null ? void 0 : s.scale) == null ? void 0 : m.type) !== Dn.LINEAR ? (s != null && s.stack && V(Uoe(s.scale.type)), null) : be(t[Gr(r)]) ? (s.stack !== void 0 && V(joe(r)), null) : (G(s) && s.aggregate && !Bse.has(s.aggregate) && V(qoe(s.aggregate)), {
    groupbyChannels: l,
    groupbyFields: u,
    fieldChannel: r,
    impute: s.impute === null ? !1 : Ho(i),
    stackBy: h,
    offset: g
  });
}
function BL(e, t, n) {
  const i = Fn(e), r = Ue("orient", i, n);
  if (i.orient = bue(i.type, t, r), r !== void 0 && r !== i.orient && V(koe(i.orient, r)), i.type === "bar" && i.orient) {
    const a = Ue("cornerRadiusEnd", i, n);
    if (a !== void 0) {
      const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Wae[i.orient];
      for (const u of l)
        i[u] = a;
      i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
    }
  }
  return Ue("opacity", i, n) === void 0 && (i.opacity = mue(i.type, t)), Ue("cursor", i, n) === void 0 && (i.cursor = pue(i, t, n)), i;
}
function pue(e, t, n) {
  return t.href || e.href || Ue("href", e, n) ? "pointer" : e.cursor;
}
function mue(e, t) {
  if (Fe([m0, pE, mE, yE], e) && !CE(t))
    return 0.7;
}
function yue(e, t, { graticule: n }) {
  if (n)
    return !1;
  const i = ks("filled", e, t), r = e.type;
  return ct(i, r !== m0 && r !== p0 && r !== _p);
}
function bue(e, t, n) {
  switch (e) {
    case m0:
    case mE:
    case yE:
    case G4:
    case Dae:
    case Nae:
      return;
  }
  const { x: i, y: r, x2: s, y2: o } = t;
  switch (e) {
    case g0:
      if (G(i) && (zt(i.bin) || G(r) && r.aggregate && !i.aggregate))
        return "vertical";
      if (G(r) && (zt(r.bin) || G(i) && i.aggregate && !r.aggregate))
        return "horizontal";
      if (o || s) {
        if (n)
          return n;
        if (!s)
          return (G(i) && i.type === Wa && !Ke(i.bin) || Sp(i)) && G(r) && zt(r.bin) ? "horizontal" : "vertical";
        if (!o)
          return (G(r) && r.type === Wa && !Ke(r.bin) || Sp(r)) && G(i) && zt(i.bin) ? "vertical" : "horizontal";
      }
    case _p:
      if (s && !(G(i) && zt(i.bin)) && o && !(G(r) && zt(r.bin)))
        return;
    case h0:
      if (o)
        return G(r) && zt(r.bin) ? "horizontal" : "vertical";
      if (s)
        return G(i) && zt(i.bin) ? "vertical" : "horizontal";
      if (e === _p) {
        if (i && !r)
          return "vertical";
        if (r && !i)
          return "horizontal";
      }
    case p0:
    case pE: {
      const a = q$(i), l = q$(r);
      if (n)
        return n;
      if (a && !l)
        return e !== "tick" ? "horizontal" : "vertical";
      if (!a && l)
        return e !== "tick" ? "vertical" : "horizontal";
      if (a && l)
        return "vertical";
      {
        const u = En(i) && i.type === Eu, c = En(r) && r.type === Eu;
        if (u && !c)
          return "vertical";
        if (!u && c)
          return "horizontal";
      }
      return;
    }
  }
  return "vertical";
}
function vue(e) {
  const { point: t, line: n, ...i } = e;
  return q(i).length > 1 ? i : i.type;
}
function xue(e) {
  for (const t of ["line", "area", "rule", "trail"])
    e[t] && (e = {
      ...e,
      // TODO: remove as any
      [t]: Nn(e[t], ["point", "line"])
    });
  return e;
}
function iy(e, t = {}, n) {
  return e.point === "transparent" ? { opacity: 0 } : e.point ? ee(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? ee(t.point) ? t.point : {} : void 0;
}
function Q$(e, t = {}) {
  return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
}
class wue {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(t, n) {
    if (Ps(t)) {
      const { mark: i, encoding: r } = t, s = Dr(i) ? i : { type: i };
      switch (s.type) {
        case "line":
        case "rule":
        case "trail":
          return !!iy(s, n[s.type], r);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!iy(s, n[s.type], r) || !!Q$(s, n[s.type])
          );
      }
    }
    return !1;
  }
  run(t, n, i) {
    const { config: r } = n, { params: s, projection: o, mark: a, name: l, encoding: u, ...c } = t, f = S0(u, r), d = Dr(a) ? a : { type: a }, h = iy(d, r[d.type], f), g = d.type === "area" && Q$(d, r[d.type]), p = [
      {
        name: l,
        ...s ? { params: s } : {},
        mark: vue({
          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...
          ...d.type === "area" && d.opacity === void 0 && d.fillOpacity === void 0 ? { opacity: 0.7 } : {},
          ...d
        }),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: Nn(f, ["shape"])
      }
    ], m = zL(BL(d, f, r), f);
    let y = f;
    if (m) {
      const { fieldChannel: b, offset: v } = m;
      y = {
        ...f,
        [b]: {
          ...f[b],
          ...v ? { stack: v } : {}
        }
      };
    }
    return y = Nn(y, ["y2", "x2"]), g && p.push({
      ...o ? { projection: o } : {},
      mark: {
        type: "line",
        ...vu(d, ["clip", "interpolate", "tension", "tooltip"]),
        ...g
      },
      encoding: y
    }), h && p.push({
      ...o ? { projection: o } : {},
      mark: {
        type: "point",
        opacity: 1,
        filled: !0,
        ...vu(d, ["clip", "tooltip"]),
        ...h
      },
      encoding: y
    }), i({
      ...c,
      layer: p
    }, {
      ...n,
      config: xue(r)
    });
  }
}
function _ue(e, t) {
  return t ? Rd(e) ? UL(e, t) : jL(e, t) : e;
}
function ry(e, t) {
  return t ? UL(e, t) : e;
}
function xv(e, t, n) {
  const i = t[e];
  if (rle(i)) {
    if (i.repeat in n)
      return { ...t, [e]: n[i.repeat] };
    V(soe(i.repeat));
    return;
  }
  return t;
}
function jL(e, t) {
  if (e = xv("field", e, t), e !== void 0) {
    if (e === null)
      return null;
    if (EE(e) && Sr(e.sort)) {
      const n = xv("field", e.sort, t);
      e = {
        ...e,
        ...n ? { sort: n } : {}
      };
    }
    return e;
  }
}
function Z$(e, t) {
  if (G(e))
    return jL(e, t);
  {
    const n = xv("datum", e, t);
    return n !== e && !n.type && (n.type = "nominal"), n;
  }
}
function eM(e, t) {
  if (be(e)) {
    const n = Z$(e, t);
    if (n)
      return n;
    if (v0(e))
      return { condition: e.condition };
  } else {
    if (Ld(e)) {
      const n = Z$(e.condition, t);
      if (n)
        return {
          ...e,
          condition: n
        };
      {
        const { condition: i, ...r } = e;
        return r;
      }
    }
    return e;
  }
}
function UL(e, t) {
  const n = {};
  for (const i in e)
    if (ce(e, i)) {
      const r = e[i];
      if (j(r))
        n[i] = r.map((s) => eM(s, t)).filter((s) => s);
      else {
        const s = eM(r, t);
        s !== void 0 && (n[i] = s);
      }
    }
  return n;
}
class Eue {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(t) {
    if (Ps(t)) {
      const { encoding: n, mark: i } = t;
      if (i === "line" || Dr(i) && i.type === "line")
        for (const r of kse) {
          const s = ll(r), o = n[s];
          if (n[r] && (G(o) && !zt(o.bin) || Yr(o)))
            return !0;
        }
    }
    return !1;
  }
  run(t, n, i) {
    const { encoding: r, mark: s } = t;
    return V(Soe(!!r.x2, !!r.y2)), i({
      ...t,
      mark: ee(s) ? { ...s, type: "rule" } : "rule"
    }, n);
  }
}
class Sue extends IE {
  constructor() {
    super(...arguments), this.nonFacetUnitNormalizers = [
      Ale,
      Mle,
      Lle,
      new wue(),
      new Eue()
    ];
  }
  map(t, n) {
    if (Ps(t)) {
      const i = ka(t.encoding, ms), r = ka(t.encoding, ys), s = ka(t.encoding, i0);
      if (i || r || s)
        return this.mapFacetedUnit(t, n);
    }
    return super.map(t, n);
  }
  // This is for normalizing non-facet unit
  mapUnit(t, n) {
    const { parentEncoding: i, parentProjection: r } = n, s = ry(t.encoding, n.repeater), o = {
      ...t,
      ...t.name ? { name: [n.repeaterPrefix, t.name].filter((l) => l).join("_") } : {},
      ...s ? { encoding: s } : {}
    };
    if (i || r)
      return this.mapUnitWithParentEncodingOrProjection(o, n);
    const a = this.mapLayerOrUnit.bind(this);
    for (const l of this.nonFacetUnitNormalizers)
      if (l.hasMatchingType(o, n.config))
        return l.run(o, n, a);
    return o;
  }
  mapRepeat(t, n) {
    return uue(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
  }
  mapLayerRepeat(t, n) {
    const { repeat: i, spec: r, ...s } = t, { row: o, column: a, layer: l } = i, { repeater: u = {}, repeaterPrefix: c = "" } = n;
    return o || a ? this.mapRepeat({
      ...t,
      repeat: {
        ...o ? { row: o } : {},
        ...a ? { column: a } : {}
      },
      spec: {
        repeat: { layer: l },
        spec: r
      }
    }, n) : {
      ...s,
      layer: l.map((f) => {
        const d = {
          ...u,
          layer: f
        }, h = `${(r.name ? `${r.name}_` : "") + c}child__layer_${et(f)}`, g = this.mapLayerOrUnit(r, { ...n, repeater: d, repeaterPrefix: h });
        return g.name = h, g;
      })
    };
  }
  mapNonLayerRepeat(t, n) {
    const { repeat: i, spec: r, data: s, ...o } = t;
    !j(i) && t.columns && (t = Nn(t, ["columns"]), V(N$("repeat")));
    const a = [], { repeater: l = {}, repeaterPrefix: u = "" } = n, c = !j(i) && i.row || [l ? l.row : null], f = !j(i) && i.column || [l ? l.column : null], d = j(i) && i || [l ? l.repeat : null];
    for (const g of d)
      for (const p of c)
        for (const m of f) {
          const y = {
            repeat: g,
            row: p,
            column: m,
            layer: l.layer
          }, b = (r.name ? `${r.name}_` : "") + u + "child__" + (j(i) ? `${et(g)}` : (i.row ? `row_${et(p)}` : "") + (i.column ? `column_${et(m)}` : "")), v = this.map(r, { ...n, repeater: y, repeaterPrefix: b });
          v.name = b, a.push(Nn(v, ["data"]));
        }
    const h = j(i) ? t.columns : i.column ? i.column.length : 1;
    return {
      data: r.data ?? s,
      align: "all",
      ...o,
      columns: h,
      concat: a
    };
  }
  mapFacet(t, n) {
    const { facet: i } = t;
    return Rd(i) && t.columns && (t = Nn(t, ["columns"]), V(N$("facet"))), super.mapFacet(t, n);
  }
  mapUnitWithParentEncodingOrProjection(t, n) {
    const { encoding: i, projection: r } = t, { parentEncoding: s, parentProjection: o, config: a } = n, l = nM({ parentProjection: o, projection: r }), u = tM({
      parentEncoding: s,
      encoding: ry(i, n.repeater)
    });
    return this.mapUnit({
      ...t,
      ...l ? { projection: l } : {},
      ...u ? { encoding: u } : {}
    }, { config: a });
  }
  mapFacetedUnit(t, n) {
    const { row: i, column: r, facet: s, ...o } = t.encoding, { mark: a, width: l, projection: u, height: c, view: f, params: d, encoding: h, ...g } = t, { facetMapping: p, layout: m } = this.getFacetMappingAndLayout({ row: i, column: r, facet: s }, n), y = ry(o, n.repeater);
    return this.mapFacet({
      ...g,
      ...m,
      // row / column has higher precedence than facet
      facet: p,
      spec: {
        ...l ? { width: l } : {},
        ...c ? { height: c } : {},
        ...f ? { view: f } : {},
        ...u ? { projection: u } : {},
        mark: a,
        encoding: y,
        ...d ? { params: d } : {}
      }
    }, n);
  }
  getFacetMappingAndLayout(t, n) {
    const { row: i, column: r, facet: s } = t;
    if (i || r) {
      s && V(_oe([...i ? [ms] : [], ...r ? [ys] : []]));
      const o = {}, a = {};
      for (const l of [ms, ys]) {
        const u = t[l];
        if (u) {
          const { align: c, center: f, spacing: d, columns: h, ...g } = u;
          o[l] = g;
          for (const p of ["align", "center", "spacing"])
            u[p] !== void 0 && (a[p] ?? (a[p] = {}), a[p][l] = u[p]);
        }
      }
      return { facetMapping: o, layout: a };
    } else {
      const { align: o, center: a, spacing: l, columns: u, ...c } = s;
      return {
        facetMapping: _ue(c, n.repeater),
        layout: {
          ...o ? { align: o } : {},
          ...a ? { center: a } : {},
          ...l ? { spacing: l } : {},
          ...u ? { columns: u } : {}
        }
      };
    }
  }
  mapLayer(t, { parentEncoding: n, parentProjection: i, ...r }) {
    const { encoding: s, projection: o, ...a } = t, l = {
      ...r,
      parentEncoding: tM({ parentEncoding: n, encoding: s, layer: !0 }),
      parentProjection: nM({ parentProjection: i, projection: o })
    };
    return super.mapLayer({
      ...a,
      ...t.name ? { name: [l.repeaterPrefix, t.name].filter((u) => u).join("_") } : {}
    }, l);
  }
}
function tM({ parentEncoding: e, encoding: t = {}, layer: n }) {
  let i = {};
  if (e) {
    const r = /* @__PURE__ */ new Set([...q(e), ...q(t)]);
    for (const s of r) {
      const o = t[s], a = e[s];
      if (be(o)) {
        const l = {
          ...a,
          ...o
        };
        i[s] = l;
      } else
        Ld(o) ? i[s] = {
          ...o,
          condition: {
            ...a,
            ...o.condition
          }
        } : o || o === null ? i[s] = o : (n || er(a) || oe(a) || be(a) || j(a)) && (i[s] = a);
    }
  } else
    i = t;
  return !i || He(i) ? void 0 : i;
}
function nM(e) {
  const { parentProjection: t, projection: n } = e;
  return t && n && V(foe({ parentProjection: t, projection: n })), n ?? t;
}
function zE(e) {
  return "filter" in e;
}
function kue(e) {
  return (e == null ? void 0 : e.stop) !== void 0;
}
function qL(e) {
  return "lookup" in e;
}
function Aue(e) {
  return "data" in e;
}
function Cue(e) {
  return "param" in e;
}
function $ue(e) {
  return "pivot" in e;
}
function Mue(e) {
  return "density" in e;
}
function Fue(e) {
  return "quantile" in e;
}
function Tue(e) {
  return "regression" in e;
}
function Oue(e) {
  return "loess" in e;
}
function Nue(e) {
  return "sample" in e;
}
function Due(e) {
  return "window" in e;
}
function Rue(e) {
  return "joinaggregate" in e;
}
function Lue(e) {
  return "flatten" in e;
}
function Pue(e) {
  return "calculate" in e;
}
function WL(e) {
  return "bin" in e;
}
function Iue(e) {
  return "impute" in e;
}
function zue(e) {
  return "timeUnit" in e;
}
function Bue(e) {
  return "aggregate" in e;
}
function jue(e) {
  return "stack" in e;
}
function Uue(e) {
  return "fold" in e;
}
function que(e) {
  return "extent" in e && !("density" in e);
}
function Wue(e) {
  return e.map((t) => zE(t) ? {
    filter: Gl(t.filter, yae)
  } : t);
}
class Hue extends IE {
  map(t, n) {
    return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = iM(t, n), super.map(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (t = iM(t, n), t.encoding) {
      const i = {};
      for (const [r, s] of So(t.encoding))
        i[r] = HL(s, n);
      t = { ...t, encoding: i };
    }
    return super.mapLayerOrUnit(t, n);
  }
  mapUnit(t, n) {
    const { selection: i, ...r } = t;
    return i ? {
      ...r,
      params: So(i).map(([s, o]) => {
        const { init: a, bind: l, empty: u, ...c } = o;
        c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[s] = u !== "none";
        for (const f of qt(n.selectionPredicates[s] ?? {}))
          f.empty = u !== "none";
        return { name: s, value: a, select: c, bind: l };
      })
    } : t;
  }
}
function iM(e, t) {
  const { transform: n, ...i } = e;
  if (n) {
    const r = n.map((s) => {
      if (zE(s))
        return { filter: wv(s, t) };
      if (WL(s) && ul(s.bin))
        return {
          ...s,
          bin: GL(s.bin)
        };
      if (qL(s)) {
        const { selection: o, ...a } = s.from;
        return o ? {
          ...s,
          from: { param: o, ...a }
        } : s;
      }
      return s;
    });
    return { ...i, transform: r };
  }
  return e;
}
function HL(e, t) {
  var i, r;
  const n = me(e);
  if (G(n) && ul(n.bin) && (n.bin = GL(n.bin)), dl(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
    const { selection: s, ...o } = n.scale.domain;
    n.scale.domain = { ...o, ...s ? { param: s } : {} };
  }
  if (v0(n))
    if (j(n.condition))
      n.condition = n.condition.map((s) => {
        const { selection: o, param: a, test: l, ...u } = s;
        return a ? s : { ...u, test: wv(s, t) };
      });
    else {
      const { selection: s, param: o, test: a, ...l } = HL(n.condition, t);
      n.condition = o ? n.condition : {
        ...l,
        test: wv(n.condition, t)
      };
    }
  return n;
}
function GL(e) {
  const t = e.extent;
  if (t != null && t.selection) {
    const { selection: n, ...i } = t;
    return { ...e, extent: { ...i, param: n } };
  }
  return e;
}
function wv(e, t) {
  const n = (i) => Gl(i, (r) => {
    var s;
    const o = t.emptySelections[r] ?? !0, a = { param: r, empty: o };
    return (s = t.selectionPredicates)[r] ?? (s[r] = []), t.selectionPredicates[r].push(a), a;
  });
  return e.selection ? n(e.selection) : Gl(e.test || e.filter, (i) => i.selection ? n(i.selection) : i);
}
class _v extends IE {
  map(t, n) {
    const i = n.selections ?? [];
    if (t.params && !Ps(t)) {
      const r = [];
      for (const s of t.params)
        RE(s) ? i.push(s) : r.push(s);
      t.params = r;
    }
    return n.selections = i, super.map(t, n);
  }
  mapUnit(t, n) {
    const i = n.selections;
    if (!i || !i.length)
      return t;
    const r = (n.path ?? []).concat(t.name), s = [];
    for (const o of i)
      if (!o.views || !o.views.length)
        s.push(o);
      else
        for (const a of o.views)
          (Q(a) && (a === t.name || r.includes(a)) || j(a) && // logic for backwards compatibility with view paths before we had unique names
          // @ts-ignore
          a.map((l) => r.indexOf(l)).every((l, u, c) => l !== -1 && (u === 0 || l > c[u - 1]))) && s.push(o);
    return s.length && (t.params = s), t;
  }
}
for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const t = _v.prototype[e];
  _v.prototype[e] = function(n, i) {
    return t.call(this, n, Gue(n, i));
  };
}
function Gue(e, t) {
  return e.name ? {
    ...t,
    path: (t.path ?? []).concat(e.name)
  } : t;
}
function VL(e, t) {
  t === void 0 && (t = IL(e.config));
  const n = Kue(e, t), { width: i, height: r } = e, s = Jue(n, { width: i, height: r, autosize: e.autosize }, t);
  return {
    ...n,
    ...s ? { autosize: s } : {}
  };
}
const Vue = new Sue(), Yue = new Hue(), Xue = new _v();
function Kue(e, t = {}) {
  const n = { config: t };
  return Xue.map(Vue.map(Yue.map(e, n), n), n);
}
function rM(e) {
  return Q(e) ? { type: e } : e ?? {};
}
function Jue(e, t, n) {
  let { width: i, height: r } = t;
  const s = Ps(e) || A0(e), o = {};
  s ? i == "container" && r == "container" ? (o.type = "fit", o.contains = "padding") : i == "container" ? (o.type = "fit-x", o.contains = "padding") : r == "container" && (o.type = "fit-y", o.contains = "padding") : (i == "container" && (V(M$("width")), i = void 0), r == "container" && (V(M$("height")), r = void 0));
  const a = {
    type: "pad",
    ...o,
    ...n ? rM(n.autosize) : {},
    ...rM(e.autosize)
  };
  if (a.type === "fit" && !s && (V(Xse), a.type = "pad"), i == "container" && !(a.type == "fit" || a.type == "fit-x") && V(F$("width")), r == "container" && !(a.type == "fit" || a.type == "fit-y") && V(F$("height")), !Kn(a, { type: "pad" }))
    return a;
}
function Que(e) {
  return e === "fit" || e === "fit-x" || e === "fit-y";
}
function Zue(e) {
  return e ? `fit-${l0(e)}` : "fit";
}
const ece = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function sM(e, t) {
  const n = {};
  for (const i of ece)
    e && e[i] !== void 0 && (n[i] = Vn(e[i]));
  return t && (n.params = e.params), n;
}
class Is {
  constructor(t = {}, n = {}) {
    this.explicit = t, this.implicit = n;
  }
  clone() {
    return new Is(me(this.explicit), me(this.implicit));
  }
  combine() {
    return {
      ...this.explicit,
      ...this.implicit
    };
  }
  get(t) {
    return ct(this.explicit[t], this.implicit[t]);
  }
  getWithExplicit(t) {
    return this.explicit[t] !== void 0 ? { explicit: !0, value: this.explicit[t] } : this.implicit[t] !== void 0 ? { explicit: !1, value: this.implicit[t] } : { explicit: !1, value: void 0 };
  }
  setWithExplicit(t, { value: n, explicit: i }) {
    n !== void 0 && this.set(t, n, i);
  }
  set(t, n, i) {
    return delete this[i ? "implicit" : "explicit"][t], this[i ? "explicit" : "implicit"][t] = n, this;
  }
  copyKeyFromSplit(t, { explicit: n, implicit: i }) {
    n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1);
  }
  copyKeyFromObject(t, n) {
    n[t] !== void 0 && this.set(t, n[t], !0);
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(t) {
    for (const n of q(t.combine())) {
      const i = t.getWithExplicit(n);
      this.setWithExplicit(n, i);
    }
  }
}
function pr(e) {
  return {
    explicit: !0,
    value: e
  };
}
function Wn(e) {
  return {
    explicit: !1,
    value: e
  };
}
function YL(e) {
  return (t, n, i, r) => {
    const s = e(t.value, n.value);
    return s > 0 ? t : s < 0 ? n : C0(t, n, i, r);
  };
}
function C0(e, t, n, i) {
  return e.explicit && t.explicit && V(Doe(n, i, e.value, t.value)), e;
}
function Co(e, t, n, i, r = C0) {
  return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Kn(e.value, t.value) ? e : r(e, t, n, i);
}
class tce extends Is {
  constructor(t = {}, n = {}, i = !1) {
    super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i;
  }
  clone() {
    const t = super.clone();
    return t.parseNothing = this.parseNothing, t;
  }
}
function $u(e) {
  return "url" in e;
}
function Yf(e) {
  return "values" in e;
}
function XL(e) {
  return "name" in e && !$u(e) && !Yf(e) && !co(e);
}
function co(e) {
  return e && (KL(e) || JL(e) || BE(e));
}
function KL(e) {
  return "sequence" in e;
}
function JL(e) {
  return "sphere" in e;
}
function BE(e) {
  return "graticule" in e;
}
var Xe;
(function(e) {
  e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup";
})(Xe || (Xe = {}));
function QL(e) {
  const { signals: t, hasLegend: n, index: i, ...r } = e;
  return r.field = Ci(r.field), r;
}
function Va(e, t = !0, n = on) {
  if (j(e)) {
    const i = e.map((r) => Va(r, t, n));
    return t ? `[${i.join(", ")}]` : i;
  } else if (cl(e))
    return n(t ? qa(e) : sae(e));
  return t ? n(Ge(e)) : e;
}
function nce(e, t) {
  for (const n of qt(e.component.selection ?? {})) {
    const i = n.name;
    let r = `${i}${Mo}, ${n.resolve === "global" ? "true" : `{unit: ${Aa(e)}}`}`;
    for (const s of T0)
      s.defined(n) && (s.signals && (t = s.signals(e, n, t)), s.modifyExpr && (r = s.modifyExpr(e, n, r)));
    t.push({
      name: i + Dce,
      on: [
        {
          events: { signal: n.name + Mo },
          update: `modify(${X(n.name + Ya)}, ${r})`
        }
      ]
    });
  }
  return jE(t);
}
function ice(e, t) {
  if (e.component.selection && q(e.component.selection).length) {
    const n = X(e.getName("cell"));
    t.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: Po("pointermove", "scope"),
          update: `isTuple(facet) ? facet : group(${n}).datum`
        }
      ]
    });
  }
  return jE(t);
}
function rce(e, t) {
  let n = !1;
  for (const i of qt(e.component.selection ?? {})) {
    const r = i.name, s = X(r + Ya);
    if (t.filter((a) => a.name === r).length === 0) {
      const a = i.resolve === "global" ? "union" : i.resolve, l = i.type === "point" ? ", true, true)" : ")";
      t.push({
        name: i.name,
        update: `${m8}(${s}, ${X(a)}${l}`
      });
    }
    n = !0;
    for (const a of T0)
      a.defined(i) && a.topLevelSignals && (t = a.topLevelSignals(e, i, t));
  }
  return n && t.filter((r) => r.name === "unit").length === 0 && t.unshift({
    name: "unit",
    value: {},
    on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
  }), jE(t);
}
function sce(e, t) {
  const n = [...t], i = Aa(e, { escape: !1 });
  for (const r of qt(e.component.selection ?? {})) {
    const s = { name: r.name + Ya };
    if (r.project.hasSelectionId && (s.transform = [{ type: "collect", sort: { field: tr } }]), r.init) {
      const a = r.project.items.map(QL);
      s.values = r.project.hasSelectionId ? r.init.map((l) => ({ unit: i, [tr]: Va(l, !1)[0] })) : r.init.map((l) => ({ unit: i, fields: a, values: Va(l, !1) }));
    }
    n.filter((a) => a.name === r.name + Ya).length || n.push(s);
  }
  return n;
}
function ZL(e, t) {
  for (const n of qt(e.component.selection ?? {}))
    for (const i of T0)
      i.defined(n) && i.marks && (t = i.marks(e, n, t));
  return t;
}
function oce(e, t) {
  for (const n of e.children)
    ot(n) && (t = ZL(n, t));
  return t;
}
function ace(e, t, n, i) {
  const r = w8(e, t.param, t);
  return {
    signal: ai(n.get("type")) && j(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
  };
}
function jE(e) {
  return e.map((t) => (t.on && !t.on.length && delete t.on, t));
}
class We {
  constructor(t, n) {
    this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t);
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(t) {
    this._parent = t, t && t.addChild(this);
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(t, n) {
    if (this._children.includes(t)) {
      V(loe);
      return;
    }
    n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
  }
  removeChild(t) {
    const n = this._children.indexOf(t);
    return this._children.splice(n, 1), n;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let t = this._parent.removeChild(this);
    for (const n of this._children)
      n._parent = this._parent, this._parent.addChild(n, t++);
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(t) {
    const n = t.parent;
    n.removeChild(this), this.parent = n, t.parent = this;
  }
  swapWithParent() {
    const t = this._parent, n = t.parent;
    for (const r of this._children)
      r.parent = t;
    this._children = [], t.removeChild(this);
    const i = t.parent.removeChild(t);
    this._parent = n, n.addChild(this, i), t.parent = this;
  }
}
class xn extends We {
  clone() {
    const t = new this.constructor();
    return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
  }
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(t, n, i, r) {
    super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return this._hash === void 0 && (this._hash = `Output ${X6()}`), this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    return this.refCounts[this._name]++, this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(t) {
    this._source = t;
  }
}
function sy(e) {
  return e.as !== void 0;
}
function oM(e) {
  return `${e}_end`;
}
class kr extends We {
  clone() {
    return new kr(null, me(this.timeUnits));
  }
  constructor(t, n) {
    super(t), this.timeUnits = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, s, o) => {
      const { field: a, timeUnit: l } = s;
      if (l) {
        let u;
        if (fl(l)) {
          if (ot(n)) {
            const { mark: c, markDef: f, config: d } = n, h = Ao({ fieldDef: s, markDef: f, config: d });
            (Vf(c) || h) && (u = {
              timeUnit: Nt(l),
              field: a
            });
          }
        } else
          u = {
            as: K(s, { forAs: !0 }),
            field: a,
            timeUnit: l
          };
        if (ot(n)) {
          const { mark: c, markDef: f, config: d } = n, h = Ao({ fieldDef: s, markDef: f, config: d });
          Vf(c) && ft(o) && h !== 0.5 && (u.rectBandPosition = h);
        }
        u && (r[Me(u)] = u);
      }
      return r;
    }, {});
    return He(i) ? null : new kr(t, i);
  }
  static makeFromTransform(t, n) {
    const { timeUnit: i, ...r } = { ...n }, s = Nt(i), o = {
      ...r,
      timeUnit: s
    };
    return new kr(t, {
      [Me(o)]: o
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(t) {
    this.timeUnits = { ...this.timeUnits };
    for (const n in t.timeUnits)
      this.timeUnits[n] || (this.timeUnits[n] = t.timeUnits[n]);
    for (const n of t.children)
      t.removeChild(n), n.parent = this;
    t.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(t) {
    const n = {};
    for (const [i, r] of So(this.timeUnits)) {
      const s = sy(r) ? r.as : `${r.field}_end`;
      t.has(s) || (n[i] = r);
    }
    this.timeUnits = n;
  }
  producedFields() {
    return new Set(qt(this.timeUnits).map((t) => sy(t) ? t.as : oM(t.field)));
  }
  dependentFields() {
    return new Set(qt(this.timeUnits).map((t) => t.field));
  }
  hash() {
    return `TimeUnit ${Me(this.timeUnits)}`;
  }
  assemble() {
    const t = [];
    for (const n of qt(this.timeUnits)) {
      const { rectBandPosition: i } = n, r = Nt(n.timeUnit);
      if (sy(n)) {
        const { field: s, as: o } = n, { unit: a, utc: l, ...u } = r, c = [o, `${o}_end`];
        t.push({
          field: Ci(s),
          type: "timeunit",
          ...a ? { units: d0(a) } : {},
          ...l ? { timezone: "utc" } : {},
          ...u,
          as: c
        }), t.push(...aM(c, i, r));
      } else if (n) {
        const { field: s } = n, o = s.replaceAll("\\.", "."), a = e8({ timeUnit: r, field: o }), l = oM(o);
        t.push({
          type: "formula",
          expr: a,
          as: l
        }), t.push(...aM([o, l], i, r));
      }
    }
    return t;
  }
}
const $0 = "offsetted_rect_start", M0 = "offsetted_rect_end";
function e8({ timeUnit: e, field: t, reverse: n }) {
  const { unit: i, utc: r } = e, s = T4(i), { part: o, step: a } = R4(s, e.step);
  return `${r ? "utcOffset" : "timeOffset"}('${o}', datum['${t}'], ${n ? -a : a})`;
}
function aM([e, t], n, i) {
  if (n !== void 0 && n !== 0.5) {
    const r = `datum['${e}']`, s = `datum['${t}']`;
    return [
      {
        type: "formula",
        expr: lM([
          e8({
            timeUnit: i,
            field: e,
            reverse: !0
          }),
          r
        ], n + 0.5),
        as: `${e}_${$0}`
      },
      {
        type: "formula",
        expr: lM([r, s], n + 0.5),
        as: `${e}_${M0}`
      }
    ];
  }
  return [];
}
function lM([e, t], n) {
  return `${1 - n} * ${e} + ${n} * ${t}`;
}
const zd = "_tuple_fields";
class lce {
  constructor(...t) {
    this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
  }
}
const uce = {
  defined: () => !0,
  parse: (e, t, n) => {
    const i = t.name, r = t.project ?? (t.project = new lce()), s = {}, o = {}, a = /* @__PURE__ */ new Set(), l = (g, p) => {
      const m = p === "visual" ? g.channel : g.field;
      let y = et(`${i}_${m}`);
      for (let b = 1; a.has(y); b++)
        y = et(`${i}_${m}_${b}`);
      return a.add(y), { [p]: y };
    }, u = t.type, c = e.config.selection[u], f = n.value !== void 0 ? J(n.value) : null;
    let { fields: d, encodings: h } = ee(n.select) ? n.select : {};
    if (!d && !h && f) {
      for (const g of f)
        if (ee(g))
          for (const p of q(g))
            Sse(p) ? (h || (h = [])).push(p) : u === "interval" ? (V(roe), h = c.encodings) : (d ?? (d = [])).push(p);
    }
    !d && !h && (h = c.encodings, "fields" in c && (d = c.fields));
    for (const g of h ?? []) {
      const p = e.fieldDef(g);
      if (p) {
        let m = p.field;
        if (p.aggregate) {
          V(Kse(g, p.aggregate));
          continue;
        } else if (!m) {
          V(O$(g));
          continue;
        }
        if (p.timeUnit && !fl(p.timeUnit)) {
          m = e.vgField(g);
          const y = {
            timeUnit: p.timeUnit,
            as: m,
            field: p.field
          };
          o[Me(y)] = y;
        }
        if (!s[m]) {
          const y = u === "interval" && Ls(g) && ai(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E", b = { field: m, channel: g, type: y, index: r.items.length };
          b.signals = { ...l(b, "data"), ...l(b, "visual") }, r.items.push(s[m] = b), r.hasField[m] = s[m], r.hasSelectionId = r.hasSelectionId || m === tr, t4(g) ? (b.geoChannel = g, b.channel = e4(g), r.hasChannel[b.channel] = s[m]) : r.hasChannel[g] = s[m];
        }
      } else
        V(O$(g));
    }
    for (const g of d ?? []) {
      if (r.hasField[g])
        continue;
      const p = { type: "E", field: g, index: r.items.length };
      p.signals = { ...l(p, "data") }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === tr;
    }
    f && (t.init = f.map((g) => r.items.map((p) => ee(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), He(o) || (r.timeUnit = new kr(null, o));
  },
  signals: (e, t, n) => {
    const i = t.name + zd;
    return n.filter((s) => s.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
      name: i,
      value: t.project.items.map(QL)
    });
  }
}, bs = {
  defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
  parse: (e, t) => {
    const n = t.scales = [];
    for (const i of t.project.items) {
      const r = i.channel;
      if (!Ls(r))
        continue;
      const s = e.getScaleComponent(r), o = s ? s.get("type") : void 0;
      if (!s || !ai(o)) {
        V(Zse);
        continue;
      }
      s.set("selectionExtent", { param: t.name, field: i.field }, !0), n.push(i);
    }
  },
  topLevelSignals: (e, t, n) => {
    const i = t.scales.filter((o) => n.filter((a) => a.name === o.signals.data).length === 0);
    if (!e.parent || uM(e) || i.length === 0)
      return n;
    const r = n.filter((o) => o.name === t.name)[0];
    let s = r.update;
    if (s.indexOf(m8) >= 0)
      r.update = `{${i.map((o) => `${X(Ci(o.field))}: ${o.signals.data}`).join(", ")}}`;
    else {
      for (const o of i) {
        const a = `${X(Ci(o.field))}: ${o.signals.data}`;
        s.includes(a) || (s = `${s.substring(0, s.length - 1)}, ${a}}`);
      }
      r.update = s;
    }
    return n.concat(i.map((o) => ({ name: o.signals.data })));
  },
  signals: (e, t, n) => {
    if (e.parent && !uM(e))
      for (const i of t.scales) {
        const r = n.filter((s) => s.name === i.signals.data)[0];
        r.push = "outer", delete r.value, delete r.update;
      }
    return n;
  }
};
function Ev(e, t) {
  return `domain(${X(e.scaleName(t))})`;
}
function uM(e) {
  return e.parent && nc(e.parent) && !e.parent.parent;
}
const Xl = "_brush", t8 = "_scale_trigger", Sc = "geo_interval_init_tick", n8 = "_init", cce = "_center", fce = {
  defined: (e) => e.type === "interval",
  parse: (e, t, n) => {
    var i;
    if (e.hasProjection) {
      const r = { ...ee(n.select) ? n.select : {} };
      r.fields = [tr], r.encodings || (r.encodings = n.value ? q(n.value) : [lr, ar]), n.select = { type: "interval", ...r };
    }
    if (t.translate && !bs.defined(t)) {
      const r = `!event.item || event.item.mark.name !== ${X(t.name + Xl)}`;
      for (const s of t.events) {
        if (!s.between) {
          V(`${s} is not an ordered event stream for interval selections.`);
          continue;
        }
        const o = J((i = s.between[0]).filter ?? (i.filter = []));
        o.indexOf(r) < 0 && o.push(r);
      }
    }
  },
  signals: (e, t, n) => {
    const i = t.name, r = i + Mo, s = qt(t.project.hasChannel).filter((a) => a.channel === tt || a.channel === Lt), o = t.init ? t.init[0] : null;
    if (n.push(...s.reduce((a, l) => a.concat(dce(e, t, l, o && o[l.index])), [])), e.hasProjection) {
      const a = X(e.projectionName()), l = e.projectionName() + cce, { x: u, y: c } = t.project.hasChannel, f = u && u.signals.visual, d = c && c.signals.visual, h = u ? o && o[u.index] : `${l}[0]`, g = c ? o && o[c.index] : `${l}[1]`, p = (_) => e.getSizeSignalRef(_).signal, m = `[[${f ? f + "[0]" : "0"}, ${d ? d + "[0]" : "0"}],[${f ? f + "[1]" : p("width")}, ${d ? d + "[1]" : p("height")}]]`;
      o && (n.unshift({
        name: i + n8,
        init: `[scale(${a}, [${u ? h[0] : h}, ${c ? g[0] : g}]), scale(${a}, [${u ? h[1] : h}, ${c ? g[1] : g}])]`
      }), (!u || !c) && (n.find((S) => S.name === l) || n.unshift({
        name: l,
        update: `invert(${a}, [${p("width")}/2, ${p("height")}/2])`
      })));
      const y = `intersect(${m}, {markname: ${X(e.getName("marks"))}}, unit.mark)`, b = `{unit: ${Aa(e)}}`, v = `vlSelectionTuples(${y}, ${b})`, w = s.map((_) => _.signals.visual);
      return n.concat({
        name: r,
        on: [
          {
            events: [
              ...w.length ? [{ signal: w.join(" || ") }] : [],
              ...o ? [{ signal: Sc }] : []
            ],
            update: v
          }
        ]
      });
    } else {
      if (!bs.defined(t)) {
        const u = i + t8, c = s.map((f) => {
          const d = f.channel, { data: h, visual: g } = f.signals, p = X(e.scaleName(d)), m = e.getScaleComponent(d).get("type"), y = ai(m) ? "+" : "";
          return `(!isArray(${h}) || (${y}invert(${p}, ${g})[0] === ${y}${h}[0] && ${y}invert(${p}, ${g})[1] === ${y}${h}[1]))`;
        });
        c.length && n.push({
          name: u,
          value: {},
          on: [
            {
              events: s.map((f) => ({ scale: e.scaleName(f.channel) })),
              update: c.join(" && ") + ` ? ${u} : {}`
            }
          ]
        });
      }
      const a = s.map((u) => u.signals.data), l = `unit: ${Aa(e)}, fields: ${i + zd}, values`;
      return n.concat({
        name: r,
        ...o ? { init: `{${l}: ${Va(o)}}` } : {},
        ...a.length ? {
          on: [
            {
              events: [{ signal: a.join(" || ") }],
              update: `${a.join(" && ")} ? {${l}: [${a}]} : null`
            }
          ]
        } : {}
      });
    }
  },
  topLevelSignals: (e, t, n) => (ot(e) && e.hasProjection && t.init && (n.filter((r) => r.name === Sc).length || n.unshift({
    name: Sc,
    value: null,
    on: [
      {
        events: "timer{1}",
        update: `${Sc} === null ? {} : ${Sc}`
      }
    ]
  })), n),
  marks: (e, t, n) => {
    const i = t.name, { x: r, y: s } = t.project.hasChannel, o = r == null ? void 0 : r.signals.visual, a = s == null ? void 0 : s.signals.visual, l = `data(${X(t.name + Ya)})`;
    if (bs.defined(t) || !r && !s)
      return n;
    const u = {
      x: r !== void 0 ? { signal: `${o}[0]` } : { value: 0 },
      y: s !== void 0 ? { signal: `${a}[0]` } : { value: 0 },
      x2: r !== void 0 ? { signal: `${o}[1]` } : { field: { group: "width" } },
      y2: s !== void 0 ? { signal: `${a}[1]` } : { field: { group: "height" } }
    };
    if (t.resolve === "global")
      for (const p of q(u))
        u[p] = [
          {
            test: `${l}.length && ${l}[0].unit === ${Aa(e)}`,
            ...u[p]
          },
          { value: 0 }
        ];
    const { fill: c, fillOpacity: f, cursor: d, ...h } = t.mark, g = q(h).reduce((p, m) => (p[m] = [
      {
        test: [r !== void 0 && `${o}[0] !== ${o}[1]`, s !== void 0 && `${a}[0] !== ${a}[1]`].filter((y) => y).join(" && "),
        value: h[m]
      },
      { value: null }
    ], p), {});
    return [
      {
        name: `${i + Xl}_bg`,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            fill: { value: c },
            fillOpacity: { value: f }
          },
          update: u
        }
      },
      ...n,
      {
        name: i + Xl,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            ...d ? { cursor: { value: d } } : {},
            fill: { value: "transparent" }
          },
          update: { ...u, ...g }
        }
      }
    ];
  }
};
function dce(e, t, n, i) {
  const r = !e.hasProjection, s = n.channel, o = n.signals.visual, a = X(r ? e.scaleName(s) : e.projectionName()), l = (d) => `scale(${a}, ${d})`, u = e.getSizeSignalRef(s === tt ? "width" : "height").signal, c = `${s}(unit)`, f = t.events.reduce((d, h) => [
    ...d,
    { events: h.between[0], update: `[${c}, ${c}]` },
    { events: h, update: `[${o}[0], clamp(${c}, 0, ${u})]` }
    // Brush End
  ], []);
  if (r) {
    const d = n.signals.data, h = bs.defined(t), g = e.getScaleComponent(s), p = g ? g.get("type") : void 0, m = i ? { init: Va(i, !0, l) } : { value: [] };
    return f.push({
      events: { signal: t.name + t8 },
      update: ai(p) ? `[${l(`${d}[0]`)}, ${l(`${d}[1]`)}]` : "[0, 0]"
    }), h ? [{ name: d, on: [] }] : [
      { name: o, ...m, on: f },
      {
        name: d,
        ...i ? { init: Va(i) } : {},
        on: [
          {
            events: { signal: o },
            update: `${o}[0] === ${o}[1] ? null : invert(${a}, ${o})`
          }
        ]
      }
    ];
  } else {
    const d = s === tt ? 0 : 1, h = t.name + n8, g = i ? { init: `[${h}[0][${d}], ${h}[1][${d}]]` } : { value: [] };
    return [{ name: o, ...g, on: f }];
  }
}
const hce = {
  defined: (e) => e.type === "point",
  signals: (e, t, n) => {
    const i = t.name, r = i + zd, s = t.project, o = "(item().isVoronoi ? datum.datum : datum)", a = qt(e.component.selection ?? {}).reduce((f, d) => d.type === "interval" ? f.concat(d.name + Xl) : f, []).map((f) => `indexof(item().mark.name, '${f}') < 0`).join(" && "), l = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${a ? ` && ${a}` : ""}`;
    let u = `unit: ${Aa(e)}, `;
    if (t.project.hasSelectionId)
      u += `${tr}: ${o}[${X(tr)}]`;
    else {
      const f = s.items.map((d) => {
        const h = e.fieldDef(d.channel);
        return h != null && h.bin ? `[${o}[${X(e.vgField(d.channel, {}))}], ${o}[${X(e.vgField(d.channel, { binSuffix: "end" }))}]]` : `${o}[${X(d.field)}]`;
      }).join(", ");
      u += `fields: ${r}, values: [${f}]`;
    }
    const c = t.events;
    return n.concat([
      {
        name: i + Mo,
        on: c ? [
          {
            events: c,
            update: `${l} ? {${u}} : null`,
            force: !0
          }
        ] : []
      }
    ]);
  }
};
function Qu(e, t, n, i) {
  const r = v0(t) && t.condition, s = i(t);
  if (r) {
    const a = J(r).map((l) => {
      const u = i(l);
      if (ile(l)) {
        const { param: c, empty: f } = l;
        return { test: x8(e, { param: c, empty: f }), ...u };
      } else
        return { test: Np(e, l.test), ...u };
    });
    return {
      [n]: [...a, ...s !== void 0 ? [s] : []]
    };
  } else
    return s !== void 0 ? { [n]: s } : {};
}
function UE(e, t = "text") {
  const n = e.encoding[t];
  return Qu(e, n, t, (i) => F0(i, e.config));
}
function F0(e, t, n = "datum") {
  if (e) {
    if (er(e))
      return Qe(e.value);
    if (be(e)) {
      const { format: i, formatType: r } = Ap(e);
      return wE({ fieldOrDatumDef: e, format: i, formatType: r, expr: n, config: t });
    }
  }
}
function i8(e, t = {}) {
  const { encoding: n, markDef: i, config: r, stack: s } = e, o = n.tooltip;
  if (j(o))
    return { tooltip: cM({ tooltip: o }, s, r, t) };
  {
    const a = t.reactiveGeom ? "datum.datum" : "datum";
    return Qu(e, o, "tooltip", (l) => {
      const u = F0(l, r, a);
      if (u)
        return u;
      if (l === null)
        return;
      let c = Ue("tooltip", i, r);
      if (c === !0 && (c = { content: "encoding" }), Q(c))
        return { value: c };
      if (ee(c))
        return oe(c) ? c : c.content === "encoding" ? cM(n, s, r, t) : { signal: a };
    });
  }
}
function r8(e, t, n, { reactiveGeom: i } = {}) {
  const r = { ...n, ...n.tooltipFormat }, s = {}, o = i ? "datum.datum" : "datum", a = [];
  function l(c, f) {
    const d = ll(f), h = En(c) ? c : {
      ...c,
      type: e[d].type
      // for secondary field def, copy type from main channel
    }, g = h.title || kE(h, r), p = J(g).join(", ").replaceAll(/"/g, '\\"');
    let m;
    if (ft(f)) {
      const y = f === "x" ? "x2" : "y2", b = Rr(e[y]);
      if (zt(h.bin) && b) {
        const v = K(h, { expr: o }), w = K(b, { expr: o }), { format: _, formatType: S } = Ap(h);
        m = Dd(v, w, _, S, r), s[y] = !0;
      }
    }
    if ((ft(f) || f === Fi || f === or) && t && t.fieldChannel === f && t.offset === "normalize") {
      const { format: y, formatType: b } = Ap(h);
      m = wE({
        fieldOrDatumDef: h,
        format: y,
        formatType: b,
        expr: o,
        config: r,
        normalizeStack: !0
      }).signal;
    }
    m ?? (m = F0(h, r, o).signal), a.push({ channel: f, key: p, value: m });
  }
  $E(e, (c, f) => {
    G(c) ? l(c, f) : x0(c) && l(c.condition, f);
  });
  const u = {};
  for (const { channel: c, key: f, value: d } of a)
    !s[c] && !u[f] && (u[f] = d);
  return u;
}
function cM(e, t, n, { reactiveGeom: i } = {}) {
  const r = r8(e, t, n, { reactiveGeom: i }), s = So(r).map(([o, a]) => `"${o}": ${a}`);
  return s.length > 0 ? { signal: `{${s.join(", ")}}` } : void 0;
}
function gce(e) {
  const { markDef: t, config: n } = e, i = Ue("aria", t, n);
  return i === !1 ? {} : {
    ...i ? { aria: i } : {},
    ...pce(e),
    ...mce(e)
  };
}
function pce(e) {
  const { mark: t, markDef: n, config: i } = e;
  if (i.aria === !1)
    return {};
  const r = Ue("ariaRoleDescription", n, i);
  return r != null ? { ariaRoleDescription: { value: r } } : t in Gse ? {} : { ariaRoleDescription: { value: t } };
}
function mce(e) {
  const { encoding: t, markDef: n, config: i, stack: r } = e, s = t.description;
  if (s)
    return Qu(e, s, "description", (l) => F0(l, e.config));
  const o = Ue("description", n, i);
  if (o != null)
    return {
      description: Qe(o)
    };
  if (i.aria === !1)
    return {};
  const a = r8(t, r, i);
  if (!He(a))
    return {
      description: {
        signal: So(a).map(([l, u], c) => `"${c > 0 ? "; " : ""}${l}: " + (${u})`).join(" + ")
      }
    };
}
function Ct(e, t, n = {}) {
  const { markDef: i, encoding: r, config: s } = t, { vgChannel: o } = n;
  let { defaultRef: a, defaultValue: l } = n;
  a === void 0 && (l ?? (l = Ue(e, i, s, { vgChannel: o, ignoreVgConfig: !0 })), l !== void 0 && (a = Qe(l)));
  const u = r[e];
  return Qu(t, u, o ?? e, (c) => xE({
    channel: e,
    channelDef: c,
    markDef: i,
    config: s,
    scaleName: t.scaleName(e),
    scale: t.getScaleComponent(e),
    stack: null,
    defaultRef: a
  }));
}
function s8(e, t = { filled: void 0 }) {
  const { markDef: n, encoding: i, config: r } = e, { type: s } = n, o = t.filled ?? Ue("filled", n, r), a = Fe(["bar", "point", "circle", "square", "geoshape"], s) ? "transparent" : void 0, l = Ue(o === !0 ? "color" : void 0, n, r, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  r.mark[o === !0 && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
  // with transparent fills https://github.com/vega/vega-lite/issues/1316
  a, u = Ue(o === !1 ? "color" : void 0, n, r, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  r.mark[o === !1 && "color"], c = o ? "fill" : "stroke", f = {
    ...l ? { fill: Qe(l) } : {},
    ...u ? { stroke: Qe(u) } : {}
  };
  return n.color && (o ? n.fill : n.stroke) && V(_4("property", { fill: "fill" in n, stroke: "stroke" in n })), {
    ...f,
    ...Ct("color", e, {
      vgChannel: c,
      defaultValue: o ? l : u
    }),
    ...Ct("fill", e, {
      // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
      defaultValue: i.fill ? l : void 0
    }),
    ...Ct("stroke", e, {
      // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
      defaultValue: i.stroke ? u : void 0
    })
  };
}
function yce(e) {
  const { encoding: t, mark: n } = e, i = t.order;
  return !Ho(n) && er(i) ? Qu(e, i, "zindex", (r) => Qe(r.value)) : {};
}
function Mu({ channel: e, markDef: t, encoding: n = {}, model: i, bandPosition: r }) {
  const s = `${e}Offset`, o = t[s], a = n[s];
  if ((s === "xOffset" || s === "yOffset") && a)
    return { offsetType: "encoding", offset: xE({
      channel: s,
      channelDef: a,
      markDef: t,
      config: i == null ? void 0 : i.config,
      scaleName: i.scaleName(s),
      scale: i.getScaleComponent(s),
      stack: null,
      defaultRef: Qe(o),
      bandPosition: r
    }) };
  const l = t[s];
  return l ? { offsetType: "visual", offset: l } : {};
}
function Zt(e, t, { defaultPos: n, vgChannel: i }) {
  const { encoding: r, markDef: s, config: o, stack: a } = t, l = r[e], u = r[Gr(e)], c = t.scaleName(e), f = t.getScaleComponent(e), { offset: d, offsetType: h } = Mu({
    channel: e,
    markDef: s,
    encoding: r,
    model: t,
    bandPosition: 0.5
  }), g = qE({
    model: t,
    defaultPos: n,
    channel: e,
    scaleName: c,
    scale: f
  }), p = !l && ft(e) && (r.latitude || r.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: t.getName(e) }
  ) : bce({
    channel: e,
    channelDef: l,
    channel2Def: u,
    markDef: s,
    config: o,
    scaleName: c,
    scale: f,
    stack: a,
    offset: d,
    defaultRef: g,
    bandPosition: h === "encoding" ? 0 : void 0
  });
  return p ? { [i || e]: p } : void 0;
}
function bce(e) {
  const { channel: t, channelDef: n, scaleName: i, stack: r, offset: s, markDef: o } = e;
  if (be(n) && r && t === r.fieldChannel) {
    if (G(n)) {
      let a = n.bandPosition;
      if (a === void 0 && o.type === "text" && (t === "radius" || t === "theta") && (a = 0.5), a !== void 0)
        return Ep({
          scaleName: i,
          fieldOrDatumDef: n,
          startSuffix: "start",
          bandPosition: a,
          offset: s
        });
    }
    return Sa(n, i, { suffix: "end" }, { offset: s });
  }
  return bE(e);
}
function qE({ model: e, defaultPos: t, channel: n, scaleName: i, scale: r }) {
  const { markDef: s, config: o } = e;
  return () => {
    const a = ll(n), l = ko(n), u = Ue(n, s, o, { vgChannel: l });
    if (u !== void 0)
      return gf(n, u);
    switch (t) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (i) {
          const c = r.get("type");
          if (!Fe([Dn.LOG, Dn.TIME, Dn.UTC], c)) {
            if (r.domainDefinitelyIncludesZero())
              return {
                scale: i,
                value: 0
              };
          }
        }
        if (t === "zeroOrMin")
          return a === "y" ? { field: { group: "height" } } : { value: 0 };
        switch (a) {
          case "radius":
            return {
              signal: `min(${e.width.signal},${e.height.signal})/2`
            };
          case "theta":
            return { signal: "2*PI" };
          case "x":
            return { field: { group: "width" } };
          case "y":
            return { value: 0 };
        }
        break;
      case "mid":
        return { ...e[jn(n)], mult: 0.5 };
    }
  };
}
const vce = {
  left: "x",
  center: "xc",
  right: "x2"
}, xce = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function o8(e, t, n, i = "middle") {
  if (e === "radius" || e === "theta")
    return ko(e);
  const r = e === "x" ? "align" : "baseline", s = Ue(r, t, n);
  let o;
  return oe(s) ? (V(Eoe(r)), o = void 0) : o = s, e === "x" ? vce[o || (i === "top" ? "left" : "center")] : xce[o || i];
}
function Tp(e, t, { defaultPos: n, defaultPos2: i, range: r }) {
  return r ? a8(e, t, { defaultPos: n, defaultPos2: i }) : Zt(e, t, { defaultPos: n });
}
function a8(e, t, { defaultPos: n, defaultPos2: i }) {
  const { markDef: r, config: s } = t, o = Gr(e), a = jn(e), l = wce(t, i, o), u = l[a] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    o8(e, r, s)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    ko(e)
  );
  return {
    ...Zt(e, t, { defaultPos: n, vgChannel: u }),
    ...l
  };
}
function wce(e, t, n) {
  const { encoding: i, mark: r, markDef: s, stack: o, config: a } = e, l = ll(n), u = jn(n), c = ko(n), f = i[l], d = e.scaleName(l), h = e.getScaleComponent(l), { offset: g } = n in i || n in s ? Mu({ channel: n, markDef: s, encoding: i, model: e }) : Mu({ channel: l, markDef: s, encoding: i, model: e });
  if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
    const m = jn(n), y = e.markDef[m];
    return y != null ? {
      [m]: { value: y }
    } : {
      [c]: { field: e.getName(n) }
    };
  }
  const p = _ce({
    channel: n,
    channelDef: f,
    channel2Def: i[n],
    markDef: s,
    config: a,
    scaleName: d,
    scale: h,
    stack: o,
    offset: g,
    defaultRef: void 0
  });
  return p !== void 0 ? { [c]: p } : vh(n, s) || vh(n, {
    [n]: xp(n, s, a.style),
    [u]: xp(u, s, a.style)
  }) || vh(n, a[r]) || vh(n, a.mark) || {
    [c]: qE({
      model: e,
      defaultPos: t,
      channel: n,
      scaleName: d,
      scale: h
    })()
  };
}
function _ce({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: s, scale: o, stack: a, offset: l, defaultRef: u }) {
  return be(t) && a && // If fieldChannel is X and channel is X2 (or Y and Y2)
  e.charAt(0) === a.fieldChannel.charAt(0) ? Sa(t, s, { suffix: "start" }, { offset: l }) : bE({
    channel: e,
    channelDef: n,
    scaleName: s,
    scale: o,
    stack: a,
    markDef: i,
    config: r,
    offset: l,
    defaultRef: u
  });
}
function vh(e, t) {
  const n = jn(e), i = ko(e);
  if (t[i] !== void 0)
    return { [i]: gf(e, t[i]) };
  if (t[e] !== void 0)
    return { [i]: gf(e, t[e]) };
  if (t[n]) {
    const r = t[n];
    if (Ha(r))
      V(yoe(n));
    else
      return { [n]: gf(e, r) };
  }
}
function $o(e, t) {
  const { config: n, encoding: i, markDef: r } = e, s = r.type, o = Gr(t), a = jn(t), l = i[t], u = i[o], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, d = r.orient, h = i[a] ?? i.size ?? Ue("size", r, n, { vgChannel: a }), g = s4(t), p = s === "bar" && (t === "x" ? d === "vertical" : d === "horizontal");
  return G(l) && (Ke(l.bin) || zt(l.bin) || l.timeUnit && !u) && !(h && !Ha(h)) && !i[g] && !Dt(f) ? kce({
    fieldDef: l,
    fieldDef2: u,
    channel: t,
    model: e
  }) : (be(l) && Dt(f) || p) && !u ? Sce(l, t, e) : a8(t, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
}
function Ece(e, t, n, i, r, s, o) {
  if (Ha(r))
    if (n) {
      const l = n.get("type");
      if (l === "band") {
        let u = `bandwidth('${t}')`;
        r.band !== 1 && (u = `${r.band} * ${u}`);
        const c = ks("minBandSize", { type: o }, i);
        return { signal: c ? `max(${Hi(c)}, ${u})` : u };
      } else
        r.band !== 1 && (V(Coe(l)), r = void 0);
    } else
      return {
        mult: r.band,
        field: { group: e }
      };
  else {
    if (oe(r))
      return r;
    if (r)
      return { value: r };
  }
  if (n) {
    const l = n.get("range");
    if (Wo(l) && Re(l.step))
      return { value: l.step - 2 };
  }
  if (!s) {
    const { bandPaddingInner: l, barBandPaddingInner: u, rectBandPaddingInner: c } = i.scale, f = ct(l, o === "bar" ? u : c);
    if (oe(f))
      return { signal: `(1 - (${f.signal})) * ${e}` };
    if (Re(f))
      return { signal: `${1 - f} * ${e}` };
  }
  return { value: Mp(i.view, e) - 2 };
}
function Sce(e, t, n) {
  var $, N;
  const { markDef: i, encoding: r, config: s, stack: o } = n, a = i.orient, l = n.scaleName(t), u = n.getScaleComponent(t), c = jn(t), f = Gr(t), d = s4(t), h = n.scaleName(d), g = n.getScaleComponent(X_(t)), p = a === "horizontal" && t === "y" || a === "vertical" && t === "x";
  let m;
  (r.size || i.size) && (p ? m = Ct("size", n, {
    vgChannel: c,
    defaultRef: Qe(i.size)
  }) : V(Toe(i.type)));
  const y = !!m, b = iL({
    channel: t,
    fieldDef: e,
    markDef: i,
    config: s,
    scaleType: ($ = u || g) == null ? void 0 : $.get("type"),
    useVlSizeChannel: p
  });
  m = m || {
    [c]: Ece(c, h || l, g || u, s, b, !!e, i.type)
  };
  const v = ((N = u || g) == null ? void 0 : N.get("type")) === "band" && Ha(b) && !y ? "top" : "middle", w = o8(t, i, s, v), _ = w === "xc" || w === "yc", { offset: S, offsetType: E } = Mu({ channel: t, markDef: i, encoding: r, model: n, bandPosition: _ ? 0.5 : 0 }), C = bE({
    channel: t,
    channelDef: e,
    markDef: i,
    config: s,
    scaleName: l,
    scale: u,
    stack: o,
    offset: S,
    defaultRef: qE({ model: n, defaultPos: "mid", channel: t, scaleName: l, scale: u }),
    bandPosition: _ ? E === "encoding" ? 0 : 0.5 : oe(b) ? { signal: `(1-${b})/2` } : Ha(b) ? (1 - b.band) / 2 : 0
  });
  if (c)
    return { [w]: C, ...m };
  {
    const T = ko(f), L = m[c], O = S ? { ...L, offset: S } : L;
    return {
      [w]: C,
      // posRef might be an array that wraps position invalid test
      [T]: j(C) ? [C[0], { ...C[1], offset: O }] : {
        ...C,
        offset: O
      }
    };
  }
}
function fM(e, t, n, i, r, s, o) {
  if (Z6(e))
    return 0;
  const a = e === "x" || e === "y2", l = a ? -t / 2 : t / 2;
  if (oe(n) || oe(r) || oe(i) || s) {
    const u = Hi(n), c = Hi(r), f = Hi(i), d = Hi(s), g = s ? `(${o} < ${d} ? ${a ? "" : "-"}0.5 * (${d} - (${o})) : ${l})` : l, p = f ? `${f} + ` : "", m = u ? `(${u} ? -1 : 1) * ` : "", y = c ? `(${c} + ${g})` : g;
    return {
      signal: p + m + y
    };
  } else
    return r = r || 0, i + (n ? -r - l : +r + l);
}
function kce({ fieldDef: e, fieldDef2: t, channel: n, model: i }) {
  var N;
  const { config: r, markDef: s, encoding: o } = i, a = i.getScaleComponent(n), l = i.scaleName(n), u = a ? a.get("type") : void 0, c = a.get("reverse"), f = iL({ channel: n, fieldDef: e, markDef: s, config: r, scaleType: u }), d = (N = i.component.axes[n]) == null ? void 0 : N[0], h = (d == null ? void 0 : d.get("translate")) ?? 0.5, g = ft(n) ? Ue("binSpacing", s, r) ?? 0 : 0, p = Gr(n), m = ko(n), y = ko(p), b = ks("minBandSize", s, r), { offset: v } = Mu({ channel: n, markDef: s, encoding: o, model: i, bandPosition: 0 }), { offset: w } = Mu({ channel: p, markDef: s, encoding: o, model: i, bandPosition: 0 }), _ = Qae({ fieldDef: e, scaleName: l }), S = fM(n, g, c, h, v, b, _), E = fM(p, g, c, h, w ?? v, b, _), C = oe(f) ? { signal: `(1-${f.signal})/2` } : Ha(f) ? (1 - f.band) / 2 : 0.5, $ = Ao({ fieldDef: e, fieldDef2: t, markDef: s, config: r });
  if (Ke(e.bin) || e.timeUnit) {
    const T = e.timeUnit && $ !== 0.5;
    return {
      [y]: dM({
        fieldDef: e,
        scaleName: l,
        bandPosition: C,
        offset: E,
        useRectOffsetField: T
      }),
      [m]: dM({
        fieldDef: e,
        scaleName: l,
        bandPosition: oe(C) ? { signal: `1-${C.signal}` } : 1 - C,
        offset: S,
        useRectOffsetField: T
      })
    };
  } else if (zt(e.bin)) {
    const T = Sa(e, l, {}, { offset: E });
    if (G(t))
      return {
        [y]: T,
        [m]: Sa(t, l, {}, { offset: S })
      };
    if (ul(e.bin) && e.bin.step)
      return {
        [y]: T,
        [m]: {
          signal: `scale("${l}", ${K(e, { expr: "datum" })} + ${e.bin.step})`,
          offset: S
        }
      };
  }
  V(k4(p));
}
function dM({ fieldDef: e, scaleName: t, bandPosition: n, offset: i, useRectOffsetField: r }) {
  return Ep({
    scaleName: t,
    fieldOrDatumDef: e,
    bandPosition: n,
    offset: i,
    ...r ? {
      startSuffix: $0,
      endSuffix: M0
    } : {}
  });
}
const Ace = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function Ti(e, t) {
  const { fill: n = void 0, stroke: i = void 0 } = t.color === "include" ? s8(e) : {};
  return {
    ...Cce(e.markDef, t),
    ...hM(e, "fill", n),
    ...hM(e, "stroke", i),
    ...Ct("opacity", e),
    ...Ct("fillOpacity", e),
    ...Ct("strokeOpacity", e),
    ...Ct("strokeWidth", e),
    ...Ct("strokeDash", e),
    ...yce(e),
    ...i8(e),
    ...UE(e, "href"),
    ...gce(e)
  };
}
function hM(e, t, n) {
  const { config: i, mark: r, markDef: s } = e;
  if (Ue("invalid", s, i) === "hide" && n && !Ho(r)) {
    const a = $ce(e, { invalid: !0, channels: u0 });
    if (a)
      return {
        [t]: [
          // prepend the invalid case
          // TODO: support custom value
          { test: a, value: null },
          ...J(n)
        ]
      };
  }
  return n ? { [t]: n } : {};
}
function Cce(e, t) {
  return Hse.reduce((n, i) => (!Ace.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = Qe(e[i])), n), {});
}
function $ce(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((s, o) => {
    const a = e.getScaleComponent(o);
    if (a) {
      const l = a.get("type"), u = e.vgField(o, { expr: "datum" });
      u && ai(l) && (s[u] = !0);
    }
    return s;
  }, {}), r = q(i);
  if (r.length > 0) {
    const s = t ? "||" : "&&";
    return r.map((o) => vE(o, t)).join(` ${s} `);
  }
}
function WE(e) {
  const { config: t, markDef: n } = e;
  if (Ue("invalid", n, t)) {
    const r = Mce(e, { channels: Vr });
    if (r)
      return { defined: { signal: r } };
  }
  return {};
}
function Mce(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((s, o) => {
    var l;
    const a = e.getScaleComponent(o);
    if (a) {
      const u = a.get("type"), c = e.vgField(o, { expr: "datum", binSuffix: (l = e.stack) != null && l.impute ? "mid" : void 0 });
      c && ai(u) && (s[c] = !0);
    }
    return s;
  }, {}), r = q(i);
  if (r.length > 0) {
    const s = t ? "||" : "&&";
    return r.map((o) => vE(o, t)).join(` ${s} `);
  }
}
function gM(e, t) {
  if (t !== void 0)
    return { [e]: Qe(t) };
}
const oy = "voronoi", l8 = {
  defined: (e) => e.type === "point" && e.nearest,
  parse: (e, t) => {
    if (t.events)
      for (const n of t.events)
        n.markname = e.getName(oy);
  },
  marks: (e, t, n) => {
    const { x: i, y: r } = t.project.hasChannel, s = e.mark;
    if (Ho(s))
      return V(Jse(s)), n;
    const o = {
      name: e.getName(oy),
      type: "path",
      interactive: !0,
      from: { data: e.getName("marks") },
      encode: {
        update: {
          fill: { value: "transparent" },
          strokeWidth: { value: 0.35 },
          stroke: { value: "transparent" },
          isVoronoi: { value: !0 },
          ...i8(e, { reactiveGeom: !0 })
        }
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: i || !r ? "datum.datum.x || 0" : "0" },
          y: { expr: r || !i ? "datum.datum.y || 0" : "0" },
          size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
        }
      ]
    };
    let a = 0, l = !1;
    return n.forEach((u, c) => {
      const f = u.name ?? "";
      f === e.component.mark[0].name ? a = c : f.indexOf(oy) >= 0 && (l = !0);
    }), l || n.splice(a + 1, 0, o), n;
  }
}, u8 = {
  defined: (e) => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !DE(e.bind),
  parse: (e, t, n) => y8(t, n),
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = t.project, s = t.bind, o = t.init && t.init[0], a = l8.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    return r.items.forEach((l, u) => {
      const c = et(`${i}_${l.field}`);
      n.filter((d) => d.name === c).length || n.unshift({
        name: c,
        ...o ? { init: Va(o[u]) } : { value: null },
        on: t.events ? [
          {
            events: t.events,
            update: `datum && item().mark.marktype !== 'group' ? ${a}[${X(l.field)}] : null`
          }
        ] : [],
        bind: s[l.field] ?? s[l.channel] ?? s
      });
    }), n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, s = n.filter((u) => u.name === i + Mo)[0], o = i + zd, a = r.items.map((u) => et(`${i}_${u.field}`)), l = a.map((u) => `${u} !== null`).join(" && ");
    return a.length && (s.update = `${l} ? {fields: ${o}, values: [${a.join(", ")}]} : null`), delete s.value, delete s.on, n;
  }
}, Op = "_toggle", c8 = {
  defined: (e) => e.type === "point" && !!e.toggle,
  signals: (e, t, n) => n.concat({
    name: t.name + Op,
    value: !1,
    on: [{ events: t.events, update: t.toggle }]
  }),
  modifyExpr: (e, t) => {
    const n = t.name + Mo, i = t.name + Op;
    return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${Aa(e)}}, `) + `${i} ? ${n} : null`;
  }
}, Fce = {
  defined: (e) => e.clear !== void 0 && e.clear !== !1,
  parse: (e, t) => {
    t.clear && (t.clear = Q(t.clear) ? Po(t.clear, "view") : t.clear);
  },
  topLevelSignals: (e, t, n) => {
    if (u8.defined(t))
      for (const i of t.project.items) {
        const r = n.findIndex((s) => s.name === et(`${t.name}_${i.field}`));
        r !== -1 && n[r].on.push({ events: t.clear, update: "null" });
      }
    return n;
  },
  signals: (e, t, n) => {
    function i(r, s) {
      r !== -1 && n[r].on && n[r].on.push({ events: t.clear, update: s });
    }
    if (t.type === "interval")
      for (const r of t.project.items) {
        const s = n.findIndex((o) => o.name === r.signals.visual);
        if (i(s, "[0, 0]"), s === -1) {
          const o = n.findIndex((a) => a.name === r.signals.data);
          i(o, "null");
        }
      }
    else {
      let r = n.findIndex((s) => s.name === t.name + Mo);
      i(r, "null"), c8.defined(t) && (r = n.findIndex((s) => s.name === t.name + Op), i(r, "false"));
    }
    return n;
  }
}, f8 = {
  defined: (e) => {
    const t = e.resolve === "global" && e.bind && DE(e.bind), n = e.project.items.length === 1 && e.project.items[0].field !== tr;
    return t && !n && V(eoe), t && n;
  },
  parse: (e, t, n) => {
    const i = me(n);
    if (i.select = Q(i.select) ? { type: i.select, toggle: t.toggle } : { ...i.select, toggle: t.toggle }, y8(t, i), ee(n.select) && (n.select.on || n.select.clear)) {
      const o = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const a of t.events)
        a.filter = J(a.filter ?? []), a.filter.includes(o) || a.filter.push(o);
    }
    const r = ny(t.bind) ? t.bind.legend : "click", s = Q(r) ? Po(r, "view") : J(r);
    t.bind = { legend: { merge: s } };
  },
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = ny(t.bind) && t.bind.legend, s = (o) => (a) => {
      const l = me(a);
      return l.markname = o, l;
    };
    for (const o of t.project.items) {
      if (!o.hasLegend)
        continue;
      const a = `${et(o.field)}_legend`, l = `${i}_${a}`;
      if (n.filter((c) => c.name === l).length === 0) {
        const c = r.merge.map(s(`${a}_symbols`)).concat(r.merge.map(s(`${a}_labels`))).concat(r.merge.map(s(`${a}_entries`)));
        n.unshift({
          name: l,
          ...t.init ? {} : { value: null },
          on: [
            // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
            {
              events: c,
              update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
              force: !0
            },
            { events: r.merge, update: `!event.item || !datum ? null : ${l}`, force: !0 }
          ]
        });
      }
    }
    return n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, s = n.find((d) => d.name === i + Mo), o = i + zd, a = r.items.filter((d) => d.hasLegend).map((d) => et(`${i}_${et(d.field)}_legend`)), u = `${a.map((d) => `${d} !== null`).join(" && ")} ? {fields: ${o}, values: [${a.join(", ")}]} : null`;
    t.events && a.length > 0 ? s.on.push({
      events: a.map((d) => ({ signal: d })),
      update: u
    }) : a.length > 0 && (s.update = u, delete s.value, delete s.on);
    const c = n.find((d) => d.name === i + Op), f = ny(t.bind) && t.bind.legend;
    return c && (t.events ? c.on.push({ ...c.on[0], events: f }) : c.on[0].events = f), n;
  }
};
function Tce(e, t, n) {
  var r;
  const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
  for (const s of qt(e.component.selection ?? {})) {
    const o = s.project.hasField[i] ?? s.project.hasChannel[t];
    if (o && f8.defined(s)) {
      const a = n.get("selections") ?? [];
      a.push(s.name), n.set("selections", a, !1), o.hasLegend = !0;
    }
  }
}
const d8 = "_translate_anchor", h8 = "_translate_delta", Oce = {
  defined: (e) => e.type === "interval" && e.translate,
  signals: (e, t, n) => {
    const i = t.name, r = bs.defined(t), s = i + d8, { x: o, y: a } = t.project.hasChannel;
    let l = Po(t.translate, "scope");
    return r || (l = l.map((u) => (u.between[0].markname = i + Xl, u))), n.push({
      name: s,
      value: {},
      on: [
        {
          events: l.map((u) => u.between[0]),
          update: "{x: x(unit), y: y(unit)" + (o !== void 0 ? `, extent_x: ${r ? Ev(e, tt) : `slice(${o.signals.visual})`}` : "") + (a !== void 0 ? `, extent_y: ${r ? Ev(e, Lt) : `slice(${a.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: i + h8,
      value: {},
      on: [
        {
          events: l,
          update: `{x: ${s}.x - x(unit), y: ${s}.y - y(unit)}`
        }
      ]
    }), o !== void 0 && pM(e, t, o, "width", n), a !== void 0 && pM(e, t, a, "height", n), n;
  }
};
function pM(e, t, n, i, r) {
  const s = t.name, o = s + d8, a = s + h8, l = n.channel, u = bs.defined(t), c = r.filter((_) => _.name === n.signals[u ? "data" : "visual"])[0], f = e.getSizeSignalRef(i).signal, d = e.getScaleComponent(l), h = d && d.get("type"), g = d && d.get("reverse"), p = u ? l === tt ? g ? "" : "-" : g ? "-" : "" : "", m = `${o}.extent_${l}`, y = `${p}${a}.${l} / ${u ? `${f}` : `span(${m})`}`, b = !u || !d ? "panLinear" : h === "log" ? "panLog" : h === "symlog" ? "panSymlog" : h === "pow" ? "panPow" : "panLinear", v = u ? h === "pow" ? `, ${d.get("exponent") ?? 1}` : h === "symlog" ? `, ${d.get("constant") ?? 1}` : "" : "", w = `${b}(${m}, ${y}${v})`;
  c.on.push({
    events: { signal: a },
    update: u ? w : `clampRange(${w}, 0, ${f})`
  });
}
const g8 = "_zoom_anchor", p8 = "_zoom_delta", Nce = {
  defined: (e) => e.type === "interval" && e.zoom,
  signals: (e, t, n) => {
    const i = t.name, r = bs.defined(t), s = i + p8, { x: o, y: a } = t.project.hasChannel, l = X(e.scaleName(tt)), u = X(e.scaleName(Lt));
    let c = Po(t.zoom, "scope");
    return r || (c = c.map((f) => (f.markname = i + Xl, f))), n.push({
      name: i + g8,
      on: [
        {
          events: c,
          update: r ? "{" + [l ? `x: invert(${l}, x(unit))` : "", u ? `y: invert(${u}, y(unit))` : ""].filter((f) => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
        }
      ]
    }, {
      name: s,
      on: [
        {
          events: c,
          force: !0,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    }), o !== void 0 && mM(e, t, o, "width", n), a !== void 0 && mM(e, t, a, "height", n), n;
  }
};
function mM(e, t, n, i, r) {
  const s = t.name, o = n.channel, a = bs.defined(t), l = r.filter((b) => b.name === n.signals[a ? "data" : "visual"])[0], u = e.getSizeSignalRef(i).signal, c = e.getScaleComponent(o), f = c && c.get("type"), d = a ? Ev(e, o) : l.name, h = s + p8, g = `${s}${g8}.${o}`, p = !a || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear", m = a ? f === "pow" ? `, ${c.get("exponent") ?? 1}` : f === "symlog" ? `, ${c.get("constant") ?? 1}` : "" : "", y = `${p}(${d}, ${g}, ${h}${m})`;
  l.on.push({
    events: { signal: h },
    update: a ? y : `clampRange(${y}, 0, ${u})`
  });
}
const Ya = "_store", Mo = "_tuple", Dce = "_modify", m8 = "vlSelectionResolve", T0 = [
  hce,
  fce,
  uce,
  c8,
  // Bindings may disable direct manipulation.
  u8,
  bs,
  f8,
  Fce,
  Oce,
  Nce,
  l8
];
function Rce(e) {
  let t = e.parent;
  for (; t && !Ki(t); )
    t = t.parent;
  return t;
}
function Aa(e, { escape: t } = { escape: !0 }) {
  let n = t ? X(e.name) : e.name;
  const i = Rce(e);
  if (i) {
    const { facet: r } = i;
    for (const s of mi)
      r[s] && (n += ` + '__facet_${s}_' + (facet[${X(i.vgField(s))}])`);
  }
  return n;
}
function HE(e) {
  return qt(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
}
function y8(e, t) {
  (Q(t.select) || !t.select.on) && delete e.events, (Q(t.select) || !t.select.clear) && delete e.clear, (Q(t.select) || !t.select.toggle) && delete e.toggle;
}
function Sv(e) {
  const t = [];
  return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...Sv(e.object)), t.push(...Sv(e.property))), t);
}
function b8(e) {
  return e.object.type === "MemberExpression" ? b8(e.object) : e.object.name === "datum";
}
function v8(e) {
  const t = c_(e), n = /* @__PURE__ */ new Set();
  return t.visit((i) => {
    i.type === "MemberExpression" && b8(i) && n.add(Sv(i).slice(1).join("."));
  }), n;
}
class Zu extends We {
  clone() {
    return new Zu(null, this.model, me(this.filter));
  }
  constructor(t, n, i) {
    super(t), this.model = n, this.filter = i, this.expr = Np(this.model, this.filter, this), this._dependentFields = v8(this.expr);
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function Lce(e, t) {
  const n = {}, i = e.config.selection;
  if (!t || !t.length)
    return n;
  for (const r of t) {
    const s = et(r.name), o = r.select, a = Q(o) ? o : o.type, l = ee(o) ? me(o) : { type: a }, u = i[a];
    for (const d in u)
      d === "fields" || d === "encodings" || (d === "mark" && (l[d] = { ...u[d], ...l[d] }), (l[d] === void 0 || l[d] === !0) && (l[d] = me(u[d] ?? l[d])));
    const c = n[s] = {
      ...l,
      name: s,
      type: a,
      init: r.value,
      bind: r.bind,
      events: Q(l.on) ? Po(l.on, "scope") : J(me(l.on))
    }, f = me(r);
    for (const d of T0)
      d.defined(c) && d.parse && d.parse(e, c, f);
  }
  return n;
}
function x8(e, t, n, i = "datum") {
  const r = Q(t) ? t : t.param, s = et(r), o = X(s + Ya);
  let a;
  try {
    a = e.getSelectionComponent(s, r);
  } catch {
    return `!!${s}`;
  }
  if (a.project.timeUnit) {
    const d = n ?? e.component.data.raw, h = a.project.timeUnit.clone();
    d.parent ? h.insertAsParentOf(d) : d.parent = h;
  }
  const l = a.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(", u = a.resolve === "global" ? ")" : `, ${X(a.resolve)})`, c = `${l}${o}, ${i}${u}`, f = `length(data(${o}))`;
  return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`;
}
function w8(e, t, n) {
  const i = et(t), r = n.encoding;
  let s = n.field, o;
  try {
    o = e.getSelectionComponent(i, t);
  } catch {
    return i;
  }
  if (!r && !s)
    s = o.project.items[0].field, o.project.items.length > 1 && V(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${X(s)}.`);
  else if (r && !s) {
    const a = o.project.items.filter((l) => l.channel === r);
    !a.length || a.length > 1 ? (s = o.project.items[0].field, V((a.length ? "Multiple " : "No ") + `matching ${X(r)} encoding found for selection ${X(n.param)}. Using "field": ${X(s)}.`)) : s = a[0].field;
  }
  return `${o.name}[${X(Ci(s))}]`;
}
function Pce(e, t) {
  for (const [n, i] of So(e.component.selection ?? {})) {
    const r = e.getName(`lookup_${n}`);
    e.component.data.outputNodes[r] = i.materialized = new xn(new Zu(t, e, { param: n }), r, Xe.Lookup, e.component.data.outputNodeRefCounts);
  }
}
function Np(e, t, n) {
  return hf(t, (i) => Q(i) ? i : gae(i) ? x8(e, i, n) : P4(i));
}
function Ice(e, t) {
  if (e)
    return j(e) && !Ys(e) ? e.map((n) => kE(n, t)).join(", ") : e;
}
function ay(e, t, n, i) {
  var r, s;
  e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i;
}
function Jc(e, t, n, i = { header: !1 }) {
  var f, d;
  const { disable: r, orient: s, scale: o, labelExpr: a, title: l, zindex: u, ...c } = e.combine();
  if (!r) {
    for (const h in c) {
      const g = yle[h], p = c[h];
      if (g && g !== t && g !== "both")
        delete c[h];
      else if (Id(p)) {
        const { condition: m, ...y } = p, b = J(m), v = W$[h];
        if (v) {
          const { vgProp: w, part: _ } = v, S = [
            ...b.map((E) => {
              const { test: C, ...$ } = E;
              return {
                test: Np(null, C),
                ...$
              };
            }),
            y
          ];
          ay(c, _, w, S), delete c[h];
        } else if (v === null) {
          const w = {
            signal: b.map((_) => {
              const { test: S, ...E } = _;
              return `${Np(null, S)} ? ${$$(E)} : `;
            }).join("") + $$(y)
          };
          c[h] = w;
        }
      } else if (oe(p)) {
        const m = W$[h];
        if (m) {
          const { vgProp: y, part: b } = m;
          ay(c, b, y, p), delete c[h];
        }
      }
      Fe(["labelAlign", "labelBaseline"], h) && c[h] === null && delete c[h];
    }
    if (t === "grid") {
      if (!c.grid)
        return;
      if (c.encode) {
        const { grid: h } = c.encode;
        c.encode = {
          ...h ? { grid: h } : {}
        }, He(c.encode) && delete c.encode;
      }
      return {
        scale: o,
        orient: s,
        ...c,
        domain: !1,
        labels: !1,
        aria: !1,
        // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
        // would not affect gridAxis
        maxExtent: 0,
        minExtent: 0,
        ticks: !1,
        zindex: ct(u, 0)
        // put grid behind marks by default
      };
    } else {
      if (!i.header && e.mainExtracted)
        return;
      if (a !== void 0) {
        let g = a;
        (d = (f = c.encode) == null ? void 0 : f.labels) != null && d.update && oe(c.encode.labels.update.text) && (g = ja(a, "datum.label", c.encode.labels.update.text.signal)), ay(c, "labels", "text", { signal: g });
      }
      if (c.labelAlign === null && delete c.labelAlign, c.encode) {
        for (const g of hL)
          e.hasAxisPart(g) || delete c.encode[g];
        He(c.encode) && delete c.encode;
      }
      const h = Ice(l, n);
      return {
        scale: o,
        orient: s,
        grid: !1,
        ...h ? { title: h } : {},
        ...c,
        ...n.aria === !1 ? { aria: !1 } : {},
        zindex: ct(u, 0)
        // put axis line above marks by default
      };
    }
  }
}
function _8(e) {
  const { axes: t } = e.component, n = [];
  for (const i of Vr)
    if (t[i]) {
      for (const r of t[i])
        if (!r.get("disable") && !r.get("gridScale")) {
          const s = i === "x" ? "height" : "width", o = e.getSizeSignalRef(s).signal;
          s !== o && n.push({
            name: s,
            update: o
          });
        }
    }
  return n;
}
function zce(e, t) {
  const { x: n = [], y: i = [] } = e;
  return [
    ...n.map((r) => Jc(r, "grid", t)),
    ...i.map((r) => Jc(r, "grid", t)),
    ...n.map((r) => Jc(r, "main", t)),
    ...i.map((r) => Jc(r, "main", t))
  ].filter((r) => r);
}
function yM(e, t, n, i) {
  return Object.assign.apply(null, [
    {},
    ...e.map((r) => {
      if (r === "axisOrient") {
        const s = n === "x" ? "bottom" : "left", o = t[n === "x" ? "axisBottom" : "axisLeft"] || {}, a = t[n === "x" ? "axisTop" : "axisRight"] || {}, l = /* @__PURE__ */ new Set([...q(o), ...q(a)]), u = {};
        for (const c of l.values())
          u[c] = {
            // orient is surely signal in this case
            signal: `${i.signal} === "${s}" ? ${Hi(o[c])} : ${Hi(a[c])}`
          };
        return u;
      }
      return t[r];
    })
  ]);
}
function Bce(e, t, n, i) {
  const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : j4(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [], s = e === "x" ? "axisX" : "axisY", o = oe(n) ? "axisOrient" : `axis${$d(n)}`, a = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...r,
    ...r.map((u) => s + u.substr(4))
  ], l = ["axis", o, s];
  return {
    vlOnlyAxisConfig: yM(a, i, e, n),
    vgAxisConfig: yM(l, i, e, n),
    axisConfigStyle: jce([...l, ...a], i)
  };
}
function jce(e, t) {
  var i;
  const n = [{}];
  for (const r of e) {
    let s = (i = t[r]) == null ? void 0 : i.style;
    if (s) {
      s = J(s);
      for (const o of s)
        n.push(t.style[o]);
    }
  }
  return Object.assign.apply(null, n);
}
function kv(e, t, n, i = {}) {
  var s;
  const r = p4(e, n, t);
  if (r !== void 0)
    return {
      configFrom: "style",
      configValue: r
    };
  for (const o of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
    if (((s = i[o]) == null ? void 0 : s[e]) !== void 0)
      return { configFrom: o, configValue: i[o][e] };
  return {};
}
const bM = {
  scale: ({ model: e, channel: t }) => e.scaleName(t),
  format: ({ format: e }) => e,
  formatType: ({ formatType: e }) => e,
  grid: ({ fieldOrDatumDef: e, axis: t, scaleType: n }) => t.grid ?? Uce(n, e),
  gridScale: ({ model: e, channel: t }) => qce(e, t),
  labelAlign: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelAlign || S8(t, n, i),
  labelAngle: ({ labelAngle: e }) => e,
  labelBaseline: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelBaseline || E8(t, n, i),
  labelFlush: ({ axis: e, fieldOrDatumDef: t, channel: n }) => e.labelFlush ?? Hce(t.type, n),
  labelOverlap: ({ axis: e, fieldOrDatumDef: t, scaleType: n }) => e.labelOverlap ?? Gce(t.type, n, G(t) && !!t.timeUnit, G(t) ? t.sort : void 0),
  // we already calculate orient in parse
  orient: ({ orient: e }) => e,
  tickCount: ({ channel: e, model: t, axis: n, fieldOrDatumDef: i, scaleType: r }) => {
    const s = e === "x" ? "width" : e === "y" ? "height" : void 0, o = s ? t.getSizeSignalRef(s) : void 0;
    return n.tickCount ?? Yce({ fieldOrDatumDef: i, scaleType: r, size: o, values: n.values });
  },
  tickMinStep: Xce,
  title: ({ axis: e, model: t, channel: n }) => {
    if (e.title !== void 0)
      return e.title;
    const i = k8(t, n);
    if (i !== void 0)
      return i;
    const r = t.typedFieldDef(n), s = n === "x" ? "x2" : "y2", o = t.fieldDef(s);
    return y4(r ? [U$(r)] : [], G(o) ? [U$(o)] : []);
  },
  values: ({ axis: e, fieldOrDatumDef: t }) => Kce(e, t),
  zindex: ({ axis: e, fieldOrDatumDef: t, mark: n }) => e.zindex ?? Jce(n, t)
};
function Uce(e, t) {
  return !Dt(e) && G(t) && !Ke(t == null ? void 0 : t.bin) && !zt(t == null ? void 0 : t.bin);
}
function qce(e, t) {
  const n = t === "x" ? "y" : "x";
  if (e.getScaleComponent(n))
    return e.scaleName(n);
}
function Wce(e, t, n, i, r) {
  const s = t == null ? void 0 : t.labelAngle;
  if (s !== void 0)
    return oe(s) ? s : Gf(s);
  {
    const { configValue: o } = kv("labelAngle", i, t == null ? void 0 : t.style, r);
    return o !== void 0 ? Gf(o) : n === tt && Fe([gE, hE], e.type) && !(G(e) && e.timeUnit) ? 270 : void 0;
  }
}
function Av(e) {
  return `(((${e.signal} % 360) + 360) % 360)`;
}
function E8(e, t, n, i) {
  if (e !== void 0)
    if (n === "x") {
      if (oe(e)) {
        const r = Av(e), s = oe(t) ? `(${t.signal} === "top")` : t === "top";
        return {
          signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${s} ? "bottom" : "top"`
        };
      }
      if (45 < e && e < 135 || 225 < e && e < 315)
        return "middle";
      if (oe(t)) {
        const r = e <= 45 || 315 <= e ? "===" : "!==";
        return { signal: `${t.signal} ${r} "top" ? "bottom" : "top"` };
      }
      return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top";
    } else {
      if (oe(e)) {
        const r = Av(e), s = oe(t) ? `(${t.signal} === "left")` : t === "left";
        return {
          signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i ? '"middle"' : "null"} : (45 <= ${r} && ${r} <= 135) === ${s} ? "top" : "bottom"`
        };
      }
      if (e <= 45 || 315 <= e || 135 <= e && e <= 225)
        return i ? "middle" : null;
      if (oe(t)) {
        const r = 45 <= e && e <= 135 ? "===" : "!==";
        return { signal: `${t.signal} ${r} "left" ? "top" : "bottom"` };
      }
      return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom";
    }
}
function S8(e, t, n) {
  if (e === void 0)
    return;
  const i = n === "x", r = i ? 0 : 90, s = i ? "bottom" : "left";
  if (oe(e)) {
    const o = Av(e), a = oe(t) ? `(${t.signal} === "${s}")` : t === s;
    return {
      signal: `(${r ? `(${o} + 90)` : o} % 180 === 0) ? ${i ? null : '"center"'} :(${r} < ${o} && ${o} < ${180 + r}) === ${a} ? "left" : "right"`
    };
  }
  if ((e + r) % 180 === 0)
    return i ? null : "center";
  if (oe(t)) {
    const o = r < e && e < 180 + r ? "===" : "!==";
    return {
      signal: `${`${t.signal} ${o} "${s}"`} ? "left" : "right"`
    };
  }
  return (r < e && e < 180 + r) == (t === s) ? "left" : "right";
}
function Hce(e, t) {
  if (t === "x" && Fe(["quantitative", "temporal"], e))
    return !0;
}
function Gce(e, t, n, i) {
  if (n && !ee(i) || e !== "nominal" && e !== "ordinal")
    return t === "log" || t === "symlog" ? "greedy" : !0;
}
function Vce(e) {
  return e === "x" ? "bottom" : "left";
}
function Yce({ fieldOrDatumDef: e, scaleType: t, size: n, values: i }) {
  var r;
  if (!i && !Dt(t) && t !== "log") {
    if (G(e)) {
      if (Ke(e.bin))
        return { signal: `ceil(${n.signal}/10)` };
      if (e.timeUnit && Fe(["month", "hours", "day", "quarter"], (r = Nt(e.timeUnit)) == null ? void 0 : r.unit))
        return;
    }
    return { signal: `ceil(${n.signal}/40)` };
  }
}
function Xce({ format: e, fieldOrDatumDef: t }) {
  if (e === "d")
    return 1;
  if (G(t)) {
    const { timeUnit: n } = t;
    if (n) {
      const i = D4(n);
      if (i)
        return { signal: i };
    }
  }
}
function k8(e, t) {
  const n = t === "x" ? "x2" : "y2", i = e.fieldDef(t), r = e.fieldDef(n), s = i ? i.title : void 0, o = r ? r.title : void 0;
  if (s && o)
    return b4(s, o);
  if (s)
    return s;
  if (o)
    return o;
  if (s !== void 0)
    return s;
  if (o !== void 0)
    return o;
}
function Kce(e, t) {
  const n = e.values;
  if (j(n))
    return dL(t, n);
  if (oe(n))
    return n;
}
function Jce(e, t) {
  return e === "rect" && kp(t) ? 1 : 0;
}
class Fu extends We {
  clone() {
    return new Fu(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this._dependentFields = v8(this.transform.calculate);
  }
  static parseAllForSortIndex(t, n) {
    return n.forEachFieldDef((i, r) => {
      if (dl(i) && nL(i.sort)) {
        const { field: s, timeUnit: o } = i, a = i.sort, l = a.map((u, c) => `${P4({ field: s, timeUnit: o, equal: u })} ? ${c} : `).join("") + a.length;
        t = new Fu(t, {
          calculate: l,
          as: Tu(i, r, { forAs: !0 })
        });
      }
    }), t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${Me(this.transform)}`;
  }
}
function Tu(e, t, n) {
  return K(e, { prefix: t, suffix: "sort_index", ...n ?? {} });
}
function O0(e, t) {
  return Fe(["top", "bottom"], t) ? "column" : Fe(["left", "right"], t) || e === "row" ? "row" : "column";
}
function Ou(e, t, n, i) {
  const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
  return ct((t || {})[e], r[e], n.header[e]);
}
function N0(e, t, n, i) {
  const r = {};
  for (const s of e) {
    const o = Ou(s, t || {}, n, i);
    o !== void 0 && (r[s] = o);
  }
  return r;
}
const GE = ["row", "column"], VE = ["header", "footer"];
function Qce(e, t) {
  const n = e.component.layoutHeaders[t].title, i = e.config ? e.config : void 0, r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0, { titleAnchor: s, titleAngle: o, titleOrient: a } = N0(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t), l = O0(t, a), u = Gf(o);
  return {
    name: `${t}-title`,
    type: "group",
    role: `${l}-title`,
    title: {
      text: n,
      ...t === "row" ? { orient: "left" } : {},
      style: "guide-title",
      ...C8(u, l),
      ...A8(l, u, s),
      ...$8(i, r, t, zle, FL)
    }
  };
}
function A8(e, t, n = "middle") {
  switch (n) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const i = S8(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
  return i ? { align: i } : {};
}
function C8(e, t) {
  const n = E8(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
  return n ? { baseline: n } : {};
}
function Zce(e, t) {
  const n = e.component.layoutHeaders[t], i = [];
  for (const r of VE)
    if (n[r])
      for (const s of n[r]) {
        const o = tfe(e, t, r, n, s);
        o != null && i.push(o);
      }
  return i;
}
function efe(e, t) {
  const { sort: n } = e;
  return Sr(n) ? {
    field: K(n, { expr: "datum" }),
    order: n.order ?? "ascending"
  } : j(n) ? {
    field: Tu(e, t, { expr: "datum" }),
    order: "ascending"
  } : {
    field: K(e, { expr: "datum" }),
    order: n ?? "ascending"
  };
}
function Cv(e, t, n) {
  const { format: i, formatType: r, labelAngle: s, labelAnchor: o, labelOrient: a, labelExpr: l } = N0(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), u = wE({
    fieldOrDatumDef: e,
    format: i,
    formatType: r,
    expr: "parent",
    config: n
  }).signal, c = O0(t, a);
  return {
    text: {
      signal: l ? ja(ja(l, "datum.label", u), "datum.value", K(e, { expr: "parent" })) : u
    },
    ...t === "row" ? { orient: "left" } : {},
    style: "guide-label",
    frame: "group",
    ...C8(s, c),
    ...A8(c, s, o),
    ...$8(n, e, t, Ble, TL)
  };
}
function tfe(e, t, n, i, r) {
  if (r) {
    let s = null;
    const { facetFieldDef: o } = i, a = e.config ? e.config : void 0;
    if (o && r.labels) {
      const { labelOrient: f } = N0(["labelOrient"], o.header, a, t);
      (t === "row" && !Fe(["top", "bottom"], f) || t === "column" && !Fe(["left", "right"], f)) && (s = Cv(o, t, a));
    }
    const l = Ki(e) && !Rd(e.facet), u = r.axes, c = (u == null ? void 0 : u.length) > 0;
    if (s || c) {
      const f = t === "row" ? "height" : "width";
      return {
        name: e.getName(`${t}_${n}`),
        type: "group",
        role: `${t}-${n}`,
        ...i.facetFieldDef ? {
          from: { data: e.getName(`${t}_domain`) },
          sort: efe(o, t)
        } : {},
        ...c && l ? {
          from: { data: e.getName(`facet_domain_${t}`) }
        } : {},
        ...s ? { title: s } : {},
        ...r.sizeSignal ? {
          encode: {
            update: {
              [f]: r.sizeSignal
            }
          }
        } : {},
        ...c ? { axes: u } : {}
      };
    }
  }
  return null;
}
const nfe = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function ife(e, t) {
  return nfe[t][e];
}
function rfe(e, t) {
  const n = {};
  for (const i of mi) {
    const r = e[i];
    if (r != null && r.facetFieldDef) {
      const { titleAnchor: s, titleOrient: o } = N0(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), a = O0(i, o), l = ife(s, a);
      l !== void 0 && (n[a] = l);
    }
  }
  return He(n) ? void 0 : n;
}
function $8(e, t, n, i, r) {
  const s = {};
  for (const o of i) {
    if (!r[o])
      continue;
    const a = Ou(o, t == null ? void 0 : t.header, e, n);
    a !== void 0 && (s[r[o]] = a);
  }
  return s;
}
function YE(e) {
  return [
    ...xh(e, "width"),
    ...xh(e, "height"),
    ...xh(e, "childWidth"),
    ...xh(e, "childHeight")
  ];
}
function xh(e, t) {
  const n = t === "width" ? "x" : "y", i = e.component.layoutSize.get(t);
  if (!i || i === "merged")
    return [];
  const r = e.getSizeSignalRef(t).signal;
  if (i === "step") {
    const s = e.getScaleComponent(n);
    if (s) {
      const o = s.get("type"), a = s.get("range");
      if (Dt(o) && Wo(a)) {
        const l = e.scaleName(n);
        return Ki(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [vM(l, a)] : [
          vM(l, a),
          {
            name: r,
            update: M8(l, s, `domain('${l}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (i == "container") {
    const s = r.endsWith("width"), o = s ? "containerSize()[0]" : "containerSize()[1]", a = vv(e.config.view, s ? "width" : "height"), l = `isFinite(${o}) ? ${o} : ${a}`;
    return [{ name: r, init: l, on: [{ update: l, events: "window:resize" }] }];
  } else
    return [
      {
        name: r,
        value: i
      }
    ];
}
function vM(e, t) {
  const n = `${e}_step`;
  return oe(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };
}
function M8(e, t, n) {
  const i = t.get("type"), r = t.get("padding"), s = ct(t.get("paddingOuter"), r);
  let o = t.get("paddingInner");
  return o = i === "band" ? (
    // only band has real paddingInner
    o !== void 0 ? o : r
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  ), `bandspace(${n}, ${Hi(o)}, ${Hi(s)}) * ${e}_step`;
}
function F8(e) {
  return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
}
function T8(e, t) {
  return q(e).reduce((n, i) => {
    const r = e[i];
    return {
      ...n,
      ...Qu(t, r, i, (s) => Qe(s.value))
    };
  }, {});
}
function O8(e, t) {
  if (Ki(t))
    return e === "theta" ? "independent" : "shared";
  if (nc(t))
    return "shared";
  if (tS(t))
    return ft(e) || e === "theta" || e === "radius" ? "independent" : "shared";
  throw new Error("invalid model type for resolve");
}
function XE(e, t) {
  const n = e.scale[t], i = ft(t) ? "axis" : "legend";
  return n === "independent" ? (e[i][t] === "shared" && V(Loe(t)), "independent") : e[i][t] || "shared";
}
const sfe = {
  ...qle,
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
}, N8 = q(sfe);
class ofe extends Is {
}
const xM = {
  symbols: afe,
  gradient: lfe,
  labels: ufe,
  entries: cfe
};
function afe(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r, legendType: s }) {
  if (s !== "symbol")
    return;
  const { markDef: o, encoding: a, config: l, mark: u } = n, c = o.filled && u !== "trail";
  let f = {
    ...Yse({}, n, zae),
    ...s8(n, { filled: c })
  };
  const d = r.get("symbolOpacity") ?? l.legend.symbolOpacity, h = r.get("symbolFillColor") ?? l.legend.symbolFillColor, g = r.get("symbolStrokeColor") ?? l.legend.symbolStrokeColor, p = d === void 0 ? D8(a.opacity) ?? o.opacity : void 0;
  if (f.fill) {
    if (i === "fill" || c && i === zn)
      delete f.fill;
    else if (f.fill.field)
      h ? delete f.fill : (f.fill = Qe(l.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = Qe(p ?? 1));
    else if (j(f.fill)) {
      const m = $v(a.fill ?? a.color) ?? o.fill ?? (c && o.color);
      m && (f.fill = Qe(m));
    }
  }
  if (f.stroke) {
    if (i === "stroke" || !c && i === zn)
      delete f.stroke;
    else if (f.stroke.field || g)
      delete f.stroke;
    else if (j(f.stroke)) {
      const m = ct($v(a.stroke || a.color), o.stroke, c ? o.color : void 0);
      m && (f.stroke = { value: m });
    }
  }
  if (i !== Rs) {
    const m = G(t) && L8(n, r, t);
    m ? f.opacity = [
      { test: m, ...Qe(p ?? 1) },
      Qe(l.legend.unselectedOpacity)
    ] : p && (f.opacity = Qe(p));
  }
  return f = { ...f, ...e }, He(f) ? void 0 : f;
}
function lfe(e, { model: t, legendType: n, legendCmpt: i }) {
  if (n !== "gradient")
    return;
  const { config: r, markDef: s, encoding: o } = t;
  let a = {};
  const u = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? D8(o.opacity) || s.opacity : void 0;
  return u && (a.opacity = Qe(u)), a = { ...a, ...e }, He(a) ? void 0 : a;
}
function ufe(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r }) {
  const s = n.legend(i) || {}, o = n.config, a = G(t) ? L8(n, r, t) : void 0, l = a ? [{ test: a, value: 1 }, { value: o.legend.unselectedOpacity }] : void 0, { format: u, formatType: c } = s;
  let f;
  Ga(c) ? f = Vi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: u,
    formatType: c,
    config: o
  }) : u === void 0 && c === void 0 && o.customFormatTypes && (t.type === "quantitative" && o.numberFormatType ? f = Vi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: o.numberFormat,
    formatType: o.numberFormatType,
    config: o
  }) : t.type === "temporal" && o.timeFormatType && G(t) && t.timeUnit === void 0 && (f = Vi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: o.timeFormat,
    formatType: o.timeFormatType,
    config: o
  })));
  const d = {
    ...l ? { opacity: l } : {},
    ...f ? { text: f } : {},
    ...e
  };
  return He(d) ? void 0 : d;
}
function cfe(e, { legendCmpt: t }) {
  const n = t.get("selections");
  return n != null && n.length ? { ...e, fill: { value: "transparent" } } : e;
}
function D8(e) {
  return R8(e, (t, n) => Math.max(t, n.value));
}
function $v(e) {
  return R8(e, (t, n) => ct(t, n.value));
}
function R8(e, t) {
  if (sle(e))
    return J(e.condition).reduce(t, e.value);
  if (er(e))
    return e.value;
}
function L8(e, t, n) {
  const i = t.get("selections");
  if (!(i != null && i.length))
    return;
  const r = X(n.field);
  return i.map((s) => `(!length(data(${X(et(s) + Ya)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ");
}
const wM = {
  direction: ({ direction: e }) => e,
  format: ({ fieldOrDatumDef: e, legend: t, config: n }) => {
    const { format: i, formatType: r } = t;
    return Q4(e, e.type, i, r, n, !1);
  },
  formatType: ({ legend: e, fieldOrDatumDef: t, scaleType: n }) => {
    const { formatType: i } = e;
    return Z4(i, t, n);
  },
  gradientLength: (e) => {
    const { legend: t, legendConfig: n } = e;
    return t.gradientLength ?? n.gradientLength ?? yfe(e);
  },
  labelOverlap: ({ legend: e, legendConfig: t, scaleType: n }) => e.labelOverlap ?? t.labelOverlap ?? bfe(n),
  symbolType: ({ legend: e, markDef: t, channel: n, encoding: i }) => e.symbolType ?? dfe(t.type, n, i.shape, t.shape),
  title: ({ fieldOrDatumDef: e, config: t }) => Yl(e, t, { allowDisabling: !0 }),
  type: ({ legendType: e, scaleType: t, channel: n }) => {
    if (Vl(n) && Gi(t)) {
      if (e === "gradient")
        return;
    } else if (e === "symbol")
      return;
    return e;
  },
  values: ({ fieldOrDatumDef: e, legend: t }) => ffe(t, e)
};
function ffe(e, t) {
  const n = e.values;
  if (j(n))
    return dL(t, n);
  if (oe(n))
    return n;
}
function dfe(e, t, n, i) {
  if (t !== "shape") {
    const r = $v(n) ?? i;
    if (r)
      return r;
  }
  switch (e) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function hfe(e) {
  const { legend: t } = e;
  return ct(t.type, gfe(e));
}
function gfe({ channel: e, timeUnit: t, scaleType: n }) {
  if (Vl(e)) {
    if (Fe(["quarter", "month", "day"], t))
      return "symbol";
    if (Gi(n))
      return "gradient";
  }
  return "symbol";
}
function pfe({ legendConfig: e, legendType: t, orient: n, legend: i }) {
  return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? mfe(n, t);
}
function mfe(e, t) {
  switch (e) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return;
    default:
      return t === "gradient" ? "horizontal" : void 0;
  }
}
function yfe({ legendConfig: e, model: t, direction: n, orient: i, scaleType: r }) {
  const { gradientHorizontalMaxLength: s, gradientHorizontalMinLength: o, gradientVerticalMaxLength: a, gradientVerticalMinLength: l } = e;
  if (Gi(r))
    return n === "horizontal" ? i === "top" || i === "bottom" ? _M(t, "width", o, s) : o : _M(t, "height", l, a);
}
function _M(e, t, n, i) {
  return { signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})` };
}
function bfe(e) {
  if (Fe(["quantile", "threshold", "log", "symlog"], e))
    return "greedy";
}
function P8(e) {
  const t = ot(e) ? vfe(e) : Efe(e);
  return e.component.legends = t, t;
}
function vfe(e) {
  const { encoding: t } = e, n = {};
  for (const i of [zn, ...NL]) {
    const r = bt(t[i]);
    !r || !e.getScaleComponent(i) || i === Bn && G(r) && r.type === Ju || (n[i] = _fe(e, i));
  }
  return n;
}
function xfe(e, t) {
  const n = e.scaleName(t);
  if (e.mark === "trail") {
    if (t === "color")
      return { stroke: n };
    if (t === "size")
      return { strokeWidth: n };
  }
  return t === "color" ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };
}
function wfe(e, t, n, i) {
  switch (t) {
    case "disable":
      return n !== void 0;
    case "values":
      return !!(n != null && n.values);
    case "title":
      if (t === "title" && e === (i == null ? void 0 : i.title))
        return !0;
  }
  return e === (n || {})[t];
}
function _fe(e, t) {
  var w;
  let n = e.legend(t);
  const { markDef: i, encoding: r, config: s } = e, o = s.legend, a = new ofe({}, xfe(e, t));
  Tce(e, t, a);
  const l = n !== void 0 ? !n : o.disable;
  if (a.set("disable", l, n !== void 0), l)
    return a;
  n = n || {};
  const u = e.getScaleComponent(t).get("type"), c = bt(r[t]), f = G(c) ? (w = Nt(c.timeUnit)) == null ? void 0 : w.unit : void 0, d = n.orient || s.legend.orient || "right", h = hfe({ legend: n, channel: t, timeUnit: f, scaleType: u }), g = pfe({ legend: n, legendType: h, orient: d, legendConfig: o }), p = {
    legend: n,
    channel: t,
    model: e,
    markDef: i,
    encoding: r,
    fieldOrDatumDef: c,
    legendConfig: o,
    config: s,
    scaleType: u,
    orient: d,
    legendType: h,
    direction: g
  };
  for (const _ of N8) {
    if (h === "gradient" && _.startsWith("symbol") || h === "symbol" && _.startsWith("gradient"))
      continue;
    const S = _ in wM ? wM[_](p) : n[_];
    if (S !== void 0) {
      const E = wfe(S, _, n, e.fieldDef(t));
      (E || s.legend[_] === void 0) && a.set(_, S, E);
    }
  }
  const m = (n == null ? void 0 : n.encoding) ?? {}, y = a.get("selections"), b = {}, v = { fieldOrDatumDef: c, model: e, channel: t, legendCmpt: a, legendType: h };
  for (const _ of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const S = T8(m[_] ?? {}, e), E = _ in xM ? xM[_](S, v) : S;
    E !== void 0 && !He(E) && (b[_] = {
      ...y != null && y.length && G(c) ? { name: `${et(c.field)}_legend_${_}` } : {},
      ...y != null && y.length ? { interactive: !!y } : {},
      update: E
    });
  }
  return He(b) || a.set("encode", b, !!(n != null && n.encoding)), a;
}
function Efe(e) {
  const { legends: t, resolve: n } = e.component;
  for (const i of e.children) {
    P8(i);
    for (const r of q(i.component.legends))
      n.legend[r] = XE(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = I8(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));
  }
  for (const i of q(t))
    for (const r of e.children)
      r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
  return t;
}
function I8(e, t) {
  var s, o, a, l;
  if (!e)
    return t.clone();
  const n = e.getWithExplicit("orient"), i = t.getWithExplicit("orient");
  if (n.explicit && i.explicit && n.value !== i.value)
    return;
  let r = !1;
  for (const u of N8) {
    const c = Co(
      e.getWithExplicit(u),
      t.getWithExplicit(u),
      u,
      "legend",
      // Tie breaker function
      (f, d) => {
        switch (u) {
          case "symbolType":
            return Sfe(f, d);
          case "title":
            return v4(f, d);
          case "type":
            return r = !0, Wn("symbol");
        }
        return C0(f, d, u, "legend");
      }
    );
    e.setWithExplicit(u, c);
  }
  return r && ((o = (s = e.implicit) == null ? void 0 : s.encode) != null && o.gradient && vp(e.implicit, ["encode", "gradient"]), (l = (a = e.explicit) == null ? void 0 : a.encode) != null && l.gradient && vp(e.explicit, ["encode", "gradient"])), e;
}
function Sfe(e, t) {
  return t.value === "circle" ? t : e;
}
function kfe(e, t, n, i) {
  var r, s;
  e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i;
}
function z8(e) {
  const t = e.component.legends, n = {};
  for (const r of q(t)) {
    const s = e.getScaleComponent(r), o = Ge(s.get("domains"));
    if (n[o])
      for (const a of n[o])
        I8(a, t[r]) || n[o].push(t[r]);
    else
      n[o] = [t[r].clone()];
  }
  return qt(n).flat().map((r) => Afe(r, e.config)).filter((r) => r !== void 0);
}
function Afe(e, t) {
  var o, a, l;
  const { disable: n, labelExpr: i, selections: r, ...s } = e.combine();
  if (!n) {
    if (t.aria === !1 && s.aria == null && (s.aria = !1), (o = s.encode) != null && o.symbols) {
      const u = s.encode.symbols.update;
      u.fill && u.fill.value !== "transparent" && !u.stroke && !s.stroke && (u.stroke = { value: "transparent" });
      for (const c of NL)
        s[c] && delete u[c];
    }
    if (s.title || delete s.title, i !== void 0) {
      let u = i;
      (l = (a = s.encode) == null ? void 0 : a.labels) != null && l.update && oe(s.encode.labels.update.text) && (u = ja(i, "datum.label", s.encode.labels.update.text.signal)), kfe(s, "labels", "text", { signal: u });
    }
    return s;
  }
}
function Cfe(e) {
  return nc(e) || tS(e) ? $fe(e) : B8(e);
}
function $fe(e) {
  return e.children.reduce((t, n) => t.concat(n.assembleProjections()), B8(e));
}
function B8(e) {
  const t = e.component.projection;
  if (!t || t.merged)
    return [];
  const n = t.combine(), { name: i } = n;
  if (t.data) {
    const r = {
      signal: `[${t.size.map((o) => o.signal).join(", ")}]`
    }, s = t.data.reduce((o, a) => {
      const l = oe(a) ? a.signal : `data('${e.lookupDataSource(a)}')`;
      return Fe(o, l) || o.push(l), o;
    }, []);
    if (s.length <= 0)
      throw new Error("Projection's fit didn't find any data sources");
    return [
      {
        name: i,
        size: r,
        fit: {
          signal: s.length > 1 ? `[${s.join(", ")}]` : s[0]
        },
        ...n
      }
    ];
  } else
    return [
      {
        name: i,
        translate: { signal: "[width / 2, height / 2]" },
        // parameters, overwrite default translate if specified
        ...n
      }
    ];
}
const Mfe = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
class j8 extends Is {
  constructor(t, n, i, r) {
    super(
      { ...n },
      // all explicit properties of projection
      { name: t }
      // name as initial implicit property
    ), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
}
function U8(e) {
  e.component.projection = ot(e) ? Ffe(e) : Nfe(e);
}
function Ffe(e) {
  if (e.hasProjection) {
    const t = Fn(e.specifiedProjection), n = !(t && (t.scale != null || t.translate != null)), i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0, r = n ? Tfe(e) : void 0, s = new j8(e.projectionName(!0), {
      ...Fn(e.config.projection) ?? {},
      ...t ?? {}
    }, i, r);
    return s.get("type") || s.set("type", "equalEarth", !1), s;
  }
}
function Tfe(e) {
  const t = [], { encoding: n } = e;
  for (const i of [
    [lr, ar],
    [$i, ur]
  ])
    (bt(n[i[0]]) || bt(n[i[1]])) && t.push({
      signal: e.getName(`geojson_${t.length}`)
    });
  return e.channelHasField(Bn) && e.typedFieldDef(Bn).type === Ju && t.push({
    signal: e.getName(`geojson_${t.length}`)
  }), t.length === 0 && t.push(e.requestDataName(Xe.Main)), t;
}
function Ofe(e, t) {
  const n = j_(Mfe, (r) => !!(!ce(e.explicit, r) && !ce(t.explicit, r) || ce(e.explicit, r) && ce(t.explicit, r) && // some properties might be signals or objects and require hashing for comparison
  Kn(e.get(r), t.get(r))));
  if (Kn(e.size, t.size)) {
    if (n)
      return e;
    if (Kn(e.explicit, {}))
      return t;
    if (Kn(t.explicit, {}))
      return e;
  }
  return null;
}
function Nfe(e) {
  if (e.children.length === 0)
    return;
  let t;
  for (const i of e.children)
    U8(i);
  const n = j_(e.children, (i) => {
    const r = i.component.projection;
    if (r)
      if (t) {
        const s = Ofe(t, r);
        return s && (t = s), !!s;
      } else
        return t = r, !0;
    else
      return !0;
  });
  if (t && n) {
    const i = e.projectionName(!0), r = new j8(i, t.specifiedProjection, t.size, me(t.data));
    for (const s of e.children) {
      const o = s.component.projection;
      o && (o.isFit && r.data.push(...s.component.projection.data), s.renameProjection(o.get("name"), i), o.merged = !0);
    }
    return r;
  }
}
function Dfe(e, t, n, i) {
  if (Pd(t, n)) {
    const r = ot(e) ? e.axis(n) ?? e.legend(n) ?? {} : {}, s = K(t, { expr: "datum" }), o = K(t, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: K(t, { binSuffix: "range", forAs: !0 }),
      formula: Dd(s, o, r.format, r.formatType, i)
    };
  }
  return {};
}
function q8(e, t) {
  return `${f4(e)}_${t}`;
}
function Rfe(e, t) {
  return {
    signal: e.getName(`${t}_bins`),
    extentSignal: e.getName(`${t}_extent`)
  };
}
function KE(e, t, n) {
  const i = w0(n, void 0) ?? {}, r = q8(i, t);
  return e.getName(`${r}_bins`);
}
function Lfe(e) {
  return "as" in e;
}
function EM(e, t, n) {
  let i, r;
  Lfe(e) ? i = Q(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [K(e, { forAs: !0 }), K(e, { binSuffix: "end", forAs: !0 })];
  const s = { ...w0(t, void 0) }, o = q8(s, e.field), { signal: a, extentSignal: l } = Rfe(n, o);
  if (c0(s.extent)) {
    const c = s.extent;
    r = w8(n, c.param, c), delete s.extent;
  }
  const u = {
    bin: s,
    field: e.field,
    as: [i],
    ...a ? { signal: a } : {},
    ...l ? { extentSignal: l } : {},
    ...r ? { span: r } : {}
  };
  return { key: o, binComponent: u };
}
class Ar extends We {
  clone() {
    return new Ar(null, me(this.bins));
  }
  constructor(t, n) {
    super(t), this.bins = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, s, o) => {
      if (En(s) && Ke(s.bin)) {
        const { key: a, binComponent: l } = EM(s, s.bin, n);
        r[a] = {
          ...l,
          ...r[a],
          ...Dfe(n, s, o, n.config)
        };
      }
      return r;
    }, {});
    return He(i) ? null : new Ar(t, i);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(t, n, i) {
    const { key: r, binComponent: s } = EM(n, n.bin, i);
    return new Ar(t, {
      [r]: s
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(t, n) {
    for (const i of q(t.bins))
      i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = xr([...this.bins[i].as, ...t.bins[i].as], Me)) : this.bins[i] = t.bins[i];
    for (const i of t.children)
      t.removeChild(i), i.parent = this;
    t.remove();
  }
  producedFields() {
    return new Set(qt(this.bins).map((t) => t.as).flat(2));
  }
  dependentFields() {
    return new Set(qt(this.bins).map((t) => t.field));
  }
  hash() {
    return `Bin ${Me(this.bins)}`;
  }
  assemble() {
    return qt(this.bins).flatMap((t) => {
      const n = [], [i, ...r] = t.as, { extent: s, ...o } = t.bin, a = {
        type: "bin",
        field: Ci(t.field),
        as: i,
        signal: t.signal,
        ...c0(s) ? { extent: null } : { extent: s },
        ...t.span ? { span: { signal: `span(${t.span})` } } : {},
        ...o
      };
      !s && t.extentSignal && (n.push({
        type: "extent",
        field: Ci(t.field),
        signal: t.extentSignal
      }), a.extent = { signal: t.extentSignal }), n.push(a);
      for (const l of r)
        for (let u = 0; u < 2; u++)
          n.push({
            type: "formula",
            expr: K({ field: i[u] }, { expr: "datum" }),
            as: l[u]
          });
      return t.formula && n.push({
        type: "formula",
        expr: t.formula,
        as: t.formulaAs
      }), n;
    });
  }
}
function Pfe(e, t, n, i) {
  var s;
  const r = ot(i) ? i.encoding[Gr(t)] : void 0;
  if (En(n) && ot(i) && rL(n, r, i.markDef, i.config)) {
    e.add(K(n, {})), e.add(K(n, { suffix: "end" }));
    const { mark: o, markDef: a, config: l } = i, u = Ao({ fieldDef: n, markDef: a, config: l });
    Vf(o) && u !== 0.5 && ft(t) && (e.add(K(n, { suffix: $0 })), e.add(K(n, { suffix: M0 }))), n.bin && Pd(n, t) && e.add(K(n, { binSuffix: "range" }));
  } else if (t4(t)) {
    const o = e4(t);
    e.add(i.getName(o));
  } else
    e.add(K(n));
  return dl(n) && Cae((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e;
}
function Ife(e, t) {
  for (const n of q(t)) {
    const i = t[n];
    for (const r of q(i))
      n in e ? e[n][r] = /* @__PURE__ */ new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = { [r]: i[r] };
  }
}
class Xi extends We {
  clone() {
    return new Xi(null, new Set(this.dimensions), me(this.measures));
  }
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(t, n, i) {
    super(t), this.dimensions = n, this.measures = i;
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(t, n) {
    let i = !1;
    n.forEachFieldDef((o) => {
      o.aggregate && (i = !0);
    });
    const r = {}, s = /* @__PURE__ */ new Set();
    return !i || (n.forEachFieldDef((o, a) => {
      const { aggregate: l, field: u } = o;
      if (l)
        if (l === "count")
          r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([K(o, { forAs: !0 })]);
        else {
          if (Ss(l) || qo(l)) {
            const c = Ss(l) ? "argmin" : "argmax", f = l[c];
            r[f] ?? (r[f] = {}), r[f][c] = /* @__PURE__ */ new Set([K({ op: c, field: f }, { forAs: !0 })]);
          } else
            r[u] ?? (r[u] = {}), r[u][l] = /* @__PURE__ */ new Set([K(o, { forAs: !0 })]);
          Ls(a) && n.scaleDomain(a) === "unaggregated" && (r[u] ?? (r[u] = {}), r[u].min = /* @__PURE__ */ new Set([K({ field: u, aggregate: "min" }, { forAs: !0 })]), r[u].max = /* @__PURE__ */ new Set([K({ field: u, aggregate: "max" }, { forAs: !0 })]));
        }
      else
        Pfe(s, a, o, n);
    }), s.size + q(r).length === 0) ? null : new Xi(t, s, r);
  }
  static makeFromTransform(t, n) {
    const i = /* @__PURE__ */ new Set(), r = {};
    for (const s of n.aggregate) {
      const { op: o, field: a, as: l } = s;
      o && (o === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([l || K(s, { forAs: !0 })])) : (r[a] ?? (r[a] = {}), r[a][o] = /* @__PURE__ */ new Set([l || K(s, { forAs: !0 })])));
    }
    for (const s of n.groupby ?? [])
      i.add(s);
    return i.size + q(r).length === 0 ? null : new Xi(t, i, r);
  }
  merge(t) {
    return G6(this.dimensions, t.dimensions) ? (Ife(this.measures, t.measures), !0) : (Qoe("different dimensions, cannot merge"), !1);
  }
  addDimensions(t) {
    t.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...q(this.measures)]);
  }
  producedFields() {
    const t = /* @__PURE__ */ new Set();
    for (const n of q(this.measures))
      for (const i of q(this.measures[n])) {
        const r = this.measures[n][i];
        r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t);
      }
    return t;
  }
  hash() {
    return `Aggregate ${Me({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const s of q(this.measures))
      for (const o of q(this.measures[s]))
        for (const a of this.measures[s][o])
          i.push(a), t.push(o), n.push(s === "*" ? null : Ci(s));
    return {
      type: "aggregate",
      groupby: [...this.dimensions].map(Ci),
      ops: t,
      fields: n,
      as: i
    };
  }
}
class ec extends We {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(t, n, i, r) {
    super(t), this.model = n, this.name = i, this.data = r;
    for (const s of mi) {
      const o = n.facet[s];
      if (o) {
        const { bin: a, sort: l } = o;
        this[s] = {
          name: n.getName(`${s}_domain`),
          fields: [K(o), ...Ke(a) ? [K(o, { binSuffix: "end" })] : []],
          ...Sr(l) ? { sortField: l } : j(l) ? { sortIndexField: Tu(o, s) } : {}
        };
      }
    }
    this.childModel = n.child;
  }
  hash() {
    let t = "Facet";
    for (const n of mi)
      this[n] && (t += ` ${n.charAt(0)}:${Me(this[n])}`);
    return t;
  }
  get fields() {
    var n;
    const t = [];
    for (const i of mi)
      (n = this[i]) != null && n.fields && t.push(...this[i].fields);
    return t;
  }
  dependentFields() {
    const t = new Set(this.fields);
    for (const n of mi)
      this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
    return t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const t = {};
    for (const n of Vr) {
      const i = this.childModel.component.scales[n];
      if (i && !i.merged) {
        const r = i.get("type"), s = i.get("range");
        if (Dt(r) && Wo(s)) {
          const o = D0(this.childModel, n), a = eS(o);
          a ? t[n] = a : V(tE(n));
        }
      }
    }
    return t;
  }
  assembleRowColumnHeaderData(t, n, i) {
    const r = { row: "y", column: "x", facet: void 0 }[t], s = [], o = [], a = [];
    r && i && i[r] && (n ? (s.push(`distinct_${i[r]}`), o.push("max")) : (s.push(i[r]), o.push("distinct")), a.push(`distinct_${i[r]}`));
    const { sortField: l, sortIndexField: u } = this[t];
    if (l) {
      const { op: c = y0, field: f } = l;
      s.push(f), o.push(c), a.push(K(l, { forAs: !0 }));
    } else
      u && (s.push(u), o.push("max"), a.push(u));
    return {
      name: this[t].name,
      // Use data from the crossed one if it exist
      source: n ?? this.data,
      transform: [
        {
          type: "aggregate",
          groupby: this[t].fields,
          ...s.length ? {
            fields: s,
            ops: o,
            as: a
          } : {}
        }
      ]
    };
  }
  assembleFacetHeaderData(t) {
    var l;
    const { columns: n } = this.model.layout, { layoutHeaders: i } = this.model.component, r = [], s = {};
    for (const u of GE) {
      for (const c of VE) {
        const f = (i[u] && i[u][c]) ?? [];
        for (const d of f)
          if (((l = d.axes) == null ? void 0 : l.length) > 0) {
            s[u] = !0;
            break;
          }
      }
      if (s[u]) {
        const c = `length(data("${this.facet.name}"))`, f = u === "row" ? n ? { signal: `ceil(${c} / ${n})` } : 1 : n ? { signal: `min(${c}, ${n})` } : { signal: c };
        r.push({
          name: `${this.facet.name}_${u}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: f
            }
          ]
        });
      }
    }
    const { row: o, column: a } = s;
    return (o || a) && r.unshift(this.assembleRowColumnHeaderData("facet", null, t)), r;
  }
  assemble() {
    const t = [];
    let n = null;
    const i = this.getChildIndependentFieldsWithStep(), { column: r, row: s, facet: o } = this;
    if (r && s && (i.x || i.y)) {
      n = `cross_${this.column.name}_${this.row.name}`;
      const a = [].concat(i.x ?? [], i.y ?? []), l = a.map(() => "distinct");
      t.push({
        name: n,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields: a,
            ops: l
          }
        ]
      });
    }
    for (const a of [ys, ms])
      this[a] && t.push(this.assembleRowColumnHeaderData(a, n, i));
    if (o) {
      const a = this.assembleFacetHeaderData(i);
      a && t.push(...a);
    }
    return t;
  }
}
function SM(e) {
  return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
}
function zfe(e, t) {
  const n = W_(e);
  if (t === "number")
    return `toNumber(${n})`;
  if (t === "boolean")
    return `toBoolean(${n})`;
  if (t === "string")
    return `toString(${n})`;
  if (t === "date")
    return `toDate(${n})`;
  if (t === "flatten")
    return n;
  if (t.startsWith("date:")) {
    const i = SM(t.slice(5, t.length));
    return `timeParse(${n},'${i}')`;
  } else if (t.startsWith("utc:")) {
    const i = SM(t.slice(4, t.length));
    return `utcParse(${n},'${i}')`;
  } else
    return V(aoe(t)), null;
}
function Bfe(e) {
  const t = {};
  return eg(e.filter, (n) => {
    if (L4(n)) {
      let i = null;
      sE(n) ? i = Vn(n.equal) : aE(n) ? i = Vn(n.lte) : oE(n) ? i = Vn(n.lt) : lE(n) ? i = Vn(n.gt) : uE(n) ? i = Vn(n.gte) : cE(n) ? i = n.range[0] : fE(n) && (i = (n.oneOf ?? n.in)[0]), i && (cl(i) ? t[n.field] = "date" : Re(i) ? t[n.field] = "number" : Q(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
    }
  }), t;
}
function jfe(e) {
  const t = {};
  function n(i) {
    Cu(i) ? t[i.field] = "date" : i.type === "quantitative" && zse(i.aggregate) ? t[i.field] = "number" : xu(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : dl(i) && Sr(i.sort) && xu(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
  }
  if ((ot(e) || Ki(e)) && e.forEachFieldDef((i, r) => {
    if (En(i))
      n(i);
    else {
      const s = ll(r), o = e.fieldDef(s);
      n({
        ...i,
        type: o.type
      });
    }
  }), ot(e)) {
    const { mark: i, markDef: r, encoding: s } = e;
    if (Ho(i) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !e.encoding.order) {
      const o = r.orient === "horizontal" ? "y" : "x", a = s[o];
      G(a) && a.type === "quantitative" && !(a.field in t) && (t[a.field] = "number");
    }
  }
  return t;
}
function Ufe(e) {
  const t = {};
  if (ot(e) && e.component.selection)
    for (const n of q(e.component.selection)) {
      const i = e.component.selection[n];
      for (const r of i.project.items)
        !r.channel && xu(r.field) > 1 && (t[r.field] = "flatten");
    }
  return t;
}
class en extends We {
  clone() {
    return new en(null, me(this._parse));
  }
  constructor(t, n) {
    super(t), this._parse = n;
  }
  hash() {
    return `Parse ${Me(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(t, n, i) {
    var o;
    let r = {};
    const s = n.data;
    return !co(s) && ((o = s == null ? void 0 : s.format) != null && o.parse) && (r = s.format.parse), this.makeWithAncestors(t, r, {}, i);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(t, n, i, r) {
    for (const a of q(i)) {
      const l = r.getWithExplicit(a);
      l.value !== void 0 && (l.explicit || l.value === i[a] || l.value === "derived" || i[a] === "flatten" ? delete i[a] : V(D$(a, i[a], l.value)));
    }
    for (const a of q(n)) {
      const l = r.get(a);
      l !== void 0 && (l === n[a] ? delete n[a] : V(D$(a, n[a], l)));
    }
    const s = new Is(n, i);
    r.copyAll(s);
    const o = {};
    for (const a of q(s.combine())) {
      const l = s.get(a);
      l !== null && (o[a] = l);
    }
    return q(o).length === 0 || r.parseNothing ? null : new en(t, o);
  }
  get parse() {
    return this._parse;
  }
  merge(t) {
    this._parse = { ...this._parse, ...t.parse }, t.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const t = {};
    for (const n of q(this._parse)) {
      const i = this._parse[n];
      xu(n) === 1 && (t[n] = i);
    }
    return t;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(q(this._parse));
  }
  dependentFields() {
    return new Set(q(this._parse));
  }
  assembleTransforms(t = !1) {
    return q(this._parse).filter((n) => t ? xu(n) > 1 : !0).map((n) => {
      const i = zfe(n, this._parse[n]);
      return i ? {
        type: "formula",
        expr: i,
        as: H_(n)
        // Vega output is always flattened
      } : null;
    }).filter((n) => n !== null);
  }
}
class Fo extends We {
  clone() {
    return new Fo(null);
  }
  constructor(t) {
    super(t);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([tr]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: tr };
  }
}
class Bd extends We {
  clone() {
    return new Bd(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  hash() {
    return `Graticule ${Me(this.params)}`;
  }
  assemble() {
    return {
      type: "graticule",
      ...this.params === !0 ? {} : this.params
    };
  }
}
class jd extends We {
  clone() {
    return new jd(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
  }
  hash() {
    return `Hash ${Me(this.params)}`;
  }
  assemble() {
    return {
      type: "sequence",
      ...this.params
    };
  }
}
class Xa extends We {
  constructor(t) {
    super(null), t ?? (t = { name: "source" });
    let n;
    if (co(t) || (n = t.format ? { ...Nn(t.format, ["parse"]) } : {}), Yf(t))
      this._data = { values: t.values };
    else if ($u(t)) {
      if (this._data = { url: t.url }, !n.type) {
        let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
        Fe(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i;
      }
    } else
      JL(t) ? this._data = { values: [{ type: "Sphere" }] } : (XL(t) || co(t)) && (this._data = {});
    this._generator = co(t), t.name && (this._name = t.name), n && !He(n) && (this._data.format = n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(t) {
    this._name = t;
  }
  set parent(t) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return {
      name: this._name,
      ...this._data,
      transform: []
    };
  }
}
var kM = function(e, t, n, i, r) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !r)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n;
}, qfe = function(e, t, n, i) {
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e);
}, Qc;
function JE(e) {
  return e instanceof Xa || e instanceof Bd || e instanceof jd;
}
class QE {
  constructor() {
    Qc.set(this, void 0), kM(this, Qc, !1, "f");
  }
  // Once true, #modified is never set to false
  setModified() {
    kM(this, Qc, !0, "f");
  }
  get modifiedFlag() {
    return qfe(this, Qc, "f");
  }
}
Qc = /* @__PURE__ */ new WeakMap();
class hl extends QE {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(t, n, i) {
    i.set(t, n);
    for (const r of t.children)
      this.getNodeDepths(r, n + 1, i);
    return i;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(t) {
    const i = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((r, s) => s[1] - r[1]);
    for (const r of i)
      this.run(r[0]);
    return this.modifiedFlag;
  }
}
class ZE extends QE {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(t) {
    this.run(t);
    for (const n of t.children)
      this.optimize(n);
    return this.modifiedFlag;
  }
}
class Wfe extends ZE {
  mergeNodes(t, n) {
    const i = n.shift();
    for (const r of n)
      t.removeChild(r), r.parent = i, r.remove();
  }
  run(t) {
    const n = t.children.map((r) => r.hash()), i = {};
    for (let r = 0; r < n.length; r++)
      i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
    for (const r of q(i))
      i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]));
  }
}
class Hfe extends ZE {
  constructor(t) {
    super(), this.requiresSelectionId = t && HE(t);
  }
  run(t) {
    t instanceof Fo && (this.requiresSelectionId && (JE(t.parent) || t.parent instanceof Xi || t.parent instanceof en) || (this.setModified(), t.remove()));
  }
}
class Gfe extends QE {
  optimize(t) {
    return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
  }
  run(t, n) {
    let i = /* @__PURE__ */ new Set();
    t instanceof kr && (i = t.producedFields(), U_(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
    for (const r of t.children)
      this.run(r, /* @__PURE__ */ new Set([...n, ...i]));
  }
}
class Vfe extends ZE {
  constructor() {
    super();
  }
  run(t) {
    t instanceof xn && !t.isRequired() && (this.setModified(), t.remove());
  }
}
class Yfe extends hl {
  run(t) {
    if (!JE(t) && !(t.numChildren() > 1)) {
      for (const n of t.children)
        if (n instanceof en)
          if (t instanceof en)
            this.setModified(), t.merge(n);
          else {
            if (q_(t.producedFields(), n.dependentFields()))
              continue;
            this.setModified(), n.swapWithParent();
          }
    }
  }
}
class Xfe extends hl {
  run(t) {
    const n = [...t.children], i = t.children.filter((r) => r instanceof en);
    if (t.numChildren() > 1 && i.length >= 1) {
      const r = {}, s = /* @__PURE__ */ new Set();
      for (const o of i) {
        const a = o.parse;
        for (const l of q(a))
          l in r ? r[l] !== a[l] && s.add(l) : r[l] = a[l];
      }
      for (const o of s)
        delete r[o];
      if (!He(r)) {
        this.setModified();
        const o = new en(t, r);
        for (const a of n) {
          if (a instanceof en)
            for (const l of q(r))
              delete a.parse[l];
          t.removeChild(a), a.parent = o, a instanceof en && q(a.parse).length === 0 && a.remove();
        }
      }
    }
  }
}
class Kfe extends hl {
  run(t) {
    t instanceof xn || t.numChildren() > 0 || t instanceof ec || t instanceof Xa || (this.setModified(), t.remove());
  }
}
class Jfe extends hl {
  run(t) {
    const n = t.children.filter((r) => r instanceof kr), i = n.pop();
    for (const r of n)
      this.setModified(), i.merge(r);
  }
}
class Qfe extends hl {
  run(t) {
    const n = t.children.filter((r) => r instanceof Xi), i = {};
    for (const r of n) {
      const s = Me(r.groupBy);
      s in i || (i[s] = []), i[s].push(r);
    }
    for (const r of q(i)) {
      const s = i[r];
      if (s.length > 1) {
        const o = s.pop();
        for (const a of s)
          o.merge(a) && (t.removeChild(a), a.parent = o, a.remove(), this.setModified());
      }
    }
  }
}
class Zfe extends hl {
  constructor(t) {
    super(), this.model = t;
  }
  run(t) {
    const n = !(JE(t) || t instanceof Zu || t instanceof en || t instanceof Fo), i = [], r = [];
    for (const s of t.children)
      s instanceof Ar && (n && !q_(t.producedFields(), s.dependentFields()) ? i.push(s) : r.push(s));
    if (i.length > 0) {
      const s = i.pop();
      for (const o of i)
        s.merge(o, this.model.renameSignal.bind(this.model));
      this.setModified(), t instanceof Ar ? t.merge(s, this.model.renameSignal.bind(this.model)) : s.swapWithParent();
    }
    if (r.length > 1) {
      const s = r.pop();
      for (const o of r)
        s.merge(o, this.model.renameSignal.bind(this.model));
      this.setModified();
    }
  }
}
class ede extends hl {
  run(t) {
    const n = [...t.children];
    if (!Ba(n, (o) => o instanceof xn) || t.numChildren() <= 1)
      return;
    const r = [];
    let s;
    for (const o of n)
      if (o instanceof xn) {
        let a = o;
        for (; a.numChildren() === 1; ) {
          const [l] = a.children;
          if (l instanceof xn)
            a = l;
          else
            break;
        }
        r.push(...a.children), s ? (t.removeChild(o), o.parent = s.parent, s.parent.removeChild(s), s.parent = a, this.setModified()) : s = a;
      } else
        r.push(o);
    if (r.length) {
      this.setModified();
      for (const o of r)
        o.parent.removeChild(o), o.parent = s;
    }
  }
}
class gl extends We {
  clone() {
    return new gl(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = xr(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? K(t);
  }
  hash() {
    return `JoinAggregateTransform ${Me(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const s of this.transform.joinaggregate)
      n.push(s.op), i.push(this.getDefaultName(s)), t.push(s.field === void 0 ? null : s.field);
    const r = this.transform.groupby;
    return {
      type: "joinaggregate",
      as: i,
      ops: n,
      fields: t,
      ...r !== void 0 ? { groupby: r } : {}
    };
  }
}
function tde(e) {
  return e.stack.stackBy.reduce((t, n) => {
    const i = n.fieldDef, r = K(i);
    return r && t.push(r), t;
  }, []);
}
function nde(e) {
  return j(e) && e.every((t) => Q(t)) && e.length > 1;
}
class vs extends We {
  clone() {
    return new vs(null, me(this._stack));
  }
  constructor(t, n) {
    super(t), this._stack = n;
  }
  static makeFromTransform(t, n) {
    const { stack: i, groupby: r, as: s, offset: o = "zero" } = n, a = [], l = [];
    if (n.sort !== void 0)
      for (const f of n.sort)
        a.push(f.field), l.push(ct(f.order, "ascending"));
    const u = {
      field: a,
      order: l
    };
    let c;
    return nde(s) ? c = s : Q(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new vs(t, {
      dimensionFieldDefs: [],
      stackField: i,
      groupby: r,
      offset: o,
      sort: u,
      facetby: [],
      as: c
    });
  }
  static makeFromEncoding(t, n) {
    const i = n.stack, { encoding: r } = n;
    if (!i)
      return null;
    const { groupbyChannels: s, fieldChannel: o, offset: a, impute: l } = i, u = s.map((h) => {
      const g = r[h];
      return Rr(g);
    }).filter((h) => !!h), c = tde(n), f = n.encoding.order;
    let d;
    if (j(f) || G(f))
      d = m4(f);
    else {
      const h = sL(f) ? f.sort : o === "y" ? "descending" : "ascending";
      d = c.reduce((g, p) => (g.field.push(p), g.order.push(h), g), { field: [], order: [] });
    }
    return new vs(t, {
      dimensionFieldDefs: u,
      stackField: n.vgField(o),
      facetby: [],
      stackby: c,
      sort: d,
      offset: a,
      impute: l,
      as: [
        n.vgField(o, { suffix: "start", forAs: !0 }),
        n.vgField(o, { suffix: "end", forAs: !0 })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(t) {
    this._stack.facetby.push(...t);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${Me(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs: t, impute: n, groupby: i } = this._stack;
    return t.length > 0 ? t.map((r) => r.bin ? n ? [K(r, { binSuffix: "mid" })] : [
      // For binned group by field without impute, we need both bin (start) and bin_end
      K(r, {}),
      K(r, { binSuffix: "end" })
    ] : [K(r)]).flat() : i ?? [];
  }
  assemble() {
    const t = [], { facetby: n, dimensionFieldDefs: i, stackField: r, stackby: s, sort: o, offset: a, impute: l, as: u } = this._stack;
    if (l)
      for (const c of i) {
        const { bandPosition: f = 0.5, bin: d } = c;
        if (d) {
          const h = K(c, { expr: "datum" }), g = K(c, { expr: "datum", binSuffix: "end" });
          t.push({
            type: "formula",
            expr: `${f}*${h}+${1 - f}*${g}`,
            as: K(c, { binSuffix: "mid", forAs: !0 })
          });
        }
        t.push({
          type: "impute",
          field: r,
          groupby: [...s, ...n],
          key: K(c, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    return t.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...n],
      field: r,
      sort: o,
      as: u,
      offset: a
    }), t;
  }
}
class tc extends We {
  clone() {
    return new tc(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = xr(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? K(t);
  }
  hash() {
    return `WindowTransform ${Me(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], i = [], r = [];
    for (const f of this.transform.window)
      n.push(f.op), i.push(this.getDefaultName(f)), r.push(f.param === void 0 ? null : f.param), t.push(f.field === void 0 ? null : f.field);
    const s = this.transform.frame, o = this.transform.groupby;
    if (s && s[0] === null && s[1] === null && n.every((f) => Z_(f)))
      return {
        type: "joinaggregate",
        as: i,
        ops: n,
        fields: t,
        ...o !== void 0 ? { groupby: o } : {}
      };
    const a = [], l = [];
    if (this.transform.sort !== void 0)
      for (const f of this.transform.sort)
        a.push(f.field), l.push(f.order ?? "ascending");
    const u = {
      field: a,
      order: l
    }, c = this.transform.ignorePeers;
    return {
      type: "window",
      params: r,
      as: i,
      ops: n,
      fields: t,
      sort: u,
      ...c !== void 0 ? { ignorePeers: c } : {},
      ...o !== void 0 ? { groupby: o } : {},
      ...s !== void 0 ? { frame: s } : {}
    };
  }
}
function ide(e) {
  function t(n) {
    if (!(n instanceof ec)) {
      const i = n.clone();
      if (i instanceof xn) {
        const r = Fv + i.getSource();
        i.setSource(r), e.model.component.data.outputNodes[r] = i;
      } else
        (i instanceof Xi || i instanceof vs || i instanceof tc || i instanceof gl) && i.addDimensions(e.fields);
      for (const r of n.children.flatMap(t))
        r.parent = i;
      return [i];
    }
    return n.children.flatMap(t);
  }
  return t;
}
function Mv(e) {
  if (e instanceof ec)
    if (e.numChildren() === 1 && !(e.children[0] instanceof xn)) {
      const t = e.children[0];
      (t instanceof Xi || t instanceof vs || t instanceof tc || t instanceof gl) && t.addDimensions(e.fields), t.swapWithParent(), Mv(e);
    } else {
      const t = e.model.component.data.main;
      W8(t);
      const n = ide(e), i = e.children.map(n).flat();
      for (const r of i)
        r.parent = t;
    }
  else
    e.children.map(Mv);
}
function W8(e) {
  if (e instanceof xn && e.type === Xe.Main && e.numChildren() === 1) {
    const t = e.children[0];
    t instanceof ec || (t.swapWithParent(), W8(e));
  }
}
const Fv = "scale_", wh = 5;
function Tv(e) {
  for (const t of e) {
    for (const n of t.children)
      if (n.parent !== t)
        return !1;
    if (!Tv(t.children))
      return !1;
  }
  return !0;
}
function Oi(e, t) {
  let n = !1;
  for (const i of t)
    n = e.optimize(i) || n;
  return n;
}
function AM(e, t, n) {
  let i = e.sources, r = !1;
  return r = Oi(new Vfe(), i) || r, r = Oi(new Hfe(t), i) || r, i = i.filter((s) => s.numChildren() > 0), r = Oi(new Kfe(), i) || r, i = i.filter((s) => s.numChildren() > 0), n || (r = Oi(new Yfe(), i) || r, r = Oi(new Zfe(t), i) || r, r = Oi(new Gfe(), i) || r, r = Oi(new Xfe(), i) || r, r = Oi(new Qfe(), i) || r, r = Oi(new Jfe(), i) || r, r = Oi(new Wfe(), i) || r, r = Oi(new ede(), i) || r), e.sources = i, r;
}
function rde(e, t) {
  Tv(e.sources);
  let n = 0, i = 0;
  for (let r = 0; r < wh && AM(e, t, !0); r++)
    n++;
  e.sources.map(Mv);
  for (let r = 0; r < wh && AM(e, t, !1); r++)
    i++;
  Tv(e.sources), Math.max(n, i) === wh && V(`Maximum optimization runs(${wh}) reached.`);
}
class At {
  constructor(t) {
    Object.defineProperty(this, "signal", {
      enumerable: !0,
      get: t
    });
  }
  static fromName(t, n) {
    return new At(() => t(n));
  }
}
function H8(e) {
  ot(e) ? sde(e) : ode(e);
}
function sde(e) {
  const t = e.component.scales;
  for (const n of q(t)) {
    const i = lde(e, n);
    if (t[n].setWithExplicit("domains", i), cde(e, n), e.component.data.isFaceted) {
      let s = e;
      for (; !Ki(s) && s.parent; )
        s = s.parent;
      if (s.component.resolve.scale[n] === "shared")
        for (const a of i.value)
          ds(a) && (a.data = Fv + a.data.replace(Fv, ""));
    }
  }
}
function ode(e) {
  for (const n of e.children)
    H8(n);
  const t = e.component.scales;
  for (const n of q(t)) {
    let i, r = null;
    for (const s of e.children) {
      const o = s.component.scales[n];
      if (o) {
        i === void 0 ? i = o.getWithExplicit("domains") : i = Co(i, o.getWithExplicit("domains"), "domains", "scale", Ov);
        const a = o.get("selectionExtent");
        r && a && r.param !== a.param && V(ioe), r = a;
      }
    }
    t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);
  }
}
function ade(e, t, n, i) {
  if (e === "unaggregated") {
    const { valid: r, reason: s } = CM(t, n);
    if (!r) {
      V(s);
      return;
    }
  } else if (e === void 0 && i.useUnaggregatedDomain) {
    const { valid: r } = CM(t, n);
    if (r)
      return "unaggregated";
  }
  return e;
}
function lde(e, t) {
  const n = e.getScaleComponent(t).get("type"), { encoding: i } = e, r = ade(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
  return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
    ...e.specifiedScales[t],
    domain: r
  }), t === "x" && bt(i.x2) ? bt(i.x) ? Co(qs(n, r, e, "x"), qs(n, r, e, "x2"), "domain", "scale", Ov) : qs(n, r, e, "x2") : t === "y" && bt(i.y2) ? bt(i.y) ? Co(qs(n, r, e, "y"), qs(n, r, e, "y2"), "domain", "scale", Ov) : qs(n, r, e, "y2") : qs(n, r, e, t);
}
function ude(e, t, n) {
  return e.map((i) => ({ signal: `{data: ${_0(i, { timeUnit: n, type: t })}}` }));
}
function ly(e, t, n) {
  var r;
  const i = (r = Nt(n)) == null ? void 0 : r.unit;
  return t === "temporal" || i ? ude(e, t, i) : [e];
}
function qs(e, t, n, i) {
  const { encoding: r, markDef: s, mark: o, config: a, stack: l } = n, u = bt(r[i]), { type: c } = u, f = u.timeUnit;
  if (Aae(t)) {
    const g = qs(e, void 0, n, i), p = ly(t.unionWith, c, f);
    return pr([...p, ...g.value]);
  } else {
    if (oe(t))
      return pr([t]);
    if (t && t !== "unaggregated" && !q4(t))
      return pr(ly(t, c, f));
  }
  if (l && i === l.fieldChannel) {
    if (l.offset === "normalize")
      return Wn([[0, 1]]);
    const g = n.requestDataName(Xe.Main);
    return Wn([
      {
        data: g,
        field: n.vgField(i, { suffix: "start" })
      },
      {
        data: g,
        field: n.vgField(i, { suffix: "end" })
      }
    ]);
  }
  const d = Ls(i) && G(u) ? fde(n, i, e) : void 0;
  if (Yr(u)) {
    const g = ly([u.datum], c, f);
    return Wn(g);
  }
  const h = u;
  if (t === "unaggregated") {
    const g = n.requestDataName(Xe.Main), { field: p } = u;
    return Wn([
      {
        data: g,
        field: K({ field: p, aggregate: "min" })
      },
      {
        data: g,
        field: K({ field: p, aggregate: "max" })
      }
    ]);
  } else if (Ke(h.bin)) {
    if (Dt(e))
      return Wn(e === "bin-ordinal" ? [] : [
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: Hf(d) ? n.requestDataName(Xe.Main) : n.requestDataName(Xe.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: n.vgField(i, Pd(h, i) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: d === !0 || !ee(d) ? {
            field: n.vgField(i, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : d
        }
      ]);
    {
      const { bin: g } = h;
      if (Ke(g)) {
        const p = KE(n, h.field, g);
        return Wn([
          new At(() => {
            const m = n.getSignalName(p);
            return `[${m}.start, ${m}.stop]`;
          })
        ]);
      } else
        return Wn([
          {
            data: n.requestDataName(Xe.Main),
            field: n.vgField(i, {})
          }
        ]);
    }
  } else if (h.timeUnit && Fe(["time", "utc"], e)) {
    const g = r[Gr(i)];
    if (rL(h, g, s, a)) {
      const p = n.requestDataName(Xe.Main), m = Ao({ fieldDef: h, fieldDef2: g, markDef: s, config: a }), y = Vf(o) && m !== 0.5 && ft(i);
      return Wn([
        {
          data: p,
          field: n.vgField(i, y ? { suffix: $0 } : {})
        },
        {
          data: p,
          field: n.vgField(i, { suffix: y ? M0 : "end" })
        }
      ]);
    }
  }
  return Wn(d ? [
    {
      // If sort by aggregation of a specified sort field, we need to use RAW table,
      // so we can aggregate values for the scale independently from the main aggregation.
      data: Hf(d) ? n.requestDataName(Xe.Main) : n.requestDataName(Xe.Raw),
      field: n.vgField(i),
      sort: d
    }
  ] : [
    {
      data: n.requestDataName(Xe.Main),
      field: n.vgField(i)
    }
  ]);
}
function uy(e, t) {
  const { op: n, field: i, order: r } = e;
  return {
    // Apply default op
    op: n ?? (t ? "sum" : y0),
    // flatten nested fields
    ...i ? { field: Ci(i) } : {},
    ...r ? { order: r } : {}
  };
}
function cde(e, t) {
  var a;
  const n = e.component.scales[t], i = e.specifiedScales[t].domain, r = (a = e.fieldDef(t)) == null ? void 0 : a.bin, s = q4(i) && i, o = ul(r) && c0(r.extent) && r.extent;
  (s || o) && n.set("selectionExtent", s ?? o, !0);
}
function fde(e, t, n) {
  if (!Dt(n))
    return;
  const i = e.fieldDef(t), r = i.sort;
  if (nL(r))
    return {
      op: "min",
      field: Tu(i, t),
      order: "ascending"
    };
  const { stack: s } = e, o = s ? /* @__PURE__ */ new Set([...s.groupbyFields, ...s.stackBy.map((a) => a.fieldDef.field)]) : void 0;
  if (Sr(r)) {
    const a = s && !o.has(r.field);
    return uy(r, a);
  } else if (tL(r)) {
    const { encoding: a, order: l } = r, u = e.fieldDef(a), { aggregate: c, field: f } = u, d = s && !o.has(f);
    if (Ss(c) || qo(c))
      return uy({
        field: K(u),
        order: l
      }, d);
    if (Z_(c) || !c)
      return uy({
        op: c,
        field: f,
        order: l
      }, d);
  } else {
    if (r === "descending")
      return {
        op: "min",
        field: e.vgField(t),
        order: "descending"
      };
    if (Fe([
      "ascending",
      void 0
      /* default =ascending*/
    ], r))
      return !0;
  }
}
function CM(e, t) {
  const { aggregate: n, type: i } = e;
  return n ? Q(n) && !jse.has(n) ? {
    valid: !1,
    reason: Moe(n)
  } : i === "quantitative" && t === "log" ? {
    valid: !1,
    reason: Foe(e)
  } : { valid: !0 } : {
    valid: !1,
    reason: $oe(e)
  };
}
function Ov(e, t, n, i) {
  return e.explicit && t.explicit && V(Roe(n, i, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };
}
function dde(e) {
  const t = xr(e.map((o) => {
    if (ds(o)) {
      const { sort: a, ...l } = o;
      return l;
    }
    return o;
  }), Me), n = xr(e.map((o) => {
    if (ds(o)) {
      const a = o.sort;
      return a !== void 0 && !Hf(a) && ("op" in a && a.op === "count" && delete a.field, a.order === "ascending" && delete a.order), a;
    }
  }).filter((o) => o !== void 0), Me);
  if (t.length === 0)
    return;
  if (t.length === 1) {
    const o = e[0];
    if (ds(o) && n.length > 0) {
      let a = n[0];
      if (n.length > 1) {
        V(L$);
        const l = n.filter((u) => ee(u) && "op" in u && u.op !== "min");
        n.every((u) => ee(u) && "op" in u) && l.length === 1 ? a = l[0] : a = !0;
      } else if (ee(a) && "field" in a) {
        const l = a.field;
        o.field === l && (a = a.order ? { order: a.order } : !0);
      }
      return {
        ...o,
        sort: a
      };
    }
    return o;
  }
  const i = xr(n.map((o) => Hf(o) || !("op" in o) || Q(o.op) && o.op in Pse ? o : (V(Poe(o)), !0)), Me);
  let r;
  i.length === 1 ? r = i[0] : i.length > 1 && (V(L$), r = !0);
  const s = xr(e.map((o) => ds(o) ? o.data : null), (o) => o);
  return s.length === 1 && s[0] !== null ? {
    data: s[0],
    fields: t.map((a) => a.field),
    ...r ? { sort: r } : {}
  } : { fields: t, ...r ? { sort: r } : {} };
}
function eS(e) {
  if (ds(e) && Q(e.field))
    return e.field;
  if (Use(e)) {
    let t;
    for (const n of e.fields)
      if (ds(n) && Q(n.field)) {
        if (!t)
          t = n.field;
        else if (t !== n.field)
          return V(Ioe), t;
      }
    return V(zoe), t;
  } else if (qse(e)) {
    V(Boe);
    const t = e.fields[0];
    return Q(t) ? t : void 0;
  }
}
function D0(e, t) {
  const i = e.component.scales[t].get("domains").map((r) => (ds(r) && (r.data = e.lookupDataSource(r.data)), r));
  return dde(i);
}
function G8(e) {
  return nc(e) || tS(e) ? e.children.reduce((t, n) => t.concat(G8(n)), $M(e)) : $M(e);
}
function $M(e) {
  return q(e.component.scales).reduce((t, n) => {
    const i = e.component.scales[n];
    if (i.merged)
      return t;
    const r = i.combine(), { name: s, type: o, selectionExtent: a, domains: l, range: u, reverse: c, ...f } = r, d = hde(r.range, s, n, e), h = D0(e, n), g = a ? ace(e, a, i, h) : null;
    return t.push({
      name: s,
      type: o,
      ...h ? { domain: h } : {},
      ...g ? { domainRaw: g } : {},
      range: d,
      ...c !== void 0 ? { reverse: c } : {},
      ...f
    }), t;
  }, []);
}
function hde(e, t, n, i) {
  if (ft(n)) {
    if (Wo(e))
      return {
        step: { signal: `${t}_step` }
      };
  } else if (ee(e) && ds(e))
    return {
      ...e,
      data: i.lookupDataSource(e.data)
    };
  return e;
}
class V8 extends Is {
  constructor(t, n) {
    super(
      {},
      // no initial explicit property
      { name: t }
      // name as initial implicit property
    ), this.merged = !1, this.setWithExplicit("type", n);
  }
  /**
   * Whether the scale definitely includes zero in the domain
   */
  domainDefinitelyIncludesZero() {
    return this.get("zero") !== !1 ? !0 : Ba(this.get("domains"), (t) => j(t) && t.length === 2 && Re(t[0]) && t[0] <= 0 && Re(t[1]) && t[1] >= 0);
  }
}
const gde = ["range", "scheme"];
function pde(e) {
  const t = e.component.scales;
  for (const n of u0) {
    const i = t[n];
    if (!i)
      continue;
    const r = mde(n, e);
    i.setWithExplicit("range", r);
  }
}
function MM(e, t) {
  const n = e.fieldDef(t);
  if (n != null && n.bin) {
    const { bin: i, field: r } = n, s = jn(t), o = e.getName(s);
    if (ee(i) && i.binned && i.step !== void 0)
      return new At(() => {
        const a = e.scaleName(t), l = `(domain("${a}")[1] - domain("${a}")[0]) / ${i.step}`;
        return `${e.getSignalName(o)} / (${l})`;
      });
    if (Ke(i)) {
      const a = KE(e, r, i);
      return new At(() => {
        const l = e.getSignalName(a), u = `(${l}.stop - ${l}.start) / ${l}.step`;
        return `${e.getSignalName(o)} / (${u})`;
      });
    }
  }
}
function mde(e, t) {
  const n = t.specifiedScales[e], { size: i } = t, s = t.getScaleComponent(e).get("type");
  for (const f of gde)
    if (n[f] !== void 0) {
      const d = mv(s, f), h = W4(e, f);
      if (!d)
        V(E4(s, f, e));
      else if (h)
        V(h);
      else
        switch (f) {
          case "range": {
            const g = n.range;
            if (j(g)) {
              if (ft(e))
                return pr(g.map((p) => {
                  if (p === "width" || p === "height") {
                    const m = t.getName(p), y = t.getSignalName.bind(t);
                    return At.fromName(y, m);
                  }
                  return p;
                }));
            } else if (ee(g))
              return pr({
                data: t.requestDataName(Xe.Main),
                field: g.field,
                sort: { op: "min", field: t.vgField(e) }
              });
            return pr(g);
          }
          case "scheme":
            return pr(yde(n[f]));
        }
    }
  const o = e === tt || e === "xOffset" ? "width" : "height", a = i[o];
  if (Lr(a)) {
    if (ft(e))
      if (Dt(s)) {
        const f = X8(a, t, e);
        if (f)
          return pr({ step: f });
      } else
        V(S4(o));
    else if (Td(e)) {
      const f = e === Io ? "x" : "y";
      if (t.getScaleComponent(f).get("type") === "band") {
        const g = K8(a, s);
        if (g)
          return pr(g);
      }
    }
  }
  const { rangeMin: l, rangeMax: u } = n, c = bde(e, t);
  return (l !== void 0 || u !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  mv(s, "rangeMin") && j(c) && c.length === 2 ? pr([l ?? c[0], u ?? c[1]]) : Wn(c);
}
function yde(e) {
  return kae(e) ? {
    scheme: e.name,
    ...Nn(e, ["name"])
  } : { scheme: e };
}
function Y8(e, t, n, { center: i } = {}) {
  const r = jn(e), s = t.getName(r), o = t.getSignalName.bind(t);
  return e === Lt && ai(n) ? i ? [
    At.fromName((a) => `${o(a)}/2`, s),
    At.fromName((a) => `-${o(a)}/2`, s)
  ] : [At.fromName(o, s), 0] : i ? [
    At.fromName((a) => `-${o(a)}/2`, s),
    At.fromName((a) => `${o(a)}/2`, s)
  ] : [0, At.fromName(o, s)];
}
function bde(e, t) {
  const { size: n, config: i, mark: r, encoding: s } = t, { type: o } = bt(s[e]), l = t.getScaleComponent(e).get("type"), { domain: u, domainMid: c } = t.specifiedScales[e];
  switch (e) {
    case tt:
    case Lt: {
      if (Fe(["point", "band"], l)) {
        const f = J8(e, n, i.view);
        if (Lr(f))
          return { step: X8(f, t, e) };
      }
      return Y8(e, t, l);
    }
    case Io:
    case Ku:
      return vde(e, t, l);
    case Ds: {
      const f = t.component.scales[e].get("zero"), d = Q8(r, f, i), h = _de(r, n, t, i);
      return Su(l) ? wde(d, h, xde(l, i, u, e)) : [d, h];
    }
    case Fi:
      return [0, Math.PI * 2];
    case al:
      return [0, 360];
    case or:
      return [
        0,
        new At(() => {
          const f = t.getSignalName("width"), d = t.getSignalName("height");
          return `min(${f},${d})/2`;
        })
      ];
    case jo:
      return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
    case Uo:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case Bn:
      return "symbol";
    case zn:
    case Wr:
    case Hr:
      return l === "ordinal" ? o === "nominal" ? "category" : "ordinal" : c !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
    case Rs:
    case zo:
    case Bo:
      return [i.scale.minOpacity, i.scale.maxOpacity];
  }
}
function X8(e, t, n) {
  const { encoding: i } = t, r = t.getScaleComponent(n), s = X_(n), o = i[s];
  if (RL({ step: e, offsetIsDiscrete: be(o) && I4(o.type) }) === "offset" && mL(i, s)) {
    const l = t.getScaleComponent(s);
    let c = `domain('${t.scaleName(s)}').length`;
    if (l.get("type") === "band") {
      const d = l.get("paddingInner") ?? l.get("padding") ?? 0, h = l.get("paddingOuter") ?? l.get("padding") ?? 0;
      c = `bandspace(${c}, ${d}, ${h})`;
    }
    const f = r.get("paddingInner") ?? r.get("padding");
    return {
      signal: `${e.step} * ${c} / (1-${Vse(f)})`
    };
  } else
    return e.step;
}
function K8(e, t) {
  if (RL({ step: e, offsetIsDiscrete: Dt(t) }) === "offset")
    return { step: e.step };
}
function vde(e, t, n) {
  const i = e === Io ? "x" : "y", r = t.getScaleComponent(i);
  if (!r)
    return Y8(i, t, n, { center: !0 });
  const s = r.get("type"), o = t.scaleName(i), { markDef: a, config: l } = t;
  if (s === "band") {
    const u = J8(i, t.size, t.config.view);
    if (Lr(u)) {
      const c = K8(u, n);
      if (c)
        return c;
    }
    return [0, { signal: `bandwidth('${o}')` }];
  } else {
    const u = t.encoding[i];
    if (G(u) && u.timeUnit) {
      const c = D4(u.timeUnit, (g) => `scale('${o}', ${g})`), f = t.config.scale.bandWithNestedOffsetPaddingInner, d = Ao({
        fieldDef: u,
        markDef: a,
        config: l
      }) - 0.5, h = d !== 0 ? ` + ${d}` : "";
      if (f) {
        const g = oe(f) ? `${f.signal}/2` + h : `${f / 2 + d}`, p = oe(f) ? `(1 - ${f.signal}/2)` + h : `${1 - f / 2 + d}`;
        return [{ signal: `${g} * (${c})` }, { signal: `${p} * (${c})` }];
      }
      return [0, { signal: c }];
    }
    return W6(`Cannot use ${e} scale if ${i} scale is not discrete.`);
  }
}
function J8(e, t, n) {
  const i = e === tt ? "width" : "height", r = t[i];
  return r || Fp(n, i);
}
function xde(e, t, n, i) {
  switch (e) {
    case "quantile":
      return t.scale.quantileCount;
    case "quantize":
      return t.scale.quantizeCount;
    case "threshold":
      return n !== void 0 && j(n) ? n.length + 1 : (V(Xoe(i)), 3);
  }
}
function wde(e, t, n) {
  const i = () => {
    const r = Hi(t), s = Hi(e), o = `(${r} - ${s}) / (${n} - 1)`;
    return `sequence(${s}, ${r} + ${o}, ${o})`;
  };
  return oe(t) ? new At(i) : { signal: i() };
}
function Q8(e, t, n) {
  if (t)
    return oe(t) ? { signal: `${t.signal} ? 0 : ${Q8(e, !1, n)}` } : 0;
  switch (e) {
    case "bar":
    case "tick":
      return n.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return n.scale.minStrokeWidth;
    case "text":
      return n.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return n.scale.minSize;
  }
  throw new Error(f0("size", e));
}
const FM = 0.95;
function _de(e, t, n, i) {
  const r = {
    x: MM(n, "x"),
    y: MM(n, "y")
  };
  switch (e) {
    case "bar":
    case "tick": {
      if (i.scale.maxBandSize !== void 0)
        return i.scale.maxBandSize;
      const s = TM(t, r, i.view);
      return Re(s) ? s - 1 : new At(() => `${s.signal} - 1`);
    }
    case "line":
    case "trail":
    case "rule":
      return i.scale.maxStrokeWidth;
    case "text":
      return i.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (i.scale.maxSize)
        return i.scale.maxSize;
      const s = TM(t, r, i.view);
      return Re(s) ? Math.pow(FM * s, 2) : new At(() => `pow(${FM} * ${s.signal}, 2)`);
    }
  }
  throw new Error(f0("size", e));
}
function TM(e, t, n) {
  const i = Lr(e.width) ? e.width.step : Mp(n, "width"), r = Lr(e.height) ? e.height.step : Mp(n, "height");
  return t.x || t.y ? new At(() => `min(${[
    t.x ? t.x.signal : i,
    t.y ? t.y.signal : r
  ].join(", ")})`) : Math.min(i, r);
}
function Z8(e, t) {
  ot(e) ? Ede(e, t) : tP(e, t);
}
function Ede(e, t) {
  const n = e.component.scales, { config: i, encoding: r, markDef: s, specifiedScales: o } = e;
  for (const a of q(n)) {
    const l = o[a], u = n[a], c = e.getScaleComponent(a), f = bt(r[a]), d = l[t], h = c.get("type"), g = c.get("padding"), p = c.get("paddingInner"), m = mv(h, t), y = W4(a, t);
    if (d !== void 0 && (m ? y && V(y) : V(E4(h, t, a))), m && y === void 0)
      if (d !== void 0) {
        const b = f.timeUnit, v = f.type;
        switch (t) {
          case "domainMax":
          case "domainMin":
            cl(l[t]) || v === "temporal" || b ? u.set(t, { signal: _0(l[t], { type: v, timeUnit: b }) }, !0) : u.set(t, l[t], !0);
            break;
          default:
            u.copyKeyFromObject(t, l);
        }
      } else {
        const b = t in OM ? OM[t]({
          model: e,
          channel: a,
          fieldOrDatumDef: f,
          scaleType: h,
          scalePadding: g,
          scalePaddingInner: p,
          domain: l.domain,
          domainMin: l.domainMin,
          domainMax: l.domainMax,
          markDef: s,
          config: i,
          hasNestedOffsetScale: yL(r, a),
          hasSecondaryRangeChannel: !!r[Gr(a)]
        }) : i.scale[t];
        b !== void 0 && u.set(t, b, !1);
      }
  }
}
const OM = {
  bins: ({ model: e, fieldOrDatumDef: t }) => G(t) ? Sde(e, t) : void 0,
  interpolate: ({ channel: e, fieldOrDatumDef: t }) => kde(e, t.type),
  nice: ({ scaleType: e, channel: t, domain: n, domainMin: i, domainMax: r, fieldOrDatumDef: s }) => Ade(e, t, n, i, r, s),
  padding: ({ channel: e, scaleType: t, fieldOrDatumDef: n, markDef: i, config: r }) => Cde(e, t, r.scale, n, i, r.bar),
  paddingInner: ({ scalePadding: e, channel: t, markDef: n, scaleType: i, config: r, hasNestedOffsetScale: s }) => $de(e, t, n.type, i, r.scale, s),
  paddingOuter: ({ scalePadding: e, channel: t, scaleType: n, scalePaddingInner: i, config: r, hasNestedOffsetScale: s }) => Mde(e, t, n, i, r.scale, s),
  reverse: ({ fieldOrDatumDef: e, scaleType: t, channel: n, config: i }) => {
    const r = G(e) ? e.sort : void 0;
    return Fde(t, r, n, i.scale);
  },
  zero: ({ channel: e, fieldOrDatumDef: t, domain: n, markDef: i, scaleType: r, config: s, hasSecondaryRangeChannel: o }) => Tde(e, t, n, i, r, s.scale, o)
};
function eP(e) {
  ot(e) ? pde(e) : tP(e, "range");
}
function tP(e, t) {
  const n = e.component.scales;
  for (const i of e.children)
    t === "range" ? eP(i) : Z8(i, t);
  for (const i of q(n)) {
    let r;
    for (const s of e.children) {
      const o = s.component.scales[i];
      if (o) {
        const a = o.getWithExplicit(t);
        r = Co(r, a, t, "scale", YL((l, u) => {
          switch (t) {
            case "range":
              return l.step && u.step ? l.step - u.step : 0;
          }
          return 0;
        }));
      }
    }
    n[i].setWithExplicit(t, r);
  }
}
function Sde(e, t) {
  const n = t.bin;
  if (Ke(n)) {
    const i = KE(e, t.field, n);
    return new At(() => e.getSignalName(i));
  } else if (zt(n) && ul(n) && n.step !== void 0)
    return {
      step: n.step
    };
}
function kde(e, t) {
  if (Fe([zn, Wr, Hr], e) && t !== "nominal")
    return "hcl";
}
function Ade(e, t, n, i, r, s) {
  var o;
  if (!((o = Rr(s)) != null && o.bin || j(n) || r != null || i != null || Fe([Dn.TIME, Dn.UTC], e)))
    return ft(t) ? !0 : void 0;
}
function Cde(e, t, n, i, r, s) {
  if (ft(e)) {
    if (Gi(t)) {
      if (n.continuousPadding !== void 0)
        return n.continuousPadding;
      const { type: o, orient: a } = r;
      if (o === "bar" && !(G(i) && (i.bin || i.timeUnit)) && (a === "vertical" && e === "x" || a === "horizontal" && e === "y"))
        return s.continuousBandSize;
    }
    if (t === Dn.POINT)
      return n.pointPadding;
  }
}
function $de(e, t, n, i, r, s = !1) {
  if (e === void 0) {
    if (ft(t)) {
      const { bandPaddingInner: o, barBandPaddingInner: a, rectBandPaddingInner: l, bandWithNestedOffsetPaddingInner: u } = r;
      return s ? u : ct(o, n === "bar" ? a : l);
    } else if (Td(t) && i === Dn.BAND)
      return r.offsetBandPaddingInner;
  }
}
function Mde(e, t, n, i, r, s = !1) {
  if (e === void 0) {
    if (ft(t)) {
      const { bandPaddingOuter: o, bandWithNestedOffsetPaddingOuter: a } = r;
      if (s)
        return a;
      if (n === Dn.BAND)
        return ct(
          o,
          /* By default, paddingOuter is paddingInner / 2. The reason is that
            size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
            and we want the width/height to be integer by default.
            Note that step (by default) and cardinality are integers.) */
          oe(i) ? { signal: `${i.signal}/2` } : i / 2
        );
    } else if (Td(t)) {
      if (n === Dn.POINT)
        return 0.5;
      if (n === Dn.BAND)
        return r.offsetBandPaddingOuter;
    }
  }
}
function Fde(e, t, n, i) {
  if (n === "x" && i.xReverse !== void 0)
    return ai(e) && t === "descending" ? oe(i.xReverse) ? { signal: `!${i.xReverse.signal}` } : !i.xReverse : i.xReverse;
  if (ai(e) && t === "descending")
    return !0;
}
function Tde(e, t, n, i, r, s, o) {
  if (!!n && n !== "unaggregated" && ai(r)) {
    if (j(n)) {
      const l = n[0], u = n[n.length - 1];
      if (Re(l) && l <= 0 && Re(u) && u >= 0)
        return !0;
    }
    return !1;
  }
  if (e === "size" && t.type === "quantitative" && !Su(r))
    return !0;
  if (!(G(t) && t.bin) && Fe([...Vr, ...Mse], e)) {
    const { orient: l, type: u } = i;
    return Fe(["bar", "area", "line", "trail"], u) && (l === "horizontal" && e === "y" || l === "vertical" && e === "x") ? !1 : Fe(["bar", "area"], u) && !o ? !0 : s == null ? void 0 : s.zero;
  }
  return !1;
}
function Ode(e, t, n, i, r = !1) {
  const s = Nde(t, n, i, r), { type: o } = e;
  return Ls(t) ? o !== void 0 ? Oae(t, o) ? G(n) && !Tae(o, n.type) ? (V(Noe(o, s)), s) : o : (V(Ooe(t, o, s)), s) : s : null;
}
function Nde(e, t, n, i) {
  var r;
  switch (t.type) {
    case "nominal":
    case "ordinal": {
      if (Vl(e) || ey(e) === "discrete")
        return e === "shape" && t.type === "ordinal" && V(ty(e, "ordinal")), "ordinal";
      if (ft(e) || Td(e)) {
        if (Fe(["rect", "bar", "image", "rule"], n.type) || i)
          return "band";
      } else if (n.type === "arc" && e in Q_)
        return "band";
      const s = n[jn(e)];
      return Ha(s) || Au(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point";
    }
    case "temporal":
      return Vl(e) ? "time" : ey(e) === "discrete" ? (V(ty(e, "temporal")), "ordinal") : G(t) && t.timeUnit && Nt(t.timeUnit).utc ? "utc" : "time";
    case "quantitative":
      return Vl(e) ? G(t) && Ke(t.bin) ? "bin-ordinal" : "linear" : ey(e) === "discrete" ? (V(ty(e, "quantitative")), "ordinal") : "linear";
    case "geojson":
      return;
  }
  throw new Error(w4(t.type));
}
function Dde(e, { ignoreRange: t } = {}) {
  nP(e), H8(e);
  for (const n of Fae)
    Z8(e, n);
  t || eP(e);
}
function nP(e) {
  ot(e) ? e.component.scales = Rde(e) : e.component.scales = Pde(e);
}
function Rde(e) {
  const { encoding: t, mark: n, markDef: i } = e, r = {};
  for (const s of u0) {
    const o = bt(t[s]);
    if (o && n === V4 && s === Bn && o.type === Ju)
      continue;
    let a = o && o.scale;
    if (o && a !== null && a !== !1) {
      a ?? (a = {});
      const l = yL(t, s), u = Ode(a, s, o, i, l);
      r[s] = new V8(e.scaleName(`${s}`, !0), {
        value: u,
        explicit: a.type === u
      });
    }
  }
  return r;
}
const Lde = YL((e, t) => I$(e) - I$(t));
function Pde(e) {
  var t;
  const n = e.component.scales = {}, i = {}, r = e.component.resolve;
  for (const s of e.children) {
    nP(s);
    for (const o of q(s.component.scales))
      if ((t = r.scale)[o] ?? (t[o] = O8(o, e)), r.scale[o] === "shared") {
        const a = i[o], l = s.component.scales[o].getWithExplicit("type");
        a ? xae(a.value, l.value) ? i[o] = Co(a, l, "type", "scale", Lde) : (r.scale[o] = "independent", delete i[o]) : i[o] = l;
      }
  }
  for (const s of q(i)) {
    const o = e.scaleName(s, !0), a = i[s];
    n[s] = new V8(o, a);
    for (const l of e.children) {
      const u = l.component.scales[s];
      u && (l.renameScale(u.get("name"), o), u.merged = !0);
    }
  }
  return n;
}
class cy {
  constructor() {
    this.nameMap = {};
  }
  rename(t, n) {
    this.nameMap[t] = n;
  }
  has(t) {
    return this.nameMap[t] !== void 0;
  }
  get(t) {
    for (; this.nameMap[t] && t !== this.nameMap[t]; )
      t = this.nameMap[t];
    return t;
  }
}
function ot(e) {
  return (e == null ? void 0 : e.type) === "unit";
}
function Ki(e) {
  return (e == null ? void 0 : e.type) === "facet";
}
function tS(e) {
  return (e == null ? void 0 : e.type) === "concat";
}
function nc(e) {
  return (e == null ? void 0 : e.type) === "layer";
}
class nS {
  constructor(t, n, i, r, s, o, a) {
    this.type = n, this.parent = i, this.config = s, this.correctDataNames = (l) => {
      var u, c, f;
      return (u = l.from) != null && u.data && (l.from.data = this.lookupDataSource(l.from.data)), (f = (c = l.from) == null ? void 0 : c.facet) != null && f.data && (l.from.facet.data = this.lookupDataSource(l.from.facet.data)), l;
    }, this.parent = i, this.config = s, this.view = Fn(a), this.name = t.name ?? r, this.title = Ys(t.title) ? { text: t.title } : t.title ? Fn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new cy(), this.projectionNameMap = i ? i.projectionNameMap : new cy(), this.signalNameMap = i ? i.signalNameMap : new cy(), this.data = t.data, this.description = t.description, this.transforms = Wue(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : Yle(t, n, s), this.component = {
      data: {
        sources: i ? i.component.data.sources : [],
        outputNodes: i ? i.component.data.outputNodes : {},
        outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: b0(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
      },
      layoutSize: new Is(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: {
        scale: {},
        axis: {},
        legend: {},
        ...o ? me(o) : {}
      },
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
  }
  parseScale() {
    Dde(this);
  }
  parseProjection() {
    U8(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
  }
  parseLegends() {
    P8(this);
  }
  assembleEncodeFromView(t) {
    const { style: n, ...i } = t, r = {};
    for (const s of q(i)) {
      const o = i[s];
      o !== void 0 && (r[s] = Qe(o));
    }
    return r;
  }
  assembleGroupEncodeEntry(t) {
    let n = {};
    return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = Qe(this.description)), this.type === "unit" || this.type === "layer") ? {
      width: this.getSizeSignalRef("width"),
      height: this.getSizeSignalRef("height"),
      ...n ?? {}
    } : He(n) ? void 0 : n;
  }
  assembleLayout() {
    if (!this.layout)
      return;
    const { spacing: t, ...n } = this.layout, { component: i, config: r } = this, s = rfe(i.layoutHeaders, r);
    return {
      padding: t,
      ...this.assembleDefaultLayout(),
      ...n,
      ...s ? { titleBand: s } : {}
    };
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: t } = this.component;
    let n = [];
    for (const i of mi)
      t[i].title && n.push(Qce(this, i));
    for (const i of GE)
      n = n.concat(Zce(this, i));
    return n;
  }
  assembleAxes() {
    return zce(this.component.axes, this.config);
  }
  assembleLegends() {
    return z8(this);
  }
  assembleProjections() {
    return Cfe(this);
  }
  assembleTitle() {
    const { encoding: t, ...n } = this.title ?? {}, i = {
      ...d4(this.config.title).nonMarkTitleProperties,
      ...n,
      ...t ? { encode: { update: t } } : {}
    };
    if (i.text)
      return Fe(["unit", "layer"], this.type) ? Fe(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), He(i) ? void 0 : i;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(t = []) {
    const n = {};
    t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
    const i = this.assembleLayout();
    i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const r = !this.parent || Ki(this.parent) ? G8(this) : [];
    r.length > 0 && (n.scales = r);
    const s = this.assembleAxes();
    s.length > 0 && (n.axes = s);
    const o = this.assembleLegends();
    return o.length > 0 && (n.legends = o), n;
  }
  getName(t) {
    return et((this.name ? `${this.name}_` : "") + t);
  }
  getDataName(t) {
    return this.getName(Xe[t].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(t) {
    const n = this.getDataName(t), i = this.component.data.outputNodeRefCounts;
    return i[n] = (i[n] || 0) + 1, n;
  }
  getSizeSignalRef(t) {
    if (Ki(this.parent)) {
      const n = F8(t), i = l0(n), r = this.component.scales[i];
      if (r && !r.merged) {
        const s = r.get("type"), o = r.get("range");
        if (Dt(s) && Wo(o)) {
          const a = r.get("name"), l = D0(this, i), u = eS(l);
          if (u) {
            const c = K({ aggregate: "distinct", field: u }, { expr: "datum" });
            return {
              signal: M8(a, r, c)
            };
          } else
            return V(tE(i)), null;
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(t))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(t) {
    const n = this.component.data.outputNodes[t];
    return n ? n.getSource() : t;
  }
  getSignalName(t) {
    return this.signalNameMap.get(t);
  }
  renameSignal(t, n) {
    this.signalNameMap.rename(t, n);
  }
  renameScale(t, n) {
    this.scaleNameMap.rename(t, n);
  }
  renameProjection(t, n) {
    this.projectionNameMap.rename(t, n);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(t, n) {
    if (n)
      return this.getName(t);
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      i4(t) && Ls(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(t))
    )
      return this.scaleNameMap.get(this.getName(t));
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(t) {
    if (t)
      return this.getName("projection");
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")))
      return this.projectionNameMap.get(this.getName("projection"));
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(t) {
    if (!this.component.scales)
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    const n = this.component.scales[t];
    return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(t, n) {
    let i = this.component.selection[t];
    if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i)
      throw new Error(Qse(n));
    return i;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var t, n;
    return ((t = this.component.axes.x) == null ? void 0 : t.some((i) => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some((i) => i.hasOrientSignalRef()));
  }
}
class iP extends nS {
  /** Get "field" reference for Vega */
  vgField(t, n = {}) {
    const i = this.fieldDef(t);
    if (i)
      return K(i, n);
  }
  reduceFieldDef(t, n) {
    return Ele(this.getMapping(), (i, r, s) => {
      const o = Rr(r);
      return o ? t(i, o, s) : i;
    }, n);
  }
  forEachFieldDef(t, n) {
    $E(this.getMapping(), (i, r) => {
      const s = Rr(i);
      s && t(s, r);
    }, n);
  }
}
class R0 extends We {
  clone() {
    return new R0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "value", i[1] ?? "density"];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { density: t, ...n } = this.transform, i = {
      type: "kde",
      field: t,
      ...n
    };
    return this.transform.groupby && (i.resolve = "shared"), i;
  }
}
class L0 extends We {
  clone() {
    return new L0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.extent]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([]);
  }
  hash() {
    return `ExtentTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { extent: t, param: n } = this.transform;
    return {
      type: "extent",
      field: t,
      signal: n
    };
  }
}
class Xf extends We {
  clone() {
    return new Xf(null, { ...this.filter });
  }
  constructor(t, n) {
    super(t), this.filter = n;
  }
  static make(t, n) {
    const { config: i, mark: r, markDef: s } = n;
    if (Ue("invalid", s, i) !== "filter")
      return null;
    const a = n.reduceFieldDef((l, u, c) => {
      const f = Ls(c) && n.getScaleComponent(c);
      if (f) {
        const d = f.get("type");
        ai(d) && u.aggregate !== "count" && !Ho(r) && (l[u.field] = u);
      }
      return l;
    }, {});
    return q(a).length ? new Xf(t, a) : null;
  }
  dependentFields() {
    return new Set(q(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${Me(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const t = q(this.filter).reduce((n, i) => {
      const r = this.filter[i], s = K(r, { expr: "datum" });
      return r !== null && (r.type === "temporal" ? n.push(`(isDate(${s}) || (isValid(${s}) && isFinite(+${s})))`) : r.type === "quantitative" && (n.push(`isValid(${s})`), n.push(`isFinite(+${s})`))), n;
    }, []);
    return t.length > 0 ? {
      type: "filter",
      expr: t.join(" && ")
    } : null;
  }
}
class P0 extends We {
  clone() {
    return new P0(this.parent, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const { flatten: i, as: r = [] } = this.transform;
    this.transform.as = i.map((s, o) => r[o] ?? s);
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { flatten: t, as: n } = this.transform;
    return {
      type: "flatten",
      fields: t,
      as: n
    };
  }
}
class I0 extends We {
  clone() {
    return new I0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "key", i[1] ?? "value"];
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { fold: t, as: n } = this.transform;
    return {
      type: "fold",
      fields: t,
      as: n
    };
  }
}
class Kl extends We {
  clone() {
    return new Kl(null, me(this.fields), this.geojson, this.signal);
  }
  static parseAll(t, n) {
    if (n.component.projection && !n.component.projection.isFit)
      return t;
    let i = 0;
    for (const r of [
      [lr, ar],
      [$i, ur]
    ]) {
      const s = r.map((o) => {
        const a = bt(n.encoding[o]);
        return G(a) ? a.field : Yr(a) ? { expr: `${a.datum}` } : er(a) ? { expr: `${a.value}` } : void 0;
      });
      (s[0] || s[1]) && (t = new Kl(t, s, null, n.getName(`geojson_${i++}`)));
    }
    if (n.channelHasField(Bn)) {
      const r = n.typedFieldDef(Bn);
      r.type === Ju && (t = new Kl(t, null, r.field, n.getName(`geojson_${i++}`)));
    }
    return t;
  }
  constructor(t, n, i, r) {
    super(t), this.fields = n, this.geojson = i, this.signal = r;
  }
  dependentFields() {
    const t = (this.fields ?? []).filter(Q);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${Me(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      {
        type: "geojson",
        ...this.fields ? { fields: this.fields } : {},
        ...this.geojson ? { geojson: this.geojson } : {},
        signal: this.signal
      }
    ];
  }
}
class Kf extends We {
  clone() {
    return new Kf(null, this.projection, me(this.fields), me(this.as));
  }
  constructor(t, n, i, r) {
    super(t), this.projection = n, this.fields = i, this.as = r;
  }
  static parseAll(t, n) {
    if (!n.projectionName())
      return t;
    for (const i of [
      [lr, ar],
      [$i, ur]
    ]) {
      const r = i.map((o) => {
        const a = bt(n.encoding[o]);
        return G(a) ? a.field : Yr(a) ? { expr: `${a.datum}` } : er(a) ? { expr: `${a.value}` } : void 0;
      }), s = i[0] === $i ? "2" : "";
      (r[0] || r[1]) && (t = new Kf(t, n.projectionName(), r, [
        n.getName(`x${s}`),
        n.getName(`y${s}`)
      ]));
    }
    return t;
  }
  dependentFields() {
    return new Set(this.fields.filter(Q));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${Me(this.fields)} ${Me(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
}
class Ca extends We {
  clone() {
    return new Ca(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(t) {
    const { start: n = 0, stop: i, step: r } = t;
    return { signal: `sequence(${[n, i, ...r ? [r] : []].join(",")})` };
  }
  static makeFromTransform(t, n) {
    return new Ca(t, n);
  }
  static makeFromEncoding(t, n) {
    const i = n.encoding, r = i.x, s = i.y;
    if (G(r) && G(s)) {
      const o = r.impute ? r : s.impute ? s : void 0;
      if (o === void 0)
        return;
      const a = r.impute ? s : s.impute ? r : void 0, { method: l, value: u, frame: c, keyvals: f } = o.impute, d = vL(n.mark, i);
      return new Ca(t, {
        impute: o.field,
        key: a.field,
        ...l ? { method: l } : {},
        ...u !== void 0 ? { value: u } : {},
        ...c ? { frame: c } : {},
        ...f !== void 0 ? { keyvals: f } : {},
        ...d.length ? { groupby: d } : {}
      });
    }
    return null;
  }
  hash() {
    return `Impute ${Me(this.transform)}`;
  }
  assemble() {
    const { impute: t, key: n, keyvals: i, method: r, groupby: s, value: o, frame: a = [null, null] } = this.transform, l = {
      type: "impute",
      field: t,
      key: n,
      ...i ? { keyvals: kue(i) ? this.processSequence(i) : i } : {},
      method: "value",
      ...s ? { groupby: s } : {},
      value: !r || r === "value" ? o : null
    };
    if (r && r !== "value") {
      const u = {
        type: "window",
        as: [`imputed_${t}_value`],
        ops: [r],
        fields: [t],
        frame: a,
        ignorePeers: !1,
        ...s ? { groupby: s } : {}
      }, c = {
        type: "formula",
        expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
        as: t
      };
      return [l, u, c];
    } else
      return [l];
  }
}
class z0 extends We {
  clone() {
    return new z0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? n.on, i[1] ?? n.loess];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { loess: t, on: n, ...i } = this.transform;
    return {
      type: "loess",
      x: n,
      y: t,
      ...i
    };
  }
}
class Jf extends We {
  clone() {
    return new Jf(null, me(this.transform), this.secondary);
  }
  constructor(t, n, i) {
    super(t), this.transform = n, this.secondary = i;
  }
  static make(t, n, i, r) {
    const s = n.component.data.sources, { from: o } = i;
    let a = null;
    if (Aue(o)) {
      let l = oP(o.data, s);
      l || (l = new Xa(o.data), s.push(l));
      const u = n.getName(`lookup_${r}`);
      a = new xn(l, u, Xe.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[u] = a;
    } else if (Cue(o)) {
      const l = o.param;
      i = { as: l, ...i };
      let u;
      try {
        u = n.getSelectionComponent(et(l), l);
      } catch {
        throw new Error(toe(l));
      }
      if (a = u.materialized, !a)
        throw new Error(noe(l));
    }
    return new Jf(t, i, a.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? J(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${Me({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let t;
    if (this.transform.from.fields)
      t = {
        values: this.transform.from.fields,
        ...this.transform.as ? { as: J(this.transform.as) } : {}
      };
    else {
      let n = this.transform.as;
      Q(n) || (V(coe), n = "_lookup"), t = {
        as: [n]
      };
    }
    return {
      type: "lookup",
      from: this.secondary,
      key: this.transform.from.key,
      fields: [this.transform.lookup],
      ...t,
      ...this.transform.default ? { default: this.transform.default } : {}
    };
  }
}
class B0 extends We {
  clone() {
    return new B0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "prob", i[1] ?? "value"];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { quantile: t, ...n } = this.transform;
    return {
      type: "quantile",
      field: t,
      ...n
    };
  }
}
class j0 extends We {
  clone() {
    return new j0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = me(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? n.on, i[1] ?? n.regression];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { regression: t, on: n, ...i } = this.transform;
    return {
      type: "regression",
      x: n,
      y: t,
      ...i
    };
  }
}
class U0 extends We {
  clone() {
    return new U0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = xr((this.transform.groupby ?? []).concat(t), (n) => n);
  }
  producedFields() {
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
  }
  hash() {
    return `PivotTransform ${Me(this.transform)}`;
  }
  assemble() {
    const { pivot: t, value: n, groupby: i, limit: r, op: s } = this.transform;
    return {
      type: "pivot",
      field: t,
      value: n,
      ...r !== void 0 ? { limit: r } : {},
      ...s !== void 0 ? { op: s } : {},
      ...i !== void 0 ? { groupby: i } : {}
    };
  }
}
class q0 extends We {
  clone() {
    return new q0(null, me(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${Me(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
}
function rP(e) {
  let t = 0;
  function n(i, r) {
    if (i instanceof Xa && !i.isGenerator && !$u(i.data) && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }), i instanceof en && (i.parent instanceof Xa && !r.source ? (r.format = {
      ...r.format ?? {},
      parse: i.assembleFormatParse()
    }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof ec) {
      r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
      return;
    }
    switch ((i instanceof Bd || i instanceof jd || i instanceof Xf || i instanceof Zu || i instanceof Fu || i instanceof Kf || i instanceof Xi || i instanceof Jf || i instanceof tc || i instanceof gl || i instanceof I0 || i instanceof P0 || i instanceof R0 || i instanceof z0 || i instanceof B0 || i instanceof j0 || i instanceof Fo || i instanceof q0 || i instanceof U0 || i instanceof L0) && r.transform.push(i.assemble()), (i instanceof Ar || i instanceof kr || i instanceof Ca || i instanceof vs || i instanceof Kl) && r.transform.push(...i.assemble()), i instanceof xn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof xn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }))), i.numChildren()) {
      case 0:
        i instanceof xn && (!r.source || r.transform.length > 0) && e.push(r);
        break;
      case 1:
        n(i.children[0], r);
        break;
      default: {
        r.name || (r.name = `data_${t++}`);
        let s = r.name;
        !r.source || r.transform.length > 0 ? e.push(r) : s = r.source;
        for (const o of i.children)
          n(o, {
            name: null,
            source: s,
            transform: []
          });
        break;
      }
    }
  }
  return n;
}
function Ide(e) {
  const t = [], n = rP(t);
  for (const i of e.children)
    n(i, {
      source: e.name,
      name: null,
      transform: []
    });
  return t;
}
function zde(e, t) {
  const n = [], i = rP(n);
  let r = 0;
  for (const o of e.sources) {
    o.hasName() || (o.dataName = `source_${r++}`);
    const a = o.assemble();
    i(o, a);
  }
  for (const o of n)
    o.transform.length === 0 && delete o.transform;
  let s = 0;
  for (const [o, a] of n.entries())
    (a.transform ?? []).length === 0 && !a.source && n.splice(s++, 0, n.splice(o, 1)[0]);
  for (const o of n)
    for (const a of o.transform ?? [])
      a.type === "lookup" && (a.from = e.outputNodes[a.from].getSource());
  for (const o of n)
    o.name in t && (o.values = t[o.name]);
  return n;
}
function Bde(e) {
  return e === "top" || e === "left" || oe(e) ? "header" : "footer";
}
function jde(e) {
  for (const t of mi)
    Ude(e, t);
  NM(e, "x"), NM(e, "y");
}
function Ude(e, t) {
  var o;
  const { facet: n, config: i, child: r, component: s } = e;
  if (e.channelHasField(t)) {
    const a = n[t], l = Ou("title", null, i, t);
    let u = Yl(a, i, {
      allowDisabling: !0,
      includeDefault: l === void 0 || !!l
    });
    r.component.layoutHeaders[t].title && (u = j(u) ? u.join(", ") : u, u += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
    const c = Ou("labelOrient", a.header, i, t), f = a.header !== null ? ct((o = a.header) == null ? void 0 : o.labels, i.header.labels, !0) : !1, d = Fe(["bottom", "right"], c) ? "footer" : "header";
    s.layoutHeaders[t] = {
      title: a.header !== null ? u : null,
      facetFieldDef: a,
      [d]: t === "facet" ? [] : [sP(e, t, f)]
    };
  }
}
function sP(e, t, n) {
  const i = t === "row" ? "height" : "width";
  return {
    labels: n,
    sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
    axes: []
  };
}
function NM(e, t) {
  const { child: n } = e;
  if (n.component.axes[t]) {
    const { layoutHeaders: i, resolve: r } = e.component;
    if (r.axis[t] = XE(r, t), r.axis[t] === "shared") {
      const s = t === "x" ? "column" : "row", o = i[s];
      for (const a of n.component.axes[t]) {
        const l = Bde(a.get("orient"));
        o[l] ?? (o[l] = [sP(e, s, !1)]);
        const u = Jc(a, "main", e.config, { header: !0 });
        u && o[l][0].axes.push(u), a.mainExtracted = !0;
      }
    }
  }
}
function qde(e) {
  iS(e), Dp(e, "width"), Dp(e, "height");
}
function Wde(e) {
  iS(e);
  const t = e.layout.columns === 1 ? "width" : "childWidth", n = e.layout.columns === void 0 ? "height" : "childHeight";
  Dp(e, t), Dp(e, n);
}
function iS(e) {
  for (const t of e.children)
    t.parseLayoutSize();
}
function Dp(e, t) {
  const n = F8(t), i = l0(n), r = e.component.resolve, s = e.component.layoutSize;
  let o;
  for (const a of e.children) {
    const l = a.component.layoutSize.getWithExplicit(n), u = r.scale[i] ?? O8(i, e);
    if (u === "independent" && l.value === "step") {
      o = void 0;
      break;
    }
    if (o) {
      if (u === "independent" && o.value !== l.value) {
        o = void 0;
        break;
      }
      o = Co(o, l, n, "");
    } else
      o = l;
  }
  if (o) {
    for (const a of e.children)
      e.renameSignal(a.getName(n), e.getName(t)), a.component.layoutSize.set(n, "merged", !1);
    s.setWithExplicit(t, o);
  } else
    s.setWithExplicit(t, {
      explicit: !1,
      value: void 0
    });
}
function Hde(e) {
  const { size: t, component: n } = e;
  for (const i of Vr) {
    const r = jn(i);
    if (t[r]) {
      const s = t[r];
      n.layoutSize.set(r, Lr(s) ? "step" : s, !0);
    } else {
      const s = Gde(e, r);
      n.layoutSize.set(r, s, !1);
    }
  }
}
function Gde(e, t) {
  const n = t === "width" ? "x" : "y", i = e.config, r = e.getScaleComponent(n);
  if (r) {
    const s = r.get("type"), o = r.get("range");
    if (Dt(s)) {
      const a = Fp(i.view, t);
      return Wo(o) || Lr(a) ? "step" : a;
    } else
      return vv(i.view, t);
  } else {
    if (e.hasProjection || e.mark === "arc")
      return vv(i.view, t);
    {
      const s = Fp(i.view, t);
      return Lr(s) ? s.step : s;
    }
  }
}
function Nv(e, t, n) {
  return K(t, { suffix: `by_${K(e)}`, ...n ?? {} });
}
class pf extends iP {
  constructor(t, n, i, r) {
    super(t, "facet", n, i, r, t.resolve), this.child = lS(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet);
  }
  initFacet(t) {
    if (!Rd(t))
      return { facet: this.initFacetFieldDef(t, "facet") };
    const n = q(t), i = {};
    for (const r of n) {
      if (![ms, ys].includes(r)) {
        V(f0(r, "facet"));
        break;
      }
      const s = t[r];
      if (s.field === void 0) {
        V(gv(s, r));
        break;
      }
      i[r] = this.initFacetFieldDef(s, r);
    }
    return i;
  }
  initFacetFieldDef(t, n) {
    const i = AE(t, n);
    return i.header ? i.header = Fn(i.header) : i.header === null && (i.header = null), i;
  }
  channelHasField(t) {
    return !!this.facet[t];
  }
  fieldDef(t) {
    return this.facet[t];
  }
  parseData() {
    this.component.data = W0(this), this.child.parseData();
  }
  parseLayoutSize() {
    iS(this);
  }
  parseSelections() {
    this.child.parseSelections(), this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders(), jde(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.child.assembleSelectionTopLevelSignals(t);
  }
  assembleSignals() {
    return this.child.assembleSignals(), [];
  }
  assembleSelectionData(t) {
    return this.child.assembleSelectionData(t);
  }
  getHeaderLayoutMixins() {
    const t = {};
    for (const n of mi)
      for (const i of VE) {
        const r = this.component.layoutHeaders[n], s = r[i], { facetFieldDef: o } = r;
        if (o) {
          const a = Ou("titleOrient", o.header, this.config, n);
          if (["right", "bottom"].includes(a)) {
            const l = O0(n, a);
            t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[l] = "end";
          }
        }
        if (s != null && s[0]) {
          const a = n === "row" ? "height" : "width", l = i === "header" ? "headerBand" : "footerBand";
          n !== "facet" && !this.child.component.layoutSize.get(a) && (t[l] ?? (t[l] = {}), t[l][n] = 0.5), r.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10);
        }
      }
    return t;
  }
  assembleDefaultLayout() {
    const { column: t, row: n } = this.facet, i = t ? this.columnDistinctSignal() : n ? 1 : void 0;
    let r = "all";
    return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), {
      ...this.getHeaderLayoutMixins(),
      ...i ? { columns: i } : {},
      bounds: "full",
      align: r
    };
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (!(this.parent && this.parent instanceof pf))
      return { signal: `length(data('${this.getName("column_domain")}'))` };
  }
  assembleGroupStyle() {
  }
  assembleGroup(t) {
    return this.parent && this.parent instanceof pf ? {
      ...this.channelHasField("column") ? {
        encode: {
          update: {
            // TODO(https://github.com/vega/vega-lite/issues/2759):
            // Correct the signal for facet of concat of facet_column
            columns: { field: K(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {},
      ...super.assembleGroup(t)
    } : super.assembleGroup(t);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const t = [], n = [], i = [];
    if (this.child instanceof pf) {
      if (this.child.channelHasField("column")) {
        const r = K(this.child.facet.column);
        t.push(r), n.push("distinct"), i.push(`distinct_${r}`);
      }
    } else
      for (const r of Vr) {
        const s = this.child.component.scales[r];
        if (s && !s.merged) {
          const o = s.get("type"), a = s.get("range");
          if (Dt(o) && Wo(a)) {
            const l = D0(this.child, r), u = eS(l);
            u ? (t.push(u), n.push("distinct"), i.push(`distinct_${u}`)) : V(tE(r));
          }
        }
      }
    return { fields: t, ops: n, as: i };
  }
  assembleFacet() {
    const { name: t, data: n } = this.component.data.facetRoot, { row: i, column: r } = this.facet, { fields: s, ops: o, as: a } = this.getCardinalityAggregateForChild(), l = [];
    for (const c of mi) {
      const f = this.facet[c];
      if (f) {
        l.push(K(f));
        const { bin: d, sort: h } = f;
        if (Ke(d) && l.push(K(f, { binSuffix: "end" })), Sr(h)) {
          const { field: g, op: p = y0 } = h, m = Nv(f, h);
          i && r ? (s.push(m), o.push("max"), a.push(m)) : (s.push(g), o.push(p), a.push(m));
        } else if (j(h)) {
          const g = Tu(f, c);
          s.push(g), o.push("max"), a.push(g);
        }
      }
    }
    const u = !!i && !!r;
    return {
      name: t,
      data: n,
      groupby: l,
      ...u || s.length > 0 ? {
        aggregate: {
          ...u ? { cross: u } : {},
          ...s.length ? { fields: s, ops: o, as: a } : {}
        }
      } : {}
    };
  }
  facetSortFields(t) {
    const { facet: n } = this, i = n[t];
    return i ? Sr(i.sort) ? [Nv(i, i.sort, { expr: "datum" })] : j(i.sort) ? [Tu(i, t, { expr: "datum" })] : [K(i, { expr: "datum" })] : [];
  }
  facetSortOrder(t) {
    const { facet: n } = this, i = n[t];
    if (i) {
      const { sort: r } = i;
      return [(Sr(r) ? r.order : !j(r) && r) || "ascending"];
    }
    return [];
  }
  assembleLabelTitle() {
    var r;
    const { facet: t, config: n } = this;
    if (t.facet)
      return Cv(t.facet, "facet", n);
    const i = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const s of GE)
      if (t[s]) {
        const o = Ou("labelOrient", (r = t[s]) == null ? void 0 : r.header, n, s);
        if (i[s].includes(o))
          return Cv(t[s], s, n);
      }
  }
  assembleMarks() {
    const { child: t } = this, n = this.component.data.facetRoot, i = Ide(n), r = t.assembleGroupEncodeEntry(!1), s = this.assembleLabelTitle() || t.assembleTitle(), o = t.assembleGroupStyle();
    return [{
      name: this.getName("cell"),
      type: "group",
      ...s ? { title: s } : {},
      ...o ? { style: o } : {},
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: mi.map((l) => this.facetSortFields(l)).flat(),
        order: mi.map((l) => this.facetSortOrder(l)).flat()
      },
      ...i.length > 0 ? { data: i } : {},
      ...r ? { encode: { update: r } } : {},
      ...t.assembleGroup(ice(this, []))
    }];
  }
  getMapping() {
    return this.facet;
  }
}
function Vde(e, t) {
  const { row: n, column: i } = t;
  if (n && i) {
    let r = null;
    for (const s of [n, i])
      if (Sr(s.sort)) {
        const { field: o, op: a = y0 } = s.sort;
        e = r = new gl(e, {
          joinaggregate: [
            {
              op: a,
              field: o,
              as: Nv(s, s.sort, { forAs: !0 })
            }
          ],
          groupby: [K(s)]
        });
      }
    return r;
  }
  return null;
}
function oP(e, t) {
  var n, i, r, s;
  for (const o of t) {
    const a = o.data;
    if (e.name && o.hasName() && e.name !== o.dataName)
      continue;
    const l = (n = e.format) == null ? void 0 : n.mesh, u = (i = a.format) == null ? void 0 : i.feature;
    if (l && u)
      continue;
    const c = (r = e.format) == null ? void 0 : r.feature;
    if ((c || u) && c !== u)
      continue;
    const f = (s = a.format) == null ? void 0 : s.mesh;
    if (!((l || f) && l !== f)) {
      if (Yf(e) && Yf(a)) {
        if (Kn(e.values, a.values))
          return o;
      } else if ($u(e) && $u(a)) {
        if (e.url === a.url)
          return o;
      } else if (XL(e) && e.name === o.dataName)
        return o;
    }
  }
  return null;
}
function Yde(e, t) {
  if (e.data || !e.parent) {
    if (e.data === null) {
      const i = new Xa({ values: [] });
      return t.push(i), i;
    }
    const n = oP(e.data, t);
    if (n)
      return co(e.data) || (n.data.format = H6({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;
    {
      const i = new Xa(e.data);
      return t.push(i), i;
    }
  } else
    return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;
}
function Xde(e, t, n) {
  let i = 0;
  for (const r of t.transforms) {
    let s, o;
    if (Pue(r))
      o = e = new Fu(e, r), s = "derived";
    else if (zE(r)) {
      const a = Bfe(r);
      o = e = en.makeWithAncestors(e, {}, a, n) ?? e, e = new Zu(e, t, r.filter);
    } else if (WL(r))
      o = e = Ar.makeFromTransform(e, r, t), s = "number";
    else if (zue(r))
      s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new en(e, { [r.field]: s }), n.set(r.field, s, !1)), o = e = kr.makeFromTransform(e, r);
    else if (Bue(r))
      o = e = Xi.makeFromTransform(e, r), s = "number", HE(t) && (e = new Fo(e));
    else if (qL(r))
      o = e = Jf.make(e, t, r, i++), s = "derived";
    else if (Due(r))
      o = e = new tc(e, r), s = "number";
    else if (Rue(r))
      o = e = new gl(e, r), s = "number";
    else if (jue(r))
      o = e = vs.makeFromTransform(e, r), s = "derived";
    else if (Uue(r))
      o = e = new I0(e, r), s = "derived";
    else if (que(r))
      o = e = new L0(e, r), s = "derived";
    else if (Lue(r))
      o = e = new P0(e, r), s = "derived";
    else if ($ue(r))
      o = e = new U0(e, r), s = "derived";
    else if (Nue(r))
      e = new q0(e, r);
    else if (Iue(r))
      o = e = Ca.makeFromTransform(e, r), s = "derived";
    else if (Mue(r))
      o = e = new R0(e, r), s = "derived";
    else if (Fue(r))
      o = e = new B0(e, r), s = "derived";
    else if (Tue(r))
      o = e = new j0(e, r), s = "derived";
    else if (Oue(r))
      o = e = new z0(e, r), s = "derived";
    else {
      V(uoe(r));
      continue;
    }
    if (o && s !== void 0)
      for (const a of o.producedFields() ?? [])
        n.set(a, s, !1);
  }
  return e;
}
function W0(e) {
  var p;
  let t = Yde(e, e.component.data.sources);
  const { outputNodes: n, outputNodeRefCounts: i } = e.component.data, r = e.data, o = !(r && (co(r) || $u(r) || Yf(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new tce();
  co(r) ? (KL(r) ? t = new jd(t, r.sequence) : BE(r) && (t = new Bd(t, r.graticule)), o.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (o.parseNothing = !0), t = en.makeExplicit(t, e, o) ?? t, t = new Fo(t);
  const a = e.parent && nc(e.parent);
  (ot(e) || Ki(e)) && a && (t = Ar.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Xde(t, e, o));
  const l = Ufe(e), u = jfe(e);
  t = en.makeWithAncestors(t, {}, { ...l, ...u }, o) ?? t, ot(e) && (t = Kl.parseAll(t, e), t = Kf.parseAll(t, e)), (ot(e) || Ki(e)) && (a || (t = Ar.makeFromEncoding(t, e) ?? t), t = kr.makeFromEncoding(t, e) ?? t, t = Fu.parseAllForSortIndex(t, e));
  const c = e.getDataName(Xe.Raw), f = new xn(t, c, Xe.Raw, i);
  if (n[c] = f, t = f, ot(e)) {
    const m = Xi.makeFromEncoding(t, e);
    m && (t = m, HE(e) && (t = new Fo(t))), t = Ca.makeFromEncoding(t, e) ?? t, t = vs.makeFromEncoding(t, e) ?? t;
  }
  ot(e) && (t = Xf.make(t, e) ?? t);
  const d = e.getDataName(Xe.Main), h = new xn(t, d, Xe.Main, i);
  n[d] = h, t = h, ot(e) && Pce(e, h);
  let g = null;
  if (Ki(e)) {
    const m = e.getName("facet");
    t = Vde(t, e.facet) ?? t, g = new ec(t, e, m, h.getSource()), n[m] = g;
  }
  return {
    ...e.component.data,
    outputNodes: n,
    outputNodeRefCounts: i,
    raw: f,
    main: h,
    facetRoot: g,
    ancestorParse: o
  };
}
class Kde extends nS {
  constructor(t, n, i, r) {
    var s, o, a, l;
    super(t, "concat", n, i, r, t.resolve), (((o = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : o.x) === "shared" || ((l = (a = t.resolve) == null ? void 0 : a.axis) == null ? void 0 : l.y) === "shared") && V(ooe), this.children = this.getChildren(t).map((u, c) => lS(u, this, this.getName(`concat_${c}`), void 0, r));
  }
  parseData() {
    this.component.data = W0(this);
    for (const t of this.children)
      t.parseData();
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of q(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    for (const t of this.children)
      t.parseAxesAndHeaders();
  }
  getChildren(t) {
    return k0(t) ? t.vconcat : PE(t) ? t.hconcat : t.concat;
  }
  parseLayoutSize() {
    Wde(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  assembleSignals() {
    return this.children.forEach((t) => t.assembleSignals()), [];
  }
  assembleLayoutSignals() {
    const t = YE(this);
    for (const n of this.children)
      t.push(...n.assembleLayoutSignals());
    return t;
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleMarks() {
    return this.children.map((t) => {
      const n = t.assembleTitle(), i = t.assembleGroupStyle(), r = t.assembleGroupEncodeEntry(!1);
      return {
        type: "group",
        name: t.getName("group"),
        ...n ? { title: n } : {},
        ...i ? { style: i } : {},
        ...r ? { encode: { update: r } } : {},
        ...t.assembleGroup()
      };
    });
  }
  assembleGroupStyle() {
  }
  assembleDefaultLayout() {
    const t = this.layout.columns;
    return {
      ...t != null ? { columns: t } : {},
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    };
  }
}
function Jde(e) {
  return e === !1 || e === null;
}
const Qde = {
  disable: 1,
  gridScale: 1,
  scale: 1,
  ...gL,
  labelExpr: 1,
  encode: 1
}, aP = q(Qde);
class rS extends Is {
  constructor(t = {}, n = {}, i = !1) {
    super(), this.explicit = t, this.implicit = n, this.mainExtracted = i;
  }
  clone() {
    return new rS(me(this.explicit), me(this.implicit), this.mainExtracted);
  }
  hasAxisPart(t) {
    return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !Jde(this.get(t));
  }
  hasOrientSignalRef() {
    return oe(this.explicit.orient);
  }
}
function Zde(e, t, n) {
  const { encoding: i, config: r } = e, s = bt(i[t]) ?? bt(i[Gr(t)]), o = e.axis(t) || {}, { format: a, formatType: l } = o;
  if (Ga(l))
    return {
      text: Vi({
        fieldOrDatumDef: s,
        field: "datum.value",
        format: a,
        formatType: l,
        config: r
      }),
      ...n
    };
  if (a === void 0 && l === void 0 && r.customFormatTypes) {
    if (ku(s) === "quantitative") {
      if (Au(s) && s.stack === "normalize" && r.normalizedNumberFormatType)
        return {
          text: Vi({
            fieldOrDatumDef: s,
            field: "datum.value",
            format: r.normalizedNumberFormat,
            formatType: r.normalizedNumberFormatType,
            config: r
          }),
          ...n
        };
      if (r.numberFormatType)
        return {
          text: Vi({
            fieldOrDatumDef: s,
            field: "datum.value",
            format: r.numberFormat,
            formatType: r.numberFormatType,
            config: r
          }),
          ...n
        };
    }
    if (ku(s) === "temporal" && r.timeFormatType && G(s) && !s.timeUnit)
      return {
        text: Vi({
          fieldOrDatumDef: s,
          field: "datum.value",
          format: r.timeFormat,
          formatType: r.timeFormatType,
          config: r
        }),
        ...n
      };
  }
  return n;
}
function ehe(e) {
  return Vr.reduce((t, n) => (e.component.scales[n] && (t[n] = [ahe(n, e)]), t), {});
}
const the = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function nhe(e) {
  const { axes: t, resolve: n } = e.component, i = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const r of e.children) {
    r.parseAxesAndHeaders();
    for (const s of q(r.component.axes))
      n.axis[s] = XE(e.component.resolve, s), n.axis[s] === "shared" && (t[s] = ihe(t[s], r.component.axes[s]), t[s] || (n.axis[s] = "independent", delete t[s]));
  }
  for (const r of Vr) {
    for (const s of e.children)
      if (s.component.axes[r]) {
        if (n.axis[r] === "independent") {
          t[r] = (t[r] ?? []).concat(s.component.axes[r]);
          for (const o of s.component.axes[r]) {
            const { value: a, explicit: l } = o.getWithExplicit("orient");
            if (!oe(a)) {
              if (i[a] > 0 && !l) {
                const u = the[a];
                i[a] > i[u] && o.set("orient", u, !1);
              }
              i[a]++;
            }
          }
        }
        delete s.component.axes[r];
      }
    if (n.axis[r] === "independent" && t[r] && t[r].length > 1)
      for (const [s, o] of (t[r] || []).entries())
        s > 0 && o.get("grid") && !o.explicit.grid && (o.implicit.grid = !1);
  }
}
function ihe(e, t) {
  if (e) {
    if (e.length !== t.length)
      return;
    const n = e.length;
    for (let i = 0; i < n; i++) {
      const r = e[i], s = t[i];
      if (!!r != !!s)
        return;
      if (r && s) {
        const o = r.getWithExplicit("orient"), a = s.getWithExplicit("orient");
        if (o.explicit && a.explicit && o.value !== a.value)
          return;
        e[i] = rhe(r, s);
      }
    }
  } else
    return t.map((n) => n.clone());
  return e;
}
function rhe(e, t) {
  for (const n of aP) {
    const i = Co(
      e.getWithExplicit(n),
      t.getWithExplicit(n),
      n,
      "axis",
      // Tie breaker function
      (r, s) => {
        switch (n) {
          case "title":
            return v4(r, s);
          case "gridScale":
            return {
              explicit: r.explicit,
              value: ct(r.value, s.value)
            };
        }
        return C0(r, s, n, "axis");
      }
    );
    e.setWithExplicit(n, i);
  }
  return e;
}
function she(e, t, n, i, r) {
  if (t === "disable")
    return n !== void 0;
  switch (n = n || {}, t) {
    case "titleAngle":
    case "labelAngle":
      return e === (oe(n.labelAngle) ? n.labelAngle : Gf(n.labelAngle));
    case "values":
      return !!n.values;
    case "encode":
      return !!n.encoding || !!n.labelAngle;
    case "title":
      if (e === k8(i, r))
        return !0;
  }
  return e === n[t];
}
const ohe = /* @__PURE__ */ new Set([
  "grid",
  "translate",
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function ahe(e, t) {
  var y, b;
  let n = t.axis(e);
  const i = new rS(), r = bt(t.encoding[e]), { mark: s, config: o } = t, a = (n == null ? void 0 : n.orient) || ((y = o[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((b = o.axis) == null ? void 0 : b.orient) || Vce(e), l = t.getScaleComponent(e).get("type"), u = Bce(e, l, a, t.config), c = n !== void 0 ? !n : kv("disable", o.style, n == null ? void 0 : n.style, u).configValue;
  if (i.set("disable", c, n !== void 0), c)
    return i;
  n = n || {};
  const f = Wce(r, n, e, o.style, u), d = Z4(n.formatType, r, l), h = Q4(r, r.type, n.format, n.formatType, o, !0), g = {
    fieldOrDatumDef: r,
    axis: n,
    channel: e,
    model: t,
    scaleType: l,
    orient: a,
    labelAngle: f,
    format: h,
    formatType: d,
    mark: s,
    config: o
  };
  for (const v of aP) {
    const w = v in bM ? bM[v](g) : H$(v) ? n[v] : void 0, _ = w !== void 0, S = she(w, v, n, t, e);
    if (_ && S)
      i.set(v, w, S);
    else {
      const { configValue: E = void 0, configFrom: C = void 0 } = H$(v) && v !== "values" ? kv(v, o.style, n.style, u) : {}, $ = E !== void 0;
      _ && !$ ? i.set(v, w, S) : (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        (C !== "vgAxisConfig" || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        ohe.has(v) && $ || // 3. Conditional axis values and signals
        Id(E) || oe(E)) && i.set(v, E, !1)
      );
    }
  }
  const p = n.encoding ?? {}, m = hL.reduce((v, w) => {
    if (!i.hasAxisPart(w))
      return v;
    const _ = T8(p[w] ?? {}, t), S = w === "labels" ? Zde(t, e, _) : _;
    return S !== void 0 && !He(S) && (v[w] = { update: S }), v;
  }, {});
  return He(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i;
}
function lhe({ encoding: e, size: t }) {
  for (const n of Vr) {
    const i = jn(n);
    Lr(t[i]) && ro(e[n]) && (delete t[i], V(S4(i)));
  }
  return t;
}
const uhe = {
  vgMark: "arc",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Zt("x", e, { defaultPos: "mid" }),
    ...Zt("y", e, { defaultPos: "mid" }),
    // arcs are rectangles in polar coordinates
    ...$o(e, "radius"),
    ...$o(e, "theta")
  })
}, che = {
  vgMark: "area",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    }),
    ...Tp("x", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "horizontal"
    }),
    ...Tp("y", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "vertical"
    }),
    ...WE(e)
  })
}, fhe = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...$o(e, "x"),
    ...$o(e, "y")
  })
}, dhe = {
  vgMark: "shape",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })
  }),
  postEncodingTransform: (e) => {
    const { encoding: t } = e, n = t.shape;
    return [{
      type: "geoshape",
      projection: e.projectionName(),
      // as: 'shape',
      ...n && G(n) && n.type === Ju ? { field: K(n, { expr: "datum" }) } : {}
    }];
  }
}, hhe = {
  vgMark: "image",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...$o(e, "x"),
    ...$o(e, "y"),
    ...UE(e, "url")
  })
}, ghe = {
  vgMark: "line",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Zt("x", e, { defaultPos: "mid" }),
    ...Zt("y", e, { defaultPos: "mid" }),
    ...Ct("size", e, {
      vgChannel: "strokeWidth"
      // VL's line size is strokeWidth
    }),
    ...WE(e)
  })
}, phe = {
  vgMark: "trail",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Zt("x", e, { defaultPos: "mid" }),
    ...Zt("y", e, { defaultPos: "mid" }),
    ...Ct("size", e),
    ...WE(e)
  })
};
function sS(e, t) {
  const { config: n } = e;
  return {
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Zt("x", e, { defaultPos: "mid" }),
    ...Zt("y", e, { defaultPos: "mid" }),
    ...Ct("size", e),
    ...Ct("angle", e),
    ...mhe(e, n, t)
  };
}
function mhe(e, t, n) {
  return n ? { shape: { value: n } } : Ct("shape", e);
}
const yhe = {
  vgMark: "symbol",
  encodeEntry: (e) => sS(e)
}, bhe = {
  vgMark: "symbol",
  encodeEntry: (e) => sS(e, "circle")
}, vhe = {
  vgMark: "symbol",
  encodeEntry: (e) => sS(e, "square")
}, xhe = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...Ti(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...$o(e, "x"),
    ...$o(e, "y")
  })
}, whe = {
  vgMark: "rule",
  encodeEntry: (e) => {
    const { markDef: t } = e, n = t.orient;
    return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
      ...Ti(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Tp("x", e, {
        defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "vertical"
        // include x2 for horizontal or line segment rule
      }),
      ...Tp("y", e, {
        defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "horizontal"
        // include y2 for vertical or line segment rule
      }),
      ...Ct("size", e, {
        vgChannel: "strokeWidth"
        // VL's rule size is strokeWidth
      })
    };
  }
}, _he = {
  vgMark: "text",
  encodeEntry: (e) => {
    const { config: t, encoding: n } = e;
    return {
      ...Ti(e, {
        align: "include",
        baseline: "include",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "include"
      }),
      ...Zt("x", e, { defaultPos: "mid" }),
      ...Zt("y", e, { defaultPos: "mid" }),
      ...UE(e),
      ...Ct("size", e, {
        vgChannel: "fontSize"
        // VL's text size is fontSize
      }),
      ...Ct("angle", e),
      ...gM("align", Ehe(e.markDef, n, t)),
      ...gM("baseline", She(e.markDef, n, t)),
      ...Zt("radius", e, { defaultPos: null }),
      ...Zt("theta", e, { defaultPos: null })
    };
  }
};
function Ehe(e, t, n) {
  if (Ue("align", e, n) === void 0)
    return "center";
}
function She(e, t, n) {
  if (Ue("baseline", e, n) === void 0)
    return "middle";
}
const khe = {
  vgMark: "rect",
  encodeEntry: (e) => {
    const { config: t, markDef: n } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", s = i === "horizontal" ? "height" : "width";
    return {
      ...Ti(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Zt("x", e, { defaultPos: "mid", vgChannel: "xc" }),
      ...Zt("y", e, { defaultPos: "mid", vgChannel: "yc" }),
      // size / thickness => width / height
      ...Ct("size", e, {
        defaultValue: Ahe(e),
        vgChannel: r
      }),
      [s]: Qe(Ue("thickness", n, t))
    };
  }
};
function Ahe(e) {
  const { config: t, markDef: n } = e, { orient: i } = n, r = i === "horizontal" ? "width" : "height", s = e.getScaleComponent(i === "horizontal" ? "x" : "y"), o = Ue("size", n, t, { vgChannel: r }) ?? t.tick.bandSize;
  if (o !== void 0)
    return o;
  {
    const a = s ? s.get("range") : void 0;
    return a && Wo(a) && Re(a.step) ? a.step * 3 / 4 : Mp(t.view, r) * 3 / 4;
  }
}
const _h = {
  arc: uhe,
  area: che,
  bar: fhe,
  circle: bhe,
  geoshape: dhe,
  image: hhe,
  line: ghe,
  point: yhe,
  rect: xhe,
  rule: whe,
  square: vhe,
  text: _he,
  tick: khe,
  trail: phe
};
function Che(e) {
  if (Fe([p0, h0, Rae], e.mark)) {
    const t = vL(e.mark, e.encoding);
    if (t.length > 0)
      return $he(e, t);
  } else if (e.mark === g0) {
    const t = hv.some((n) => Ue(n, e.markDef, e.config));
    if (e.stack && !e.fieldDef("size") && t)
      return Mhe(e);
  }
  return oS(e);
}
const DM = "faceted_path_";
function $he(e, t) {
  return [
    {
      name: e.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: DM + e.requestDataName(Xe.Main),
          data: e.requestDataName(Xe.Main),
          groupby: t
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: oS(e, { fromPrefix: DM })
    }
  ];
}
const RM = "stack_group_";
function Mhe(e) {
  var u;
  const [t] = oS(e, { fromPrefix: RM }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
    const d = [
      i({ prefix: "min", suffix: "start", expr: f }),
      i({ prefix: "max", suffix: "start", expr: f }),
      i({ prefix: "min", suffix: "end", expr: f }),
      i({ prefix: "max", suffix: "end", expr: f })
    ];
    return `${c}(${d.map((h) => `scale('${n}',${h})`).join(",")})`;
  };
  let s, o;
  e.stack.fieldChannel === "x" ? (s = {
    ...vu(t.encode.update, ["y", "yc", "y2", "height", ...hv]),
    x: { signal: r("min", "datum") },
    x2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, o = {
    x: { field: { group: "x" }, mult: -1 },
    height: { field: { group: "height" } }
  }, t.encode.update = {
    ...Nn(t.encode.update, ["y", "yc", "y2"]),
    height: { field: { group: "height" } }
  }) : (s = {
    ...vu(t.encode.update, ["x", "xc", "x2", "width"]),
    y: { signal: r("min", "datum") },
    y2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, o = {
    y: { field: { group: "y" }, mult: -1 },
    width: { field: { group: "width" } }
  }, t.encode.update = {
    ...Nn(t.encode.update, ["x", "xc", "x2"]),
    width: { field: { group: "width" } }
  });
  for (const c of hv) {
    const f = ks(c, e.markDef, e.config);
    t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = Qe(f)), f && (t.encode.update[c] = { value: 0 });
  }
  const a = [];
  if (((u = e.stack.groupbyChannels) == null ? void 0 : u.length) > 0)
    for (const c of e.stack.groupbyChannels) {
      const f = e.fieldDef(c), d = K(f);
      d && a.push(d), (f != null && f.bin || f != null && f.timeUnit) && a.push(K(f, { binSuffix: "end" }));
    }
  return s = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ].reduce((c, f) => {
    if (t.encode.update[f])
      return { ...c, [f]: t.encode.update[f] };
    {
      const d = ks(f, e.markDef, e.config);
      return d !== void 0 ? { ...c, [f]: Qe(d) } : c;
    }
  }, s), s.stroke && (s.strokeForeground = { value: !0 }, s.strokeOffset = { value: 0 }), [
    {
      type: "group",
      from: {
        facet: {
          data: e.requestDataName(Xe.Main),
          name: RM + e.requestDataName(Xe.Main),
          groupby: a,
          aggregate: {
            fields: [
              i({ suffix: "start" }),
              i({ suffix: "start" }),
              i({ suffix: "end" }),
              i({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: s
      },
      marks: [
        {
          type: "group",
          encode: { update: o },
          marks: [t]
        }
      ]
    }
  ];
}
function Fhe(e) {
  var a;
  const { encoding: t, stack: n, mark: i, markDef: r, config: s } = e, o = t.order;
  if (!(!j(o) && er(o) && fv(o.value) || !o && fv(Ue("order", r, s)))) {
    if ((j(o) || G(o)) && !n)
      return m4(o, { expr: "datum" });
    if (Ho(i)) {
      const l = r.orient === "horizontal" ? "y" : "x", u = t[l];
      if (G(u)) {
        const c = u.sort;
        if (j(c))
          return {
            field: K(u, { prefix: l, suffix: "sort_index", expr: "datum" })
          };
        if (Sr(c))
          return {
            field: K({
              // FIXME: this op might not already exist?
              // FIXME: what if dimensionChannel (x or y) contains custom domain?
              aggregate: CE(e.encoding) ? c.op : void 0,
              field: c.field
            }, { expr: "datum" })
          };
        if (tL(c)) {
          const f = e.fieldDef(c.encoding);
          return {
            field: K(f, { expr: "datum" }),
            order: c.order
          };
        } else
          return c === null ? void 0 : {
            field: K(u, {
              // For stack with imputation, we only have bin_mid
              binSuffix: (a = e.stack) != null && a.impute ? "mid" : void 0,
              expr: "datum"
            })
          };
      }
      return;
    }
  }
}
function oS(e, t = { fromPrefix: "" }) {
  const { mark: n, markDef: i, encoding: r, config: s } = e, o = ct(i.clip, The(e), Ohe(e)), a = g4(i), l = r.key, u = Fhe(e), c = Nhe(e), f = Ue("aria", i, s), d = _h[n].postEncodingTransform ? _h[n].postEncodingTransform(e) : null;
  return [
    {
      name: e.getName("marks"),
      type: _h[n].vgMark,
      ...o ? { clip: !0 } : {},
      ...a ? { style: a } : {},
      ...l ? { key: l.field } : {},
      ...u ? { sort: u } : {},
      ...c || {},
      ...f === !1 ? { aria: f } : {},
      from: { data: t.fromPrefix + e.requestDataName(Xe.Main) },
      encode: {
        update: _h[n].encodeEntry(e)
      },
      ...d ? {
        transform: d
      } : {}
    }
  ];
}
function The(e) {
  const t = e.getScaleComponent("x"), n = e.getScaleComponent("y");
  return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0;
}
function Ohe(e) {
  const t = e.component.projection;
  return t && !t.isFit ? !0 : void 0;
}
function Nhe(e) {
  if (!e.component.selection)
    return null;
  const t = q(e.component.selection).length;
  let n = t, i = e.parent;
  for (; i && n === 0; )
    n = q(i.component.selection).length, i = i.parent;
  return n ? {
    interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip
  } : null;
}
class lP extends iP {
  constructor(t, n, i, r = {}, s) {
    super(t, "unit", n, i, s, void 0, V$(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
    const o = Dr(t.mark) ? { ...t.mark } : { type: t.mark }, a = o.type;
    o.filled === void 0 && (o.filled = yue(o, s, {
      graticule: t.data && BE(t.data)
    }));
    const l = this.encoding = wle(t.encoding || {}, a, o.filled, s);
    this.markDef = BL(o, l, s), this.size = lhe({
      encoding: l,
      size: V$(t) ? {
        ...r,
        ...t.width ? { width: t.width } : {},
        ...t.height ? { height: t.height } : {}
      } : r
    }), this.stack = zL(this.markDef, l), this.specifiedScales = this.initScales(a, l), this.specifiedAxes = this.initAxes(l), this.specifiedLegends = this.initLegends(l), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((u) => RE(u));
  }
  get hasProjection() {
    const { encoding: t } = this, n = this.mark === V4, i = t && xse.some((r) => be(t[r]));
    return n || i;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(t) {
    const n = this.specifiedScales[t];
    return n ? n.domain : void 0;
  }
  axis(t) {
    return this.specifiedAxes[t];
  }
  legend(t) {
    return this.specifiedLegends[t];
  }
  initScales(t, n) {
    return u0.reduce((i, r) => {
      const s = bt(n[r]);
      return s && (i[r] = this.initScale(s.scale ?? {})), i;
    }, {});
  }
  initScale(t) {
    const { domain: n, range: i } = t, r = Fn(t);
    return j(n) && (r.domain = n.map(Vn)), j(i) && (r.range = i.map(Vn)), r;
  }
  initAxes(t) {
    return Vr.reduce((n, i) => {
      const r = t[i];
      if (be(r) || i === tt && be(t.x2) || i === Lt && be(t.y2)) {
        const s = be(r) ? r.axis : void 0;
        n[i] = s && this.initAxis({ ...s });
      }
      return n;
    }, {});
  }
  initAxis(t) {
    const n = q(t), i = {};
    for (const r of n) {
      const s = t[r];
      i[r] = Id(s) ? h4(s) : Vn(s);
    }
    return i;
  }
  initLegends(t) {
    return Fse.reduce((n, i) => {
      const r = bt(t[i]);
      if (r && Ose(i)) {
        const s = r.legend;
        n[i] = s && Fn(s);
      }
      return n;
    }, {});
  }
  parseData() {
    this.component.data = W0(this);
  }
  parseLayoutSize() {
    Hde(this);
  }
  parseSelections() {
    this.component.selection = Lce(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = Che(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = ehe(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return rce(this, t);
  }
  assembleSignals() {
    return [..._8(this), ...nce(this, [])];
  }
  assembleSelectionData(t) {
    return sce(this, t);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return YE(this);
  }
  assembleMarks() {
    let t = this.component.mark ?? [];
    return (!this.parent || !nc(this.parent)) && (t = ZL(this, t)), t.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: t } = this.view || {};
    return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view";
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(t) {
    return ka(this.encoding, t);
  }
  fieldDef(t) {
    const n = this.encoding[t];
    return Rr(n);
  }
  typedFieldDef(t) {
    const n = this.fieldDef(t);
    return En(n) ? n : null;
  }
}
class aS extends nS {
  constructor(t, n, i, r, s) {
    super(t, "layer", n, i, s, t.resolve, t.view);
    const o = {
      ...r,
      ...t.width ? { width: t.width } : {},
      ...t.height ? { height: t.height } : {}
    };
    this.children = t.layer.map((a, l) => {
      if (A0(a))
        return new aS(a, this, this.getName(`layer_${l}`), o, s);
      if (Ps(a))
        return new lP(a, this, this.getName(`layer_${l}`), o, s);
      throw new Error(eE(a));
    });
  }
  parseData() {
    this.component.data = W0(this);
    for (const t of this.children)
      t.parseData();
  }
  parseLayoutSize() {
    qde(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of q(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    nhe(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleSignals()), _8(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), YE(this));
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleGroupStyle() {
    const t = /* @__PURE__ */ new Set();
    for (const i of this.children)
      for (const r of J(i.assembleGroupStyle()))
        t.add(r);
    const n = Array.from(t);
    return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
  }
  assembleTitle() {
    let t = super.assembleTitle();
    if (t)
      return t;
    for (const n of this.children)
      if (t = n.assembleTitle(), t)
        return t;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return oce(this, this.children.flatMap((t) => t.assembleMarks()));
  }
  assembleLegends() {
    return this.children.reduce((t, n) => t.concat(n.assembleLegends()), z8(this));
  }
}
function lS(e, t, n, i, r) {
  if (b0(e))
    return new pf(e, t, n, r);
  if (A0(e))
    return new aS(e, t, n, i, r);
  if (Ps(e))
    return new lP(e, t, n, i, r);
  if (Hle(e))
    return new Kde(e, t, n, r);
  throw new Error(eE(e));
}
function Dhe(e, t = {}) {
  t.logger && Koe(t.logger), t.fieldTitle && cL(t.fieldTitle);
  try {
    const n = IL(Du(t.config, e.config)), i = VL(e, n), r = lS(i, null, "", void 0, n);
    return r.parse(), rde(r.component.data, r), {
      spec: Lhe(r, Rhe(e, i.autosize, n, r), e.datasets, e.usermeta),
      normalized: i
    };
  } finally {
    t.logger && Joe(), t.fieldTitle && dle();
  }
}
function Rhe(e, t, n, i) {
  const r = i.component.layoutSize.get("width"), s = i.component.layoutSize.get("height");
  if (t === void 0 ? (t = { type: "pad" }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : Q(t) && (t = { type: t }), r && s && Que(t.type)) {
    if (r === "step" && s === "step")
      V(T$()), t.type = "pad";
    else if (r === "step" || s === "step") {
      const o = r === "step" ? "width" : "height";
      V(T$(l0(o)));
      const a = o === "width" ? "height" : "width";
      t.type = Zue(a);
    }
  }
  return {
    ...q(t).length === 1 && t.type ? t.type === "pad" ? {} : { autosize: t.type } : { autosize: t },
    ...sM(n, !1),
    ...sM(e, !0)
  };
}
function Lhe(e, t, n = {}, i) {
  const r = e.config ? sue(e.config) : void 0, s = [].concat(
    e.assembleSelectionData([]),
    // only assemble data in the root
    zde(e.component.data, n)
  ), o = e.assembleProjections(), a = e.assembleTitle(), l = e.assembleGroupStyle(), u = e.assembleGroupEncodeEntry(!0);
  let c = e.assembleLayoutSignals();
  c = c.filter((h) => (h.name === "width" || h.name === "height") && h.value !== void 0 ? (t[h.name] = +h.value, !1) : !0);
  const { params: f, ...d } = t;
  return {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    ...e.description ? { description: e.description } : {},
    ...d,
    ...a ? { title: a } : {},
    ...l ? { style: l } : {},
    ...u ? { encode: { update: u } } : {},
    data: s,
    ...o.length > 0 ? { projections: o } : {},
    ...e.assembleGroup([
      ...c,
      ...e.assembleSelectionTopLevelSignals([]),
      ...DL(f)
    ]),
    ...r ? { config: r } : {},
    ...i ? { usermeta: i } : {}
  };
}
const Phe = gse.version, Ihe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accessPathDepth: xu,
  accessPathWithDatum: W_,
  compile: Dhe,
  contains: Fe,
  deepEqual: Kn,
  deleteNestedProperty: vp,
  duplicate: me,
  entries: So,
  every: j_,
  fieldIntersection: q_,
  flatAccessWithDatum: V6,
  getFirstDefined: ct,
  hasIntersection: U_,
  hash: Me,
  internalField: K6,
  isBoolean: Hf,
  isEmpty: He,
  isEqual: mse,
  isInternalField: J6,
  isNullOrFalse: fv,
  isNumeric: n0,
  keys: q,
  logicalExpr: hf,
  mergeDeep: H6,
  never: W6,
  normalize: VL,
  normalizeAngle: Gf,
  omit: Nn,
  pick: vu,
  prefixGenerator: dv,
  removePathFromField: H_,
  replaceAll: ja,
  replacePathInField: Ci,
  resetIdCounter: bse,
  setEqual: G6,
  some: Ba,
  stringify: Ge,
  titleCase: $d,
  unique: xr,
  uniqueId: X6,
  vals: qt,
  varName: et,
  version: Phe
}, Symbol.toStringTag, { value: "Module" }));
function uP(e) {
  const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
  return { library: t, version: n };
}
var zhe = "vega-themes", Bhe = "2.14.0", jhe = "Themes for stylized Vega and Vega-Lite visualizations.", Uhe = ["vega", "vega-lite", "themes", "style"], qhe = "BSD-3-Clause", Whe = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
}, Hhe = [{
  name: "Emily Gu",
  url: "https://github.com/emilygu"
}, {
  name: "Arvind Satyanarayan",
  url: "http://arvindsatya.com"
}, {
  name: "Jeffrey Heer",
  url: "https://idl.cs.washington.edu"
}, {
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}], Ghe = "build/vega-themes.js", Vhe = "build/vega-themes.module.js", Yhe = "build/vega-themes.min.js", Xhe = "build/vega-themes.min.js", Khe = "build/vega-themes.module.d.ts", Jhe = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
}, Qhe = ["src", "build"], Zhe = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  format: "eslint . --fix",
  lint: "eslint .",
  release: "release-it"
}, ege = {
  "@babel/core": "^7.22.9",
  "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
  "@babel/plugin-proposal-json-strings": "^7.18.6",
  "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
  "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
  "@babel/plugin-transform-runtime": "^7.22.9",
  "@babel/preset-env": "^7.22.9",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.1.0",
  "@rollup/plugin-terser": "^0.4.3",
  "@typescript-eslint/eslint-plugin": "^6.0.0",
  "@typescript-eslint/parser": "^6.0.0",
  "browser-sync": "^2.29.3",
  concurrently: "^8.2.0",
  eslint: "^8.45.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^5.0.0",
  "gh-pages": "^5.0.0",
  prettier: "^3.0.0",
  "release-it": "^16.1.0",
  rollup: "^3.26.2",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-ts": "^3.2.0",
  typescript: "^5.1.6",
  vega: "^5.25.0",
  "vega-lite": "^5.9.3"
}, tge = {
  vega: "*",
  "vega-lite": "*"
}, nge = {}, ige = {
  name: zhe,
  version: Bhe,
  description: jhe,
  keywords: Uhe,
  license: qhe,
  author: Whe,
  contributors: Hhe,
  main: Ghe,
  module: Vhe,
  unpkg: Yhe,
  jsdelivr: Xhe,
  types: Khe,
  repository: Jhe,
  files: Qhe,
  scripts: Zhe,
  devDependencies: ege,
  peerDependencies: tge,
  dependencies: nge
};
const Cl = "#fff", LM = "#888", rge = {
  background: "#333",
  view: {
    stroke: LM
  },
  title: {
    color: Cl,
    subtitleColor: Cl
  },
  style: {
    "guide-label": {
      fill: Cl
    },
    "guide-title": {
      fill: Cl
    }
  },
  axis: {
    domainColor: Cl,
    gridColor: LM,
    tickColor: Cl
  }
}, Ko = "#4572a7", sge = {
  background: "#fff",
  arc: {
    fill: Ko
  },
  area: {
    fill: Ko
  },
  line: {
    stroke: Ko,
    strokeWidth: 2
  },
  path: {
    stroke: Ko
  },
  rect: {
    fill: Ko
  },
  shape: {
    stroke: Ko
  },
  symbol: {
    fill: Ko,
    strokeWidth: 1.5,
    size: 50
  },
  axis: {
    bandPosition: 0.5,
    grid: !0,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: !1,
    tickExtra: !0
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
  }
}, Jo = "#30a2da", fy = "#cbcbcb", oge = "#999", age = "#333", PM = "#f0f0f0", IM = "#333", lge = {
  arc: {
    fill: Jo
  },
  area: {
    fill: Jo
  },
  axis: {
    domainColor: fy,
    grid: !0,
    gridColor: fy,
    gridWidth: 1,
    labelColor: oge,
    labelFontSize: 10,
    titleColor: age,
    tickColor: fy,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: !1
  },
  background: PM,
  group: {
    fill: PM
  },
  legend: {
    labelColor: IM,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: IM,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: Jo,
    strokeWidth: 2
  },
  path: {
    stroke: Jo,
    strokeWidth: 0.5
  },
  rect: {
    fill: Jo
  },
  range: {
    category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: !0,
    shape: "circle"
  },
  shape: {
    stroke: Jo
  },
  bar: {
    binSpacing: 2,
    fill: Jo,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
}, Qo = "#000", uge = {
  group: {
    fill: "#e5e5e5"
  },
  arc: {
    fill: Qo
  },
  area: {
    fill: Qo
  },
  line: {
    stroke: Qo
  },
  path: {
    stroke: Qo
  },
  rect: {
    fill: Qo
  },
  shape: {
    stroke: Qo
  },
  symbol: {
    fill: Qo,
    size: 40
  },
  axis: {
    domain: !1,
    grid: !0,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
  }
}, cge = 22, fge = "normal", zM = "Benton Gothic, sans-serif", BM = 11.5, dge = "normal", Zo = "#82c6df", dy = "Benton Gothic Bold, sans-serif", jM = "normal", UM = 13, kc = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
}, hge = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: dy,
    fontSize: cge,
    fontWeight: fge
  },
  arc: {
    fill: Zo
  },
  area: {
    fill: Zo
  },
  line: {
    stroke: Zo,
    strokeWidth: 2
  },
  path: {
    stroke: Zo
  },
  rect: {
    fill: Zo
  },
  shape: {
    stroke: Zo
  },
  symbol: {
    fill: Zo,
    size: 30
  },
  axis: {
    labelFont: zM,
    labelFontSize: BM,
    labelFontWeight: dge,
    titleFont: dy,
    titleFontSize: UM,
    titleFontWeight: jM
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: zM,
    labelFontSize: BM,
    symbolType: "square",
    titleFont: dy,
    titleFontSize: UM,
    titleFontWeight: jM
  },
  range: {
    category: kc["category-6"],
    diverging: kc["fireandice-6"],
    heatmap: kc["fire-7"],
    ordinal: kc["fire-7"],
    ramp: kc["fire-7"]
  }
}, ea = "#ab5787", Eh = "#979797", gge = {
  background: "#f9f9f9",
  arc: {
    fill: ea
  },
  area: {
    fill: ea
  },
  line: {
    stroke: ea
  },
  path: {
    stroke: ea
  },
  rect: {
    fill: ea
  },
  shape: {
    stroke: ea
  },
  symbol: {
    fill: ea,
    size: 30
  },
  axis: {
    domainColor: Eh,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: Eh,
    tickColor: Eh,
    tickWidth: 0.2,
    titleColor: Eh
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    grid: !0,
    tickSize: 10
  },
  axisY: {
    domain: !1,
    grid: !0,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
  }
}, ta = "#3e5c69", pge = {
  background: "#fff",
  arc: {
    fill: ta
  },
  area: {
    fill: ta
  },
  line: {
    stroke: ta
  },
  path: {
    stroke: ta
  },
  rect: {
    fill: ta
  },
  shape: {
    stroke: ta
  },
  symbol: {
    fill: ta
  },
  axis: {
    domainWidth: 0.5,
    grid: !0,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
}, ci = "#1696d2", qM = "#000000", mge = "#FFFFFF", Sh = "Lato", hy = "Lato", yge = "Lato", bge = "#DEDDDD", vge = 18, Ac = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
}, xge = {
  background: mge,
  title: {
    anchor: "start",
    fontSize: vge,
    font: Sh
  },
  axisX: {
    domain: !0,
    domainColor: qM,
    domainWidth: 1,
    grid: !1,
    labelFontSize: 12,
    labelFont: hy,
    labelAngle: 0,
    tickColor: qM,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Sh
  },
  axisY: {
    domain: !1,
    domainWidth: 1,
    grid: !0,
    gridColor: bge,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: hy,
    labelPadding: 8,
    ticks: !1,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Sh,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: hy,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Sh,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: Ac["six-groups-cat-1"],
    diverging: Ac["diverging-colors"],
    heatmap: Ac["diverging-colors"],
    ordinal: Ac["six-groups-seq"],
    ramp: Ac["shades-blue"]
  },
  area: {
    fill: ci
  },
  rect: {
    fill: ci
  },
  line: {
    color: ci,
    stroke: ci,
    strokeWidth: 5
  },
  trail: {
    color: ci,
    stroke: ci,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: ci,
    strokeWidth: 0.5
  },
  point: {
    filled: !0
  },
  text: {
    font: yge,
    color: ci,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: ci,
      stroke: null
    }
  },
  arc: {
    fill: ci
  },
  shape: {
    stroke: ci
  },
  symbol: {
    fill: ci,
    size: 30
  }
}, na = "#3366CC", WM = "#ccc", kh = "Arial, sans-serif", wge = {
  arc: {
    fill: na
  },
  area: {
    fill: na
  },
  path: {
    stroke: na
  },
  rect: {
    fill: na
  },
  shape: {
    stroke: na
  },
  symbol: {
    stroke: na
  },
  circle: {
    fill: na
  },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: kh,
      fontSize: 12
    },
    "guide-title": {
      font: kh,
      fontSize: 12
    },
    "group-title": {
      font: kh,
      fontSize: 12
    }
  },
  title: {
    font: kh,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: WM,
    tickColor: WM,
    domain: !1,
    grid: !0
  },
  range: {
    category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
}, uS = (e) => e * (1 / 3 + 1), HM = uS(9), GM = uS(10), VM = uS(12), Cc = "Segoe UI", YM = "wf_standard-font, helvetica, arial, sans-serif", XM = "#252423", $c = "#605E5C", KM = "transparent", _ge = "#C8C6C4", Di = "#118DFF", Ege = "#12239E", Sge = "#E66C37", kge = "#6B007B", Age = "#E044A7", Cge = "#744EC2", $ge = "#D9B300", Mge = "#D64550", cP = Di, fP = "#DEEFFF", JM = [fP, cP], Fge = [fP, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", cP], Tge = {
  view: {
    stroke: KM
  },
  background: KM,
  font: Cc,
  header: {
    titleFont: YM,
    titleFontSize: VM,
    titleColor: XM,
    labelFont: Cc,
    labelFontSize: GM,
    labelColor: $c
  },
  axis: {
    ticks: !1,
    grid: !1,
    domain: !1,
    labelColor: $c,
    labelFontSize: HM,
    titleFont: YM,
    titleColor: XM,
    titleFontSize: VM,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: !0,
    gridColor: _ge,
    gridDash: [1, 5],
    labelFlush: !1
  },
  axisBand: {
    tickExtra: !0
  },
  axisX: {
    labelPadding: 5
  },
  axisY: {
    labelPadding: 10
  },
  bar: {
    fill: Di
  },
  line: {
    stroke: Di,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: {
    font: Cc,
    fontSize: HM,
    fill: $c
  },
  arc: {
    fill: Di
  },
  area: {
    fill: Di,
    line: !0,
    opacity: 0.6
  },
  path: {
    stroke: Di
  },
  rect: {
    fill: Di
  },
  point: {
    fill: Di,
    filled: !0,
    size: 75
  },
  shape: {
    stroke: Di
  },
  symbol: {
    fill: Di,
    strokeWidth: 1.5,
    size: 50
  },
  legend: {
    titleFont: Cc,
    titleFontWeight: "bold",
    titleColor: $c,
    labelFont: Cc,
    labelFontSize: GM,
    labelColor: $c,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [Di, Ege, Sge, kge, Age, Cge, $ge, Mge],
    diverging: JM,
    heatmap: JM,
    ordinal: Fge
  }
}, gy = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', QM = 400, Oge = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"], Nge = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
function H0({
  type: e,
  background: t
}) {
  const n = e === "dark" ? "#161616" : "#ffffff", i = e === "dark" ? "#f4f4f4" : "#161616", r = e === "dark" ? Oge : Nge, s = e === "dark" ? "#d4bbff" : "#6929c4";
  return {
    background: t,
    arc: {
      fill: s
    },
    area: {
      fill: s
    },
    path: {
      stroke: s
    },
    rect: {
      fill: s
    },
    shape: {
      stroke: s
    },
    symbol: {
      stroke: s
    },
    circle: {
      fill: s
    },
    view: {
      fill: n,
      stroke: n
    },
    group: {
      fill: n
    },
    title: {
      color: i,
      anchor: "start",
      dy: -15,
      fontSize: 16,
      font: gy,
      fontWeight: 600
    },
    axis: {
      labelColor: i,
      labelFontSize: 12,
      grid: !0,
      gridColor: "#525252",
      titleColor: i,
      labelAngle: 0
    },
    style: {
      "guide-label": {
        font: gy,
        fill: i,
        fontWeight: QM
      },
      "guide-title": {
        font: gy,
        fill: i,
        fontWeight: QM
      }
    },
    range: {
      category: r,
      diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
      heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
    }
  };
}
const Dge = H0({
  type: "light",
  background: "#ffffff"
}), Rge = H0({
  type: "light",
  background: "#f4f4f4"
}), Lge = H0({
  type: "dark",
  background: "#262626"
}), Pge = H0({
  type: "dark",
  background: "#161616"
}), Ige = ige.version, zge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  carbong10: Rge,
  carbong100: Pge,
  carbong90: Lge,
  carbonwhite: Dge,
  dark: rge,
  excel: sge,
  fivethirtyeight: lge,
  ggplot2: uge,
  googlecharts: wge,
  latimes: hge,
  powerbi: Tge,
  quartz: gge,
  urbaninstitute: xge,
  version: Ige,
  vox: pge
}, Symbol.toStringTag, { value: "Module" }));
function Bge(e, t, n, i) {
  if (j(e))
    return `[${e.map((r) => t(Q(r) ? r : ZM(r, n))).join(", ")}]`;
  if (ee(e)) {
    let r = "";
    const {
      title: s,
      image: o,
      ...a
    } = e;
    s && (r += `<h2>${t(s)}</h2>`), o && (r += `<img src="${new URL(t(o), i || location.href).href}">`);
    const l = Object.keys(a);
    if (l.length > 0) {
      r += "<table>";
      for (const u of l) {
        let c = a[u];
        c !== void 0 && (ee(c) && (c = ZM(c, n)), r += `<tr><td class="key">${t(u)}</td><td class="value">${t(c)}</td></tr>`);
      }
      r += "</table>";
    }
    return r || "{}";
  }
  return t(e);
}
function jge(e) {
  const t = [];
  return function(n, i) {
    if (typeof i != "object" || i === null)
      return i;
    const r = t.indexOf(this) + 1;
    return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i);
  };
}
function ZM(e, t) {
  return JSON.stringify(e, jge(t));
}
var Uge = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
const dP = "vg-tooltip-element", qge = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: dP,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: !1,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: Wge,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @param baseURL The `baseURL` from `options.baseURL`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: Bge,
  /**
   * The baseurl to use in image paths.
   */
  baseURL: ""
};
function Wge(e) {
  return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function Hge(e) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(e))
    throw new Error("Invalid HTML ID");
  return Uge.toString().replace(dP, e);
}
function Gge(e, t, n, i) {
  let r = e.clientX + n;
  r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
  let s = e.clientY + i;
  return s + t.height > window.innerHeight && (s = +e.clientY - i - t.height), {
    x: r,
    y: s
  };
}
class Vge {
  /**
   * The handler function. We bind this to this function in the constructor.
   */
  /**
   * Complete tooltip options.
   */
  /**
   * The tooltip html element.
   */
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(t) {
    this.options = {
      ...qge,
      ...t
    };
    const n = this.options.id;
    if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const i = document.createElement("style");
      i.setAttribute("id", this.options.styleId), i.innerHTML = Hge(n);
      const r = document.head;
      r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i);
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(t, n, i, r) {
    if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth, this.options.baseURL), this.el.classList.add("visible", `${this.options.theme}-theme`);
    const {
      x: s,
      y: o
    } = Gge(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.style.top = `${o}px`, this.el.style.left = `${s}px`;
  }
}
function Yge(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var py, e3;
function Xge() {
  return e3 || (e3 = 1, py = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), py;
}
var Kge = ze;
ze.Node = Ka;
ze.create = ze;
function ze(e) {
  var t = this;
  if (t instanceof ze || (t = new ze()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(r) {
      t.push(r);
    });
  else if (arguments.length > 0)
    for (var n = 0, i = arguments.length; n < i; n++)
      t.push(arguments[n]);
  return t;
}
ze.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, n = e.prev;
  return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
ze.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
ze.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
ze.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    Qge(this, arguments[e]);
  return this.length;
};
ze.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    Zge(this, arguments[e]);
  return this.length;
};
ze.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
ze.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
ze.prototype.forEach = function(e, t) {
  t = t || this;
  for (var n = this.head, i = 0; n !== null; i++)
    e.call(t, n.value, i, this), n = n.next;
};
ze.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var n = this.tail, i = this.length - 1; n !== null; i--)
    e.call(t, n.value, i, this), n = n.prev;
};
ze.prototype.get = function(e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++)
    n = n.next;
  if (t === e && n !== null)
    return n.value;
};
ze.prototype.getReverse = function(e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++)
    n = n.prev;
  if (t === e && n !== null)
    return n.value;
};
ze.prototype.map = function(e, t) {
  t = t || this;
  for (var n = new ze(), i = this.head; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.next;
  return n;
};
ze.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var n = new ze(), i = this.tail; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.prev;
  return n;
};
ze.prototype.reduce = function(e, t) {
  var n, i = this.head;
  if (arguments.length > 1)
    n = t;
  else if (this.head)
    i = this.head.next, n = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = 0; i !== null; r++)
    n = e(n, i.value, r), i = i.next;
  return n;
};
ze.prototype.reduceReverse = function(e, t) {
  var n, i = this.tail;
  if (arguments.length > 1)
    n = t;
  else if (this.tail)
    i = this.tail.prev, n = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = this.length - 1; i !== null; r--)
    n = e(n, i.value, r), i = i.prev;
  return n;
};
ze.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    e[t] = n.value, n = n.next;
  return e;
};
ze.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    e[t] = n.value, n = n.prev;
  return e;
};
ze.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new ze();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, r = this.head; r !== null && i < e; i++)
    r = r.next;
  for (; r !== null && i < t; i++, r = r.next)
    n.push(r.value);
  return n;
};
ze.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new ze();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, r = this.tail; r !== null && i > t; i--)
    r = r.prev;
  for (; r !== null && i > e; i--, r = r.prev)
    n.push(r.value);
  return n;
};
ze.prototype.splice = function(e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var i = 0, r = this.head; r !== null && i < e; i++)
    r = r.next;
  for (var s = [], i = 0; r && i < t; i++)
    s.push(r.value), r = this.removeNode(r);
  r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
  for (var i = 0; i < n.length; i++)
    r = Jge(this, r, n[i]);
  return s;
};
ze.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var i = n.prev;
    n.prev = n.next, n.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function Jge(e, t, n) {
  var i = t === e.head ? new Ka(n, null, t, e) : new Ka(n, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function Qge(e, t) {
  e.tail = new Ka(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function Zge(e, t) {
  e.head = new Ka(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function Ka(e, t, n, i) {
  if (!(this instanceof Ka))
    return new Ka(e, t, n, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
}
try {
  Xge()(ze);
} catch {
}
const epe = Kge, fa = Symbol("max"), rs = Symbol("length"), $l = Symbol("lengthCalculator"), mf = Symbol("allowStale"), ya = Symbol("maxAge"), ts = Symbol("dispose"), t3 = Symbol("noDisposeOnSet"), kt = Symbol("lruList"), Ri = Symbol("cache"), hP = Symbol("updateAgeOnGet"), my = () => 1;
class tpe {
  constructor(t) {
    if (typeof t == "number" && (t = {
      max: t
    }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[fa] = t.max || 1 / 0;
    const n = t.length || my;
    if (this[$l] = typeof n != "function" ? my : n, this[mf] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[ya] = t.maxAge || 0, this[ts] = t.dispose, this[t3] = t.noDisposeOnSet || !1, this[hP] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[fa] = t || 1 / 0, Mc(this);
  }
  get max() {
    return this[fa];
  }
  set allowStale(t) {
    this[mf] = !!t;
  }
  get allowStale() {
    return this[mf];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[ya] = t, Mc(this);
  }
  get maxAge() {
    return this[ya];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = my), t !== this[$l] && (this[$l] = t, this[rs] = 0, this[kt].forEach((n) => {
      n.length = this[$l](n.value, n.key), this[rs] += n.length;
    })), Mc(this);
  }
  get lengthCalculator() {
    return this[$l];
  }
  get length() {
    return this[rs];
  }
  get itemCount() {
    return this[kt].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let i = this[kt].tail; i !== null; ) {
      const r = i.prev;
      n3(this, t, i, n), i = r;
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let i = this[kt].head; i !== null; ) {
      const r = i.next;
      n3(this, t, i, n), i = r;
    }
  }
  keys() {
    return this[kt].toArray().map((t) => t.key);
  }
  values() {
    return this[kt].toArray().map((t) => t.value);
  }
  reset() {
    this[ts] && this[kt] && this[kt].length && this[kt].forEach((t) => this[ts](t.key, t.value)), this[Ri] = /* @__PURE__ */ new Map(), this[kt] = new epe(), this[rs] = 0;
  }
  dump() {
    return this[kt].map((t) => Rp(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[kt];
  }
  set(t, n, i) {
    if (i = i || this[ya], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    const r = i ? Date.now() : 0, s = this[$l](n, t);
    if (this[Ri].has(t)) {
      if (s > this[fa])
        return Jl(this, this[Ri].get(t)), !1;
      const l = this[Ri].get(t).value;
      return this[ts] && (this[t3] || this[ts](t, l.value)), l.now = r, l.maxAge = i, l.value = n, this[rs] += s - l.length, l.length = s, this.get(t), Mc(this), !0;
    }
    const o = new npe(t, n, s, r, i);
    return o.length > this[fa] ? (this[ts] && this[ts](t, n), !1) : (this[rs] += o.length, this[kt].unshift(o), this[Ri].set(t, this[kt].head), Mc(this), !0);
  }
  has(t) {
    if (!this[Ri].has(t))
      return !1;
    const n = this[Ri].get(t).value;
    return !Rp(this, n);
  }
  get(t) {
    return yy(this, t, !0);
  }
  peek(t) {
    return yy(this, t, !1);
  }
  pop() {
    const t = this[kt].tail;
    return t ? (Jl(this, t), t.value) : null;
  }
  del(t) {
    Jl(this, this[Ri].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let i = t.length - 1; i >= 0; i--) {
      const r = t[i], s = r.e || 0;
      if (s === 0)
        this.set(r.k, r.v);
      else {
        const o = s - n;
        o > 0 && this.set(r.k, r.v, o);
      }
    }
  }
  prune() {
    this[Ri].forEach((t, n) => yy(this, n, !1));
  }
}
const yy = (e, t, n) => {
  const i = e[Ri].get(t);
  if (i) {
    const r = i.value;
    if (Rp(e, r)) {
      if (Jl(e, i), !e[mf])
        return;
    } else
      n && (e[hP] && (i.value.now = Date.now()), e[kt].unshiftNode(i));
    return r.value;
  }
}, Rp = (e, t) => {
  if (!t || !t.maxAge && !e[ya])
    return !1;
  const n = Date.now() - t.now;
  return t.maxAge ? n > t.maxAge : e[ya] && n > e[ya];
}, Mc = (e) => {
  if (e[rs] > e[fa])
    for (let t = e[kt].tail; e[rs] > e[fa] && t !== null; ) {
      const n = t.prev;
      Jl(e, t), t = n;
    }
}, Jl = (e, t) => {
  if (t) {
    const n = t.value;
    e[ts] && e[ts](n.key, n.value), e[rs] -= n.length, e[Ri].delete(n.key), e[kt].removeNode(t);
  }
};
class npe {
  constructor(t, n, i, r, s) {
    this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = s || 0;
  }
}
const n3 = (e, t, n, i) => {
  let r = n.value;
  Rp(e, r) && (Jl(e, n), e[mf] || (r = void 0)), r && t.call(i, r.value, r.key, e);
};
var ipe = tpe;
const rpe = Object.freeze({
  loose: !0
}), spe = Object.freeze({}), ope = (e) => e ? typeof e != "object" ? rpe : e : spe;
var cS = ope, Dv = { exports: {} };
const ape = "2.0.0", gP = 256, lpe = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, upe = 16, cpe = gP - 6, fpe = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var fS = {
  MAX_LENGTH: gP,
  MAX_SAFE_COMPONENT_LENGTH: upe,
  MAX_SAFE_BUILD_LENGTH: cpe,
  MAX_SAFE_INTEGER: lpe,
  RELEASE_TYPES: fpe,
  SEMVER_SPEC_VERSION: ape,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const dpe = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var G0 = dpe;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_LENGTH: r
  } = fS, s = G0;
  t = e.exports = {};
  const o = t.re = [], a = t.safeRe = [], l = t.src = [], u = t.t = {};
  let c = 0;
  const f = "[a-zA-Z0-9-]", d = [["\\s", 1], ["\\d", r], [f, i]], h = (p) => {
    for (const [m, y] of d)
      p = p.split(`${m}*`).join(`${m}{0,${y}}`).split(`${m}+`).join(`${m}{1,${y}}`);
    return p;
  }, g = (p, m, y) => {
    const b = h(m), v = c++;
    s(p, v, m), u[p] = v, l[v] = m, o[v] = new RegExp(m, y ? "g" : void 0), a[v] = new RegExp(b, y ? "g" : void 0);
  };
  g("NUMERICIDENTIFIER", "0|[1-9]\\d*"), g("NUMERICIDENTIFIERLOOSE", "\\d+"), g("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), g("MAINVERSION", `(${l[u.NUMERICIDENTIFIER]})\\.(${l[u.NUMERICIDENTIFIER]})\\.(${l[u.NUMERICIDENTIFIER]})`), g("MAINVERSIONLOOSE", `(${l[u.NUMERICIDENTIFIERLOOSE]})\\.(${l[u.NUMERICIDENTIFIERLOOSE]})\\.(${l[u.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASEIDENTIFIER", `(?:${l[u.NUMERICIDENTIFIER]}|${l[u.NONNUMERICIDENTIFIER]})`), g("PRERELEASEIDENTIFIERLOOSE", `(?:${l[u.NUMERICIDENTIFIERLOOSE]}|${l[u.NONNUMERICIDENTIFIER]})`), g("PRERELEASE", `(?:-(${l[u.PRERELEASEIDENTIFIER]}(?:\\.${l[u.PRERELEASEIDENTIFIER]})*))`), g("PRERELEASELOOSE", `(?:-?(${l[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[u.PRERELEASEIDENTIFIERLOOSE]})*))`), g("BUILDIDENTIFIER", `${f}+`), g("BUILD", `(?:\\+(${l[u.BUILDIDENTIFIER]}(?:\\.${l[u.BUILDIDENTIFIER]})*))`), g("FULLPLAIN", `v?${l[u.MAINVERSION]}${l[u.PRERELEASE]}?${l[u.BUILD]}?`), g("FULL", `^${l[u.FULLPLAIN]}$`), g("LOOSEPLAIN", `[v=\\s]*${l[u.MAINVERSIONLOOSE]}${l[u.PRERELEASELOOSE]}?${l[u.BUILD]}?`), g("LOOSE", `^${l[u.LOOSEPLAIN]}$`), g("GTLT", "((?:<|>)?=?)"), g("XRANGEIDENTIFIERLOOSE", `${l[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), g("XRANGEIDENTIFIER", `${l[u.NUMERICIDENTIFIER]}|x|X|\\*`), g("XRANGEPLAIN", `[v=\\s]*(${l[u.XRANGEIDENTIFIER]})(?:\\.(${l[u.XRANGEIDENTIFIER]})(?:\\.(${l[u.XRANGEIDENTIFIER]})(?:${l[u.PRERELEASE]})?${l[u.BUILD]}?)?)?`), g("XRANGEPLAINLOOSE", `[v=\\s]*(${l[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[u.XRANGEIDENTIFIERLOOSE]})(?:${l[u.PRERELEASELOOSE]})?${l[u.BUILD]}?)?)?`), g("XRANGE", `^${l[u.GTLT]}\\s*${l[u.XRANGEPLAIN]}$`), g("XRANGELOOSE", `^${l[u.GTLT]}\\s*${l[u.XRANGEPLAINLOOSE]}$`), g("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), g("COERCERTL", l[u.COERCE], !0), g("LONETILDE", "(?:~>?)"), g("TILDETRIM", `(\\s*)${l[u.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", g("TILDE", `^${l[u.LONETILDE]}${l[u.XRANGEPLAIN]}$`), g("TILDELOOSE", `^${l[u.LONETILDE]}${l[u.XRANGEPLAINLOOSE]}$`), g("LONECARET", "(?:\\^)"), g("CARETTRIM", `(\\s*)${l[u.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", g("CARET", `^${l[u.LONECARET]}${l[u.XRANGEPLAIN]}$`), g("CARETLOOSE", `^${l[u.LONECARET]}${l[u.XRANGEPLAINLOOSE]}$`), g("COMPARATORLOOSE", `^${l[u.GTLT]}\\s*(${l[u.LOOSEPLAIN]})$|^$`), g("COMPARATOR", `^${l[u.GTLT]}\\s*(${l[u.FULLPLAIN]})$|^$`), g("COMPARATORTRIM", `(\\s*)${l[u.GTLT]}\\s*(${l[u.LOOSEPLAIN]}|${l[u.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", g("HYPHENRANGE", `^\\s*(${l[u.XRANGEPLAIN]})\\s+-\\s+(${l[u.XRANGEPLAIN]})\\s*$`), g("HYPHENRANGELOOSE", `^\\s*(${l[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[u.XRANGEPLAINLOOSE]})\\s*$`), g("STAR", "(<|>)?=?\\s*\\*"), g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Dv, Dv.exports);
var dS = Dv.exports;
const i3 = /^[0-9]+$/, pP = (e, t) => {
  const n = i3.test(e), i = i3.test(t);
  return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1;
}, hpe = (e, t) => pP(t, e);
var gpe = {
  compareIdentifiers: pP,
  rcompareIdentifiers: hpe
};
const Ah = G0, {
  MAX_LENGTH: r3,
  MAX_SAFE_INTEGER: Ch
} = fS, {
  safeRe: s3,
  t: o3
} = dS, ppe = cS, {
  compareIdentifiers: Ml
} = gpe;
let mpe = class hr {
  constructor(t, n) {
    if (n = ppe(n), t instanceof hr) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > r3)
      throw new TypeError(`version is longer than ${r3} characters`);
    Ah("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const i = t.trim().match(n.loose ? s3[o3.LOOSE] : s3[o3.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Ch || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Ch || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Ch || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((r) => {
      if (/^[0-9]+$/.test(r)) {
        const s = +r;
        if (s >= 0 && s < Ch)
          return s;
      }
      return r;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Ah("SemVer.compare", this.version, this.options, t), !(t instanceof hr)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new hr(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof hr || (t = new hr(t, this.options)), Ml(this.major, t.major) || Ml(this.minor, t.minor) || Ml(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof hr || (t = new hr(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let n = 0;
    do {
      const i = this.prerelease[n], r = t.prerelease[n];
      if (Ah("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return Ml(i, r);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof hr || (t = new hr(t, this.options));
    let n = 0;
    do {
      const i = this.build[n], r = t.build[n];
      if (Ah("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return Ml(i, r);
    } while (++n);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, n, i) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const r = Number(i) ? 1 : 0;
        if (!n && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [r];
        else {
          let s = this.prerelease.length;
          for (; --s >= 0; )
            typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
          if (s === -1) {
            if (n === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(r);
          }
        }
        if (n) {
          let s = [n, r];
          i === !1 && (s = [n]), Ml(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = s) : this.prerelease = s;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var hS = mpe;
const a3 = hS, ype = (e, t, n) => new a3(e, n).compare(new a3(t, n));
var ic = ype;
const bpe = ic, vpe = (e, t, n) => bpe(e, t, n) === 0;
var xpe = vpe;
const wpe = ic, _pe = (e, t, n) => wpe(e, t, n) !== 0;
var Epe = _pe;
const Spe = ic, kpe = (e, t, n) => Spe(e, t, n) > 0;
var Ape = kpe;
const Cpe = ic, $pe = (e, t, n) => Cpe(e, t, n) >= 0;
var Mpe = $pe;
const Fpe = ic, Tpe = (e, t, n) => Fpe(e, t, n) < 0;
var Ope = Tpe;
const Npe = ic, Dpe = (e, t, n) => Npe(e, t, n) <= 0;
var Rpe = Dpe;
const Lpe = xpe, Ppe = Epe, Ipe = Ape, zpe = Mpe, Bpe = Ope, jpe = Rpe, Upe = (e, t, n, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
      return Lpe(e, n, i);
    case "!=":
      return Ppe(e, n, i);
    case ">":
      return Ipe(e, n, i);
    case ">=":
      return zpe(e, n, i);
    case "<":
      return Bpe(e, n, i);
    case "<=":
      return jpe(e, n, i);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var qpe = Upe, by, l3;
function Wpe() {
  if (l3)
    return by;
  l3 = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(c, f) {
      if (f = n(f), c instanceof t) {
        if (c.loose === !!f.loose)
          return c;
        c = c.value;
      }
      c = c.trim().split(/\s+/).join(" "), o("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(c) {
      const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR], d = c.match(f);
      if (!d)
        throw new TypeError(`Invalid comparator: ${c}`);
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new a(d[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(c) {
      if (o("Comparator.test", c, this.options.loose), this.semver === e || c === e)
        return !0;
      if (typeof c == "string")
        try {
          c = new a(c, this.options);
        } catch {
          return !1;
        }
      return s(c, this.operator, this.semver, this.options);
    }
    intersects(c, f) {
      if (!(c instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new l(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new l(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || s(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || s(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")));
    }
  }
  by = t;
  const n = cS, {
    safeRe: i,
    t: r
  } = dS, s = qpe, o = G0, a = hS, l = mP();
  return by;
}
var vy, u3;
function mP() {
  if (u3)
    return vy;
  u3 = 1;
  class e {
    constructor(F, x) {
      if (x = i(x), F instanceof e)
        return F.loose === !!x.loose && F.includePrerelease === !!x.includePrerelease ? F : new e(F.raw, x);
      if (F instanceof r)
        return this.raw = F.value, this.set = [[F]], this.format(), this;
      if (this.options = x, this.loose = !!x.loose, this.includePrerelease = !!x.includePrerelease, this.raw = F.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((k) => this.parseRange(k.trim())).filter((k) => k.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const k = this.set[0];
        if (this.set = this.set.filter((A) => !g(A[0])), this.set.length === 0)
          this.set = [k];
        else if (this.set.length > 1) {
          for (const A of this.set)
            if (A.length === 1 && p(A[0])) {
              this.set = [A];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((F) => F.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(F) {
      const k = ((this.options.includePrerelease && d) | (this.options.loose && h)) + ":" + F, A = n.get(k);
      if (A)
        return A;
      const M = this.options.loose, D = M ? a[l.HYPHENRANGELOOSE] : a[l.HYPHENRANGE];
      F = F.replace(D, T(this.options.includePrerelease)), s("hyphen replace", F), F = F.replace(a[l.COMPARATORTRIM], u), s("comparator trim", F), F = F.replace(a[l.TILDETRIM], c), s("tilde trim", F), F = F.replace(a[l.CARETTRIM], f), s("caret trim", F);
      let R = F.split(" ").map((Z) => y(Z, this.options)).join(" ").split(/\s+/).map((Z) => N(Z, this.options));
      M && (R = R.filter((Z) => (s("loose invalid filter", Z, this.options), !!Z.match(a[l.COMPARATORLOOSE])))), s("range list", R);
      const U = /* @__PURE__ */ new Map(), W = R.map((Z) => new r(Z, this.options));
      for (const Z of W) {
        if (g(Z))
          return [Z];
        U.set(Z.value, Z);
      }
      U.size > 1 && U.has("") && U.delete("");
      const ne = [...U.values()];
      return n.set(k, ne), ne;
    }
    intersects(F, x) {
      if (!(F instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((k) => m(k, x) && F.set.some((A) => m(A, x) && k.every((M) => A.every((D) => M.intersects(D, x)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(F) {
      if (!F)
        return !1;
      if (typeof F == "string")
        try {
          F = new o(F, this.options);
        } catch {
          return !1;
        }
      for (let x = 0; x < this.set.length; x++)
        if (L(this.set[x], F, this.options))
          return !0;
      return !1;
    }
  }
  vy = e;
  const t = ipe, n = new t({
    max: 1e3
  }), i = cS, r = Wpe(), s = G0, o = hS, {
    safeRe: a,
    t: l,
    comparatorTrimReplace: u,
    tildeTrimReplace: c,
    caretTrimReplace: f
  } = dS, {
    FLAG_INCLUDE_PRERELEASE: d,
    FLAG_LOOSE: h
  } = fS, g = (O) => O.value === "<0.0.0-0", p = (O) => O.value === "", m = (O, F) => {
    let x = !0;
    const k = O.slice();
    let A = k.pop();
    for (; x && k.length; )
      x = k.every((M) => A.intersects(M, F)), A = k.pop();
    return x;
  }, y = (O, F) => (s("comp", O, F), O = _(O, F), s("caret", O), O = v(O, F), s("tildes", O), O = E(O, F), s("xrange", O), O = $(O, F), s("stars", O), O), b = (O) => !O || O.toLowerCase() === "x" || O === "*", v = (O, F) => O.trim().split(/\s+/).map((x) => w(x, F)).join(" "), w = (O, F) => {
    const x = F.loose ? a[l.TILDELOOSE] : a[l.TILDE];
    return O.replace(x, (k, A, M, D, R) => {
      s("tilde", O, k, A, M, D, R);
      let U;
      return b(A) ? U = "" : b(M) ? U = `>=${A}.0.0 <${+A + 1}.0.0-0` : b(D) ? U = `>=${A}.${M}.0 <${A}.${+M + 1}.0-0` : R ? (s("replaceTilde pr", R), U = `>=${A}.${M}.${D}-${R} <${A}.${+M + 1}.0-0`) : U = `>=${A}.${M}.${D} <${A}.${+M + 1}.0-0`, s("tilde return", U), U;
    });
  }, _ = (O, F) => O.trim().split(/\s+/).map((x) => S(x, F)).join(" "), S = (O, F) => {
    s("caret", O, F);
    const x = F.loose ? a[l.CARETLOOSE] : a[l.CARET], k = F.includePrerelease ? "-0" : "";
    return O.replace(x, (A, M, D, R, U) => {
      s("caret", O, A, M, D, R, U);
      let W;
      return b(M) ? W = "" : b(D) ? W = `>=${M}.0.0${k} <${+M + 1}.0.0-0` : b(R) ? M === "0" ? W = `>=${M}.${D}.0${k} <${M}.${+D + 1}.0-0` : W = `>=${M}.${D}.0${k} <${+M + 1}.0.0-0` : U ? (s("replaceCaret pr", U), M === "0" ? D === "0" ? W = `>=${M}.${D}.${R}-${U} <${M}.${D}.${+R + 1}-0` : W = `>=${M}.${D}.${R}-${U} <${M}.${+D + 1}.0-0` : W = `>=${M}.${D}.${R}-${U} <${+M + 1}.0.0-0`) : (s("no pr"), M === "0" ? D === "0" ? W = `>=${M}.${D}.${R}${k} <${M}.${D}.${+R + 1}-0` : W = `>=${M}.${D}.${R}${k} <${M}.${+D + 1}.0-0` : W = `>=${M}.${D}.${R} <${+M + 1}.0.0-0`), s("caret return", W), W;
    });
  }, E = (O, F) => (s("replaceXRanges", O, F), O.split(/\s+/).map((x) => C(x, F)).join(" ")), C = (O, F) => {
    O = O.trim();
    const x = F.loose ? a[l.XRANGELOOSE] : a[l.XRANGE];
    return O.replace(x, (k, A, M, D, R, U) => {
      s("xRange", O, k, A, M, D, R, U);
      const W = b(M), ne = W || b(D), Z = ne || b(R), re = Z;
      return A === "=" && re && (A = ""), U = F.includePrerelease ? "-0" : "", W ? A === ">" || A === "<" ? k = "<0.0.0-0" : k = "*" : A && re ? (ne && (D = 0), R = 0, A === ">" ? (A = ">=", ne ? (M = +M + 1, D = 0, R = 0) : (D = +D + 1, R = 0)) : A === "<=" && (A = "<", ne ? M = +M + 1 : D = +D + 1), A === "<" && (U = "-0"), k = `${A + M}.${D}.${R}${U}`) : ne ? k = `>=${M}.0.0${U} <${+M + 1}.0.0-0` : Z && (k = `>=${M}.${D}.0${U} <${M}.${+D + 1}.0-0`), s("xRange return", k), k;
    });
  }, $ = (O, F) => (s("replaceStars", O, F), O.trim().replace(a[l.STAR], "")), N = (O, F) => (s("replaceGTE0", O, F), O.trim().replace(a[F.includePrerelease ? l.GTE0PRE : l.GTE0], "")), T = (O) => (F, x, k, A, M, D, R, U, W, ne, Z, re, Ce) => (b(k) ? x = "" : b(A) ? x = `>=${k}.0.0${O ? "-0" : ""}` : b(M) ? x = `>=${k}.${A}.0${O ? "-0" : ""}` : D ? x = `>=${x}` : x = `>=${x}${O ? "-0" : ""}`, b(W) ? U = "" : b(ne) ? U = `<${+W + 1}.0.0-0` : b(Z) ? U = `<${W}.${+ne + 1}.0-0` : re ? U = `<=${W}.${ne}.${Z}-${re}` : O ? U = `<${W}.${ne}.${+Z + 1}-0` : U = `<=${U}`, `${x} ${U}`.trim()), L = (O, F, x) => {
    for (let k = 0; k < O.length; k++)
      if (!O[k].test(F))
        return !1;
    if (F.prerelease.length && !x.includePrerelease) {
      for (let k = 0; k < O.length; k++)
        if (s(O[k].semver), O[k].semver !== r.ANY && O[k].semver.prerelease.length > 0) {
          const A = O[k].semver;
          if (A.major === F.major && A.minor === F.minor && A.patch === F.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return vy;
}
const Hpe = mP(), Gpe = (e, t, n) => {
  try {
    t = new Hpe(t, n);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Vpe = Gpe, yP = /* @__PURE__ */ Yge(Vpe);
function Ype(e, t, n) {
  const i = e.open(t), r = 1e4, s = 250, {
    origin: o
  } = new URL(t);
  let a = ~~(r / s);
  function l(c) {
    c.source === i && (a = 0, e.removeEventListener("message", l, !1));
  }
  e.addEventListener("message", l, !1);
  function u() {
    a <= 0 || (i.postMessage(n, o), setTimeout(u, s), a -= 1);
  }
  setTimeout(u, s);
}
var Xpe = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
function bP(e, ...t) {
  for (const n of t)
    Kpe(e, n);
  return e;
}
function Kpe(e, t) {
  for (const n of Object.keys(t))
    Ru(e, n, t[n], !0);
}
const Li = Rre;
let Qf = Ihe;
const $h = typeof window < "u" ? window : void 0;
var C3;
Qf === void 0 && ((C3 = $h == null ? void 0 : $h.vl) != null && C3.compile) && (Qf = $h.vl);
const Jpe = {
  export: {
    svg: !0,
    png: !0
  },
  source: !0,
  compiled: !0,
  editor: !0
}, Qpe = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
}, Zc = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
}, Lp = {
  vega: Li.version,
  "vega-lite": Qf ? Qf.version : "not available"
}, Zpe = {
  vega: (e) => e,
  "vega-lite": (e, t) => Qf.compile(e, {
    config: t
  }).spec
}, eme = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`, tme = "chart-wrapper";
function nme(e) {
  return typeof e == "function";
}
function c3(e, t, n, i) {
  const r = `<html><head>${t}</head><body><pre><code class="json">`, s = `</code></pre>${n}</body></html>`, o = window.open("");
  o.document.write(r + e + s), o.document.title = `${Zc[i]} JSON Source`;
}
function ime(e, t) {
  if (e.$schema) {
    const n = uP(e.$schema);
    t && t !== n.library && console.warn(`The given visualization spec is written in ${Zc[n.library]}, but mode argument sets ${Zc[t] ?? t}.`);
    const i = n.library;
    return yP(Lp[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${Zc[i]} ${n.version}, but the current version of ${Zc[i]} is v${Lp[i]}.`), i;
  }
  return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega";
}
function vP(e) {
  return !!(e && "load" in e);
}
function f3(e) {
  return vP(e) ? e : Li.loader(e);
}
function rme(e) {
  var n;
  const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
  return Q(t.defaultStyle) && (t.defaultStyle = !1), t;
}
async function sme(e, t, n = {}) {
  let i, r;
  Q(t) ? (r = f3(n.loader), i = JSON.parse(await r.load(t))) : i = t;
  const s = rme(i), o = s.loader;
  (!r || o) && (r = f3(n.loader ?? o));
  const a = await d3(s, r), l = await d3(n, r), u = {
    ...bP(l, a),
    config: Du(l.config ?? {}, a.config ?? {})
  };
  return await ame(e, i, u, r);
}
async function d3(e, t) {
  const n = Q(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {}, i = Q(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
  return {
    ...e,
    ...i ? {
      patch: i
    } : {},
    ...n ? {
      config: n
    } : {}
  };
}
function ome(e) {
  const t = e.getRootNode ? e.getRootNode() : document;
  return t instanceof ShadowRoot ? {
    root: t,
    rootContainer: t
  } : {
    root: document,
    rootContainer: document.head ?? document.body
  };
}
async function ame(e, t, n = {}, i) {
  const r = n.theme ? Du(zge[n.theme], n.config ?? {}) : n.config, s = To(n.actions) ? n.actions : bP({}, Jpe, n.actions ?? {}), o = {
    ...Qpe,
    ...n.i18n
  }, a = n.renderer ?? "canvas", l = n.logLevel ?? Li.Warn, u = n.downloadFileName ?? "visualization", c = typeof e == "string" ? document.querySelector(e) : e;
  if (!c)
    throw new Error(`${e} does not exist`);
  if (n.defaultStyle !== !1) {
    const _ = "vega-embed-style", {
      root: S,
      rootContainer: E
    } = ome(c);
    if (!S.getElementById(_)) {
      const C = document.createElement("style");
      C.id = _, C.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? Xpe.toString() : n.defaultStyle, E.appendChild(C);
    }
  }
  const f = ime(t, n.mode);
  let d = Zpe[f](t, r);
  if (f === "vega-lite" && d.$schema) {
    const _ = uP(d.$schema);
    yP(Lp.vega, `^${_.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${_.version}, but current version is v${Lp.vega}.`);
  }
  c.classList.add("vega-embed"), s && c.classList.add("has-actions"), c.innerHTML = "";
  let h = c;
  if (s) {
    const _ = document.createElement("div");
    _.classList.add(tme), c.appendChild(_), h = _;
  }
  const g = n.patch;
  if (g && (d = g instanceof Function ? g(d) : Bp(d, g, !0, !1).newDocument), n.formatLocale && Li.formatLocale(n.formatLocale), n.timeFormatLocale && Li.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
    for (const _ in n.expressionFunctions) {
      const S = n.expressionFunctions[_];
      "fn" in S ? Li.expressionFunction(_, S.fn, S.visitor) : S instanceof Function && Li.expressionFunction(_, S);
    }
  const {
    ast: p
  } = n, m = Li.parse(d, f === "vega-lite" ? {} : r, {
    ast: p
  }), y = new (n.viewClass || Li.View)(m, {
    loader: i,
    logLevel: l,
    renderer: a,
    ...p ? {
      expr: Li.expressionInterpreter ?? n.expr ?? Hre
    } : {}
  });
  if (y.addSignalListener("autosize", (_, S) => {
    const {
      type: E
    } = S;
    E == "fit-x" ? (h.classList.add("fit-x"), h.classList.remove("fit-y")) : E == "fit-y" ? (h.classList.remove("fit-x"), h.classList.add("fit-y")) : E == "fit" ? h.classList.add("fit-x", "fit-y") : h.classList.remove("fit-x", "fit-y");
  }), n.tooltip !== !1) {
    const {
      loader: _,
      tooltip: S
    } = n, E = _ && !vP(_) ? _ == null ? void 0 : _.baseURL : void 0, C = nme(S) ? S : (
      // user provided boolean true or tooltip options
      new Vge({
        baseURL: E,
        ...S === !0 ? {} : S
      }).call
    );
    y.tooltip(C);
  }
  let {
    hover: b
  } = n;
  if (b === void 0 && (b = f === "vega"), b) {
    const {
      hoverSet: _,
      updateSet: S
    } = typeof b == "boolean" ? {} : b;
    y.hover(_, S);
  }
  n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(h, n.bind).runAsync();
  let v;
  if (s !== !1) {
    let _ = c;
    if (n.defaultStyle !== !1 || n.forceActionsMenu) {
      const E = document.createElement("details");
      E.title = o.CLICK_TO_VIEW_ACTIONS, c.append(E), _ = E;
      const C = document.createElement("summary");
      C.innerHTML = eme, E.append(C), v = ($) => {
        E.contains($.target) || E.removeAttribute("open");
      }, document.addEventListener("click", v);
    }
    const S = document.createElement("div");
    if (_.append(S), S.classList.add("vega-actions"), s === !0 || s.export !== !1) {
      for (const E of ["svg", "png"])
        if (s === !0 || s.export === !0 || s.export[E]) {
          const C = o[`${E.toUpperCase()}_ACTION`], $ = document.createElement("a"), N = ee(n.scaleFactor) ? n.scaleFactor[E] : n.scaleFactor;
          $.text = C, $.href = "#", $.target = "_blank", $.download = `${u}.${E}`, $.addEventListener("mousedown", async function(T) {
            T.preventDefault();
            const L = await y.toImageURL(E, N);
            this.href = L;
          }), S.append($);
        }
    }
    if (s === !0 || s.source !== !1) {
      const E = document.createElement("a");
      E.text = o.SOURCE_ACTION, E.href = "#", E.addEventListener("click", function(C) {
        c3(Y0(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), C.preventDefault();
      }), S.append(E);
    }
    if (f === "vega-lite" && (s === !0 || s.compiled !== !1)) {
      const E = document.createElement("a");
      E.text = o.COMPILED_ACTION, E.href = "#", E.addEventListener("click", function(C) {
        c3(Y0(d), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), C.preventDefault();
      }), S.append(E);
    }
    if (s === !0 || s.editor !== !1) {
      const E = n.editorUrl ?? "https://vega.github.io/editor/", C = document.createElement("a");
      C.text = o.EDITOR_ACTION, C.href = "#", C.addEventListener("click", function($) {
        Ype(window, E, {
          config: r,
          mode: f,
          renderer: a,
          spec: Y0(t)
        }), $.preventDefault();
      }), S.append(C);
    }
  }
  function w() {
    v && document.removeEventListener("click", v), y.finalize();
  }
  return {
    view: y,
    spec: t,
    vgSpec: d,
    finalize: w,
    embedOptions: n
  };
}
const lme = /* @__PURE__ */ new Set(["width", "height"]);
var ume = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var i, r, s;
    if (Array.isArray(t)) {
      if (i = t.length, i != n.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (!e(t[r], n[r]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (s = Object.keys(t), i = s.length, i !== Object.keys(n).length)
      return !1;
    for (r = i; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, s[r]))
        return !1;
    for (r = i; r-- !== 0; ) {
      var o = s[r];
      if (!e(t[o], n[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const cme = /* @__PURE__ */ P3(ume);
function fme(e, t) {
  for (const [n, i] of Object.entries(t))
    i && (i && {}.toString.call(i) === "[object Function]" ? i(e.data(n)) : e.change(n, Li.changeset().remove(() => !0).insert(i)));
}
function Mh(e = {}, t = {}, n = /* @__PURE__ */ new Set()) {
  const i = Object.keys(e), r = Object.keys(t);
  return e === t || i.length === r.length && i.filter((s) => !n.has(s)).every((s) => e[s] === t[s]);
}
function h3(e, t) {
  const n = Object.keys(t);
  for (const i of n)
    try {
      e.removeSignalListener(i, t[i]);
    } catch (r) {
      console.warn("Cannot remove invalid signal listener.", r);
    }
  return n.length > 0;
}
function xy(e, t) {
  const n = Object.keys(t);
  for (const i of n)
    try {
      e.addSignalListener(i, t[i]);
    } catch (r) {
      console.warn("Cannot add invalid signal listener.", r);
    }
  return n.length > 0;
}
function dme(e) {
  return new Set(e.flatMap((t) => Object.keys(t)));
}
function hme(e, t) {
  if (e === t)
    return !1;
  const n = {
    width: !1,
    height: !1,
    isExpensive: !1
  }, i = "width" in e || "width" in t, r = "height" in e || "height" in t;
  return i && (!("width" in e) || !("width" in t) || e.width !== t.width) && ("width" in e && typeof e.width == "number" ? n.width = e.width : n.isExpensive = !0), r && (!("height" in e) || !("height" in t) || e.height !== t.height) && ("height" in e && typeof e.height == "number" ? n.height = e.height : n.isExpensive = !0), [...dme([e, t])].filter((o) => o !== "width" && o !== "height").some((o) => !(o in e) || !(o in t) || !cme(e[o], t[o])) && (n.isExpensive = !0), n.width !== !1 || n.height !== !1 || n.isExpensive ? n : !1;
}
function g3(e, t) {
  const { width: n, height: i } = t;
  return typeof n < "u" && typeof i < "u" ? { ...e, width: n, height: i } : typeof n < "u" ? { ...e, width: n } : typeof i < "u" ? { ...e, height: i } : e;
}
function gme(e) {
  let t;
  return {
    c() {
      t = ge("div");
    },
    m(n, i) {
      Se(n, t, i), e[11](t);
    },
    p: Jn,
    i: Jn,
    o: Jn,
    d(n) {
      n && _e(t), e[11](null);
    }
  };
}
function pme(e, t, n) {
  let { options: i } = t, { spec: r } = t, { view: s } = t, { signalListeners: o = {} } = t, { data: a = {} } = t;
  const l = Bv();
  let u, c = {}, f = {}, d = {}, h = {}, g;
  OP(() => {
    m();
  });
  async function p() {
    m();
    try {
      n(6, u = await sme(g, r, i)), n(1, s = u.view), xy(s, o) && s.runAsync(), b(s);
    } catch (_) {
      y(_);
    }
  }
  function m() {
    u && (u.finalize(), n(6, u = void 0), n(1, s = void 0));
  }
  function y(_) {
    l("onError", { error: _ }), console.warn(_);
  }
  function b(_) {
    v(), l("onNewView", { view: _ });
  }
  async function v() {
    a && Object.keys(a).length > 0 && u !== void 0 && (n(1, s = u.view), fme(s, a), await s.resize().runAsync());
  }
  function w(_) {
    Ql[_ ? "unshift" : "push"](() => {
      g = _, n(0, g);
    });
  }
  return e.$$set = (_) => {
    "options" in _ && n(2, i = _.options), "spec" in _ && n(3, r = _.spec), "view" in _ && n(1, s = _.view), "signalListeners" in _ && n(4, o = _.signalListeners), "data" in _ && n(5, a = _.data);
  }, e.$$.update = () => {
    if (e.$$.dirty & /*data, prevData*/
    1056 && (Mh(a, h) || v(), n(10, h = a)), e.$$.dirty & /*chartContainer, options, prevOptions, spec, prevSpec, signalListeners, prevSignalListeners, result, view*/
    991 && g !== void 0) {
      if (!Mh(i, c, lme))
        p();
      else {
        const _ = hme(g3(r, i), g3(d, c)), S = o, E = f;
        if (_) {
          if (_.isExpensive)
            p();
          else if (u !== void 0) {
            const C = !Mh(S, E);
            n(1, s = u.view), _.width !== !1 && s.width(_.width), _.height !== !1 && s.height(_.height), C && (E && h3(s, E), S && xy(s, S)), s.runAsync();
          }
        } else
          !Mh(S, E) && u !== void 0 && (n(1, s = u.view), E && h3(s, E), S && xy(s, S), s.runAsync());
      }
      n(7, c = i), n(8, f = o), n(9, d = r);
    }
  }, [
    g,
    s,
    i,
    r,
    o,
    a,
    u,
    c,
    f,
    d,
    h,
    w
  ];
}
class mme extends Ms {
  constructor(t) {
    super(), $s(this, t, pme, gme, Cs, {
      options: 2,
      spec: 3,
      view: 1,
      signalListeners: 4,
      data: 5
    });
  }
}
function yme(e) {
  let t, n, i;
  function r(o) {
    e[6](o);
  }
  let s = {
    spec: (
      /*spec*/
      e[1]
    ),
    data: (
      /*data*/
      e[2]
    ),
    signalListeners: (
      /*signalListeners*/
      e[3]
    ),
    options: (
      /*vegaLiteOptions*/
      e[4]
    )
  };
  return (
    /*view*/
    e[0] !== void 0 && (s.view = /*view*/
    e[0]), t = new mme({ props: s }), Ql.push(() => Uv(t, "view", r)), t.$on(
      "onNewView",
      /*onNewView_handler*/
      e[7]
    ), t.$on(
      "onError",
      /*onError_handler*/
      e[8]
    ), {
      c() {
        wi(t.$$.fragment);
      },
      m(o, a) {
        ti(t, o, a), i = !0;
      },
      p(o, [a]) {
        const l = {};
        a & /*spec*/
        2 && (l.spec = /*spec*/
        o[1]), a & /*data*/
        4 && (l.data = /*data*/
        o[2]), a & /*signalListeners*/
        8 && (l.signalListeners = /*signalListeners*/
        o[3]), a & /*vegaLiteOptions*/
        16 && (l.options = /*vegaLiteOptions*/
        o[4]), !n && a & /*view*/
        1 && (n = !0, l.view = /*view*/
        o[0], jv(() => n = !1)), t.$set(l);
      },
      i(o) {
        i || (pe(t.$$.fragment, o), i = !0);
      },
      o(o) {
        $e(t.$$.fragment, o), i = !1;
      },
      d(o) {
        ni(t, o);
      }
    }
  );
}
const bme = "vega-lite";
function vme(e, t, n) {
  let i, { spec: r } = t, { options: s = {} } = t, { data: o = {} } = t, { signalListeners: a = {} } = t, { view: l = void 0 } = t;
  function u(d) {
    l = d, n(0, l);
  }
  function c(d) {
    vS.call(this, e, d);
  }
  function f(d) {
    vS.call(this, e, d);
  }
  return e.$$set = (d) => {
    "spec" in d && n(1, r = d.spec), "options" in d && n(5, s = d.options), "data" in d && n(2, o = d.data), "signalListeners" in d && n(3, a = d.signalListeners), "view" in d && n(0, l = d.view);
  }, e.$$.update = () => {
    e.$$.dirty & /*options*/
    32 && n(4, i = { ...s, mode: bme });
  }, [
    l,
    r,
    o,
    a,
    i,
    s,
    u,
    c,
    f
  ];
}
class xP extends Ms {
  constructor(t) {
    super(), $s(this, t, vme, yme, Cs, {
      spec: 1,
      options: 5,
      data: 2,
      signalListeners: 3,
      view: 0
    });
  }
}
function xme(e) {
  let t, n, i, r;
  function s(a) {
    e[5](a);
  }
  let o = {
    data: (
      /*data*/
      e[0]
    ),
    spec: (
      /*specVL*/
      e[2]
    ),
    options: { actions: !1 }
  };
  return (
    /*viewVL*/
    e[1] !== void 0 && (o.view = /*viewVL*/
    e[1]), n = new xP({ props: o }), Ql.push(() => Uv(n, "view", s)), {
      c() {
        t = ge("div"), wi(n.$$.fragment), de(t, "class", "chart");
      },
      m(a, l) {
        Se(a, t, l), ti(n, t, null), r = !0;
      },
      p(a, [l]) {
        const u = {};
        l & /*data*/
        1 && (u.data = /*data*/
        a[0]), !i && l & /*viewVL*/
        2 && (i = !0, u.view = /*viewVL*/
        a[1], jv(() => i = !1)), n.$set(u);
      },
      i(a) {
        r || (pe(n.$$.fragment, a), r = !0);
      },
      o(a) {
        $e(n.$$.fragment, a), r = !1;
      },
      d(a) {
        a && _e(t), ni(n);
      }
    }
  );
}
function wme(e, t, n) {
  let { rows: i = [] } = t, { filterItems: r } = t, s, o;
  function a(c, f) {
    c = c.filter((h) => {
      let g = !0;
      for (let [p, m] of Object.entries(f))
        h[p] != m && (g = !1);
      return g;
    }), n(0, s = { rows: c });
  }
  a(i, r);
  let l = {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    description: "A simple bar chart with embedded data.",
    data: { name: "rows" },
    mark: { type: "bar" },
    title: "Concept Prevalence",
    width: 150,
    encoding: {
      y: {
        field: "concept_score_orig",
        type: "quantitative",
        aggregate: "sum",
        // scale: {
        //     domain: [0, 1]
        // },
        title: "Concept Prevalence"
      },
      x: {
        field: "id",
        type: "ordinal",
        axis: { labelLimit: 100, labelAngle: -45 },
        title: "Group",
        sort: null
      },
      tooltip: {
        field: "concept_score_orig",
        type: "quantitative",
        aggregate: "sum"
      }
      // format: '.2f',
    }
  };
  function u(c) {
    o = c, n(1, o);
  }
  return e.$$set = (c) => {
    "rows" in c && n(3, i = c.rows), "filterItems" in c && n(4, r = c.filterItems);
  }, e.$$.update = () => {
    e.$$.dirty & /*rows, filterItems*/
    24 && a(i, r);
  }, [s, o, l, i, r, u];
}
class _me extends Ms {
  constructor(t) {
    super(), $s(this, t, wme, xme, Cs, { rows: 3, filterItems: 4 });
  }
}
function p3(e, t, n) {
  const i = e.slice();
  return i[13] = t[n][0], i[14] = t[n][1], i;
}
function m3(e) {
  let t, n;
  return {
    c() {
      t = ge("h2"), n = Qn(
        /*selectedTitle*/
        e[2]
      );
    },
    m(i, r) {
      Se(i, t, r), xe(t, n);
    },
    p(i, r) {
      r & /*selectedTitle*/
      4 && xs(
        n,
        /*selectedTitle*/
        i[2]
      );
    },
    d(i) {
      i && _e(t);
    }
  };
}
function y3(e) {
  let t, n, i, r, s, o, a, l = Rn(Object.entries(
    /*selectedMetadata*/
    e[3]
  )), u = [];
  for (let f = 0; f < l.length; f += 1)
    u[f] = b3(p3(e, l, f));
  let c = (
    /*selectedMatrixElem*/
    e[0] == "concept" && v3(e)
  );
  return {
    c() {
      t = ge("h3"), t.textContent = "CONCEPT SUMMARY", n = vt(), i = ge("div"), r = ge("div");
      for (let f = 0; f < u.length; f += 1)
        u[f].c();
      s = vt(), o = ge("div"), c && c.c(), de(t, "class", "card-title"), de(r, "class", "overview-card-left"), de(o, "class", "overview-card-right"), de(i, "class", "overview-card");
    },
    m(f, d) {
      Se(f, t, d), Se(f, n, d), Se(f, i, d), xe(i, r);
      for (let h = 0; h < u.length; h += 1)
        u[h] && u[h].m(r, null);
      xe(i, s), xe(i, o), c && c.m(o, null), a = !0;
    },
    p(f, d) {
      if (d & /*Object, selectedMetadata*/
      8) {
        l = Rn(Object.entries(
          /*selectedMetadata*/
          f[3]
        ));
        let h;
        for (h = 0; h < l.length; h += 1) {
          const g = p3(f, l, h);
          u[h] ? u[h].p(g, d) : (u[h] = b3(g), u[h].c(), u[h].m(r, null));
        }
        for (; h < u.length; h += 1)
          u[h].d(1);
        u.length = l.length;
      }
      /*selectedMatrixElem*/
      f[0] == "concept" ? c ? (c.p(f, d), d & /*selectedMatrixElem*/
      1 && pe(c, 1)) : (c = v3(f), c.c(), pe(c, 1), c.m(o, null)) : c && (vi(), $e(c, 1, 1, () => {
        c = null;
      }), xi());
    },
    i(f) {
      a || (pe(c), a = !0);
    },
    o(f) {
      $e(c), a = !1;
    },
    d(f) {
      f && (_e(t), _e(n), _e(i)), Ja(u, f), c && c.d();
    }
  };
}
function b3(e) {
  let t, n, i = (
    /*key*/
    e[13] + ""
  ), r, s, o, a = (
    /*value*/
    e[14] + ""
  );
  return {
    c() {
      t = ge("p"), n = ge("b"), r = Qn(i), s = Qn(": "), o = new Ip(!1), o.a = null;
    },
    m(l, u) {
      Se(l, t, u), xe(t, n), xe(n, r), xe(t, s), o.m(a, t);
    },
    p(l, u) {
      u & /*selectedMetadata*/
      8 && i !== (i = /*key*/
      l[13] + "") && xs(r, i), u & /*selectedMetadata*/
      8 && a !== (a = /*value*/
      l[14] + "") && o.p(a);
    },
    d(l) {
      l && _e(t);
    }
  };
}
function v3(e) {
  let t, n;
  return t = new _me({
    props: {
      rows: (
        /*rows*/
        e[4]
      ),
      filterItems: (
        /*filterItems*/
        e[1]
      )
    }
  }), {
    c() {
      wi(t.$$.fragment);
    },
    m(i, r) {
      ti(t, i, r), n = !0;
    },
    p(i, r) {
      const s = {};
      r & /*rows*/
      16 && (s.rows = /*rows*/
      i[4]), r & /*filterItems*/
      2 && (s.filterItems = /*filterItems*/
      i[1]), t.$set(s);
    },
    i(i) {
      n || (pe(t.$$.fragment, i), n = !0);
    },
    o(i) {
      $e(t.$$.fragment, i), n = !1;
    },
    d(i) {
      ni(t, i);
    }
  };
}
function x3(e) {
  let t, n;
  return t = new N3({
    props: {
      columns: (
        /*columns*/
        e[7]
      ),
      rows: (
        /*rowsMatch*/
        e[5]
      ),
      filterSelections: (
        /*filterItems*/
        e[1]
      )
    }
  }), {
    c() {
      wi(t.$$.fragment);
    },
    m(i, r) {
      ti(t, i, r), n = !0;
    },
    p(i, r) {
      const s = {};
      r & /*rowsMatch*/
      32 && (s.rows = /*rowsMatch*/
      i[5]), r & /*filterItems*/
      2 && (s.filterSelections = /*filterItems*/
      i[1]), t.$set(s);
    },
    i(i) {
      n || (pe(t.$$.fragment, i), n = !0);
    },
    o(i) {
      $e(t.$$.fragment, i), n = !1;
    },
    d(i) {
      ni(t, i);
    }
  };
}
function Eme(e) {
  let t, n, i, r, s, o, a, l, u, c = (
    /*selectedTitle*/
    e[2] && m3(e)
  ), f = (
    /*selectedMetadata*/
    e[3] && y3(e)
  ), d = (
    /*remount*/
    e[6] && x3(e)
  );
  return {
    c() {
      t = ge("div"), c && c.c(), n = vt(), i = ge("div"), r = ge("div"), f && f.c(), s = vt(), o = ge("h3"), o.textContent = "POTENTIAL CONCEPT MATCHES", a = vt(), l = ge("div"), d && d.c(), de(o, "class", "card-title"), de(l, "class", "highlight-card"), de(r, "class", "right-col"), de(i, "class", "row"), de(t, "class", "");
    },
    m(h, g) {
      Se(h, t, g), c && c.m(t, null), xe(t, n), xe(t, i), xe(i, r), f && f.m(r, null), xe(r, s), xe(r, o), xe(r, a), xe(r, l), d && d.m(l, null), u = !0;
    },
    p(h, [g]) {
      /*selectedTitle*/
      h[2] ? c ? c.p(h, g) : (c = m3(h), c.c(), c.m(t, n)) : c && (c.d(1), c = null), /*selectedMetadata*/
      h[3] ? f ? (f.p(h, g), g & /*selectedMetadata*/
      8 && pe(f, 1)) : (f = y3(h), f.c(), pe(f, 1), f.m(r, s)) : f && (vi(), $e(f, 1, 1, () => {
        f = null;
      }), xi()), /*remount*/
      h[6] ? d ? (d.p(h, g), g & /*remount*/
      64 && pe(d, 1)) : (d = x3(h), d.c(), pe(d, 1), d.m(l, null)) : d && (vi(), $e(d, 1, 1, () => {
        d = null;
      }), xi());
    },
    i(h) {
      u || (pe(f), pe(d), u = !0);
    },
    o(h) {
      $e(f), $e(d), u = !1;
    },
    d(h) {
      h && _e(t), c && c.d(), f && f.d(), d && d.d();
    }
  };
}
function Sme(e, t, n) {
  let { data: i } = t, { selectedMatrixElem: r } = t, { el: s } = t, { filterItems: o } = t, { selectedTitle: a } = t, { selectedMetadata: l } = t, u = [], c = [], f = [], d = !0, h = ["concept_score_orig"];
  zp(() => {
    g(i);
  });
  function g(p) {
    if (p != null) {
      let y = document.createElement("div"), b = JSON.parse(p);
      n(4, u = b);
      for (var m = 0; m < Object.keys(u[0]).length; m++) {
        const v = Object.keys(u[0])[m];
        h.includes(v) || c.push({
          key: v,
          title: v,
          value: (w) => w[v],
          sortable: !0,
          parseHTML: !0
        });
      }
      n(6, d = !1), setTimeout(() => n(6, d = !0), 0), s.appendChild(y), n(5, f = u.filter((v) => v.concept_score_orig == 1 && v.id == "All")), u.filter((v) => v.concept_score_orig == 0 && v.id == "All");
    }
  }
  return e.$$set = (p) => {
    "data" in p && n(8, i = p.data), "selectedMatrixElem" in p && n(0, r = p.selectedMatrixElem), "el" in p && n(9, s = p.el), "filterItems" in p && n(1, o = p.filterItems), "selectedTitle" in p && n(2, a = p.selectedTitle), "selectedMetadata" in p && n(3, l = p.selectedMetadata);
  }, [
    r,
    o,
    a,
    l,
    u,
    f,
    d,
    c,
    i,
    s
  ];
}
class kme extends Ms {
  constructor(t) {
    super(), $s(this, t, Sme, Eme, Cs, {
      data: 8,
      selectedMatrixElem: 0,
      el: 9,
      filterItems: 1,
      selectedTitle: 2,
      selectedMetadata: 3
    });
  }
}
function Ame(e) {
  let t, n, i, r;
  function s(a) {
    e[5](a);
  }
  let o = {
    data: (
      /*data*/
      e[0]
    ),
    spec: (
      /*specVL*/
      e[2]
    ),
    options: { actions: !1 }
  };
  return (
    /*viewVL*/
    e[1] !== void 0 && (o.view = /*viewVL*/
    e[1]), n = new xP({ props: o }), Ql.push(() => Uv(n, "view", s)), {
      c() {
        t = ge("div"), wi(n.$$.fragment), de(t, "class", "chart");
      },
      m(a, l) {
        Se(a, t, l), ti(n, t, null), r = !0;
      },
      p(a, [l]) {
        const u = {};
        l & /*data*/
        1 && (u.data = /*data*/
        a[0]), !i && l & /*viewVL*/
        2 && (i = !0, u.view = /*viewVL*/
        a[1], jv(() => i = !1)), n.$set(u);
      },
      i(a) {
        r || (pe(n.$$.fragment, a), r = !0);
      },
      o(a) {
        $e(n.$$.fragment, a), r = !1;
      },
      d(a) {
        a && _e(t), ni(n);
      }
    }
  );
}
function Cme(e, t, n) {
  let { rows: i = [] } = t, { filterItems: r } = t, s, o;
  function a(c, f) {
    c = c.filter((h) => {
      let g = !0;
      for (let [p, m] of Object.entries(f))
        h[p] != m && (g = !1);
      return g;
    }), n(0, s = { rows: c });
  }
  a(i, r);
  let l = {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    description: "A simple bar chart with embedded data.",
    data: { name: "rows" },
    mark: { type: "bar" },
    width: 150,
    encoding: {
      x: {
        field: "concept_score_orig",
        type: "quantitative",
        aggregate: "mean",
        scale: { domain: [0, 1] },
        title: "Concept Prevalence"
      },
      y: {
        field: "concept",
        type: "nominal",
        axis: { labelLimit: 100 },
        sort: null,
        title: "Concept"
      },
      color: { field: "concept", legend: null },
      tooltip: {
        field: "concept_score_orig",
        type: "quantitative",
        aggregate: "mean",
        format: ".2f"
      }
    }
  };
  function u(c) {
    o = c, n(1, o);
  }
  return e.$$set = (c) => {
    "rows" in c && n(3, i = c.rows), "filterItems" in c && n(4, r = c.filterItems);
  }, e.$$.update = () => {
    e.$$.dirty & /*rows, filterItems*/
    24 && a(i, r);
  }, [s, o, l, i, r, u];
}
class $me extends Ms {
  constructor(t) {
    super(), $s(this, t, Cme, Ame, Cs, { rows: 3, filterItems: 4 });
  }
}
function w3(e, t, n) {
  const i = e.slice();
  return i[13] = t[n][0], i[14] = t[n][1], i;
}
function _3(e) {
  let t, n;
  return {
    c() {
      t = ge("h2"), n = Qn(
        /*selectedTitle*/
        e[3]
      );
    },
    m(i, r) {
      Se(i, t, r), xe(t, n);
    },
    p(i, r) {
      r & /*selectedTitle*/
      8 && xs(
        n,
        /*selectedTitle*/
        i[3]
      );
    },
    d(i) {
      i && _e(t);
    }
  };
}
function E3(e) {
  let t, n, i, r, s, o, a = Rn(Object.entries(
    /*selectedMetadata*/
    e[4]
  )), l = [];
  for (let u = 0; u < a.length; u += 1)
    l[u] = S3(w3(e, a, u));
  return s = new $me({
    props: {
      rows: (
        /*rowsLong*/
        e[6]
      ),
      filterItems: (
        /*filterItems*/
        e[0]
      )
    }
  }), {
    c() {
      t = ge("h3"), t.textContent = "SLICE SUMMARY", n = vt(), i = ge("div");
      for (let u = 0; u < l.length; u += 1)
        l[u].c();
      r = vt(), wi(s.$$.fragment), de(t, "class", "card-title"), de(i, "class", "overview-card");
    },
    m(u, c) {
      Se(u, t, c), Se(u, n, c), Se(u, i, c);
      for (let f = 0; f < l.length; f += 1)
        l[f] && l[f].m(i, null);
      xe(i, r), ti(s, i, null), o = !0;
    },
    p(u, c) {
      if (c & /*Object, selectedMetadata*/
      16) {
        a = Rn(Object.entries(
          /*selectedMetadata*/
          u[4]
        ));
        let d;
        for (d = 0; d < a.length; d += 1) {
          const h = w3(u, a, d);
          l[d] ? l[d].p(h, c) : (l[d] = S3(h), l[d].c(), l[d].m(i, r));
        }
        for (; d < l.length; d += 1)
          l[d].d(1);
        l.length = a.length;
      }
      const f = {};
      c & /*rowsLong*/
      64 && (f.rows = /*rowsLong*/
      u[6]), c & /*filterItems*/
      1 && (f.filterItems = /*filterItems*/
      u[0]), s.$set(f);
    },
    i(u) {
      o || (pe(s.$$.fragment, u), o = !0);
    },
    o(u) {
      $e(s.$$.fragment, u), o = !1;
    },
    d(u) {
      u && (_e(t), _e(n), _e(i)), Ja(l, u), ni(s);
    }
  };
}
function S3(e) {
  let t, n, i = (
    /*key*/
    e[13] + ""
  ), r, s, o = (
    /*value*/
    e[14] + ""
  ), a;
  return {
    c() {
      t = ge("p"), n = ge("b"), r = Qn(i), s = Qn(": "), a = Qn(o);
    },
    m(l, u) {
      Se(l, t, u), xe(t, n), xe(n, r), xe(t, s), xe(t, a);
    },
    p(l, u) {
      u & /*selectedMetadata*/
      16 && i !== (i = /*key*/
      l[13] + "") && xs(r, i), u & /*selectedMetadata*/
      16 && o !== (o = /*value*/
      l[14] + "") && xs(a, o);
    },
    d(l) {
      l && _e(t);
    }
  };
}
function k3(e) {
  let t, n;
  return t = new N3({
    props: {
      columns: (
        /*columns*/
        e[8]
      ),
      rows: (
        /*rows*/
        e[5]
      ),
      sortBy: (
        /*sortBy*/
        e[1]
      ),
      sortOrder: (
        /*sortOrder*/
        e[2]
      ),
      filterSelections: (
        /*filterItems*/
        e[0]
      )
    }
  }), {
    c() {
      wi(t.$$.fragment);
    },
    m(i, r) {
      ti(t, i, r), n = !0;
    },
    p(i, r) {
      const s = {};
      r & /*rows*/
      32 && (s.rows = /*rows*/
      i[5]), r & /*sortBy*/
      2 && (s.sortBy = /*sortBy*/
      i[1]), r & /*sortOrder*/
      4 && (s.sortOrder = /*sortOrder*/
      i[2]), r & /*filterItems*/
      1 && (s.filterSelections = /*filterItems*/
      i[0]), t.$set(s);
    },
    i(i) {
      n || (pe(t.$$.fragment, i), n = !0);
    },
    o(i) {
      $e(t.$$.fragment, i), n = !1;
    },
    d(i) {
      ni(t, i);
    }
  };
}
function Mme(e) {
  let t, n, i, r, s, o, a, l, u, c, f = (
    /*selectedTitle*/
    e[3] && _3(e)
  ), d = (
    /*selectedMetadata*/
    e[4] && E3(e)
  ), h = (
    /*remount*/
    e[7] && k3(e)
  );
  return {
    c() {
      t = ge("div"), f && f.c(), n = vt(), i = ge("div"), r = ge("div"), d && d.c(), s = vt(), o = ge("div"), a = ge("h3"), a.textContent = "SLICE EXAMPLES", l = vt(), u = ge("div"), h && h.c(), de(r, "class", "left-col"), de(a, "class", "card-title"), de(u, "class", "highlight-card-50"), de(o, "class", "right-col"), de(i, "class", "row"), de(t, "class", "");
    },
    m(g, p) {
      Se(g, t, p), f && f.m(t, null), xe(t, n), xe(t, i), xe(i, r), d && d.m(r, null), xe(i, s), xe(i, o), xe(o, a), xe(o, l), xe(o, u), h && h.m(u, null), c = !0;
    },
    p(g, [p]) {
      /*selectedTitle*/
      g[3] ? f ? f.p(g, p) : (f = _3(g), f.c(), f.m(t, n)) : f && (f.d(1), f = null), /*selectedMetadata*/
      g[4] ? d ? (d.p(g, p), p & /*selectedMetadata*/
      16 && pe(d, 1)) : (d = E3(g), d.c(), pe(d, 1), d.m(r, null)) : d && (vi(), $e(d, 1, 1, () => {
        d = null;
      }), xi()), /*remount*/
      g[7] ? h ? (h.p(g, p), p & /*remount*/
      128 && pe(h, 1)) : (h = k3(g), h.c(), pe(h, 1), h.m(u, null)) : h && (vi(), $e(h, 1, 1, () => {
        h = null;
      }), xi());
    },
    i(g) {
      c || (pe(d), pe(h), c = !0);
    },
    o(g) {
      $e(d), $e(h), c = !1;
    },
    d(g) {
      g && _e(t), f && f.d(), d && d.d(), h && h.d();
    }
  };
}
function Fme(e, t, n) {
  let { data: i } = t, { dataLong: r } = t, { el: s } = t, { filterItems: o } = t, { sortBy: a } = t, { sortOrder: l } = t, { selectedTitle: u } = t, { selectedMetadata: c } = t, f = [], d = [], h = [], g = !0;
  zp(() => {
    p(i, r);
  });
  function p(m, y) {
    if (m != null && y != null) {
      let v = document.createElement("div"), w = JSON.parse(m);
      n(5, f = w);
      let _ = JSON.parse(y);
      n(6, h = _);
      for (var b = 0; b < Object.keys(f[0]).length; b++) {
        const S = Object.keys(f[0])[b];
        d.push({
          key: S,
          title: S,
          value: (E) => E[S],
          sortable: !0,
          parseHTML: !0
        });
      }
      n(7, g = !1), setTimeout(() => n(7, g = !0), 0), s.appendChild(v);
    }
  }
  return e.$$set = (m) => {
    "data" in m && n(9, i = m.data), "dataLong" in m && n(10, r = m.dataLong), "el" in m && n(11, s = m.el), "filterItems" in m && n(0, o = m.filterItems), "sortBy" in m && n(1, a = m.sortBy), "sortOrder" in m && n(2, l = m.sortOrder), "selectedTitle" in m && n(3, u = m.selectedTitle), "selectedMetadata" in m && n(4, c = m.selectedMetadata);
  }, [
    o,
    a,
    l,
    u,
    c,
    f,
    h,
    g,
    d,
    i,
    r,
    s
  ];
}
class Tme extends Ms {
  constructor(t) {
    super(), $s(this, t, Fme, Mme, Cs, {
      data: 9,
      dataLong: 10,
      el: 11,
      filterItems: 0,
      sortBy: 1,
      sortOrder: 2,
      selectedTitle: 3,
      selectedMetadata: 4
    });
  }
}
function A3(e) {
  let t, n, i, r, s, o;
  t = new jP({
    props: {
      data: (
        /*data*/
        e[1]
      ),
      div: (
        /*matrixDiv*/
        e[11]
      ),
      numConcepts: (
        /*numConcepts*/
        e[4]
      )
    }
  }), t.$on(
    "message",
    /*handleMatrixEvent*/
    e[12]
  );
  const a = [Nme, Ome], l = [];
  function u(c, f) {
    return (
      /*selectedMatrixElem*/
      c[5] == "cell" || /*selectedMatrixElem*/
      c[5] == "concept" ? 0 : (
        /*selectedMatrixElem*/
        c[5] == "group" ? 1 : -1
      )
    );
  }
  return ~(r = u(e)) && (s = l[r] = a[r](e)), {
    c() {
      wi(t.$$.fragment), n = vt(), i = ge("div"), s && s.c(), de(i, "class", "tables");
    },
    m(c, f) {
      ti(t, c, f), Se(c, n, f), Se(c, i, f), ~r && l[r].m(i, null), o = !0;
    },
    p(c, f) {
      const d = {};
      f & /*data*/
      2 && (d.data = /*data*/
      c[1]), f & /*numConcepts*/
      16 && (d.numConcepts = /*numConcepts*/
      c[4]), t.$set(d);
      let h = r;
      r = u(c), r === h ? ~r && l[r].p(c, f) : (s && (vi(), $e(l[h], 1, 1, () => {
        l[h] = null;
      }), xi()), ~r ? (s = l[r], s ? s.p(c, f) : (s = l[r] = a[r](c), s.c()), pe(s, 1), s.m(i, null)) : s = null);
    },
    i(c) {
      o || (pe(t.$$.fragment, c), pe(s), o = !0);
    },
    o(c) {
      $e(t.$$.fragment, c), $e(s), o = !1;
    },
    d(c) {
      c && (_e(n), _e(i)), ni(t, c), ~r && l[r].d();
    }
  };
}
function Ome(e) {
  let t, n;
  return t = new Tme({
    props: {
      data: (
        /*dataItemsWide*/
        e[3]
      ),
      dataLong: (
        /*dataItems*/
        e[2]
      ),
      el: (
        /*el*/
        e[0]
      ),
      filterItems: (
        /*filterItems*/
        e[6]
      ),
      sortBy: (
        /*sortBy*/
        e[7]
      ),
      sortOrder: (
        /*sortOrder*/
        e[8]
      ),
      selectedTitle: (
        /*selectedTitle*/
        e[9]
      ),
      selectedMetadata: (
        /*selectedMetadata*/
        e[10]
      )
    }
  }), {
    c() {
      wi(t.$$.fragment);
    },
    m(i, r) {
      ti(t, i, r), n = !0;
    },
    p(i, r) {
      const s = {};
      r & /*dataItemsWide*/
      8 && (s.data = /*dataItemsWide*/
      i[3]), r & /*dataItems*/
      4 && (s.dataLong = /*dataItems*/
      i[2]), r & /*el*/
      1 && (s.el = /*el*/
      i[0]), r & /*filterItems*/
      64 && (s.filterItems = /*filterItems*/
      i[6]), r & /*sortBy*/
      128 && (s.sortBy = /*sortBy*/
      i[7]), r & /*sortOrder*/
      256 && (s.sortOrder = /*sortOrder*/
      i[8]), r & /*selectedTitle*/
      512 && (s.selectedTitle = /*selectedTitle*/
      i[9]), r & /*selectedMetadata*/
      1024 && (s.selectedMetadata = /*selectedMetadata*/
      i[10]), t.$set(s);
    },
    i(i) {
      n || (pe(t.$$.fragment, i), n = !0);
    },
    o(i) {
      $e(t.$$.fragment, i), n = !1;
    },
    d(i) {
      ni(t, i);
    }
  };
}
function Nme(e) {
  let t, n;
  return t = new kme({
    props: {
      data: (
        /*dataItems*/
        e[2]
      ),
      selectedMatrixElem: (
        /*selectedMatrixElem*/
        e[5]
      ),
      el: (
        /*el*/
        e[0]
      ),
      filterItems: (
        /*filterItems*/
        e[6]
      ),
      sortBy: (
        /*sortBy*/
        e[7]
      ),
      sortOrder: (
        /*sortOrder*/
        e[8]
      ),
      selectedTitle: (
        /*selectedTitle*/
        e[9]
      ),
      selectedMetadata: (
        /*selectedMetadata*/
        e[10]
      )
    }
  }), {
    c() {
      wi(t.$$.fragment);
    },
    m(i, r) {
      ti(t, i, r), n = !0;
    },
    p(i, r) {
      const s = {};
      r & /*dataItems*/
      4 && (s.data = /*dataItems*/
      i[2]), r & /*selectedMatrixElem*/
      32 && (s.selectedMatrixElem = /*selectedMatrixElem*/
      i[5]), r & /*el*/
      1 && (s.el = /*el*/
      i[0]), r & /*filterItems*/
      64 && (s.filterItems = /*filterItems*/
      i[6]), r & /*sortBy*/
      128 && (s.sortBy = /*sortBy*/
      i[7]), r & /*sortOrder*/
      256 && (s.sortOrder = /*sortOrder*/
      i[8]), r & /*selectedTitle*/
      512 && (s.selectedTitle = /*selectedTitle*/
      i[9]), r & /*selectedMetadata*/
      1024 && (s.selectedMetadata = /*selectedMetadata*/
      i[10]), t.$set(s);
    },
    i(i) {
      n || (pe(t.$$.fragment, i), n = !0);
    },
    o(i) {
      $e(t.$$.fragment, i), n = !1;
    },
    d(i) {
      ni(t, i);
    }
  };
}
function Dme(e) {
  let t, n, i = (
    /*numConcepts*/
    e[4] > 0 && A3(e)
  );
  return {
    c() {
      t = ge("div"), i && i.c(), de(t, "class", "");
    },
    m(r, s) {
      Se(r, t, s), i && i.m(t, null), n = !0;
    },
    p(r, [s]) {
      /*numConcepts*/
      r[4] > 0 ? i ? (i.p(r, s), s & /*numConcepts*/
      16 && pe(i, 1)) : (i = A3(r), i.c(), pe(i, 1), i.m(t, null)) : i && (vi(), $e(i, 1, 1, () => {
        i = null;
      }), xi());
    },
    i(r) {
      n || (pe(i), n = !0);
    },
    o(r) {
      $e(i), n = !1;
    },
    d(r) {
      r && _e(t), i && i.d();
    }
  };
}
function Rme(e, t, n) {
  let { model: i } = t, { el: r } = t, s, o, a, l, u, c, f, d, h, g, p, m;
  s = i.get("data"), o = i.get("data_items"), a = i.get("data_items_wide"), l = i.get("metadata");
  let y = document.createElement("div");
  y.classList.add("matrix"), r.appendChild(y), zp(() => {
    l != null && (u = JSON.parse(l), n(4, c = Object.keys(u.concepts).length));
  });
  function b() {
    n(5, f = null), n(6, d = {}), n(9, p = null), n(10, m = null);
  }
  function v(w) {
    let _ = w.detail.col, S = w.detail.row, E = w.detail.selection_type;
    if (E == "cell") {
      if (_ == null)
        b();
      else {
        n(5, f = "cell"), n(6, d = { id: _, concept: S }), n(9, p = "Slice: " + _ + ", Concept: " + S);
        let C = u.items[_], $ = u.concepts[S];
        n(10, m = Object.assign(C, $));
      }
      n(7, h = null), n(8, g = 0);
    } else if (E == "col") {
      let C = w.detail.sortOrder;
      _ == null ? b() : (n(5, f = "group"), n(6, d = { id: _ }), n(9, p = "Slice: " + _), n(10, m = u.items[_]), n(7, h = "concept_score"), C == 0 ? n(8, g = 0) : C == 1 ? n(8, g = 1) : C == 2 && n(8, g = -1));
    } else if (E == "row") {
      let C = w.detail.sortOrder;
      S == null ? (b(), n(8, g = 0)) : (n(5, f = "concept"), n(6, d = { concept: S }), n(9, p = "Concept: " + S), n(10, m = u.concepts[S]), n(7, h = "concept_score"), C == 0 ? n(8, g = 0) : C == 1 ? n(8, g = 1) : C == 2 && n(8, g = -1));
    }
  }
  return e.$$set = (w) => {
    "model" in w && n(13, i = w.model), "el" in w && n(0, r = w.el);
  }, [
    r,
    s,
    o,
    a,
    c,
    f,
    d,
    h,
    g,
    p,
    m,
    y,
    v,
    i
  ];
}
class Lme extends Ms {
  constructor(t) {
    super(), $s(this, t, Rme, Dme, Cs, { model: 13, el: 0 });
  }
}
function w0e({ model: e, el: t }) {
  let n = new Lme({ target: t, props: { model: e, el: t } });
  return console.log("index.js mat", n), () => n.$destroy();
}
export {
  w0e as render
};
